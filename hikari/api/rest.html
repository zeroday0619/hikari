<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.api.rest API documentation</title>
<meta name="description" content="Provides an interface for REST API implementations to follow." />
<meta property="og:title" content="hikari.api.rest module documentation" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png" />
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions" />
<meta property="theme-color" content="#ff029a" />
<link rel="shortcut icon" type="image/png" href="https://hikari-py.github.io/hikari/logo.png"/>
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet"/>
<style>
* {
scrollbar-color: #202324 #454a4d;
scroll-behavior: smooth;
}
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
}
small.smaller {
font-size: 0.75em;
}
body {
background-color: #181A1B;
color: #C9C5C0;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<!-- body.mako -->
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="https://hikari-py.github.io/hikari/logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small>v2.0.0.dev92</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/hikari/index.html">Home</a></li>
<li class="nav-item active"><a class="nav-link" href="/hikari/hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" >
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.api -- Interfaces for components that make up Hikari applications …" href="index.html"
>api</a></li>
<li class="breadcrumb-item active"><a href="#">rest</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Provides an interface for REST API implementations to follow.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="ConnectorFactory -- Provider of a connector." href="#hikari.api.rest.ConnectorFactory"
>ConnectorFactory</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="acquire -- Acquire the connector." href="#hikari.api.rest.ConnectorFactory.acquire"
>acquire</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- Close any resources if they exist." href="#hikari.api.rest.ConnectorFactory.close"
>close</a>
</li>
<br />
</ul>
</li>
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="#hikari.api.rest.RESTClient"
>RESTClient</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="add_reaction -- Add a reaction emoji to a message in a given channel …" href="#hikari.api.rest.RESTClient.add_reaction"
>add_reaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="add_role_to_member -- Add a role to a member …" href="#hikari.api.rest.RESTClient.add_role_to_member"
>add_role_to_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="add_user_to_guild -- Add a user to a guild …" href="#hikari.api.rest.RESTClient.add_user_to_guild"
>add_user_to_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="ban_member -- Ban a member from a guild …" href="#hikari.api.rest.RESTClient.ban_user"
>ban_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="ban_user -- Ban a member from a guild …" href="#hikari.api.rest.RESTClient.ban_user"
>ban_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="begin_guild_prune -- Begin the guild prune …" href="#hikari.api.rest.RESTClient.begin_guild_prune"
>begin_guild_prune</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- Close the client session." href="#hikari.api.rest.RESTClient.close"
>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_crossposts -- Broadcast an announcement message …" href="#hikari.api.rest.RESTClient.create_crossposts"
>create_crossposts</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_dm_channel -- Create a DM channel with a user …" href="#hikari.api.rest.RESTClient.create_dm_channel"
>create_dm_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_emoji -- Create an emoji in a guild …" href="#hikari.api.rest.RESTClient.create_emoji"
>create_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_category -- Create a category in a guild …" href="#hikari.api.rest.RESTClient.create_guild_category"
>create_guild_category</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_news_channel -- Create a news channel in a guild …" href="#hikari.api.rest.RESTClient.create_guild_news_channel"
>create_guild_news_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_text_channel -- Create a text channel in a guild …" href="#hikari.api.rest.RESTClient.create_guild_text_channel"
>create_guild_text_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_guild_voice_channel -- Create a voice channel in a guild …" href="#hikari.api.rest.RESTClient.create_guild_voice_channel"
>create_guild_voice_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_invite -- Create an invite to the given guild channel …" href="#hikari.api.rest.RESTClient.create_invite"
>create_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_message -- Create a message in the given channel …" href="#hikari.api.rest.RESTClient.create_message"
>create_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_role -- Create a role …" href="#hikari.api.rest.RESTClient.create_role"
>create_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="create_webhook -- Create webhook in a channel …" href="#hikari.api.rest.RESTClient.create_webhook"
>create_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_all_reactions -- Delete all reactions from a message …" href="#hikari.api.rest.RESTClient.delete_all_reactions"
>delete_all_reactions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_all_reactions_for_emoji -- Delete all reactions for a single emoji on a given message …" href="#hikari.api.rest.RESTClient.delete_all_reactions_for_emoji"
>delete_all_reactions_for_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_channel -- Delete a channel in a guild, or close a DM …" href="#hikari.api.rest.RESTClient.delete_channel"
>delete_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_emoji -- Delete an emoji in a guild …" href="#hikari.api.rest.RESTClient.delete_emoji"
>delete_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_guild -- Delete a guild …" href="#hikari.api.rest.RESTClient.delete_guild"
>delete_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_invite -- Delete an existing invite …" href="#hikari.api.rest.RESTClient.delete_invite"
>delete_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_message -- Delete a given message in a given channel …" href="#hikari.api.rest.RESTClient.delete_message"
>delete_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_messages -- Bulk-delete messages from the channel …" href="#hikari.api.rest.RESTClient.delete_messages"
>delete_messages</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_my_reaction -- Delete a reaction that your application user created …" href="#hikari.api.rest.RESTClient.delete_my_reaction"
>delete_my_reaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_permission_overwrite -- Delete a custom permission for an entity in a given guild channel …" href="#hikari.api.rest.RESTClient.delete_permission_overwrite"
>delete_permission_overwrite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_reaction -- Delete a reaction from a message …" href="#hikari.api.rest.RESTClient.delete_reaction"
>delete_reaction</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_role -- Delete a role …" href="#hikari.api.rest.RESTClient.delete_role"
>delete_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="delete_webhook -- Delete a webhook …" href="#hikari.api.rest.RESTClient.delete_webhook"
>delete_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_channel -- Edit a channel …" href="#hikari.api.rest.RESTClient.edit_channel"
>edit_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_emoji -- Edit an emoji in a guild …" href="#hikari.api.rest.RESTClient.edit_emoji"
>edit_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_guild -- Edit a guild …" href="#hikari.api.rest.RESTClient.edit_guild"
>edit_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_member -- Edit a guild member …" href="#hikari.api.rest.RESTClient.edit_member"
>edit_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_message -- Edit an existing message in a given channel …" href="#hikari.api.rest.RESTClient.edit_message"
>edit_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_my_nick -- Edit the associated token's member nick …" href="#hikari.api.rest.RESTClient.edit_my_nick"
>edit_my_nick</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_my_user -- Edit the token's associated user …" href="#hikari.api.rest.RESTClient.edit_my_user"
>edit_my_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_permission_overwrites -- Edit permissions for a specific entity in the given guild channel …" href="#hikari.api.rest.RESTClient.edit_permission_overwrites"
>edit_permission_overwrites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_role -- Edit a role …" href="#hikari.api.rest.RESTClient.edit_role"
>edit_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_webhook -- Edit a webhook …" href="#hikari.api.rest.RESTClient.edit_webhook"
>edit_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="edit_widget -- Fetch a guilds's widget …" href="#hikari.api.rest.RESTClient.edit_widget"
>edit_widget</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="estimate_guild_prune_count -- Estimate the guild prune count …" href="#hikari.api.rest.RESTClient.estimate_guild_prune_count"
>estimate_guild_prune_count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="execute_webhook -- Execute a webhook …" href="#hikari.api.rest.RESTClient.execute_webhook"
>execute_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_application -- Fetch the token's associated application …" href="#hikari.api.rest.RESTClient.fetch_application"
>fetch_application</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_audit_log -- Fetch the guild's audit log …" href="#hikari.api.rest.RESTClient.fetch_audit_log"
>fetch_audit_log</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_ban -- Fetch the guild's ban info for a user …" href="#hikari.api.rest.RESTClient.fetch_ban"
>fetch_ban</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_bans -- Fetch the bans of a guild …" href="#hikari.api.rest.RESTClient.fetch_bans"
>fetch_bans</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel -- Fetch a channel …" href="#hikari.api.rest.RESTClient.fetch_channel"
>fetch_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel_invites -- Fetch all invites pointing to the given guild channel …" href="#hikari.api.rest.RESTClient.fetch_channel_invites"
>fetch_channel_invites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_channel_webhooks -- Fetch all channel webhooks …" href="#hikari.api.rest.RESTClient.fetch_channel_webhooks"
>fetch_channel_webhooks</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_emoji -- Fetch a guild emoji …" href="#hikari.api.rest.RESTClient.fetch_emoji"
>fetch_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_gateway_bot -- Fetch the gateway gateway info for the bot …" href="#hikari.api.rest.RESTClient.fetch_gateway_bot"
>fetch_gateway_bot</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_gateway_url -- Fetch the gateway url …" href="#hikari.api.rest.RESTClient.fetch_gateway_url"
>fetch_gateway_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild -- Fetch a guild …" href="#hikari.api.rest.RESTClient.fetch_guild"
>fetch_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_channels -- Fetch the channels in a guild …" href="#hikari.api.rest.RESTClient.fetch_guild_channels"
>fetch_guild_channels</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_emojis -- Fetch the emojis of a guild …" href="#hikari.api.rest.RESTClient.fetch_guild_emojis"
>fetch_guild_emojis</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_invites -- Fetch the guild's invites …" href="#hikari.api.rest.RESTClient.fetch_guild_invites"
>fetch_guild_invites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_preview -- Fetch a guild preview …" href="#hikari.api.rest.RESTClient.fetch_guild_preview"
>fetch_guild_preview</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_voice_regions -- Fetch the available voice regions for a guild …" href="#hikari.api.rest.RESTClient.fetch_guild_voice_regions"
>fetch_guild_voice_regions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_guild_webhooks -- Fetch all guild webhooks …" href="#hikari.api.rest.RESTClient.fetch_guild_webhooks"
>fetch_guild_webhooks</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_integrations -- Fetch the guild's integrations …" href="#hikari.api.rest.RESTClient.fetch_integrations"
>fetch_integrations</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_invite -- Fetch an existing invite …" href="#hikari.api.rest.RESTClient.fetch_invite"
>fetch_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_member -- Fetch a guild member …" href="#hikari.api.rest.RESTClient.fetch_member"
>fetch_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_members -- Fetch the members from a guild …" href="#hikari.api.rest.RESTClient.fetch_members"
>fetch_members</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_message -- Fetch a specific message in the given text channel …" href="#hikari.api.rest.RESTClient.fetch_message"
>fetch_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_messages -- Browse the message history for a given text channel …" href="#hikari.api.rest.RESTClient.fetch_messages"
>fetch_messages</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_my_connections -- Fetch the token's associated connections …" href="#hikari.api.rest.RESTClient.fetch_my_connections"
>fetch_my_connections</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_my_guilds -- Fetch the token's associated guilds …" href="#hikari.api.rest.RESTClient.fetch_my_guilds"
>fetch_my_guilds</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_my_user -- Fetch the token's associated user …" href="#hikari.api.rest.RESTClient.fetch_my_user"
>fetch_my_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_pins -- Fetch the pinned messages in this text channel …" href="#hikari.api.rest.RESTClient.fetch_pins"
>fetch_pins</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_reactions_for_emoji -- Fetch reactions for an emoji from a message …" href="#hikari.api.rest.RESTClient.fetch_reactions_for_emoji"
>fetch_reactions_for_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_roles -- Fetch the roles of a guild …" href="#hikari.api.rest.RESTClient.fetch_roles"
>fetch_roles</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_user -- Fetch a user …" href="#hikari.api.rest.RESTClient.fetch_user"
>fetch_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_vanity_url -- Fetch a guild's vanity url …" href="#hikari.api.rest.RESTClient.fetch_vanity_url"
>fetch_vanity_url</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_voice_regions -- Fetch available voice regions …" href="#hikari.api.rest.RESTClient.fetch_voice_regions"
>fetch_voice_regions</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_webhook -- Fetch an existing webhook …" href="#hikari.api.rest.RESTClient.fetch_webhook"
>fetch_webhook</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="fetch_widget -- Fetch a guilds's widget …" href="#hikari.api.rest.RESTClient.fetch_widget"
>fetch_widget</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="follow_channel -- Follow a news channel to send messages to a target channel …" href="#hikari.api.rest.RESTClient.follow_channel"
>follow_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="guild_builder -- Make a guild builder to create a guild with …" href="#hikari.api.rest.RESTClient.guild_builder"
>guild_builder</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- Return the HTTP settings in use by this component …" href="../traits.html#hikari.traits.NetworkSettingsAware.http_settings"
>http_settings</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="kick_member -- Kick a member from a guild …" href="#hikari.api.rest.RESTClient.kick_user"
>kick_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="kick_user -- Kick a member from a guild …" href="#hikari.api.rest.RESTClient.kick_user"
>kick_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="leave_guild -- Leave a guild …" href="#hikari.api.rest.RESTClient.leave_guild"
>leave_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="pin_message -- Pin an existing message in the given text channel …" href="#hikari.api.rest.RESTClient.pin_message"
>pin_message</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- Return the proxy settings in use by this component …" href="../traits.html#hikari.traits.NetworkSettingsAware.proxy_settings"
>proxy_settings</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="remove_role_from_member -- Remove a role from a member …" href="#hikari.api.rest.RESTClient.remove_role_from_member"
>remove_role_from_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="reposition_channels -- Reposition the channels in a guild …" href="#hikari.api.rest.RESTClient.reposition_channels"
>reposition_channels</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="reposition_roles -- Reposition the roles in a guild …" href="#hikari.api.rest.RESTClient.reposition_roles"
>reposition_roles</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="trigger_typing -- Trigger typing in a text channel …" href="#hikari.api.rest.RESTClient.trigger_typing"
>trigger_typing</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="unban_member -- Unban a member from a guild …" href="#hikari.api.rest.RESTClient.unban_user"
>unban_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="unban_user -- Unban a member from a guild …" href="#hikari.api.rest.RESTClient.unban_user"
>unban_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="unpin_message -- Unpin a given message from a given text channel …" href="#hikari.api.rest.RESTClient.unpin_message"
>unpin_message</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L0-L4741" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Provides an interface for REST API implementations to follow.&#34;&#34;&#34;
from __future__ import annotations

__all__: typing.List[str] = [&#34;ConnectorFactory&#34;, &#34;RESTClient&#34;]

import abc
import typing

from hikari import traits
from hikari import undefined

if typing.TYPE_CHECKING:

    import aiohttp

    from hikari import applications
    from hikari import audit_logs
    from hikari import channels
    from hikari import colors
    from hikari import embeds as embeds_
    from hikari import emojis
    from hikari import files
    from hikari import guilds
    from hikari import invites
    from hikari import iterators
    from hikari import messages as messages_
    from hikari import permissions as permissions_
    from hikari import sessions
    from hikari import snowflakes
    from hikari import users
    from hikari import voices
    from hikari import webhooks
    from hikari.api import special_endpoints
    from hikari.internal import time


class ConnectorFactory(abc.ABC):
    &#34;&#34;&#34;Provider of a connector.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close any resources if they exist.&#34;&#34;&#34;

    @abc.abstractmethod
    def acquire(self) -&gt; aiohttp.BaseConnector:
        &#34;&#34;&#34;Acquire the connector.&#34;&#34;&#34;


class RESTClient(traits.NetworkSettingsAware, abc.ABC):
    &#34;&#34;&#34;Interface for functionality that a REST API implementation provides.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the client session.&#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_channel(
        self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]
    ) -&gt; channels.PartialChannel:
        &#34;&#34;&#34;Fetch a channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]
            The channel to fetch. This may be the object or the ID of an
            existing channel.

        Returns
        -------
        hikari.channels.PartialChannel
            The channel. This will be a _derivative_ of
            `hikari.channels.PartialChannel`, depending on the type of
            channel you request for.

            This means that you may get one of
            `hikari.channels.DMChannel`,
            `hikari.channels.GroupDMChannel`,
            `hikari.channels.GuildTextChannel`,
            `hikari.channels.GuildVoiceChannel`,
            `hikari.channels.GuildStoreChannel`,
            `hikari.channels.GuildNewsChannel`.

            Likewise, the `hikari.channels.GuildChannel` can be used to
            determine if a channel is guild-bound, and
            `hikari.channels.TextChannel` can be used to determine
            if the channel provides textual functionality to the application.

            You can check for these using the `builtins.isinstance`
            builtin function.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGES` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_channel(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        /,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        parent_category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.PartialChannel:
        &#34;&#34;&#34;Edit a channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to edit. This may be the object or the ID of an
            existing channel.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[[builtins.str]
            If provided, the new name for the channel.
        position : hikari.undefined.UndefinedOr[[builtins.int]
            If provided, the new position for the channel.
        topic : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new topic for the channel.
        nsfw : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the channel should be marked as NSFW or not.
        bitrate : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the new bitrate for the channel.
        user_limit : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the new user limit in the channel.
        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
            If provided, the new rate limit per user in the channel.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the new permission overwrites for the channel.
        parent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
            If provided, the new guild category for the channel.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.PartialChannel
            The edited channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing permissions to edit the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def follow_channel(
        self,
        news_channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
        target_channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    ) -&gt; channels.ChannelFollow:
        &#34;&#34;&#34;Follow a news channel to send messages to a target channel.

        Parameters
        ----------
        news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]
            The object or ID of the news channel to follow.
        target_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The object or ID of the channel to target.

        Returns
        -------
        hikari.channels.ChannelFollow
            Information about the new relationship that was made.

        Raises
        ------
        hikari.errors.BadRequestError
            If you try to follow a channel that&#39;s not a news channel or if the
            target channel has reached it&#39;s webhook limit, which is 10 at the
            time of writing.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission in the target
            channel or are missing the `VIEW_CHANNEL` permission in the origin
            channel.
        hikari.errors.NotFoundError
            If the origin or target channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_channel(self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]) -&gt; None:
        &#34;&#34;&#34;Delete a channel in a guild, or close a DM.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]
            The channel to delete. This may be the object or the ID of an
            existing channel.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            For Public servers, the set &#39;Rules&#39; or &#39;Guidelines&#39; channels and the
            &#39;Public Server Updates&#39; channel cannot be deleted.
        &#34;&#34;&#34;

    @typing.overload
    @abc.abstractmethod
    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: typing.Union[channels.PermissionOverwrite, users.PartialUser, guilds.PartialRole],
        *,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit permissions for a target entity.&#34;&#34;&#34;

    @typing.overload
    @abc.abstractmethod
    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: snowflakes.Snowflakeish,
        *,
        target_type: channels.PermissionOverwriteType,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit permissions for a given entity ID and type.&#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: typing.Union[
            snowflakes.Snowflakeish, users.PartialUser, guilds.PartialRole, channels.PermissionOverwrite
        ],
        *,
        target_type: undefined.UndefinedOr[channels.PermissionOverwriteType] = undefined.UNDEFINED,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit permissions for a specific entity in the given guild channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to edit a permission overwrite in. This may be the
            object, or the ID of an existing channel.
        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]
            The channel overwrite to edit. This may be the object or the ID of an
            existing overwrite.

        Other Parameters
        ----------------
        target_type : hikari.undefined.UndefinedOr[hikari.channels.PermissionOverwriteType]
            If provided, the type of the target to update. If unset, will attempt to get
            the type from `target`.
        allow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
            If provided, the new vale of all allowed permissions.
        deny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
            If provided, the new vale of all disallowed permissions.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        builtins.TypeError
            If `target_type` is unset and we were unable to determine the type
            from `target`.
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found or the target is not found if it is
            a role.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def delete_permission_overwrite(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: snowflakes.SnowflakeishOr[
            typing.Union[channels.PermissionOverwrite, guilds.PartialRole, users.PartialUser, snowflakes.Snowflakeish]
        ],
    ) -&gt; None:
        &#34;&#34;&#34;Delete a custom permission for an entity in a given guild channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to delete a permission overwrite in. This may be the
            object, or the ID of an existing channel.
        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]
            The channel overwrite to delete.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found or the target is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def fetch_channel_invites(
        self, channel: snowflakes.SnowflakeishOr[channels.GuildChannel]
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Fetch all invites pointing to the given guild channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to fetch the invites from. This may be a channel
            object, or the ID of an existing channel.

        Returns
        -------
        typing.Sequence[hikari.invites.InviteWithMetadata]
            The invites pointing to the given guild channel.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found in any guilds you are a member of.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_invite(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        *,
        max_age: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        max_uses: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        temporary: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        unique: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        target_user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        target_user_type: undefined.UndefinedOr[invites.TargetUserType] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; invites.InviteWithMetadata:
        &#34;&#34;&#34;Create an invite to the given guild channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to create a invite for. This may be the object
            or the ID of an existing channel.

        Other Parameters
        ----------------
        max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, builtins.float, builtins.int]]
            If provided, the duration of the invite before expiry.
        max_uses : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the max uses the invite can have.
        temporary : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the invite only grants temporary membership.
        unique : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the invite should be unique.
        target_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]
            If provided, the target user id for this invite. This may be the
            object or the ID of an existing user.
        target_user_type : hikari.undefined.UndefinedOr[hikari.invites.TargetUserType]
            If provided, the type of target user for this invite.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.invites.InviteWithMetadata
            The invite to the given guild channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNELS` permission.
        hikari.errors.NotFoundError
            If the channel is not found, or if the target user does not exist,
            if provided.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    def trigger_typing(
        self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
    ) -&gt; special_endpoints.TypingIndicator:
        &#34;&#34;&#34;Trigger typing in a text channel.

        The result of this call can be awaited to trigger typing once, or
        can be used as an async context manager to continually type until the
        context manager is left.

        Examples
        --------
        ```py
        # Trigger typing just once.
        await rest.trigger_typing(channel)

        # Trigger typing repeatedly for 1 minute.
        async with rest.trigger_typing(channel):
            await asyncio.sleep(60)
        ```

        !!! warning
            Sending a message to the channel will cause the typing indicator
            to disappear until it is re-triggered.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to trigger typing in. This may be the object or
            the ID of an existing channel.

        Returns
        -------
        hikari.api.special_endpoints.TypingIndicator
            A typing indicator to use.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `SEND_MESSAGES` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the result
            is awaited or iterated over. Invoking this function itself will
            not raise any of the above types.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_pins(
        self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
    ) -&gt; typing.Sequence[messages_.Message]:
        &#34;&#34;&#34;Fetch the pinned messages in this text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to fetch pins from. This may be the object or
            the ID of an existing channel.

        Returns
        -------
        typing.Sequence[hikari.messages.Message]
            The pinned messages in this text channel.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGES` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def pin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Pin an existing message in the given text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to pin a message in. This may be the object or
            the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to pin. This may be the object or the ID
            of an existing message.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found, or if the message does not exist in
            the given channel.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def unpin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Unpin a given message from a given text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to unpin a message in. This may be the object or
            the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to unpin. This may be the object or the ID of an
            existing message.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` permission.
        hikari.errors.NotFoundError
            If the channel is not found or the message is not a pinned message
            in the given channel.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def fetch_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        after: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        around: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[messages_.Message]:
        &#34;&#34;&#34;Browse the message history for a given text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to fetch messages in. This may be the object or
            the ID of an existing channel.

        Other Parameters
        ----------------
        before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
            If provided, fetch messages before this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may be any other Discord entity that has an ID. In this case, the
            date the object was first created will be used.
        after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
            If provided, fetch messages after this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may be any other Discord entity that has an ID. In this case, the
            date the object was first created will be used.
        around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
            If provided, fetch messages around this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may be any other Discord entity that has an ID. In this case, the
            date the object was first created will be used.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.messages.Message]
            An iterator to fetch the messages.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        builtins.TypeError
            If you specify more than one of `before`, `after`, `about`.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGE_HISTORY` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint (other than `builtins.TypeError`) will only
            be raised once the result is awaited or iterated over. Invoking
            this function itself will not raise anything (other than
            `builtins.TypeError`).
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def fetch_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Fetch a specific message in the given text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to fetch messages in. This may be the object or
            the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to fetch. This may be the object or the ID of an
            existing channel.

        Returns
        -------
        hikari.messages.Message
            The requested message.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGE_HISTORY` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found or the message is not found in the
            given text channel.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Create a message in the given channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to create the message in.
        content : hikari.undefined.UndefinedOr[typing.Any]
            If provided, the message contents. If
            `hikari.undefined.UNDEFINED`, then nothing will be sent
            in the content. Any other value here will be cast to a
            `builtins.str`.

            If this is a `hikari.embeds.Embed` and no `embed` kwarg is
            provided, then this will instead update the embed. This allows for
            simpler syntax when sending an embed alone.

            Likewise, if this is a `hikari.files.Resource`, then the
            content is instead treated as an attachment if no `attachment` and
            no `attachments` kwargs are provided.

        Other Parameters
        ----------------
        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
            If provided, the message embed.
        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],
            If provided, the message attachment. This can be a resource,
            or string of a path on your computer or a URL.
        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],
            If provided, the message attachments. These can be resources, or
            strings consisting of paths on your computer or URLs.
        tts : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message will be read out by a screen
            reader using Discord&#39;s TTS (text-to-speech) system.
        nonce : hikari.undefined.UndefinedOr[builtins.str]
            An arbitrary identifier to associate with the message. This
            can be used to identify it later in received events. If provided,
            this must be less than 32 bytes. If not provided, then
            a null value is placed on the message instead. All users can
            see this value.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message should parse @everyone/@here
            mentions.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]], builtins.bool]]
            If provided, and `builtins.True`, all user mentions will be detected.
            If provided, and `builtins.False`, all user mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.users.PartialUser` derivatives to enforce mentioning
            specific users.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]], builtins.bool]]
            If provided, and `builtins.True`, all role mentions will be detected.
            If provided, and `builtins.False`, all role mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.guilds.PartialRole` derivatives to enforce mentioning
            specific roles.

        !!! note
            Attachments can be passed as many different things, to aid in
            convenience.

            - If a `pathlib.PurePath` or `builtins.str` to a valid URL, the
                resource at the given URL will be streamed to Discord when
                sending the message. Subclasses of
                `hikari.files.WebResource` such as
                `hikari.files.URL`,
                `hikari.messages.Attachment`,
                `hikari.emojis.Emoji`,
                `EmbedResource`, etc will also be uploaded this way.
                This will use bit-inception, so only a small percentage of the
                resource will remain in memory at any one time, thus aiding in
                scalability.
            - If a `hikari.files.Bytes` is passed, or a `builtins.str`
                that contains a valid data URI is passed, then this is uploaded
                with a randomized file name if not provided.
            - If a `hikari.files.File`, `pathlib.PurePath` or
                `builtins.str` that is an absolute or relative path to a file
                on your file system is passed, then this resource is uploaded
                as an attachment using non-blocking code internally and streamed
                using bit-inception where possible. This depends on the
                type of `concurrent.futures.Executor` that is being used for
                the application (default is a thread pool which supports this
                behaviour).

        Returns
        -------
        hikari.messages.Message
            The created message.

        Raises
        ------
        builtins.ValueError
            If more than 100 unique objects/entities are passed for
            `role_mentions` or `user_mentions`.
        builtins.TypeError
            If both `attachment` and `attachments` are specified.
        hikari.errors.BadRequestError
            This may be raised in several discrete situations, such as messages
            being empty with no attachments or embeds; messages with more than
            2000 characters in them, embeds that exceed one of the many embed
            limits; too many attachments; attachments that are too large;
            invalid image URLs in embeds; users in `user_mentions` not being
            mentioned in the message content; roles in `role_mentions` not
            being mentioned in the message content.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `SEND_MESSAGES` in the channel or the
            person you are trying to message has the DM&#39;s disabled.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! warning
            You are expected to make a connection to the gateway and identify
            once before being able to use this endpoint for a bot.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def create_crossposts(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Broadcast an announcement message.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]
            The object or ID of the news channel to crosspost a message in.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The object or ID of the message to crosspost.

        Returns
        -------
        hikari.messages.Message
            The message object that was crossposted.

        Raises
        ------
        hikari.errors.BadRequestError
            If you tried to crosspost a message that has already been broadcast.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you try to crosspost a message by the current user without the
            `SEND_MESSAGES` permission for the target news channel or try to
            crosspost a message by another user without both the `SEND_MESSAGES`
            and `MANAGE_MESSAGES` permissions for the target channel.
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
        flags: undefined.UndefinedOr[messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Edit an existing message in a given channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to create the message in. This may be
            the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to edit. This may be the object or the ID
            of an existing message.
        content : hikari.undefined.UndefinedOr[typing.Any]
            If provided, the message content to update with. If
            `hikari.undefined.UNDEFINED`, then the content will not
            be changed. If `builtins.None`, then the content will be removed.

            Any other value will be cast to a `builtins.str` before sending.

            If this is a `hikari.embeds.Embed` and no `embed` kwarg is
            provided, then this will instead update the embed. This allows for
            simpler syntax when sending an embed alone.

        Other Parameters
        ----------------
        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]
            If provided, the embed to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous embed if
            present is not changed. If this is `builtins.None`, then the embed
            is removed if present. Otherwise, the new embed value that was
            provided will be used as the replacement.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, sanitation for `@everyone` mentions. If
            `hikari.undefined.UNDEFINED`, then the previous setting is
            not changed. If `builtins.True`, then `@everyone`/`@here` mentions
            in the message content will show up as mentioning everyone that can
            view the chat.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]], builtins.bool]]
            If provided, sanitation for user mentions. If
            `hikari.undefined.UNDEFINED`, then the previous setting is
            not changed. If `builtins.True`, all valid user mentions will behave
            as mentions. If `builtins.False`, all valid user mentions will not
            behave as mentions.

            You may alternatively pass a collection of
            `hikari.snowflakes.Snowflake` user IDs, or
            `hikari.users.PartialUser`-derived objects.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]], builtins.bool]]
            If provided, sanitation for role mentions. If
            `hikari.undefined.UNDEFINED`, then the previous setting is
            not changed. If `builtins.True`, all valid role mentions will behave
            as mentions. If `builtins.False`, all valid role mentions will not
            behave as mentions.

            You may alternatively pass a collection of
            `hikari.snowflakes.Snowflake` role IDs, or
            `hikari.guilds.PartialRole`-derived objects.
        flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag]
            If provided, optional flags to set on the message. If
            `hikari.undefined.UNDEFINED`, then nothing is changed.

            Note that some flags may not be able to be set. Currently the only
            flags that can be set are `NONE` and `SUPPRESS_EMBEDS`. If you
            have `MANAGE_MESSAGES` permissions, you can use this call to
            suppress embeds on another user&#39;s message.

        !!! note
            Mentioning everyone, roles, or users in message edits currently
            will not send a push notification showing a new mention to people
            on Discord. It will still highlight in their chat as if they
            were mentioned, however.

        !!! note
            There is currently no documented way to clear attachments or edit
            attachments from a previously sent message on Discord&#39;s API. To
            do this, `delete` the message and re-send it. This also applies
            to embed attachments.

        !!! warning
            If you specify one of `mentions_everyone`, `user_mentions`, or
            `role_mentions`, then all others will default to `builtins.False`,
            even if they were enabled previously.

            This is a limitation of Discord&#39;s design. If in doubt, specify all three of
            them each time.

        !!! warning
            If the message was not sent by your user, the only parameter
            you may provide to this call is the `flags` parameter. Anything
            else will result in a `hikari.errors.ForbiddenError` being raised.

        Returns
        -------
        hikari.messages.Message
            The edited message.

        Raises
        ------
        hikari.errors.BadRequestError
            This may be raised in several discrete situations, such as messages
            being empty with no embeds; messages with more than 2000 characters
            in them, embeds that exceed one of the many embed
            limits; invalid image URLs in embeds; users in `user_mentions` not
            being mentioned in the message content; roles in `role_mentions` not
            being mentioned in the message content.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `SEND_MESSAGES` in the channel; if you try to
            change the contents of another user&#39;s message; or if you try to edit
            the flags on another user&#39;s message without the `MANAGE_MESSAGES`
            permission.
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def delete_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Delete a given message in a given channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to delete the message in. This may be
            the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete. This may be the object or the ID of
            an existing message.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES`, and the message is
            not sent by you.
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        /,
        *messages: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Bulk-delete messages from the channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to bulk delete the messages in. This may be
            the object or the ID of an existing channel.
        *messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The messages to delete. This may be one or more
            objects or IDs of existing messages.

        !!! note
            This API endpoint will only be able to delete 100 messages
            at a time. For anything more than this, multiple requests will
            be executed one-after-the-other, since the rate limits for this
            endpoint do not favour more than one request per bucket.

            If one message is left over from chunking per 100 messages, or
            only one message is passed to this coroutine function, then the
            logic is expected to defer to `delete_message`. The implication
            of this is that the `delete_message` endpoint is ratelimited
            by a different bucket with different usage rates.

        !!! warning
            This endpoint is not atomic. If an error occurs midway through
            a bulk delete, you will **not** be able to revert any changes made
            up to this point.

        !!! warning
            Specifying any messages more than 14 days old will cause the call
            to fail, potentially with partial completion.

        Raises
        ------
        hikari.errors.BulkDeleteError
            An error containing the messages successfully deleted, and the
            messages that were not removed. The
            `builtins.BaseException.__cause__` of the exception will be the
            original error that terminated this process.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def add_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        &#34;&#34;&#34;Add a reaction emoji to a message in a given channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to add the reaction to is. This
            may be a `hikari.channels.TextChannel` or the ID of an existing
            channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to add a reaction to. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to react to the message with.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `ADD_REACTIONS` (this is only necessary if you
            are the first person to add the reaction).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_my_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        &#34;&#34;&#34;Delete a reaction that your application user created.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete the reaction from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete a reaction from. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to remove your reaction from.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_all_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        &#34;&#34;&#34;Delete all reactions for a single emoji on a given message.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete the reactions from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete a reactions from. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to delete all reactions from.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; None:
        &#34;&#34;&#34;Delete a reaction from a message.

        If you are looking to delete your own applications reaction, use
        `delete_my_reaction`.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete the reaction from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete a reaction from. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to delete all reactions from.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_all_reactions(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Delete all reactions from a message.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete all reactions from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete all reaction from. This may be the
            object or the ID of an existing message.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def fetch_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
    ) -&gt; iterators.LazyIterator[users.User]:
        &#34;&#34;&#34;Fetch reactions for an emoji from a message.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete all reactions from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete all reaction from. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to filter reactions by.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.users.User]
            An iterator to fetch the users.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the
            result is awaited or iterated over. Invoking this function
            itself will not raise anything.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_webhook(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        name: str,
        *,
        avatar: typing.Optional[files.Resourceish] = None,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        &#34;&#34;&#34;Create webhook in a channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the webhook will be created. This may be
            the object or the ID of an existing channel.
        name : str
            The name for the webhook. This cannnot be `clyde`.

        Other Parameters
        ----------------
        avatar : typing.Optional[hikari.files.Resourceish]
            If provided, the avatar for the webhook.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.webhooks.Webhook
            The created webhook.

        Raises
        ------
        hikari.errors.BadRequestError
            If `name` doesnt follow the restrictions enforced by discord.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        &#34;&#34;&#34;Fetch an existing webhook.

        Parameters
        ----------
        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
            The webhook to fetch. This may be the object or the ID
            of an existing webhook.

        Other Parameters
        ----------------
        token : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the webhoook token that will be used to fetch
            the webhook instead of the token the client was initialized with.

        Returns
        -------
        hikari.webhooks.Webhook
            The requested webhook.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission when not
            using a token.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_channel_webhooks(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    ) -&gt; typing.Sequence[webhooks.Webhook]:
        &#34;&#34;&#34;Fetch all channel webhooks.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to fetch the webhooks for. This
            may be a `hikari.channels.TextChannel` or the ID of an
            existing channel.

        Returns
        -------
        typing.Sequence[hikari.webhooks.Webhook]
            The fetched webhooks.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_webhooks(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[webhooks.Webhook]:
        &#34;&#34;&#34;Fetch all guild webhooks.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the webhooks for. This may be the object
            or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.webhooks.Webhook]
            The fetched webhooks.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.TextChannel]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        &#34;&#34;&#34;Edit a webhook.

        Parameters
        ----------
        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
            The webhook to edit. This may be the object or the
            ID of an existing webhook.

        Other Parameters
        ----------------
        token : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the webhoook token that will be used to edit
            the webhook instead of the token the client was initialized with.
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new webhook name.
        avatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]
            If provided, the new webhook avatar. If `builtins.None`, will
            remove the webhook avatar.
        channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]]
            If provided, the text channel to move the webhook to.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.webhooks.Webhook
            The edited webhook.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission when not
            using a token.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Delete a webhook.

        Parameters
        ----------
        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
            The webhook to delete. This may be the object or the
            ID of an existing webhook.

        Other Parameters
        ----------------
        token : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the webhoook token that will be used to delete
            the webhook instead of the token the client was initialized with.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission when not
            using a token.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhoook is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def execute_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        token: str,
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Execute a webhook.

        Parameters
        ----------
        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
            The webhook to execute. This may be the object
            or the ID of an existing webhook
        token: builtins.str
            The webhook token.
        content : hikari.undefined.UndefinedOr[typing.Any]
            If provided, the message contents. If
            `hikari.undefined.UNDEFINED`, then nothing will be sent
            in the content. Any other value here will be cast to a
            `builtins.str`.

            If this is a `hikari.embeds.Embed` and no `embed` nor
            no `embeds` kwarg is provided, then this will instead
            update the embed. This allows for simpler syntax when
            sending an embed alone.

            Likewise, if this is a `hikari.files.Resource`, then the
            content is instead treated as an attachment if no `attachment` and
            no `attachments` kwargs are provided.

        Other Parameters
        ----------------
        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
            If provided, the message embed.
        embeds : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
            If provided, the message embeds.
        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],
            If provided, the message attachment. This can be a resource,
            or string of a path on your computer or a URL.
        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],
            If provided, the message attachments. These can be resources, or
            strings consisting of paths on your computer or URLs.
        tts : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message will be read out by a screen
            reader using Discord&#39;s TTS (text-to-speech) system.
        nonce : hikari.undefined.UndefinedOr[builtins.str]
            An arbitrary identifier to associate with the message. This
            can be used to identify it later in received events. If provided,
            this must be less than 32 bytes. If not provided, then
            a null value is placed on the message instead. All users can
            see this value.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message should parse @everyone/@here
            mentions.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]], builtins.bool]]
            If provided, and `builtins.True`, all user mentions will be detected.
            If provided, and `builtins.False`, all user mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.users.PartialUser` derivatives to enforce mentioning
            specific users.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]], builtins.bool]]
            If provided, and `builtins.True`, all role mentions will be detected.
            If provided, and `builtins.False`, all role mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.guilds.PartialRole` derivatives to enforce mentioning
            specific roles.

        !!! note
            Attachments can be passed as many different things, to aid in
            convenience.

            - If a `pathlib.PurePath` or `builtins.str` to a valid URL, the
                resource at the given URL will be streamed to Discord when
                sending the message. Subclasses of
                `hikari.files.WebResource` such as
                `hikari.files.URL`,
                `hikari.messages.Attachment`,
                `hikari.emojis.Emoji`,
                `EmbedResource`, etc will also be uploaded this way.
                This will use bit-inception, so only a small percentage of the
                resource will remain in memory at any one time, thus aiding in
                scalability.
            - If a `hikari.files.Bytes` is passed, or a `builtins.str`
                that contains a valid data URI is passed, then this is uploaded
                with a randomized file name if not provided.
            - If a `hikari.files.File`, `pathlib.PurePath` or
                `builtins.str` that is an absolute or relative path to a file
                on your file system is passed, then this resource is uploaded
                as an attachment using non-blocking code internally and streamed
                using bit-inception where possible. This depends on the
                type of `concurrent.futures.Executor` that is being used for
                the application (default is a thread pool which supports this
                behaviour).

        Returns
        -------
        hikari.messages.Message
            The created message.

        Raises
        ------
        builtins.ValueError
            If more than 100 unique objects/entities are passed for
            `role_mentions` or `user_mentions`.
        builtins.TypeError
            If both `attachment` and `attachments` are specified or if both
            `embed` and `embeds` are specified.
        hikari.errors.BadRequestError
            This may be raised in several discrete situations, such as messages
            being empty with no attachments or embeds; messages with more than
            2000 characters in them, embeds that exceed one of the many embed
            limits; too many attachments; attachments that are too large;
            invalid image URLs in embeds; users in `user_mentions` not being
            mentioned in the message content; roles in `role_mentions` not
            being mentioned in the message content.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def fetch_gateway_url(self) -&gt; str:
        &#34;&#34;&#34;Fetch the gateway url.

        !!! note
            This endpoint does not require any valid authorization.

        Raises
        ------
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_gateway_bot(self) -&gt; sessions.GatewayBot:
        &#34;&#34;&#34;Fetch the gateway gateway info for the bot.

        Returns
        -------
        hikari.sessions.GatewayBot
            The gateway bot.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_invite(self, invite: invites.Inviteish) -&gt; invites.Invite:
        &#34;&#34;&#34;Fetch an existing invite.

        Parameters
        ----------
        invite : hikari.invites.Inviteish
            The invite to fetch. This may be an invite object or
            the code of an existing invite.

        Returns
        -------
        hikari.invites.Invite
            The requested invite.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the invite is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_invite(self, invite: invites.Inviteish) -&gt; None:
        &#34;&#34;&#34;Delete an existing invite.

        Parameters
        ----------
        invite : hikari.invites.Inviteish
            The invite to delete. This may be an invite object or
            the code of an existing invite.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission in the guild
            the invite is from or if you are missing the `MANAGE_CHANNELS`
            permission in the channel the invite is from.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the invite is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_my_user(self) -&gt; users.OwnUser:
        &#34;&#34;&#34;Fetch the token&#39;s associated user.

        Returns
        -------
        hikari.users.OwnUser
            The token&#39;s associated user.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_my_user(
        self,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    ) -&gt; users.OwnUser:
        &#34;&#34;&#34;Edit the token&#39;s associated user.

        Other Parameters
        ----------------
        username : undefined.UndefinedOr[builtins.str]
            If provided, the new username.
        avatar : undefined.UndefinedNoneOr[hikari.files.Resourceish]
            If provided, the new avatar. If `builtins.None`,
            the avatar will be removed.

        Returns
        -------
        hikari.users.OwnUser
            The edited token&#39;s associated user.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.

            Discord also returns this on a ratelimit:
            https://github.com/discord/discord-api-docs/issues/1462
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_my_connections(self) -&gt; typing.Sequence[applications.OwnConnection]:
        &#34;&#34;&#34;Fetch the token&#39;s associated connections.

        Returns
        -------
        hikari.applications.OwnConnection
            The token&#39;s associated connections.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def fetch_my_guilds(
        self,
        *,
        newest_first: bool = False,
        start_at: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[applications.OwnGuild]:
        &#34;&#34;&#34;Fetch the token&#39;s associated guilds.

        Other Parameters
        ----------------
        newest_first : builtins.bool
            Whether to fetch the newest first or the olders first.
            Defaults to `builtins.False`.
        start_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild]]
            If provided, will start at this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may also be a guild object. In this case, the
            date the object was first created will be used.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.applications.OwnGuild]
            The token&#39;s associated guilds.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the
            result is awaited or iterated over. Invoking this function
            itself will not raise anything.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def leave_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /) -&gt; None:
        &#34;&#34;&#34;Leave a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to leave. This may be the object or
            the ID of an existing guild.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found or you own the guild.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    # THIS IS AN OAUTH2 FLOW ONLY
    @abc.abstractmethod
    async def create_dm_channel(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; channels.DMChannel:
        &#34;&#34;&#34;Create a DM channel with a user.

        Parameters
        ----------
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to create the DM channel with. This may be the
            object or the ID of an existing user.

        Returns
        -------
        hikari.channels.DMChannel
            The created DM channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If the user is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    # THIS IS AN OAUTH2 FLOW BUT CAN BE USED BY BOTS ALSO
    @abc.abstractmethod
    async def fetch_application(self) -&gt; applications.Application:
        &#34;&#34;&#34;Fetch the token&#39;s associated application.

        Returns
        -------
        hikari.applications.Application
            The token&#39;s associated application.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    # THIS IS AN OAUTH2 FLOW ONLY
    @abc.abstractmethod
    async def add_user_to_guild(
        self,
        access_token: str,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[guilds.Member]:
        &#34;&#34;&#34;Add a user to a guild.

        !!! note
            This requires the `access_token` to have the
            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to add the user to. This may be the object
            or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to add to the guild. This may be the object
            or the ID of an existing user.

        Other Parameters
        ----------------
        nick : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the nick to add to the user when he joins the guild.

            Requires the `MANAGE_NICKNAMES` permission on the guild.
        roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the roles to add to the user when he joins the guild.
            This may be a collection objects or IDs of existing roles.

            Requires the `MANAGE_ROLES` permission on the guild.
        mute : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, the mute state to add the user when he joins the guild.

            Requires the `MUTE_MEMBERS` permission on the guild.
        deaf : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, the deaf state to add the user when he joins the guild.

            Requires the `DEAFEN_MEMBERS` permission on the guild.

        Returns
        -------
        typing.Optional[hikari.guilds.Member]
            `builtins.None` if the user was already part of the guild, else
            `hikari.guilds.Member`.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are not part of the guild you want to add the user to,
            if you are missing permissions to do one of the things you specified,
            if you are using an access token for another user, if the token is
            bound to annother bot or if the access token doesnt have the
            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If you own the guild or the user is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_voice_regions(self) -&gt; typing.Sequence[voices.VoiceRegion]:
        &#34;&#34;&#34;Fetch available voice regions.

        !!! note
            This endpoint doesn&#39;t return VIP voice regions.

        Returns
        -------
        typing.Sequence[hikari.voices.VoiceRegion]
            The available voice regions.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser]) -&gt; users.User:
        &#34;&#34;&#34;Fetch a user.

        Parameters
        ----------
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to fetch. This can be the object
            or the ID of an existing user.

        Returns
        -------
        hikari.users.User
            The requested user

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the user is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    def fetch_audit_log(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        event_type: undefined.UndefinedOr[audit_logs.AuditLogEventType] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[audit_logs.AuditLog]:
        &#34;&#34;&#34;Fetch the guild&#39;s audit log.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the audit logs from. This can be a
            guild object or the ID of an existing guild.

        Other Parameters
        ----------------
        before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
            If provided, filter to only actions after this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may be any other Discord entity that has an ID. In this case, the
            date the object was first created will be used.
        user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]
            If provided, the user to filter for.
        event_type : hikari.undefined.UndefinedOr[hikari.audit_logs.AuditLogEventType]
            If provided, the event type to filter for.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog]
            The guild&#39;s audit log.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `VIEW_AUDIT_LOG` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the
            result is awaited or iterated over. Invoking this function
            itself will not raise anything.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
    ) -&gt; emojis.KnownCustomEmoji:
        &#34;&#34;&#34;Fetch a guild emoji.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the emoji from. This can be a
            guild object or the ID of an existing guild.
        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]
            The emoji to fetch. This can be a `hikari.emojis.CustomEmoji`
            or the ID of an existing emoji.

        Returns
        -------
        hikari.emojis.KnownCustomEmoji
            The requested emoji.

        Raises
        ------
        hikari.errors.NotFoundError
            If the guild or the emoji are not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_emojis(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[emojis.KnownCustomEmoji]:
        &#34;&#34;&#34;Fetch the emojis of a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the emojis from. This can be a
            guild object or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.emojis.KnownCustomEmoji]
            The requested emojis.

        Raises
        ------
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        image: files.Resourceish,
        *,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        &#34;&#34;&#34;Create an emoji in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the emoji on. This can be a
            guild object or the ID of an existing guild.
        name : builtins.str
            The name for the emoji.
        image : hikari.files.Resourceish
            The 128x128 image for the emoji. Maximum upload size is 256kb.
            This can be a still or an animated image.

        Other Parameters
        ----------------
        roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, a collection of the roles that will be able to
            use this emoji. This can be a `hikari.guilds.PartialRole` or
            the ID of an existing role.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.emojis.KnownCustomEmoji
            The created emoji.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value or
            if there are no more spaces for the type of emoji in the guild.
        hikari.errors.ForbiddenError
            If you are missing `MANAGE_EMOJIS` in the server.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        &#34;&#34;&#34;Edit an emoji in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit the emoji on. This can be a
            guild object or the ID of an existing guild.
        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]
            The emoji to edit. This can be a `hikari.emojis.CustomEmoji`
            or the ID of an existing emoji.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name for the emoji.
        roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the new collection of roles that will be able to
            use this emoji. This can be a `hikari.guilds.PartialRole` or
            the ID of an existing role.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.emojis.KnownCustomEmoji
            The edited emoji.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing `MANAGE_EMOJIS` in the server.
        hikari.errors.NotFoundError
            If the guild or the emoji are not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
        # Reason is not currently supported for some reason.
    ) -&gt; None:
        &#34;&#34;&#34;Delete an emoji in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to delete the emoji on. This can be a
            guild object or the ID of an existing guild.
        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]
            The emoji to delete. This can be a `hikari.emojis.CustomEmoji`
            or the ID of an existing emoji.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing `MANAGE_EMOJIS` in the server.
        hikari.errors.NotFoundError
            If the guild or the emoji are not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def guild_builder(self, name: str, /) -&gt; special_endpoints.GuildBuilder:
        &#34;&#34;&#34;Make a guild builder to create a guild with.

        Parameters
        ----------
        name : builtins.str
            The new guilds name.

        Returns
        -------
        hikari.api.special_endpoints.GuildBuilder
            The guild builder to use. This will allow to create a guild
            later with `hikari.api.special_endpoints.GuildBuilder.create`.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once
            `hikari.api.special_endpoints.GuildBuilder.create` is called.
            Invoking this function itself will not raise any of
            the above types.

        See Also
        --------
        Guild builder: `hikari.api.special_endpoints.GuildBuilder`
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.RESTGuild:
        &#34;&#34;&#34;Fetch a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch. This can be the object
            or the ID of an existing guild.

        Returns
        -------
        hikari.guilds.RESTGuild
            The requested guild.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are not part of the guild.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_preview(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildPreview:
        &#34;&#34;&#34;Fetch a guild preview.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the preview of. This can be a
            guild object or the ID of an existing guild.

        Returns
        -------
        hikari.guilds.GuildPreview
            The requested guild preview.

        !!! note
            This will only work for guilds you are a part of or are public.

        Raises
        ------
        hikari.errors.NotFoundError
            If the guild is not found or you are not part of the guild.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_guild(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[voices.VoiceRegionish] = undefined.UNDEFINED,
        verification_level: undefined.UndefinedOr[guilds.GuildVerificationLevel] = undefined.UNDEFINED,
        default_message_notifications: undefined.UndefinedOr[
            guilds.GuildMessageNotificationsLevel
        ] = undefined.UNDEFINED,
        explicit_content_filter_level: undefined.UndefinedOr[
            guilds.GuildExplicitContentFilterLevel
        ] = undefined.UNDEFINED,
        afk_channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]] = undefined.UNDEFINED,
        afk_timeout: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        icon: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        owner: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        splash: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        banner: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        system_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        rules_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        public_updates_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        preferred_locale: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.RESTGuild:
        &#34;&#34;&#34;Edit a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit. This may be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name for the guild.
        region : hikari.undefined.UndefinedOr[hikari.voices.VoiceRegionish]
            If provided, the new voice region for the guild.
        verification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel]
            If provided, the new verification level.
        default_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel]
            If provided, the new default message notifications level.
        explicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel]
            If provided, the new explicit content filter level.
        afk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]
            If provided, the new afk channel. Requires `afk_timeout` to
            be set to work.
        afk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
            If provided, the new afk timeout.
        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the new guild icon. Must be a 1024x1024 image or can be
            an animated gif when the guild has the `ANIMATED_ICON` feature.
        owner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]]
            If provided, the new guild owner.

            !!! warn
                You need to be the owner of the server to use this.
        splash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]
            If provided, the new guild splash. Must be a 16:9 image and the
            guild must have the `INVITE_SPLASH` feature.
        banner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]
            If provided, the new guild banner. Must be a 16:9 image and the
            guild must have the `BANNER` feature.
        system_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]
            If provided, the new system channel.
        rules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]
            If provided, the new rules channel.
        public_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]
            If provided, the new public updates channel.
        preferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str]
            If provided, the new preferred locale.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.guilds.RESTGuild
            The edited guild.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value. Or
            you are missing the
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission or if you tried to
            pass ownership without being the server owner.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def delete_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; None:
        &#34;&#34;&#34;Delete a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to delete. This may be the object or
            the ID of an existing guild.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are not the owner of the guild.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If you own the guild or if you are not in it.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_channels(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[channels.GuildChannel]:
        &#34;&#34;&#34;Fetch the channels in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the channels from. This may be the
            object or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.channels.GuildChannel]
            The requested channels.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_guild_text_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildTextChannel:
        &#34;&#34;&#34;Create a text channel in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the channel in. This may be the
            object or the ID of an existing guild.
        name : builtins.str
            The channels name. Must be between 2 and 1000 characters.

        Other Parameters
        ----------------
        position : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the position of the channel (relative to the
            category, if any).
        topic : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the channels topic. Maximum 1024 characters.
        nsfw : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to mark the channel as NSFW.
        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
            If provided, the ammount of seconds a user has to wait
            before being able to send another message in the channel.
            Maximum 21600 seconds.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the permission overwrites for the channel.
        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
            The category to create the channel under. This may be the
            object or the ID of an existing category.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.GuildTextChannel
            The created channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_guild_news_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildNewsChannel:
        &#34;&#34;&#34;Create a news channel in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the channel in. This may be the
            object or the ID of an existing guild.
        name : builtins.str
            The channels name. Must be between 2 and 1000 characters.

        Other Parameters
        ----------------
        position : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the position of the channel (relative to the
            category, if any).
        topic : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the channels topic. Maximum 1024 characters.
        nsfw : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to mark the channel as NSFW.
        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
            If provided, the ammount of seconds a user has to wait
            before being able to send another message in the channel.
            Maximum 21600 seconds.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the permission overwrites for the channel.
        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
            The category to create the channel under. This may be the
            object or the ID of an existing category.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.GuildNewsChannel
            The created channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_guild_voice_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildVoiceChannel:
        &#34;&#34;&#34;Create a voice channel in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the channel in. This may be the
            object or the ID of an existing guild.
        name : builtins.str
            The channels name. Must be between 2 and 1000 characters.

        Other Parameters
        ----------------
        position : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the position of the channel (relative to the
            category, if any).
        user_limit : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the maximum users in the channel at once.
            Must be between 0 and 99 with 0 meaning no limit.
        bitrate : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the bitrate for the channel. Must be
            between 8000 and 96000 or 8000 and 128000 for VIP
            servers.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the permission overwrites for the channel.
        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
            The category to create the channel under. This may be the
            object or the ID of an existing category.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.GuildVoiceChannel
            The created channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_guild_category(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildCategory:
        &#34;&#34;&#34;Create a category in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the channel in. This may be the
            object or the ID of an existing guild.
        name : builtins.str
            The channels name. Must be between 2 and 1000 characters.

        Other Parameters
        ----------------
        position : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the position of the category.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the permission overwrites for the category.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.GuildCategory
            The created category.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def reposition_channels(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[channels.GuildChannel]],
    ) -&gt; None:
        &#34;&#34;&#34;Reposition the channels in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to reposition the channels in. This may be the
            object or the ID of an existing guild.
        positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]
            A mapping of of the object or the ID of an existing channel to
            the new position, relative to their parent category, if any.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.Member:
        &#34;&#34;&#34;Fetch a guild member.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to get the member from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to get the member for. This may be the
            object or the ID of an existing user.

        Returns
        -------
        hikari.guilds.Member
            The requested member.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or the user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def fetch_members(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; iterators.LazyIterator[guilds.Member]:
        &#34;&#34;&#34;Fetch the members from a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the members of. This may be the
            object or the ID of an existing guild.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.guilds.Member]
            An iterator to fetch the members.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the
            result is awaited or iterated over. Invoking this function
            itself will not raise anything.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        voice_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit a guild member.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit. This may be the object
            or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit. This may be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        nick : hikari.undefined.UndefinedNoneOr[builtins.str]
            If provided, the new nick for the member. If `builtins.None`,
            will remove the members nick.

            Requires the `MANAGE_NICKNAMES` permission.
        roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the new roles for the member.

            Requires the `MANAGE_ROLES` permission.
        mute : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, the new server mute state for the member.

            Requires the `MUTE_MEMBERS` permission.
        deaf : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, the new server deaf state for the member.

            Requires the `DEAFEN_MEMBERS` permission.
        voice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]]
            If provided, `builtins.None` or the object or the ID of
            an existing voice channel to move the member to.
            If `builtins.None`, will disconnect the member from voice.

            Requires the `MOVE_MEMBERS` permission and the `CONNECT`
            permission in the original voice channel and the target
            voice channel.

            !!! note
                If the member is not in a voice channel, this will
                take no effect.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing a permission to do an action.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or the user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_my_nick(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.Guild],
        nick: typing.Optional[str],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit the associated token&#39;s member nick.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit. This may be the object
            or the ID of an existing guild.
        nick : typing.Optional[builtins.str]
            The new nick. If `builtins.None`,
            will remove the nick.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `CHANGE_NICKNAME` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def add_role_to_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Add a role to a member.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild where the member is in. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to add the role to. This may be the
            object or the ID of an existing user.
        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
            The role to add. This may be the object or the
            ID of an existing role.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild, user or role are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def remove_role_from_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Remove a role from a member.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild where the member is in. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to remove the role from. This may be the
            object or the ID of an existing user.
        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
            The role to remove. This may be the object or the
            ID of an existing role.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild, user or role are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def kick_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Kick a member from a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to kick the member from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to kick. This may be the object
            or the ID of an existing user.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `KICK_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    kick_member = kick_user
    &#34;&#34;&#34;This is simply an alias for readability.&#34;&#34;&#34;

    @abc.abstractmethod
    async def ban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        delete_message_days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Ban a member from a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to ban the member from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to kick. This may be the object
            or the ID of an existing user.

        Other Parameters
        ----------------
        delete_message_days : hikari.undefined.UndefinedNoneOr[int]
            If provided, the number of days to delete messages for.
            This must be between 0 and 7.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `BAN_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    ban_member = ban_user
    &#34;&#34;&#34;This is simply an alias for readability.&#34;&#34;&#34;

    @abc.abstractmethod
    async def unban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Unban a member from a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to unban the member from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to unban. This may be the object
            or the ID of an existing user.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `BAN_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    unban_member = unban_user
    &#34;&#34;&#34;This is simply an alias for readability.&#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_ban(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.GuildMemberBan:
        &#34;&#34;&#34;Fetch the guild&#39;s ban info for a user.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the ban from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to fetch the ban of. This may be the
            object or the ID of an existing user.

        Returns
        -------
        hikari.guilds.GuildMemberBan
            The requested ban info.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `BAN_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or user are not found or if the user
            is not banned.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_bans(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.GuildMemberBan]:
        &#34;&#34;&#34;Fetch the bans of a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the bans from. This may be the
            object or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.guilds.GuildMemberBan]
            The requested bans.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `BAN_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Role]:
        &#34;&#34;&#34;Fetch the roles of a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the roles from. This may be the
            object or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.guilds.Role]
            The requested roles.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        &#34;&#34;&#34;Create a role.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the role in. This may be the
            object or the ID of an existing guild.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the name for the role.
        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
            The permissions to give the role. This will default to setting
            NO roles if left to the default value. This is in contrast to
            default behaviour on Discord where some random permissions will
            be set by default.
        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
            If provided, the role&#39;s color.
        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
            An alias for `color`.
        hoist : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to hoist the role.
        mentionable : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to make the role mentionable.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.guilds.Role
            The created role.

        Raises
        ------
        builtins.TypeError
            If both `color` and `colour` are specified.
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def reposition_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[guilds.PartialRole]],
    ) -&gt; None:
        &#34;&#34;&#34;Reposition the roles in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to reposition the roles in. This may be
            the object or the ID of an existing guild.
        positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]
            A mapping of the position to the role.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        &#34;&#34;&#34;Edit a role.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit the role in. This may be the
            object or the ID of an existing guild.
        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
            The role to edit. This may be the object or the
            ID of an existing role.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name for the role.
        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
            If provided, the new permissions for the role.
        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
            If provided, the new color for the role.
        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
            An alias for `color`.
        hoist : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to hoist the role.
        mentionable : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to make the role mentionable.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.guilds.Role
            The edited role.

        Raises
        ------
        builtins.TypeError
            If both `color` and `colour` are specified.
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or role are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    ) -&gt; None:
        &#34;&#34;&#34;Delete a role.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to delete the role in. This may be the
            object or the ID of an existing guild.
        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
            The role to delete. This may be the object or the
            ID of an existing role.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or role are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def estimate_guild_prune_count(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
    ) -&gt; int:
        &#34;&#34;&#34;Estimate the guild prune count.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to estimate the guild prune count for. This may be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        days : hikari.undefined.UndefinedOr[builtins.int]
            If provided, number of days to count prune for.
        include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the role(s) to include. By default, this endpoint will
            not count users with roles. Providing roles using this attribute
            will make members with the specified roles also get included into
            the count.

        Returns
        -------
        builtins.int
            The estimated guild prune count.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `KICK_MEMBERS` permission.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def begin_guild_prune(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        compute_prune_count: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;Begin the guild prune.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to begin the guild prune in. This may be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        days : hikari.undefined.UndefinedOr[builtins.int]
            If provided, number of days to count prune for.
        compute_prune_count: hikari.snowflakes.SnowflakeishOr[builtins.bool]
            If provided, whether to return the prune count. This is discouraged
            for large guilds.
        include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the role(s) to include. By default, this endpoint will
            not count users with roles. Providing roles using this attribute
            will make members with the specified roles also get included into
            the count.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        typing.Optional[builtins.int]
            If `compute_prune_count` is not provided or `builtins.True`, the
            number of members pruned. Else `builtins.None`.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `KICK_MEMBERS` permission.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def fetch_guild_voice_regions(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[voices.VoiceRegion]:
        &#34;&#34;&#34;Fetch the available voice regions for a guild.

        !!! note
            Unlike `RESTClient.fetch_voice_regions`, this will
            return the VIP regions if the guild has access to them.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the voice regions for. This may be the object
            or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.voices.VoiceRegion]
            The available voice regions for the guild.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_invites(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Fetch the guild&#39;s invites.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the invites for. This may be the object
            or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.invites.InviteWithMetadata]
            The invites for the guild.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_integrations(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Integration]:
        &#34;&#34;&#34;Fetch the guild&#39;s integrations.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the integrations for. This may be the object
            or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.guilds.Integration]
            The integrations for the guild.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_widget(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildWidget:
        &#34;&#34;&#34;Fetch a guilds&#39;s widget.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the widget from. This can be the object
            or the ID of an existing guild.

        Returns
        -------
        hikari.guilds.GuildWidget
            The requested guild widget.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_widget(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        channel: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[channels.GuildChannel]] = undefined.UNDEFINED,
        enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.GuildWidget:
        &#34;&#34;&#34;Fetch a guilds&#39;s widget.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit the widget in. This can be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]
            If provided, the channel to set the widget to. If `builtins.None`,
            will not set to any.
        enabled : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to enable the widget.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.guilds.GuildWidget
            The edited guild widget.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_vanity_url(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; invites.VanityURL:
        &#34;&#34;&#34;Fetch a guild&#39;s vanity url.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the vanity url from. This can
            be the object or the ID of an existing guild.

        Returns
        -------
        hikari.invites.VanityURL
            The requested invite.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are not part of the guild.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="ConnectorFactory -- Provider of a connector." href="#hikari.api.rest.ConnectorFactory"
>ConnectorFactory</a></h4>
</dt>
<dd>
<pre><code id="hikari.api.rest.ConnectorFactory" class="hljs python"><abbr title='A standard Python type.'>class</abbr> ConnectorFactory: ...</code></pre>
<p>Provider of a connector.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L58-L69" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class ConnectorFactory(abc.ABC):
    &#34;&#34;&#34;Provider of a connector.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close any resources if they exist.&#34;&#34;&#34;

    @abc.abstractmethod
    def acquire(self) -&gt; aiohttp.BaseConnector:
        &#34;&#34;&#34;Acquire the connector.&#34;&#34;&#34;</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="BasicLazyCachedTCPConnectorFactory -- Lazy cached TCP connector factory." href="../impl/rest.html#hikari.impl.rest.BasicLazyCachedTCPConnectorFactory"
>BasicLazyCachedTCPConnectorFactory</a></dt>
<dd class="nested"><p>Lazy cached TCP connector factory.</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="ConnectorFactory -- Provider of a connector." href="#hikari.api.rest.ConnectorFactory"
>ConnectorFactory</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.api.rest.ConnectorFactory.acquire" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="acquire" href="#hikari.api.rest.ConnectorFactory.acquire" id="hikari.api.rest.ConnectorFactory.acquire">acquire</a>() -> <a href='https://docs.aiohttp.org/en/stable/client_reference.html#aiohttp.BaseConnector'>aiohttp.BaseConnector</a>: ...</code></pre>
</dt>
<dd>
<p>Acquire the connector.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L67-L69" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def acquire(self) -&gt; aiohttp.BaseConnector:
    &#34;&#34;&#34;Acquire the connector.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.ConnectorFactory.close" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="close" href="#hikari.api.rest.ConnectorFactory.close" id="hikari.api.rest.ConnectorFactory.close">close</a>() -> None: ...</code></pre>
</dt>
<dd>
<p>Close any resources if they exist.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L63-L65" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def close(self) -&gt; None:
    &#34;&#34;&#34;Close any resources if they exist.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="#hikari.api.rest.RESTClient"
>RESTClient</a></h4>
</dt>
<dd>
<pre><code id="hikari.api.rest.RESTClient" class="hljs python"><abbr title='A standard Python type.'>class</abbr> RESTClient (
    *args,
    **kwargs,
): ...</code></pre>
<p>Interface for functionality that a REST API implementation provides.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L72-L4742" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class RESTClient(traits.NetworkSettingsAware, abc.ABC):
    &#34;&#34;&#34;Interface for functionality that a REST API implementation provides.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the client session.&#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_channel(
        self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]
    ) -&gt; channels.PartialChannel:
        &#34;&#34;&#34;Fetch a channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]
            The channel to fetch. This may be the object or the ID of an
            existing channel.

        Returns
        -------
        hikari.channels.PartialChannel
            The channel. This will be a _derivative_ of
            `hikari.channels.PartialChannel`, depending on the type of
            channel you request for.

            This means that you may get one of
            `hikari.channels.DMChannel`,
            `hikari.channels.GroupDMChannel`,
            `hikari.channels.GuildTextChannel`,
            `hikari.channels.GuildVoiceChannel`,
            `hikari.channels.GuildStoreChannel`,
            `hikari.channels.GuildNewsChannel`.

            Likewise, the `hikari.channels.GuildChannel` can be used to
            determine if a channel is guild-bound, and
            `hikari.channels.TextChannel` can be used to determine
            if the channel provides textual functionality to the application.

            You can check for these using the `builtins.isinstance`
            builtin function.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGES` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_channel(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        /,
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        parent_category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.PartialChannel:
        &#34;&#34;&#34;Edit a channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to edit. This may be the object or the ID of an
            existing channel.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[[builtins.str]
            If provided, the new name for the channel.
        position : hikari.undefined.UndefinedOr[[builtins.int]
            If provided, the new position for the channel.
        topic : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new topic for the channel.
        nsfw : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the channel should be marked as NSFW or not.
        bitrate : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the new bitrate for the channel.
        user_limit : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the new user limit in the channel.
        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
            If provided, the new rate limit per user in the channel.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the new permission overwrites for the channel.
        parent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
            If provided, the new guild category for the channel.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.PartialChannel
            The edited channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing permissions to edit the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def follow_channel(
        self,
        news_channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
        target_channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    ) -&gt; channels.ChannelFollow:
        &#34;&#34;&#34;Follow a news channel to send messages to a target channel.

        Parameters
        ----------
        news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]
            The object or ID of the news channel to follow.
        target_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The object or ID of the channel to target.

        Returns
        -------
        hikari.channels.ChannelFollow
            Information about the new relationship that was made.

        Raises
        ------
        hikari.errors.BadRequestError
            If you try to follow a channel that&#39;s not a news channel or if the
            target channel has reached it&#39;s webhook limit, which is 10 at the
            time of writing.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission in the target
            channel or are missing the `VIEW_CHANNEL` permission in the origin
            channel.
        hikari.errors.NotFoundError
            If the origin or target channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_channel(self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]) -&gt; None:
        &#34;&#34;&#34;Delete a channel in a guild, or close a DM.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]
            The channel to delete. This may be the object or the ID of an
            existing channel.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            For Public servers, the set &#39;Rules&#39; or &#39;Guidelines&#39; channels and the
            &#39;Public Server Updates&#39; channel cannot be deleted.
        &#34;&#34;&#34;

    @typing.overload
    @abc.abstractmethod
    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: typing.Union[channels.PermissionOverwrite, users.PartialUser, guilds.PartialRole],
        *,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit permissions for a target entity.&#34;&#34;&#34;

    @typing.overload
    @abc.abstractmethod
    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: snowflakes.Snowflakeish,
        *,
        target_type: channels.PermissionOverwriteType,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit permissions for a given entity ID and type.&#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_permission_overwrites(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: typing.Union[
            snowflakes.Snowflakeish, users.PartialUser, guilds.PartialRole, channels.PermissionOverwrite
        ],
        *,
        target_type: undefined.UndefinedOr[channels.PermissionOverwriteType] = undefined.UNDEFINED,
        allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit permissions for a specific entity in the given guild channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to edit a permission overwrite in. This may be the
            object, or the ID of an existing channel.
        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]
            The channel overwrite to edit. This may be the object or the ID of an
            existing overwrite.

        Other Parameters
        ----------------
        target_type : hikari.undefined.UndefinedOr[hikari.channels.PermissionOverwriteType]
            If provided, the type of the target to update. If unset, will attempt to get
            the type from `target`.
        allow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
            If provided, the new vale of all allowed permissions.
        deny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
            If provided, the new vale of all disallowed permissions.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        builtins.TypeError
            If `target_type` is unset and we were unable to determine the type
            from `target`.
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found or the target is not found if it is
            a role.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def delete_permission_overwrite(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        target: snowflakes.SnowflakeishOr[
            typing.Union[channels.PermissionOverwrite, guilds.PartialRole, users.PartialUser, snowflakes.Snowflakeish]
        ],
    ) -&gt; None:
        &#34;&#34;&#34;Delete a custom permission for an entity in a given guild channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to delete a permission overwrite in. This may be the
            object, or the ID of an existing channel.
        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]
            The channel overwrite to delete.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found or the target is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def fetch_channel_invites(
        self, channel: snowflakes.SnowflakeishOr[channels.GuildChannel]
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Fetch all invites pointing to the given guild channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to fetch the invites from. This may be a channel
            object, or the ID of an existing channel.

        Returns
        -------
        typing.Sequence[hikari.invites.InviteWithMetadata]
            The invites pointing to the given guild channel.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission in the channel.
        hikari.errors.NotFoundError
            If the channel is not found in any guilds you are a member of.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_invite(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
        *,
        max_age: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        max_uses: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        temporary: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        unique: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        target_user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        target_user_type: undefined.UndefinedOr[invites.TargetUserType] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; invites.InviteWithMetadata:
        &#34;&#34;&#34;Create an invite to the given guild channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
            The channel to create a invite for. This may be the object
            or the ID of an existing channel.

        Other Parameters
        ----------------
        max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, builtins.float, builtins.int]]
            If provided, the duration of the invite before expiry.
        max_uses : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the max uses the invite can have.
        temporary : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the invite only grants temporary membership.
        unique : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the invite should be unique.
        target_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]
            If provided, the target user id for this invite. This may be the
            object or the ID of an existing user.
        target_user_type : hikari.undefined.UndefinedOr[hikari.invites.TargetUserType]
            If provided, the type of target user for this invite.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.invites.InviteWithMetadata
            The invite to the given guild channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNELS` permission.
        hikari.errors.NotFoundError
            If the channel is not found, or if the target user does not exist,
            if provided.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    def trigger_typing(
        self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
    ) -&gt; special_endpoints.TypingIndicator:
        &#34;&#34;&#34;Trigger typing in a text channel.

        The result of this call can be awaited to trigger typing once, or
        can be used as an async context manager to continually type until the
        context manager is left.

        Examples
        --------
        ```py
        # Trigger typing just once.
        await rest.trigger_typing(channel)

        # Trigger typing repeatedly for 1 minute.
        async with rest.trigger_typing(channel):
            await asyncio.sleep(60)
        ```

        !!! warning
            Sending a message to the channel will cause the typing indicator
            to disappear until it is re-triggered.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to trigger typing in. This may be the object or
            the ID of an existing channel.

        Returns
        -------
        hikari.api.special_endpoints.TypingIndicator
            A typing indicator to use.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `SEND_MESSAGES` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the result
            is awaited or iterated over. Invoking this function itself will
            not raise any of the above types.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_pins(
        self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
    ) -&gt; typing.Sequence[messages_.Message]:
        &#34;&#34;&#34;Fetch the pinned messages in this text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to fetch pins from. This may be the object or
            the ID of an existing channel.

        Returns
        -------
        typing.Sequence[hikari.messages.Message]
            The pinned messages in this text channel.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGES` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def pin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Pin an existing message in the given text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to pin a message in. This may be the object or
            the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to pin. This may be the object or the ID
            of an existing message.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found, or if the message does not exist in
            the given channel.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def unpin_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Unpin a given message from a given text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to unpin a message in. This may be the object or
            the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to unpin. This may be the object or the ID of an
            existing message.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` permission.
        hikari.errors.NotFoundError
            If the channel is not found or the message is not a pinned message
            in the given channel.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def fetch_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        after: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        around: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[messages_.Message]:
        &#34;&#34;&#34;Browse the message history for a given text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to fetch messages in. This may be the object or
            the ID of an existing channel.

        Other Parameters
        ----------------
        before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
            If provided, fetch messages before this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may be any other Discord entity that has an ID. In this case, the
            date the object was first created will be used.
        after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
            If provided, fetch messages after this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may be any other Discord entity that has an ID. In this case, the
            date the object was first created will be used.
        around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
            If provided, fetch messages around this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may be any other Discord entity that has an ID. In this case, the
            date the object was first created will be used.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.messages.Message]
            An iterator to fetch the messages.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        builtins.TypeError
            If you specify more than one of `before`, `after`, `about`.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGE_HISTORY` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint (other than `builtins.TypeError`) will only
            be raised once the result is awaited or iterated over. Invoking
            this function itself will not raise anything (other than
            `builtins.TypeError`).
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def fetch_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Fetch a specific message in the given text channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to fetch messages in. This may be the object or
            the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to fetch. This may be the object or the ID of an
            existing channel.

        Returns
        -------
        hikari.messages.Message
            The requested message.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `READ_MESSAGE_HISTORY` in the channel.
        hikari.errors.NotFoundError
            If the channel is not found or the message is not found in the
            given text channel.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Create a message in the given channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to create the message in.
        content : hikari.undefined.UndefinedOr[typing.Any]
            If provided, the message contents. If
            `hikari.undefined.UNDEFINED`, then nothing will be sent
            in the content. Any other value here will be cast to a
            `builtins.str`.

            If this is a `hikari.embeds.Embed` and no `embed` kwarg is
            provided, then this will instead update the embed. This allows for
            simpler syntax when sending an embed alone.

            Likewise, if this is a `hikari.files.Resource`, then the
            content is instead treated as an attachment if no `attachment` and
            no `attachments` kwargs are provided.

        Other Parameters
        ----------------
        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
            If provided, the message embed.
        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],
            If provided, the message attachment. This can be a resource,
            or string of a path on your computer or a URL.
        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],
            If provided, the message attachments. These can be resources, or
            strings consisting of paths on your computer or URLs.
        tts : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message will be read out by a screen
            reader using Discord&#39;s TTS (text-to-speech) system.
        nonce : hikari.undefined.UndefinedOr[builtins.str]
            An arbitrary identifier to associate with the message. This
            can be used to identify it later in received events. If provided,
            this must be less than 32 bytes. If not provided, then
            a null value is placed on the message instead. All users can
            see this value.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message should parse @everyone/@here
            mentions.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]], builtins.bool]]
            If provided, and `builtins.True`, all user mentions will be detected.
            If provided, and `builtins.False`, all user mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.users.PartialUser` derivatives to enforce mentioning
            specific users.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]], builtins.bool]]
            If provided, and `builtins.True`, all role mentions will be detected.
            If provided, and `builtins.False`, all role mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.guilds.PartialRole` derivatives to enforce mentioning
            specific roles.

        !!! note
            Attachments can be passed as many different things, to aid in
            convenience.

            - If a `pathlib.PurePath` or `builtins.str` to a valid URL, the
                resource at the given URL will be streamed to Discord when
                sending the message. Subclasses of
                `hikari.files.WebResource` such as
                `hikari.files.URL`,
                `hikari.messages.Attachment`,
                `hikari.emojis.Emoji`,
                `EmbedResource`, etc will also be uploaded this way.
                This will use bit-inception, so only a small percentage of the
                resource will remain in memory at any one time, thus aiding in
                scalability.
            - If a `hikari.files.Bytes` is passed, or a `builtins.str`
                that contains a valid data URI is passed, then this is uploaded
                with a randomized file name if not provided.
            - If a `hikari.files.File`, `pathlib.PurePath` or
                `builtins.str` that is an absolute or relative path to a file
                on your file system is passed, then this resource is uploaded
                as an attachment using non-blocking code internally and streamed
                using bit-inception where possible. This depends on the
                type of `concurrent.futures.Executor` that is being used for
                the application (default is a thread pool which supports this
                behaviour).

        Returns
        -------
        hikari.messages.Message
            The created message.

        Raises
        ------
        builtins.ValueError
            If more than 100 unique objects/entities are passed for
            `role_mentions` or `user_mentions`.
        builtins.TypeError
            If both `attachment` and `attachments` are specified.
        hikari.errors.BadRequestError
            This may be raised in several discrete situations, such as messages
            being empty with no attachments or embeds; messages with more than
            2000 characters in them, embeds that exceed one of the many embed
            limits; too many attachments; attachments that are too large;
            invalid image URLs in embeds; users in `user_mentions` not being
            mentioned in the message content; roles in `role_mentions` not
            being mentioned in the message content.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `SEND_MESSAGES` in the channel or the
            person you are trying to message has the DM&#39;s disabled.
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! warning
            You are expected to make a connection to the gateway and identify
            once before being able to use this endpoint for a bot.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def create_crossposts(
        self,
        channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Broadcast an announcement message.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]
            The object or ID of the news channel to crosspost a message in.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The object or ID of the message to crosspost.

        Returns
        -------
        hikari.messages.Message
            The message object that was crossposted.

        Raises
        ------
        hikari.errors.BadRequestError
            If you tried to crosspost a message that has already been broadcast.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you try to crosspost a message by the current user without the
            `SEND_MESSAGES` permission for the target news channel or try to
            crosspost a message by another user without both the `SEND_MESSAGES`
            and `MANAGE_MESSAGES` permissions for the target channel.
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
        flags: undefined.UndefinedOr[messages_.MessageFlag] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Edit an existing message in a given channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to create the message in. This may be
            the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to edit. This may be the object or the ID
            of an existing message.
        content : hikari.undefined.UndefinedOr[typing.Any]
            If provided, the message content to update with. If
            `hikari.undefined.UNDEFINED`, then the content will not
            be changed. If `builtins.None`, then the content will be removed.

            Any other value will be cast to a `builtins.str` before sending.

            If this is a `hikari.embeds.Embed` and no `embed` kwarg is
            provided, then this will instead update the embed. This allows for
            simpler syntax when sending an embed alone.

        Other Parameters
        ----------------
        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]
            If provided, the embed to set on the message. If
            `hikari.undefined.UNDEFINED`, the previous embed if
            present is not changed. If this is `builtins.None`, then the embed
            is removed if present. Otherwise, the new embed value that was
            provided will be used as the replacement.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, sanitation for `@everyone` mentions. If
            `hikari.undefined.UNDEFINED`, then the previous setting is
            not changed. If `builtins.True`, then `@everyone`/`@here` mentions
            in the message content will show up as mentioning everyone that can
            view the chat.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]], builtins.bool]]
            If provided, sanitation for user mentions. If
            `hikari.undefined.UNDEFINED`, then the previous setting is
            not changed. If `builtins.True`, all valid user mentions will behave
            as mentions. If `builtins.False`, all valid user mentions will not
            behave as mentions.

            You may alternatively pass a collection of
            `hikari.snowflakes.Snowflake` user IDs, or
            `hikari.users.PartialUser`-derived objects.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]], builtins.bool]]
            If provided, sanitation for role mentions. If
            `hikari.undefined.UNDEFINED`, then the previous setting is
            not changed. If `builtins.True`, all valid role mentions will behave
            as mentions. If `builtins.False`, all valid role mentions will not
            behave as mentions.

            You may alternatively pass a collection of
            `hikari.snowflakes.Snowflake` role IDs, or
            `hikari.guilds.PartialRole`-derived objects.
        flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag]
            If provided, optional flags to set on the message. If
            `hikari.undefined.UNDEFINED`, then nothing is changed.

            Note that some flags may not be able to be set. Currently the only
            flags that can be set are `NONE` and `SUPPRESS_EMBEDS`. If you
            have `MANAGE_MESSAGES` permissions, you can use this call to
            suppress embeds on another user&#39;s message.

        !!! note
            Mentioning everyone, roles, or users in message edits currently
            will not send a push notification showing a new mention to people
            on Discord. It will still highlight in their chat as if they
            were mentioned, however.

        !!! note
            There is currently no documented way to clear attachments or edit
            attachments from a previously sent message on Discord&#39;s API. To
            do this, `delete` the message and re-send it. This also applies
            to embed attachments.

        !!! warning
            If you specify one of `mentions_everyone`, `user_mentions`, or
            `role_mentions`, then all others will default to `builtins.False`,
            even if they were enabled previously.

            This is a limitation of Discord&#39;s design. If in doubt, specify all three of
            them each time.

        !!! warning
            If the message was not sent by your user, the only parameter
            you may provide to this call is the `flags` parameter. Anything
            else will result in a `hikari.errors.ForbiddenError` being raised.

        Returns
        -------
        hikari.messages.Message
            The edited message.

        Raises
        ------
        hikari.errors.BadRequestError
            This may be raised in several discrete situations, such as messages
            being empty with no embeds; messages with more than 2000 characters
            in them, embeds that exceed one of the many embed
            limits; invalid image URLs in embeds; users in `user_mentions` not
            being mentioned in the message content; roles in `role_mentions` not
            being mentioned in the message content.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `SEND_MESSAGES` in the channel; if you try to
            change the contents of another user&#39;s message; or if you try to edit
            the flags on another user&#39;s message without the `MANAGE_MESSAGES`
            permission.
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def delete_message(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Delete a given message in a given channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to delete the message in. This may be
            the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete. This may be the object or the ID of
            an existing message.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES`, and the message is
            not sent by you.
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_messages(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        /,
        *messages: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Bulk-delete messages from the channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to bulk delete the messages in. This may be
            the object or the ID of an existing channel.
        *messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The messages to delete. This may be one or more
            objects or IDs of existing messages.

        !!! note
            This API endpoint will only be able to delete 100 messages
            at a time. For anything more than this, multiple requests will
            be executed one-after-the-other, since the rate limits for this
            endpoint do not favour more than one request per bucket.

            If one message is left over from chunking per 100 messages, or
            only one message is passed to this coroutine function, then the
            logic is expected to defer to `delete_message`. The implication
            of this is that the `delete_message` endpoint is ratelimited
            by a different bucket with different usage rates.

        !!! warning
            This endpoint is not atomic. If an error occurs midway through
            a bulk delete, you will **not** be able to revert any changes made
            up to this point.

        !!! warning
            Specifying any messages more than 14 days old will cause the call
            to fail, potentially with partial completion.

        Raises
        ------
        hikari.errors.BulkDeleteError
            An error containing the messages successfully deleted, and the
            messages that were not removed. The
            `builtins.BaseException.__cause__` of the exception will be the
            original error that terminated this process.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def add_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        &#34;&#34;&#34;Add a reaction emoji to a message in a given channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to add the reaction to is. This
            may be a `hikari.channels.TextChannel` or the ID of an existing
            channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to add a reaction to. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to react to the message with.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `ADD_REACTIONS` (this is only necessary if you
            are the first person to add the reaction).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_my_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        &#34;&#34;&#34;Delete a reaction that your application user created.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete the reaction from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete a reaction from. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to remove your reaction from.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_all_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
    ) -&gt; None:
        &#34;&#34;&#34;Delete all reactions for a single emoji on a given message.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete the reactions from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete a reactions from. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to delete all reactions from.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_reaction(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; None:
        &#34;&#34;&#34;Delete a reaction from a message.

        If you are looking to delete your own applications reaction, use
        `delete_my_reaction`.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete the reaction from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete a reaction from. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to delete all reactions from.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_all_reactions(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    ) -&gt; None:
        &#34;&#34;&#34;Delete all reactions from a message.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete all reactions from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete all reaction from. This may be the
            object or the ID of an existing message.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_MESSAGES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def fetch_reactions_for_emoji(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
        emoji: emojis.Emojiish,
    ) -&gt; iterators.LazyIterator[users.User]:
        &#34;&#34;&#34;Fetch reactions for an emoji from a message.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the message to delete all reactions from is.
            This may be the object or the ID of an existing channel.
        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
            The message to delete all reaction from. This may be the
            object or the ID of an existing message.
        emoji : hikari.emojis.Emojiish
            The emoji to filter reactions by.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.users.User]
            An iterator to fetch the users.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        hikari.errors.BadRequestError
            If an invalid unicode emoji is given, or if the given custom emoji
            does not exist.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel or message is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the
            result is awaited or iterated over. Invoking this function
            itself will not raise anything.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_webhook(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
        name: str,
        *,
        avatar: typing.Optional[files.Resourceish] = None,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        &#34;&#34;&#34;Create webhook in a channel.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel where the webhook will be created. This may be
            the object or the ID of an existing channel.
        name : str
            The name for the webhook. This cannnot be `clyde`.

        Other Parameters
        ----------------
        avatar : typing.Optional[hikari.files.Resourceish]
            If provided, the avatar for the webhook.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.webhooks.Webhook
            The created webhook.

        Raises
        ------
        hikari.errors.BadRequestError
            If `name` doesnt follow the restrictions enforced by discord.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        &#34;&#34;&#34;Fetch an existing webhook.

        Parameters
        ----------
        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
            The webhook to fetch. This may be the object or the ID
            of an existing webhook.

        Other Parameters
        ----------------
        token : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the webhoook token that will be used to fetch
            the webhook instead of the token the client was initialized with.

        Returns
        -------
        hikari.webhooks.Webhook
            The requested webhook.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission when not
            using a token.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_channel_webhooks(
        self,
        channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    ) -&gt; typing.Sequence[webhooks.Webhook]:
        &#34;&#34;&#34;Fetch all channel webhooks.

        Parameters
        ----------
        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
            The channel to fetch the webhooks for. This
            may be a `hikari.channels.TextChannel` or the ID of an
            existing channel.

        Returns
        -------
        typing.Sequence[hikari.webhooks.Webhook]
            The fetched webhooks.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_webhooks(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[webhooks.Webhook]:
        &#34;&#34;&#34;Fetch all guild webhooks.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the webhooks for. This may be the object
            or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.webhooks.Webhook]
            The fetched webhooks.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.TextChannel]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; webhooks.Webhook:
        &#34;&#34;&#34;Edit a webhook.

        Parameters
        ----------
        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
            The webhook to edit. This may be the object or the
            ID of an existing webhook.

        Other Parameters
        ----------------
        token : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the webhoook token that will be used to edit
            the webhook instead of the token the client was initialized with.
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new webhook name.
        avatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]
            If provided, the new webhook avatar. If `builtins.None`, will
            remove the webhook avatar.
        channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]]
            If provided, the text channel to move the webhook to.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.webhooks.Webhook
            The edited webhook.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission when not
            using a token.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhook is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        *,
        token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Delete a webhook.

        Parameters
        ----------
        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
            The webhook to delete. This may be the object or the
            ID of an existing webhook.

        Other Parameters
        ----------------
        token : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the webhoook token that will be used to delete
            the webhook instead of the token the client was initialized with.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_WEBHOOKS` permission when not
            using a token.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the webhoook is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def execute_webhook(
        self,
        webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
        token: str,
        content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
        embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
        attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
        attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
        tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        user_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
        ] = undefined.UNDEFINED,
        role_mentions: undefined.UndefinedOr[
            typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
        ] = undefined.UNDEFINED,
    ) -&gt; messages_.Message:
        &#34;&#34;&#34;Execute a webhook.

        Parameters
        ----------
        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
            The webhook to execute. This may be the object
            or the ID of an existing webhook
        token: builtins.str
            The webhook token.
        content : hikari.undefined.UndefinedOr[typing.Any]
            If provided, the message contents. If
            `hikari.undefined.UNDEFINED`, then nothing will be sent
            in the content. Any other value here will be cast to a
            `builtins.str`.

            If this is a `hikari.embeds.Embed` and no `embed` nor
            no `embeds` kwarg is provided, then this will instead
            update the embed. This allows for simpler syntax when
            sending an embed alone.

            Likewise, if this is a `hikari.files.Resource`, then the
            content is instead treated as an attachment if no `attachment` and
            no `attachments` kwargs are provided.

        Other Parameters
        ----------------
        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
            If provided, the message embed.
        embeds : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
            If provided, the message embeds.
        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],
            If provided, the message attachment. This can be a resource,
            or string of a path on your computer or a URL.
        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],
            If provided, the message attachments. These can be resources, or
            strings consisting of paths on your computer or URLs.
        tts : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message will be read out by a screen
            reader using Discord&#39;s TTS (text-to-speech) system.
        nonce : hikari.undefined.UndefinedOr[builtins.str]
            An arbitrary identifier to associate with the message. This
            can be used to identify it later in received events. If provided,
            this must be less than 32 bytes. If not provided, then
            a null value is placed on the message instead. All users can
            see this value.
        mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether the message should parse @everyone/@here
            mentions.
        user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]], builtins.bool]]
            If provided, and `builtins.True`, all user mentions will be detected.
            If provided, and `builtins.False`, all user mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.users.PartialUser` derivatives to enforce mentioning
            specific users.
        role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]], builtins.bool]]
            If provided, and `builtins.True`, all role mentions will be detected.
            If provided, and `builtins.False`, all role mentions will be ignored
            if appearing in the message body.
            Alternatively this may be a collection of
            `hikari.snowflakes.Snowflake`, or
            `hikari.guilds.PartialRole` derivatives to enforce mentioning
            specific roles.

        !!! note
            Attachments can be passed as many different things, to aid in
            convenience.

            - If a `pathlib.PurePath` or `builtins.str` to a valid URL, the
                resource at the given URL will be streamed to Discord when
                sending the message. Subclasses of
                `hikari.files.WebResource` such as
                `hikari.files.URL`,
                `hikari.messages.Attachment`,
                `hikari.emojis.Emoji`,
                `EmbedResource`, etc will also be uploaded this way.
                This will use bit-inception, so only a small percentage of the
                resource will remain in memory at any one time, thus aiding in
                scalability.
            - If a `hikari.files.Bytes` is passed, or a `builtins.str`
                that contains a valid data URI is passed, then this is uploaded
                with a randomized file name if not provided.
            - If a `hikari.files.File`, `pathlib.PurePath` or
                `builtins.str` that is an absolute or relative path to a file
                on your file system is passed, then this resource is uploaded
                as an attachment using non-blocking code internally and streamed
                using bit-inception where possible. This depends on the
                type of `concurrent.futures.Executor` that is being used for
                the application (default is a thread pool which supports this
                behaviour).

        Returns
        -------
        hikari.messages.Message
            The created message.

        Raises
        ------
        builtins.ValueError
            If more than 100 unique objects/entities are passed for
            `role_mentions` or `user_mentions`.
        builtins.TypeError
            If both `attachment` and `attachments` are specified or if both
            `embed` and `embeds` are specified.
        hikari.errors.BadRequestError
            This may be raised in several discrete situations, such as messages
            being empty with no attachments or embeds; messages with more than
            2000 characters in them, embeds that exceed one of the many embed
            limits; too many attachments; attachments that are too large;
            invalid image URLs in embeds; users in `user_mentions` not being
            mentioned in the message content; roles in `role_mentions` not
            being mentioned in the message content.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the channel is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def fetch_gateway_url(self) -&gt; str:
        &#34;&#34;&#34;Fetch the gateway url.

        !!! note
            This endpoint does not require any valid authorization.

        Raises
        ------
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_gateway_bot(self) -&gt; sessions.GatewayBot:
        &#34;&#34;&#34;Fetch the gateway gateway info for the bot.

        Returns
        -------
        hikari.sessions.GatewayBot
            The gateway bot.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_invite(self, invite: invites.Inviteish) -&gt; invites.Invite:
        &#34;&#34;&#34;Fetch an existing invite.

        Parameters
        ----------
        invite : hikari.invites.Inviteish
            The invite to fetch. This may be an invite object or
            the code of an existing invite.

        Returns
        -------
        hikari.invites.Invite
            The requested invite.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the invite is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_invite(self, invite: invites.Inviteish) -&gt; None:
        &#34;&#34;&#34;Delete an existing invite.

        Parameters
        ----------
        invite : hikari.invites.Inviteish
            The invite to delete. This may be an invite object or
            the code of an existing invite.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission in the guild
            the invite is from or if you are missing the `MANAGE_CHANNELS`
            permission in the channel the invite is from.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the invite is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_my_user(self) -&gt; users.OwnUser:
        &#34;&#34;&#34;Fetch the token&#39;s associated user.

        Returns
        -------
        hikari.users.OwnUser
            The token&#39;s associated user.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_my_user(
        self,
        *,
        username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    ) -&gt; users.OwnUser:
        &#34;&#34;&#34;Edit the token&#39;s associated user.

        Other Parameters
        ----------------
        username : undefined.UndefinedOr[builtins.str]
            If provided, the new username.
        avatar : undefined.UndefinedNoneOr[hikari.files.Resourceish]
            If provided, the new avatar. If `builtins.None`,
            the avatar will be removed.

        Returns
        -------
        hikari.users.OwnUser
            The edited token&#39;s associated user.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.

            Discord also returns this on a ratelimit:
            https://github.com/discord/discord-api-docs/issues/1462
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_my_connections(self) -&gt; typing.Sequence[applications.OwnConnection]:
        &#34;&#34;&#34;Fetch the token&#39;s associated connections.

        Returns
        -------
        hikari.applications.OwnConnection
            The token&#39;s associated connections.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def fetch_my_guilds(
        self,
        *,
        newest_first: bool = False,
        start_at: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[applications.OwnGuild]:
        &#34;&#34;&#34;Fetch the token&#39;s associated guilds.

        Other Parameters
        ----------------
        newest_first : builtins.bool
            Whether to fetch the newest first or the olders first.
            Defaults to `builtins.False`.
        start_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild]]
            If provided, will start at this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may also be a guild object. In this case, the
            date the object was first created will be used.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.applications.OwnGuild]
            The token&#39;s associated guilds.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the
            result is awaited or iterated over. Invoking this function
            itself will not raise anything.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def leave_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /) -&gt; None:
        &#34;&#34;&#34;Leave a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to leave. This may be the object or
            the ID of an existing guild.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found or you own the guild.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    # THIS IS AN OAUTH2 FLOW ONLY
    @abc.abstractmethod
    async def create_dm_channel(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; channels.DMChannel:
        &#34;&#34;&#34;Create a DM channel with a user.

        Parameters
        ----------
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to create the DM channel with. This may be the
            object or the ID of an existing user.

        Returns
        -------
        hikari.channels.DMChannel
            The created DM channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If the user is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    # THIS IS AN OAUTH2 FLOW BUT CAN BE USED BY BOTS ALSO
    @abc.abstractmethod
    async def fetch_application(self) -&gt; applications.Application:
        &#34;&#34;&#34;Fetch the token&#39;s associated application.

        Returns
        -------
        hikari.applications.Application
            The token&#39;s associated application.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    # THIS IS AN OAUTH2 FLOW ONLY
    @abc.abstractmethod
    async def add_user_to_guild(
        self,
        access_token: str,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[guilds.Member]:
        &#34;&#34;&#34;Add a user to a guild.

        !!! note
            This requires the `access_token` to have the
            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to add the user to. This may be the object
            or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to add to the guild. This may be the object
            or the ID of an existing user.

        Other Parameters
        ----------------
        nick : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the nick to add to the user when he joins the guild.

            Requires the `MANAGE_NICKNAMES` permission on the guild.
        roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the roles to add to the user when he joins the guild.
            This may be a collection objects or IDs of existing roles.

            Requires the `MANAGE_ROLES` permission on the guild.
        mute : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, the mute state to add the user when he joins the guild.

            Requires the `MUTE_MEMBERS` permission on the guild.
        deaf : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, the deaf state to add the user when he joins the guild.

            Requires the `DEAFEN_MEMBERS` permission on the guild.

        Returns
        -------
        typing.Optional[hikari.guilds.Member]
            `builtins.None` if the user was already part of the guild, else
            `hikari.guilds.Member`.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are not part of the guild you want to add the user to,
            if you are missing permissions to do one of the things you specified,
            if you are using an access token for another user, if the token is
            bound to annother bot or if the access token doesnt have the
            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If you own the guild or the user is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_voice_regions(self) -&gt; typing.Sequence[voices.VoiceRegion]:
        &#34;&#34;&#34;Fetch available voice regions.

        !!! note
            This endpoint doesn&#39;t return VIP voice regions.

        Returns
        -------
        typing.Sequence[hikari.voices.VoiceRegion]
            The available voice regions.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser]) -&gt; users.User:
        &#34;&#34;&#34;Fetch a user.

        Parameters
        ----------
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to fetch. This can be the object
            or the ID of an existing user.

        Returns
        -------
        hikari.users.User
            The requested user

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the user is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    def fetch_audit_log(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
        user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        event_type: undefined.UndefinedOr[audit_logs.AuditLogEventType] = undefined.UNDEFINED,
    ) -&gt; iterators.LazyIterator[audit_logs.AuditLog]:
        &#34;&#34;&#34;Fetch the guild&#39;s audit log.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the audit logs from. This can be a
            guild object or the ID of an existing guild.

        Other Parameters
        ----------------
        before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
            If provided, filter to only actions after this snowflake. If you provide
            a datetime object, it will be transformed into a snowflake. This
            may be any other Discord entity that has an ID. In this case, the
            date the object was first created will be used.
        user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]
            If provided, the user to filter for.
        event_type : hikari.undefined.UndefinedOr[hikari.audit_logs.AuditLogEventType]
            If provided, the event type to filter for.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog]
            The guild&#39;s audit log.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `VIEW_AUDIT_LOG` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the
            result is awaited or iterated over. Invoking this function
            itself will not raise anything.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
    ) -&gt; emojis.KnownCustomEmoji:
        &#34;&#34;&#34;Fetch a guild emoji.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the emoji from. This can be a
            guild object or the ID of an existing guild.
        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]
            The emoji to fetch. This can be a `hikari.emojis.CustomEmoji`
            or the ID of an existing emoji.

        Returns
        -------
        hikari.emojis.KnownCustomEmoji
            The requested emoji.

        Raises
        ------
        hikari.errors.NotFoundError
            If the guild or the emoji are not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_emojis(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[emojis.KnownCustomEmoji]:
        &#34;&#34;&#34;Fetch the emojis of a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the emojis from. This can be a
            guild object or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.emojis.KnownCustomEmoji]
            The requested emojis.

        Raises
        ------
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        image: files.Resourceish,
        *,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        &#34;&#34;&#34;Create an emoji in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the emoji on. This can be a
            guild object or the ID of an existing guild.
        name : builtins.str
            The name for the emoji.
        image : hikari.files.Resourceish
            The 128x128 image for the emoji. Maximum upload size is 256kb.
            This can be a still or an animated image.

        Other Parameters
        ----------------
        roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, a collection of the roles that will be able to
            use this emoji. This can be a `hikari.guilds.PartialRole` or
            the ID of an existing role.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.emojis.KnownCustomEmoji
            The created emoji.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value or
            if there are no more spaces for the type of emoji in the guild.
        hikari.errors.ForbiddenError
            If you are missing `MANAGE_EMOJIS` in the server.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; emojis.KnownCustomEmoji:
        &#34;&#34;&#34;Edit an emoji in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit the emoji on. This can be a
            guild object or the ID of an existing guild.
        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]
            The emoji to edit. This can be a `hikari.emojis.CustomEmoji`
            or the ID of an existing emoji.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name for the emoji.
        roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the new collection of roles that will be able to
            use this emoji. This can be a `hikari.guilds.PartialRole` or
            the ID of an existing role.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.emojis.KnownCustomEmoji
            The edited emoji.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing `MANAGE_EMOJIS` in the server.
        hikari.errors.NotFoundError
            If the guild or the emoji are not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_emoji(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
        # Reason is not currently supported for some reason.
    ) -&gt; None:
        &#34;&#34;&#34;Delete an emoji in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to delete the emoji on. This can be a
            guild object or the ID of an existing guild.
        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]
            The emoji to delete. This can be a `hikari.emojis.CustomEmoji`
            or the ID of an existing emoji.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing `MANAGE_EMOJIS` in the server.
        hikari.errors.NotFoundError
            If the guild or the emoji are not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def guild_builder(self, name: str, /) -&gt; special_endpoints.GuildBuilder:
        &#34;&#34;&#34;Make a guild builder to create a guild with.

        Parameters
        ----------
        name : builtins.str
            The new guilds name.

        Returns
        -------
        hikari.api.special_endpoints.GuildBuilder
            The guild builder to use. This will allow to create a guild
            later with `hikari.api.special_endpoints.GuildBuilder.create`.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once
            `hikari.api.special_endpoints.GuildBuilder.create` is called.
            Invoking this function itself will not raise any of
            the above types.

        See Also
        --------
        Guild builder: `hikari.api.special_endpoints.GuildBuilder`
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.RESTGuild:
        &#34;&#34;&#34;Fetch a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch. This can be the object
            or the ID of an existing guild.

        Returns
        -------
        hikari.guilds.RESTGuild
            The requested guild.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are not part of the guild.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_preview(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildPreview:
        &#34;&#34;&#34;Fetch a guild preview.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the preview of. This can be a
            guild object or the ID of an existing guild.

        Returns
        -------
        hikari.guilds.GuildPreview
            The requested guild preview.

        !!! note
            This will only work for guilds you are a part of or are public.

        Raises
        ------
        hikari.errors.NotFoundError
            If the guild is not found or you are not part of the guild.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_guild(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        region: undefined.UndefinedOr[voices.VoiceRegionish] = undefined.UNDEFINED,
        verification_level: undefined.UndefinedOr[guilds.GuildVerificationLevel] = undefined.UNDEFINED,
        default_message_notifications: undefined.UndefinedOr[
            guilds.GuildMessageNotificationsLevel
        ] = undefined.UNDEFINED,
        explicit_content_filter_level: undefined.UndefinedOr[
            guilds.GuildExplicitContentFilterLevel
        ] = undefined.UNDEFINED,
        afk_channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]] = undefined.UNDEFINED,
        afk_timeout: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        icon: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        owner: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
        splash: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        banner: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
        system_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        rules_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        public_updates_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildTextChannel]
        ] = undefined.UNDEFINED,
        preferred_locale: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.RESTGuild:
        &#34;&#34;&#34;Edit a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit. This may be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name for the guild.
        region : hikari.undefined.UndefinedOr[hikari.voices.VoiceRegionish]
            If provided, the new voice region for the guild.
        verification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel]
            If provided, the new verification level.
        default_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel]
            If provided, the new default message notifications level.
        explicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel]
            If provided, the new explicit content filter level.
        afk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]
            If provided, the new afk channel. Requires `afk_timeout` to
            be set to work.
        afk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
            If provided, the new afk timeout.
        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
            If provided, the new guild icon. Must be a 1024x1024 image or can be
            an animated gif when the guild has the `ANIMATED_ICON` feature.
        owner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]]
            If provided, the new guild owner.

            !!! warn
                You need to be the owner of the server to use this.
        splash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]
            If provided, the new guild splash. Must be a 16:9 image and the
            guild must have the `INVITE_SPLASH` feature.
        banner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]
            If provided, the new guild banner. Must be a 16:9 image and the
            guild must have the `BANNER` feature.
        system_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]
            If provided, the new system channel.
        rules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]
            If provided, the new rules channel.
        public_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]
            If provided, the new public updates channel.
        preferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str]
            If provided, the new preferred locale.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.guilds.RESTGuild
            The edited guild.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value. Or
            you are missing the
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission or if you tried to
            pass ownership without being the server owner.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def delete_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; None:
        &#34;&#34;&#34;Delete a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to delete. This may be the object or
            the ID of an existing guild.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are not the owner of the guild.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If you own the guild or if you are not in it.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_channels(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; typing.Sequence[channels.GuildChannel]:
        &#34;&#34;&#34;Fetch the channels in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the channels from. This may be the
            object or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.channels.GuildChannel]
            The requested channels.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_guild_text_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildTextChannel:
        &#34;&#34;&#34;Create a text channel in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the channel in. This may be the
            object or the ID of an existing guild.
        name : builtins.str
            The channels name. Must be between 2 and 1000 characters.

        Other Parameters
        ----------------
        position : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the position of the channel (relative to the
            category, if any).
        topic : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the channels topic. Maximum 1024 characters.
        nsfw : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to mark the channel as NSFW.
        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
            If provided, the ammount of seconds a user has to wait
            before being able to send another message in the channel.
            Maximum 21600 seconds.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the permission overwrites for the channel.
        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
            The category to create the channel under. This may be the
            object or the ID of an existing category.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.GuildTextChannel
            The created channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_guild_news_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildNewsChannel:
        &#34;&#34;&#34;Create a news channel in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the channel in. This may be the
            object or the ID of an existing guild.
        name : builtins.str
            The channels name. Must be between 2 and 1000 characters.

        Other Parameters
        ----------------
        position : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the position of the channel (relative to the
            category, if any).
        topic : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the channels topic. Maximum 1024 characters.
        nsfw : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to mark the channel as NSFW.
        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
            If provided, the ammount of seconds a user has to wait
            before being able to send another message in the channel.
            Maximum 21600 seconds.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the permission overwrites for the channel.
        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
            The category to create the channel under. This may be the
            object or the ID of an existing category.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.GuildNewsChannel
            The created channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_guild_voice_channel(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildVoiceChannel:
        &#34;&#34;&#34;Create a voice channel in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the channel in. This may be the
            object or the ID of an existing guild.
        name : builtins.str
            The channels name. Must be between 2 and 1000 characters.

        Other Parameters
        ----------------
        position : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the position of the channel (relative to the
            category, if any).
        user_limit : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the maximum users in the channel at once.
            Must be between 0 and 99 with 0 meaning no limit.
        bitrate : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the bitrate for the channel. Must be
            between 8000 and 96000 or 8000 and 128000 for VIP
            servers.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the permission overwrites for the channel.
        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
            The category to create the channel under. This may be the
            object or the ID of an existing category.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.GuildVoiceChannel
            The created channel.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_guild_category(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        name: str,
        *,
        position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        permission_overwrites: undefined.UndefinedOr[
            typing.Sequence[channels.PermissionOverwrite]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; channels.GuildCategory:
        &#34;&#34;&#34;Create a category in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the channel in. This may be the
            object or the ID of an existing guild.
        name : builtins.str
            The channels name. Must be between 2 and 1000 characters.

        Other Parameters
        ----------------
        position : hikari.undefined.UndefinedOr[builtins.int]
            If provided, the position of the category.
        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
            If provided, the permission overwrites for the category.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.channels.GuildCategory
            The created category.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def reposition_channels(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[channels.GuildChannel]],
    ) -&gt; None:
        &#34;&#34;&#34;Reposition the channels in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to reposition the channels in. This may be the
            object or the ID of an existing guild.
        positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]
            A mapping of of the object or the ID of an existing channel to
            the new position, relative to their parent category, if any.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_CHANNEL` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.Member:
        &#34;&#34;&#34;Fetch a guild member.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to get the member from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to get the member for. This may be the
            object or the ID of an existing user.

        Returns
        -------
        hikari.guilds.Member
            The requested member.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or the user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    def fetch_members(
        self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
    ) -&gt; iterators.LazyIterator[guilds.Member]:
        &#34;&#34;&#34;Fetch the members from a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the members of. This may be the
            object or the ID of an existing guild.

        Returns
        -------
        hikari.iterators.LazyIterator[hikari.guilds.Member]
            An iterator to fetch the members.

        !!! note
           This call is not a coroutine function, it returns a special type of
           lazy iterator that will perform API calls as you iterate across it.
           See `hikari.iterators` for the full API for this iterator type.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.

        !!! note
            The exceptions on this endpoint will only be raised once the
            result is awaited or iterated over. Invoking this function
            itself will not raise anything.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        nick: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
        roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        voice_channel: undefined.UndefinedNoneOr[
            snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit a guild member.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit. This may be the object
            or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit. This may be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        nick : hikari.undefined.UndefinedNoneOr[builtins.str]
            If provided, the new nick for the member. If `builtins.None`,
            will remove the members nick.

            Requires the `MANAGE_NICKNAMES` permission.
        roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the new roles for the member.

            Requires the `MANAGE_ROLES` permission.
        mute : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, the new server mute state for the member.

            Requires the `MUTE_MEMBERS` permission.
        deaf : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, the new server deaf state for the member.

            Requires the `DEAFEN_MEMBERS` permission.
        voice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]]
            If provided, `builtins.None` or the object or the ID of
            an existing voice channel to move the member to.
            If `builtins.None`, will disconnect the member from voice.

            Requires the `MOVE_MEMBERS` permission and the `CONNECT`
            permission in the original voice channel and the target
            voice channel.

            !!! note
                If the member is not in a voice channel, this will
                take no effect.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing a permission to do an action.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or the user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_my_nick(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.Guild],
        nick: typing.Optional[str],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Edit the associated token&#39;s member nick.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit. This may be the object
            or the ID of an existing guild.
        nick : typing.Optional[builtins.str]
            The new nick. If `builtins.None`,
            will remove the nick.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `CHANGE_NICKNAME` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def add_role_to_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Add a role to a member.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild where the member is in. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to add the role to. This may be the
            object or the ID of an existing user.
        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
            The role to add. This may be the object or the
            ID of an existing role.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild, user or role are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def remove_role_from_member(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Remove a role from a member.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild where the member is in. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to remove the role from. This may be the
            object or the ID of an existing user.
        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
            The role to remove. This may be the object or the
            ID of an existing role.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild, user or role are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def kick_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Kick a member from a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to kick the member from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to kick. This may be the object
            or the ID of an existing user.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `KICK_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    kick_member = kick_user
    &#34;&#34;&#34;This is simply an alias for readability.&#34;&#34;&#34;

    @abc.abstractmethod
    async def ban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        delete_message_days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Ban a member from a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to ban the member from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to kick. This may be the object
            or the ID of an existing user.

        Other Parameters
        ----------------
        delete_message_days : hikari.undefined.UndefinedNoneOr[int]
            If provided, the number of days to delete messages for.
            This must be between 0 and 7.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `BAN_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    ban_member = ban_user
    &#34;&#34;&#34;This is simply an alias for readability.&#34;&#34;&#34;

    @abc.abstractmethod
    async def unban_user(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
        *,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        &#34;&#34;&#34;Unban a member from a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to unban the member from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to unban. This may be the object
            or the ID of an existing user.

        Other Parameters
        ----------------
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `BAN_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or user are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    unban_member = unban_user
    &#34;&#34;&#34;This is simply an alias for readability.&#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_ban(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        user: snowflakes.SnowflakeishOr[users.PartialUser],
    ) -&gt; guilds.GuildMemberBan:
        &#34;&#34;&#34;Fetch the guild&#39;s ban info for a user.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the ban from. This may be the
            object or the ID of an existing guild.
        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
            The user to fetch the ban of. This may be the
            object or the ID of an existing user.

        Returns
        -------
        hikari.guilds.GuildMemberBan
            The requested ban info.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `BAN_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or user are not found or if the user
            is not banned.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_bans(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.GuildMemberBan]:
        &#34;&#34;&#34;Fetch the bans of a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the bans from. This may be the
            object or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.guilds.GuildMemberBan]
            The requested bans.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `BAN_MEMBERS` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Role]:
        &#34;&#34;&#34;Fetch the roles of a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the roles from. This may be the
            object or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.guilds.Role]
            The requested roles.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def create_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        &#34;&#34;&#34;Create a role.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to create the role in. This may be the
            object or the ID of an existing guild.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the name for the role.
        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
            The permissions to give the role. This will default to setting
            NO roles if left to the default value. This is in contrast to
            default behaviour on Discord where some random permissions will
            be set by default.
        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
            If provided, the role&#39;s color.
        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
            An alias for `color`.
        hoist : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to hoist the role.
        mentionable : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to make the role mentionable.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.guilds.Role
            The created role.

        Raises
        ------
        builtins.TypeError
            If both `color` and `colour` are specified.
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def reposition_roles(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        positions: typing.Mapping[int, snowflakes.SnowflakeishOr[guilds.PartialRole]],
    ) -&gt; None:
        &#34;&#34;&#34;Reposition the roles in a guild.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to reposition the roles in. This may be
            the object or the ID of an existing guild.
        positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]
            A mapping of the position to the role.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
        *,
        name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
        permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
        color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
        hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.Role:
        &#34;&#34;&#34;Edit a role.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit the role in. This may be the
            object or the ID of an existing guild.
        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
            The role to edit. This may be the object or the
            ID of an existing role.

        Other Parameters
        ----------------
        name : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the new name for the role.
        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
            If provided, the new permissions for the role.
        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
            If provided, the new color for the role.
        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
            An alias for `color`.
        hoist : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to hoist the role.
        mentionable : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to make the role mentionable.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.guilds.Role
            The edited role.

        Raises
        ------
        builtins.TypeError
            If both `color` and `colour` are specified.
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or role are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def delete_role(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    ) -&gt; None:
        &#34;&#34;&#34;Delete a role.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to delete the role in. This may be the
            object or the ID of an existing guild.
        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
            The role to delete. This may be the object or the
            ID of an existing role.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_ROLES` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild or role are not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def estimate_guild_prune_count(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
    ) -&gt; int:
        &#34;&#34;&#34;Estimate the guild prune count.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to estimate the guild prune count for. This may be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        days : hikari.undefined.UndefinedOr[builtins.int]
            If provided, number of days to count prune for.
        include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the role(s) to include. By default, this endpoint will
            not count users with roles. Providing roles using this attribute
            will make members with the specified roles also get included into
            the count.

        Returns
        -------
        builtins.int
            The estimated guild prune count.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `KICK_MEMBERS` permission.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def begin_guild_prune(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
        compute_prune_count: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        include_roles: undefined.UndefinedOr[
            typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
        ] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;Begin the guild prune.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to begin the guild prune in. This may be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        days : hikari.undefined.UndefinedOr[builtins.int]
            If provided, number of days to count prune for.
        compute_prune_count: hikari.snowflakes.SnowflakeishOr[builtins.bool]
            If provided, whether to return the prune count. This is discouraged
            for large guilds.
        include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
            If provided, the role(s) to include. By default, this endpoint will
            not count users with roles. Providing roles using this attribute
            will make members with the specified roles also get included into
            the count.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        typing.Optional[builtins.int]
            If `compute_prune_count` is not provided or `builtins.True`, the
            number of members pruned. Else `builtins.None`.

        Raises
        ------
        hikari.errors.BadRequestError
            If any of the fields that are passed have an invalid value.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.ForbiddenError
            If you are missing the `KICK_MEMBERS` permission.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;  # noqa: E501 - Line too long

    @abc.abstractmethod
    async def fetch_guild_voice_regions(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[voices.VoiceRegion]:
        &#34;&#34;&#34;Fetch the available voice regions for a guild.

        !!! note
            Unlike `RESTClient.fetch_voice_regions`, this will
            return the VIP regions if the guild has access to them.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the voice regions for. This may be the object
            or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.voices.VoiceRegion]
            The available voice regions for the guild.

        Raises
        ------
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_guild_invites(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[invites.InviteWithMetadata]:
        &#34;&#34;&#34;Fetch the guild&#39;s invites.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the invites for. This may be the object
            or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.invites.InviteWithMetadata]
            The invites for the guild.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_integrations(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    ) -&gt; typing.Sequence[guilds.Integration]:
        &#34;&#34;&#34;Fetch the guild&#39;s integrations.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the integrations for. This may be the object
            or the ID of an existing guild.

        Returns
        -------
        typing.Sequence[hikari.guilds.Integration]
            The integrations for the guild.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_widget(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildWidget:
        &#34;&#34;&#34;Fetch a guilds&#39;s widget.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the widget from. This can be the object
            or the ID of an existing guild.

        Returns
        -------
        hikari.guilds.GuildWidget
            The requested guild widget.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def edit_widget(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        channel: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[channels.GuildChannel]] = undefined.UNDEFINED,
        enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; guilds.GuildWidget:
        &#34;&#34;&#34;Fetch a guilds&#39;s widget.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to edit the widget in. This can be the object
            or the ID of an existing guild.

        Other Parameters
        ----------------
        channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]
            If provided, the channel to set the widget to. If `builtins.None`,
            will not set to any.
        enabled : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to enable the widget.
        reason : hikari.undefined.UndefinedOr[builtins.str]
            If provided, the reason that will be recorded in the audit logs.
            Maximum of 512 characters.

        Returns
        -------
        hikari.guilds.GuildWidget
            The edited guild widget.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are missing the `MANAGE_GUILD` permission.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def fetch_vanity_url(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; invites.VanityURL:
        &#34;&#34;&#34;Fetch a guild&#39;s vanity url.

        Parameters
        ----------
        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
            The guild to fetch the vanity url from. This can
            be the object or the ID of an existing guild.

        Returns
        -------
        hikari.invites.VanityURL
            The requested invite.

        Raises
        ------
        hikari.errors.ForbiddenError
            If you are not part of the guild.
        hikari.errors.NotFoundError
            If the guild is not found.
        hikari.errors.UnauthorizedError
            If you are unauthorized to make the request (invalid/missing token).
        hikari.errors.RateLimitTooLongError
            Raised in the event that a rate limit occurs that is
            longer than `max_rate_limit` when making a request.
        hikari.errors.RateLimitedError
            Usually, Hikari will handle and retry on hitting
            rate-limits automatically. This includes most bucket-specific
            rate-limits and global rate-limits. In some rare edge cases,
            however, Discord implements other undocumented rules for
            rate-limiting, such as limits per attribute. These cannot be
            detected or handled normally by Hikari due to their undocumented
            nature, and will trigger this exception if they occur.
        hikari.errors.InternalServerError
            If an internal error occurs on Discord while handling the request.
        &#34;&#34;&#34;</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClientImpl -- Implementation of the V6 and V7-compatible Discord HTTP API …" href="../impl/rest.html#hikari.impl.rest.RESTClientImpl"
>RESTClientImpl</a></dt>
<dd class="nested"><p>Implementation of the V6 and V7-compatible Discord HTTP API …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="RESTClient -- Interface for functionality that a REST API implementation provides." href="#hikari.api.rest.RESTClient"
>RESTClient</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="NetworkSettingsAware -- Structural supertype for any component aware of network settings." href="../traits.html#hikari.traits.NetworkSettingsAware"
>NetworkSettingsAware</a></dt>
<dd class="nested"><p>Structural supertype for any component aware of network settings.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Protocol -- Base class for protocol classes …" href="https://docs.python.org/3/library/typing.html#typing.Protocol"
>Protocol</a></dt>
<dd class="nested"><p>Base class for protocol classes …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="http_settings -- Return the HTTP settings in use by this component …" href="../traits.html#hikari.traits.NetworkSettingsAware.http_settings" id="hikari.api.rest.RESTClient.http_settings" >http_settings</a> : config.HTTPSettings</code></pre>
</dt>
<dd><p>Return the HTTP settings in use by this component.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a></code></dt>
<dd>The HTTP settings in use.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="proxy_settings -- Return the proxy settings in use by this component …" href="../traits.html#hikari.traits.NetworkSettingsAware.proxy_settings" id="hikari.api.rest.RESTClient.proxy_settings" >proxy_settings</a> : config.ProxySettings</code></pre>
</dt>
<dd><p>Return the proxy settings in use by this component.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a></code></dt>
<dd>The proxy settings in use.</dd>
</dl></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.api.rest.RESTClient.add_reaction" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="add_reaction" href="#hikari.api.rest.RESTClient.add_reaction" id="hikari.api.rest.RESTClient.add_reaction">add_reaction</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Add a reaction emoji to a message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to add the reaction to is. This
may be a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an existing
channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to add a reaction to. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to react to the message with.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>ADD_REACTIONS</code> (this is only necessary if you
are the first person to add the reaction).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1294-L1340" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def add_reaction(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    emoji: emojis.Emojiish,
) -&gt; None:
    &#34;&#34;&#34;Add a reaction emoji to a message in a given channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel where the message to add the reaction to is. This
        may be a `hikari.channels.TextChannel` or the ID of an existing
        channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to add a reaction to. This may be the
        object or the ID of an existing message.
    emoji : hikari.emojis.Emojiish
        The emoji to react to the message with.

    Raises
    ------
    hikari.errors.BadRequestError
        If an invalid unicode emoji is given, or if the given custom emoji
        does not exist.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `ADD_REACTIONS` (this is only necessary if you
        are the first person to add the reaction).
    hikari.errors.NotFoundError
        If the channel or message is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.add_role_to_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="add_role_to_member" href="#hikari.api.rest.RESTClient.add_role_to_member" id="hikari.api.rest.RESTClient.add_role_to_member">add_role_to_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Add a role to a member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild where the member is in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to add the role to. This may be the
object or the ID of an existing user.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>The role to add. This may be the object or the
ID of an existing role.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild, user or role are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3745-L3795" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def add_role_to_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Add a role to a member.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild where the member is in. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to add the role to. This may be the
        object or the ID of an existing user.
    role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
        The role to add. This may be the object or the
        ID of an existing role.

    Other Parameters
    ----------------
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_ROLES` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild, user or role are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.add_user_to_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="add_user_to_guild" href="#hikari.api.rest.RESTClient.add_user_to_guild" id="hikari.api.rest.RESTClient.add_user_to_guild">add_user_to_guild</a>(
    access_token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    nick: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    mute: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    deaf: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>]: ...</code></pre>
</dt>
<dd>
<p>Add a user to a guild.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This requires the <code>access_token</code> to have the
<code><a href='../applications.html#hikari.applications.OAuth2Scope.GUILDS_JOIN'>GUILDS_JOIN</a></code> scope enabled.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to add the user to. This may be the object
or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to add to the guild. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>nick</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>
<p>If provided, the nick to add to the user when he joins the guild.</p>
<p>Requires the <code>MANAGE_NICKNAMES</code> permission on the guild.</p>
</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]]</code></dt>
<dd>
<p>If provided, the roles to add to the user when he joins the guild.
This may be a collection objects or IDs of existing roles.</p>
<p>Requires the <code>MANAGE_ROLES</code> permission on the guild.</p>
</dd>
<dt><strong><code>mute</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, the mute state to add the user when he joins the guild.</p>
<p>Requires the <code>MUTE_MEMBERS</code> permission on the guild.</p>
</dd>
<dt><strong><code>deaf</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, the deaf state to add the user when he joins the guild.</p>
<p>Requires the <code>DEAFEN_MEMBERS</code> permission on the guild.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd><code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if the user was already part of the guild, else
<code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild you want to add the user to,
if you are missing permissions to do one of the things you specified,
if you are using an access token for another user, if the token is
bound to annother bot or if the access token doesnt have the
<code><a href='../applications.html#hikari.applications.OAuth2Scope.GUILDS_JOIN'>GUILDS_JOIN</a></code> scope enabled.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If you own the guild or the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2405-L2487" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def add_user_to_guild(
    self,
    access_token: str,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    nick: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
) -&gt; typing.Optional[guilds.Member]:
    &#34;&#34;&#34;Add a user to a guild.

    !!! note
        This requires the `access_token` to have the
        `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to add the user to. This may be the object
        or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to add to the guild. This may be the object
        or the ID of an existing user.

    Other Parameters
    ----------------
    nick : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the nick to add to the user when he joins the guild.

        Requires the `MANAGE_NICKNAMES` permission on the guild.
    roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
        If provided, the roles to add to the user when he joins the guild.
        This may be a collection objects or IDs of existing roles.

        Requires the `MANAGE_ROLES` permission on the guild.
    mute : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, the mute state to add the user when he joins the guild.

        Requires the `MUTE_MEMBERS` permission on the guild.
    deaf : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, the deaf state to add the user when he joins the guild.

        Requires the `DEAFEN_MEMBERS` permission on the guild.

    Returns
    -------
    typing.Optional[hikari.guilds.Member]
        `builtins.None` if the user was already part of the guild, else
        `hikari.guilds.Member`.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are not part of the guild you want to add the user to,
        if you are missing permissions to do one of the things you specified,
        if you are using an access token for another user, if the token is
        bound to annother bot or if the access token doesnt have the
        `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If you own the guild or the user is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.ban_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="ban_member" href="#hikari.api.rest.RESTClient.ban_user" id="hikari.api.rest.RESTClient.ban_member">ban_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    delete_message_days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Ban a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to ban the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to kick. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>delete_message_days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the number of days to delete messages for.
This must be between 0 and 7.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3900-L3952" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def ban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    delete_message_days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Ban a member from a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to ban the member from. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to kick. This may be the object
        or the ID of an existing user.

    Other Parameters
    ----------------
    delete_message_days : hikari.undefined.UndefinedNoneOr[int]
        If provided, the number of days to delete messages for.
        This must be between 0 and 7.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing the `BAN_MEMBERS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or user are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.ban_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="ban_user" href="#hikari.api.rest.RESTClient.ban_user" id="hikari.api.rest.RESTClient.ban_user">ban_user</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    delete_message_days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Ban a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to ban the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to kick. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>delete_message_days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the number of days to delete messages for.
This must be between 0 and 7.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3900-L3952" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def ban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    delete_message_days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Ban a member from a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to ban the member from. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to kick. This may be the object
        or the ID of an existing user.

    Other Parameters
    ----------------
    delete_message_days : hikari.undefined.UndefinedNoneOr[int]
        If provided, the number of days to delete messages for.
        This must be between 0 and 7.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing the `BAN_MEMBERS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or user are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.begin_guild_prune" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="begin_guild_prune" href="#hikari.api.rest.RESTClient.begin_guild_prune" id="hikari.api.rest.RESTClient.begin_guild_prune">begin_guild_prune</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    compute_prune_count: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    include_roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]: ...</code></pre>
</dt>
<dd>
<p>Begin the guild prune.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to begin the guild prune in. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, number of days to count prune for.</dd>
<dt><strong><code>compute_prune_count</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to return the prune count. This is discouraged
for large guilds.</dd>
<dt><strong><code>include_roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]]</code></dt>
<dd>If provided, the role(s) to include. By default, this endpoint will
not count users with roles. Providing roles using this attribute
will make members with the specified roles also get included into
the count.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If <code>compute_prune_count</code> is not provided or <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, the
number of members pruned. Else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4420-L4485" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def begin_guild_prune(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    compute_prune_count: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    include_roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; typing.Optional[int]:
    &#34;&#34;&#34;Begin the guild prune.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to begin the guild prune in. This may be the object
        or the ID of an existing guild.

    Other Parameters
    ----------------
    days : hikari.undefined.UndefinedOr[builtins.int]
        If provided, number of days to count prune for.
    compute_prune_count: hikari.snowflakes.SnowflakeishOr[builtins.bool]
        If provided, whether to return the prune count. This is discouraged
        for large guilds.
    include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
        If provided, the role(s) to include. By default, this endpoint will
        not count users with roles. Providing roles using this attribute
        will make members with the specified roles also get included into
        the count.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    typing.Optional[builtins.int]
        If `compute_prune_count` is not provided or `builtins.True`, the
        number of members pruned. Else `builtins.None`.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `KICK_MEMBERS` permission.
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.close" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="close" href="#hikari.api.rest.RESTClient.close" id="hikari.api.rest.RESTClient.close">close</a>() -> None: ...</code></pre>
</dt>
<dd>
<p>Close the client session.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L77-L79" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def close(self) -&gt; None:
    &#34;&#34;&#34;Close the client session.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_crossposts" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_crossposts" href="#hikari.api.rest.RESTClient.create_crossposts" id="hikari.api.rest.RESTClient.create_crossposts">create_crossposts</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>channels.GuildNewsChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p>Broadcast an announcement message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>]</code></dt>
<dd>The object or ID of the news channel to crosspost a message in.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The object or ID of the message to crosspost.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The message object that was crossposted.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If you tried to crosspost a message that has already been broadcast.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you try to crosspost a message by the current user without the
<code>SEND_MESSAGES</code> permission for the target news channel or try to
crosspost a message by another user without both the <code>SEND_MESSAGES</code>
and <code>MANAGE_MESSAGES</code> permissions for the target channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1013-L1059" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_crossposts(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; messages_.Message:
    &#34;&#34;&#34;Broadcast an announcement message.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]
        The object or ID of the news channel to crosspost a message in.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The object or ID of the message to crosspost.

    Returns
    -------
    hikari.messages.Message
        The message object that was crossposted.

    Raises
    ------
    hikari.errors.BadRequestError
        If you tried to crosspost a message that has already been broadcast.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you try to crosspost a message by the current user without the
        `SEND_MESSAGES` permission for the target news channel or try to
        crosspost a message by another user without both the `SEND_MESSAGES`
        and `MANAGE_MESSAGES` permissions for the target channel.
    hikari.errors.NotFoundError
        If the channel or message is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_dm_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_dm_channel" href="#hikari.api.rest.RESTClient.create_dm_channel" id="hikari.api.rest.RESTClient.create_dm_channel">create_dm_channel</a>(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    /,
) -> <a href='../channels.html#hikari.channels.DMChannel'>channels.DMChannel</a>: ...</code></pre>
</dt>
<dd>
<p>Create a DM channel with a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to create the DM channel with. This may be the
object or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a></code></dt>
<dd>The created DM channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2339-L2373" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_dm_channel(self, user: snowflakes.SnowflakeishOr[users.PartialUser], /) -&gt; channels.DMChannel:
    &#34;&#34;&#34;Create a DM channel with a user.

    Parameters
    ----------
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to create the DM channel with. This may be the
        object or the ID of an existing user.

    Returns
    -------
    hikari.channels.DMChannel
        The created DM channel.

    Raises
    ------
    hikari.errors.BadRequestError
        If the user is not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_emoji" href="#hikari.api.rest.RESTClient.create_emoji" id="hikari.api.rest.RESTClient.create_emoji">create_emoji</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    image: <a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>,
    *,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>: ...</code></pre>
</dt>
<dd>
<p>Create an emoji in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the emoji on. This can be a
guild object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The name for the emoji.</dd>
<dt><strong><code>image</code></strong> :&ensp;<code><a href='../files.html#hikari.files.Resourceish'>Resourceish</a></code></dt>
<dd>The 128x128 image for the emoji. Maximum upload size is 256kb.
This can be a still or an animated image.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]]</code></dt>
<dd>If provided, a collection of the roles that will be able to
use this emoji. This can be a <code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> or
the ID of an existing role.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The created emoji.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value or
if there are no more spaces for the type of emoji in the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing <code>MANAGE_EMOJIS</code> in the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2703-L2767" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    image: files.Resourceish,
    *,
    roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; emojis.KnownCustomEmoji:
    &#34;&#34;&#34;Create an emoji in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to create the emoji on. This can be a
        guild object or the ID of an existing guild.
    name : builtins.str
        The name for the emoji.
    image : hikari.files.Resourceish
        The 128x128 image for the emoji. Maximum upload size is 256kb.
        This can be a still or an animated image.

    Other Parameters
    ----------------
    roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
        If provided, a collection of the roles that will be able to
        use this emoji. This can be a `hikari.guilds.PartialRole` or
        the ID of an existing role.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.emojis.KnownCustomEmoji
        The created emoji.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value or
        if there are no more spaces for the type of emoji in the guild.
    hikari.errors.ForbiddenError
        If you are missing `MANAGE_EMOJIS` in the server.
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_guild_category" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_category" href="#hikari.api.rest.RESTClient.create_guild_category" id="hikari.api.rest.RESTClient.create_guild_category">create_guild_category</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildCategory'>channels.GuildCategory</a>: ...</code></pre>
</dt>
<dd>
<p>Create a category in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the channel in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The channels name. Must be between 2 and 1000 characters.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the position of the category.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the permission overwrites for the category.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a></code></dt>
<dd>The created category.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3416-L3476" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_guild_category(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.GuildCategory:
    &#34;&#34;&#34;Create a category in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to create the channel in. This may be the
        object or the ID of an existing guild.
    name : builtins.str
        The channels name. Must be between 2 and 1000 characters.

    Other Parameters
    ----------------
    position : hikari.undefined.UndefinedOr[builtins.int]
        If provided, the position of the category.
    permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
        If provided, the permission overwrites for the category.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.channels.GuildCategory
        The created category.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_CHANNEL` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_guild_news_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_news_channel" href="#hikari.api.rest.RESTClient.create_guild_news_channel" id="hikari.api.rest.RESTClient.create_guild_news_channel">create_guild_news_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    topic: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    nsfw: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    rate_limit_per_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildNewsChannel'>channels.GuildNewsChannel</a>: ...</code></pre>
</dt>
<dd>
<p>Create a news channel in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the channel in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The channels name. Must be between 2 and 1000 characters.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the position of the channel (relative to the
category, if any).</dd>
<dt><strong><code>topic</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the channels topic. Maximum 1024 characters.</dd>
<dt><strong><code>nsfw</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to mark the channel as NSFW.</dd>
<dt><strong><code>rate_limit_per_user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>Intervalish</a>]</code></dt>
<dd>If provided, the ammount of seconds a user has to wait
before being able to send another message in the channel.
Maximum 21600 seconds.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the permission overwrites for the channel.</dd>
<dt><strong><code>category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>The category to create the channel under. This may be the
object or the ID of an existing category.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a></code></dt>
<dd>The created channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3262-L3338" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_guild_news_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.GuildNewsChannel:
    &#34;&#34;&#34;Create a news channel in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to create the channel in. This may be the
        object or the ID of an existing guild.
    name : builtins.str
        The channels name. Must be between 2 and 1000 characters.

    Other Parameters
    ----------------
    position : hikari.undefined.UndefinedOr[builtins.int]
        If provided, the position of the channel (relative to the
        category, if any).
    topic : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the channels topic. Maximum 1024 characters.
    nsfw : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether to mark the channel as NSFW.
    rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
        If provided, the ammount of seconds a user has to wait
        before being able to send another message in the channel.
        Maximum 21600 seconds.
    permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
        If provided, the permission overwrites for the channel.
    category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
        The category to create the channel under. This may be the
        object or the ID of an existing category.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.channels.GuildNewsChannel
        The created channel.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_CHANNEL` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_guild_text_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_text_channel" href="#hikari.api.rest.RESTClient.create_guild_text_channel" id="hikari.api.rest.RESTClient.create_guild_text_channel">create_guild_text_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    topic: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    nsfw: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    rate_limit_per_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildTextChannel'>channels.GuildTextChannel</a>: ...</code></pre>
</dt>
<dd>
<p>Create a text channel in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the channel in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The channels name. Must be between 2 and 1000 characters.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the position of the channel (relative to the
category, if any).</dd>
<dt><strong><code>topic</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the channels topic. Maximum 1024 characters.</dd>
<dt><strong><code>nsfw</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to mark the channel as NSFW.</dd>
<dt><strong><code>rate_limit_per_user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>Intervalish</a>]</code></dt>
<dd>If provided, the ammount of seconds a user has to wait
before being able to send another message in the channel.
Maximum 21600 seconds.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the permission overwrites for the channel.</dd>
<dt><strong><code>category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>The category to create the channel under. This may be the
object or the ID of an existing category.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a></code></dt>
<dd>The created channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3184-L3260" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_guild_text_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.GuildTextChannel:
    &#34;&#34;&#34;Create a text channel in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to create the channel in. This may be the
        object or the ID of an existing guild.
    name : builtins.str
        The channels name. Must be between 2 and 1000 characters.

    Other Parameters
    ----------------
    position : hikari.undefined.UndefinedOr[builtins.int]
        If provided, the position of the channel (relative to the
        category, if any).
    topic : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the channels topic. Maximum 1024 characters.
    nsfw : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether to mark the channel as NSFW.
    rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
        If provided, the ammount of seconds a user has to wait
        before being able to send another message in the channel.
        Maximum 21600 seconds.
    permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
        If provided, the permission overwrites for the channel.
    category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
        The category to create the channel under. This may be the
        object or the ID of an existing category.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.channels.GuildTextChannel
        The created channel.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_CHANNEL` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_guild_voice_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_guild_voice_channel" href="#hikari.api.rest.RESTClient.create_guild_voice_channel" id="hikari.api.rest.RESTClient.create_guild_voice_channel">create_guild_voice_channel</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    user_limit: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    bitrate: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.GuildVoiceChannel'>channels.GuildVoiceChannel</a>: ...</code></pre>
</dt>
<dd>
<p>Create a voice channel in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the channel in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The channels name. Must be between 2 and 1000 characters.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the position of the channel (relative to the
category, if any).</dd>
<dt><strong><code>user_limit</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the maximum users in the channel at once.
Must be between 0 and 99 with 0 meaning no limit.</dd>
<dt><strong><code>bitrate</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the bitrate for the channel. Must be
between 8000 and 96000 or 8000 and 128000 for VIP
servers.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the permission overwrites for the channel.</dd>
<dt><strong><code>category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>The category to create the channel under. This may be the
object or the ID of an existing category.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a></code></dt>
<dd>The created channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3340-L3414" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_guild_voice_channel(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    name: str,
    *,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.GuildVoiceChannel:
    &#34;&#34;&#34;Create a voice channel in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to create the channel in. This may be the
        object or the ID of an existing guild.
    name : builtins.str
        The channels name. Must be between 2 and 1000 characters.

    Other Parameters
    ----------------
    position : hikari.undefined.UndefinedOr[builtins.int]
        If provided, the position of the channel (relative to the
        category, if any).
    user_limit : hikari.undefined.UndefinedOr[builtins.int]
        If provided, the maximum users in the channel at once.
        Must be between 0 and 99 with 0 meaning no limit.
    bitrate : hikari.undefined.UndefinedOr[builtins.int]
        If provided, the bitrate for the channel. Must be
        between 8000 and 96000 or 8000 and 128000 for VIP
        servers.
    permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
        If provided, the permission overwrites for the channel.
    category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
        The category to create the channel under. This may be the
        object or the ID of an existing category.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.channels.GuildVoiceChannel
        The created channel.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_CHANNEL` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_invite" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_invite" href="#hikari.api.rest.RESTClient.create_invite" id="hikari.api.rest.RESTClient.create_invite">create_invite</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
    *,
    max_age: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    max_uses: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    temporary: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    unique: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    target_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]] = UNDEFINED,
    target_user_type: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../invites.html#hikari.invites.TargetUserType'>invites.TargetUserType</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>: ...</code></pre>
</dt>
<dd>
<p>Create an invite to the given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to create a invite for. This may be the object
or the ID of an existing channel.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>max_age</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/datetime.html#datetime.timedelta'>datetime.timedelta</a>, <a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]]</code></dt>
<dd>If provided, the duration of the invite before expiry.</dd>
<dt><strong><code>max_uses</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the max uses the invite can have.</dd>
<dt><strong><code>temporary</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the invite only grants temporary membership.</dd>
<dt><strong><code>unique</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the invite should be unique.</dd>
<dt><strong><code>target_user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]]</code></dt>
<dd>If provided, the target user id for this invite. This may be the
object or the ID of an existing user.</dd>
<dt><strong><code>target_user_type</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../invites.html#hikari.invites.TargetUserType'>TargetUserType</a>]</code></dt>
<dd>If provided, the type of target user for this invite.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a></code></dt>
<dd>The invite to the given guild channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNELS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found, or if the target user does not exist,
if provided.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L483-L552" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_invite(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    *,
    max_age: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    max_uses: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    temporary: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    unique: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    target_user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
    target_user_type: undefined.UndefinedOr[invites.TargetUserType] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; invites.InviteWithMetadata:
    &#34;&#34;&#34;Create an invite to the given guild channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
        The channel to create a invite for. This may be the object
        or the ID of an existing channel.

    Other Parameters
    ----------------
    max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, builtins.float, builtins.int]]
        If provided, the duration of the invite before expiry.
    max_uses : hikari.undefined.UndefinedOr[builtins.int]
        If provided, the max uses the invite can have.
    temporary : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether the invite only grants temporary membership.
    unique : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether the invite should be unique.
    target_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]
        If provided, the target user id for this invite. This may be the
        object or the ID of an existing user.
    target_user_type : hikari.undefined.UndefinedOr[hikari.invites.TargetUserType]
        If provided, the type of target user for this invite.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.invites.InviteWithMetadata
        The invite to the given guild channel.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_CHANNELS` permission.
    hikari.errors.NotFoundError
        If the channel is not found, or if the target user does not exist,
        if provided.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_message" href="#hikari.api.rest.RESTClient.create_message" id="hikari.api.rest.RESTClient.create_message">create_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    attachment: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    tts: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    nonce: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p>Create a message in the given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to create the message in.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message contents. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> kwarg is
provided, then this will instead update the embed. This allows for
simpler syntax when sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='../files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the message embed.</dd>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>],</code></dt>
<dd>If provided, the message attachment. This can be a resource,
or string of a path on your computer or a URL.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]],</code></dt>
<dd>If provided, the message attachments. These can be resources, or
strings consisting of paths on your computer or URLs.</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message will be read out by a screen
reader using Discord's TTS (text-to-speech) system.</dd>
<dt><strong><code>nonce</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>An arbitrary identifier to associate with the message. This
can be used to identify it later in received events. If provided,
this must be less than 32 bytes. If not provided, then
a null value is placed on the message instead. All users can
see this value.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all user mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all user mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all role mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all role mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Attachments can be passed as many different things, to aid in
convenience.</p>
<ul>
<li>If a <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> to a valid URL, the
resource at the given URL will be streamed to Discord when
sending the message. Subclasses of
<code><a href='../files.html#hikari.files.WebResource'>WebResource</a></code> such as
<code><a href='../files.html#hikari.files.URL'>URL</a></code>,
<code><a href='../messages.html#hikari.messages.Attachment'>Attachment</a></code>,
<code><a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a></code>,
<code>EmbedResource</code>, etc will also be uploaded this way.
This will use bit-inception, so only a small percentage of the
resource will remain in memory at any one time, thus aiding in
scalability.</li>
<li>If a <code><a href='../files.html#hikari.files.Bytes'>Bytes</a></code> is passed, or a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>
that contains a valid data URI is passed, then this is uploaded
with a randomized file name if not provided.</li>
<li>If a <code><a href='../files.html#hikari.files.File'>File</a></code>, <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> that is an absolute or relative path to a file
on your file system is passed, then this resource is uploaded
as an attachment using non-blocking code internally and streamed
using bit-inception where possible. This depends on the
type of <code><a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a></code> that is being used for
the application (default is a thread pool which supports this
behaviour).</li>
</ul>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The created message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If more than 100 unique objects/entities are passed for
<code>role_mentions</code> or <code>user_mentions</code>.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code> are specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
invalid image URLs in embeds; users in <code>user_mentions</code> not being
mentioned in the message content; roles in <code>role_mentions</code> not
being mentioned in the message content.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>SEND_MESSAGES</code> in the channel or the
person you are trying to message has the DM's disabled.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>You are expected to make a connection to the gateway and identify
once before being able to use this endpoint for a bot.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L862-L1011" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
    ] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    &#34;&#34;&#34;Create a message in the given channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to create the message in.
    content : hikari.undefined.UndefinedOr[typing.Any]
        If provided, the message contents. If
        `hikari.undefined.UNDEFINED`, then nothing will be sent
        in the content. Any other value here will be cast to a
        `builtins.str`.

        If this is a `hikari.embeds.Embed` and no `embed` kwarg is
        provided, then this will instead update the embed. This allows for
        simpler syntax when sending an embed alone.

        Likewise, if this is a `hikari.files.Resource`, then the
        content is instead treated as an attachment if no `attachment` and
        no `attachments` kwargs are provided.

    Other Parameters
    ----------------
    embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
        If provided, the message embed.
    attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],
        If provided, the message attachment. This can be a resource,
        or string of a path on your computer or a URL.
    attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],
        If provided, the message attachments. These can be resources, or
        strings consisting of paths on your computer or URLs.
    tts : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether the message will be read out by a screen
        reader using Discord&#39;s TTS (text-to-speech) system.
    nonce : hikari.undefined.UndefinedOr[builtins.str]
        An arbitrary identifier to associate with the message. This
        can be used to identify it later in received events. If provided,
        this must be less than 32 bytes. If not provided, then
        a null value is placed on the message instead. All users can
        see this value.
    mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether the message should parse @everyone/@here
        mentions.
    user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]], builtins.bool]]
        If provided, and `builtins.True`, all user mentions will be detected.
        If provided, and `builtins.False`, all user mentions will be ignored
        if appearing in the message body.
        Alternatively this may be a collection of
        `hikari.snowflakes.Snowflake`, or
        `hikari.users.PartialUser` derivatives to enforce mentioning
        specific users.
    role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]], builtins.bool]]
        If provided, and `builtins.True`, all role mentions will be detected.
        If provided, and `builtins.False`, all role mentions will be ignored
        if appearing in the message body.
        Alternatively this may be a collection of
        `hikari.snowflakes.Snowflake`, or
        `hikari.guilds.PartialRole` derivatives to enforce mentioning
        specific roles.

    !!! note
        Attachments can be passed as many different things, to aid in
        convenience.

        - If a `pathlib.PurePath` or `builtins.str` to a valid URL, the
            resource at the given URL will be streamed to Discord when
            sending the message. Subclasses of
            `hikari.files.WebResource` such as
            `hikari.files.URL`,
            `hikari.messages.Attachment`,
            `hikari.emojis.Emoji`,
            `EmbedResource`, etc will also be uploaded this way.
            This will use bit-inception, so only a small percentage of the
            resource will remain in memory at any one time, thus aiding in
            scalability.
        - If a `hikari.files.Bytes` is passed, or a `builtins.str`
            that contains a valid data URI is passed, then this is uploaded
            with a randomized file name if not provided.
        - If a `hikari.files.File`, `pathlib.PurePath` or
            `builtins.str` that is an absolute or relative path to a file
            on your file system is passed, then this resource is uploaded
            as an attachment using non-blocking code internally and streamed
            using bit-inception where possible. This depends on the
            type of `concurrent.futures.Executor` that is being used for
            the application (default is a thread pool which supports this
            behaviour).

    Returns
    -------
    hikari.messages.Message
        The created message.

    Raises
    ------
    builtins.ValueError
        If more than 100 unique objects/entities are passed for
        `role_mentions` or `user_mentions`.
    builtins.TypeError
        If both `attachment` and `attachments` are specified.
    hikari.errors.BadRequestError
        This may be raised in several discrete situations, such as messages
        being empty with no attachments or embeds; messages with more than
        2000 characters in them, embeds that exceed one of the many embed
        limits; too many attachments; attachments that are too large;
        invalid image URLs in embeds; users in `user_mentions` not being
        mentioned in the message content; roles in `role_mentions` not
        being mentioned in the message content.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `SEND_MESSAGES` in the channel or the
        person you are trying to message has the DM&#39;s disabled.
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.

    !!! warning
        You are expected to make a connection to the gateway and identify
        once before being able to use this endpoint for a bot.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_role" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_role" href="#hikari.api.rest.RESTClient.create_role" id="hikari.api.rest.RESTClient.create_role">create_role</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    permissions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    color: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    colour: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    hoist: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentionable: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>: ...</code></pre>
</dt>
<dd>
<p>Create a role.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to create the role in. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the name for the role.</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>The permissions to give the role. This will default to setting
NO roles if left to the default value. This is in contrast to
default behaviour on Discord where some random permissions will
be set by default.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>Colorish</a>]</code></dt>
<dd>If provided, the role's color.</dd>
<dt><strong><code>colour</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>Colorish</a>]</code></dt>
<dd>An alias for <code>color</code>.</dd>
<dt><strong><code>hoist</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to hoist the role.</dd>
<dt><strong><code>mentionable</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to make the role mentionable.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Role'>Role</a></code></dt>
<dd>The created role.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>color</code> and <code>colour</code> are specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4134-L4206" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_role(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.Role:
    &#34;&#34;&#34;Create a role.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to create the role in. This may be the
        object or the ID of an existing guild.

    Other Parameters
    ----------------
    name : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the name for the role.
    permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
        The permissions to give the role. This will default to setting
        NO roles if left to the default value. This is in contrast to
        default behaviour on Discord where some random permissions will
        be set by default.
    color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
        If provided, the role&#39;s color.
    colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
        An alias for `color`.
    hoist : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether to hoist the role.
    mentionable : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether to make the role mentionable.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.guilds.Role
        The created role.

    Raises
    ------
    builtins.TypeError
        If both `color` and `colour` are specified.
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_ROLES` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.create_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="create_webhook" href="#hikari.api.rest.RESTClient.create_webhook" id="hikari.api.rest.RESTClient.create_webhook">create_webhook</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    *,
    avatar: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = None,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>: ...</code></pre>
</dt>
<dd>
<p>Create webhook in a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the webhook will be created. This may be
the object or the ID of an existing channel.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The name for the webhook. This cannnot be <code>clyde</code>.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the avatar for the webhook.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code></dt>
<dd>The created webhook.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/reference/introduction.html#grammar-token-name'>name</a></code> doesnt follow the restrictions enforced by discord.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1584-L1639" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def create_webhook(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    name: str,
    *,
    avatar: typing.Optional[files.Resourceish] = None,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; webhooks.Webhook:
    &#34;&#34;&#34;Create webhook in a channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel where the webhook will be created. This may be
        the object or the ID of an existing channel.
    name : str
        The name for the webhook. This cannnot be `clyde`.

    Other Parameters
    ----------------
    avatar : typing.Optional[hikari.files.Resourceish]
        If provided, the avatar for the webhook.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.webhooks.Webhook
        The created webhook.

    Raises
    ------
    hikari.errors.BadRequestError
        If `name` doesnt follow the restrictions enforced by discord.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_WEBHOOKS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_all_reactions" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_all_reactions" href="#hikari.api.rest.RESTClient.delete_all_reactions" id="hikari.api.rest.RESTClient.delete_all_reactions">delete_all_reactions</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete all reactions from a message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete all reactions from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete all reaction from. This may be the
object or the ID of an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1482-L1523" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_all_reactions(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    &#34;&#34;&#34;Delete all reactions from a message.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel where the message to delete all reactions from is.
        This may be the object or the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to delete all reaction from. This may be the
        object or the ID of an existing message.

    Raises
    ------
    hikari.errors.BadRequestError
        If an invalid unicode emoji is given, or if the given custom emoji
        does not exist.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_MESSAGES` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the channel or message is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_all_reactions_for_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_all_reactions_for_emoji" href="#hikari.api.rest.RESTClient.delete_all_reactions_for_emoji" id="hikari.api.rest.RESTClient.delete_all_reactions_for_emoji">delete_all_reactions_for_emoji</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete all reactions for a single emoji on a given message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete the reactions from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete a reactions from. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to delete all reactions from.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1386-L1430" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_all_reactions_for_emoji(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    emoji: emojis.Emojiish,
) -&gt; None:
    &#34;&#34;&#34;Delete all reactions for a single emoji on a given message.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel where the message to delete the reactions from is.
        This may be the object or the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to delete a reactions from. This may be the
        object or the ID of an existing message.
    emoji : hikari.emojis.Emojiish
        The emoji to delete all reactions from.

    Raises
    ------
    hikari.errors.BadRequestError
        If an invalid unicode emoji is given, or if the given custom emoji
        does not exist.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_MESSAGES` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the channel or message is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_channel" href="#hikari.api.rest.RESTClient.delete_channel" id="hikari.api.rest.RESTClient.delete_channel">delete_channel</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete a channel in a guild, or close a DM.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>The channel to delete. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>For Public servers, the set 'Rules' or 'Guidelines' channels and the
'Public Server Updates' channel cannot be deleted.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L272-L307" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_channel(self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]) -&gt; None:
    &#34;&#34;&#34;Delete a channel in a guild, or close a DM.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]
        The channel to delete. This may be the object or the ID of an
        existing channel.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_CHANNEL` permission in the channel.
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.

    !!! note
        For Public servers, the set &#39;Rules&#39; or &#39;Guidelines&#39; channels and the
        &#39;Public Server Updates&#39; channel cannot be deleted.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_emoji" href="#hikari.api.rest.RESTClient.delete_emoji" id="hikari.api.rest.RESTClient.delete_emoji">delete_emoji</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    emoji: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete an emoji in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to delete the emoji on. This can be a
guild object or the ID of an existing guild.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]</code></dt>
<dd>The emoji to delete. This can be a <code><a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a></code>
or the ID of an existing emoji.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing <code>MANAGE_EMOJIS</code> in the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the emoji are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2834-L2873" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
    # Reason is not currently supported for some reason.
) -&gt; None:
    &#34;&#34;&#34;Delete an emoji in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to delete the emoji on. This can be a
        guild object or the ID of an existing guild.
    emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]
        The emoji to delete. This can be a `hikari.emojis.CustomEmoji`
        or the ID of an existing emoji.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing `MANAGE_EMOJIS` in the server.
    hikari.errors.NotFoundError
        If the guild or the emoji are not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_guild" href="#hikari.api.rest.RESTClient.delete_guild" id="hikari.api.rest.RESTClient.delete_guild">delete_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to delete. This may be the object or
the ID of an existing guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not the owner of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If you own the guild or if you are not in it.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3113-L3144" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; None:
    &#34;&#34;&#34;Delete a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to delete. This may be the object or
        the ID of an existing guild.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are not the owner of the guild.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If you own the guild or if you are not in it.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_invite" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_invite" href="#hikari.api.rest.RESTClient.delete_invite" id="hikari.api.rest.RESTClient.delete_invite">delete_invite</a>(
    invite: <a href='../invites.html#hikari.invites.Inviteish'>invites.Inviteish</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete an existing invite.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='../invites.html#hikari.invites.Inviteish'>Inviteish</a></code></dt>
<dd>The invite to delete. This may be an invite object or
the code of an existing invite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission in the guild
the invite is from or if you are missing the <code>MANAGE_CHANNELS</code>
permission in the channel the invite is from.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the invite is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2125-L2158" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_invite(self, invite: invites.Inviteish) -&gt; None:
    &#34;&#34;&#34;Delete an existing invite.

    Parameters
    ----------
    invite : hikari.invites.Inviteish
        The invite to delete. This may be an invite object or
        the code of an existing invite.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_GUILD` permission in the guild
        the invite is from or if you are missing the `MANAGE_CHANNELS`
        permission in the channel the invite is from.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the invite is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_message" href="#hikari.api.rest.RESTClient.delete_message" id="hikari.api.rest.RESTClient.delete_message">delete_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete a given message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to delete the message in. This may be
the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete. This may be the object or the ID of
an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code>, and the message is
not sent by you.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1205-L1244" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    &#34;&#34;&#34;Delete a given message in a given channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to delete the message in. This may be
        the object or the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to delete. This may be the object or the ID of
        an existing message.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_MESSAGES`, and the message is
        not sent by you.
    hikari.errors.NotFoundError
        If the channel or message is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_messages" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_messages" href="#hikari.api.rest.RESTClient.delete_messages" id="hikari.api.rest.RESTClient.delete_messages">delete_messages</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    /,
    *messages: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Bulk-delete messages from the channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to bulk delete the messages in. This may be
the object or the ID of an existing channel.</dd>
<dt><strong><code>*messages</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The messages to delete. This may be one or more
objects or IDs of existing messages.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This API endpoint will only be able to delete 100 messages
at a time. For anything more than this, multiple requests will
be executed one-after-the-other, since the rate limits for this
endpoint do not favour more than one request per bucket.</p>
<p>If one message is left over from chunking per 100 messages, or
only one message is passed to this coroutine function, then the
logic is expected to defer to <code>delete_message</code>. The implication
of this is that the <code>delete_message</code> endpoint is ratelimited
by a different bucket with different usage rates.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>This endpoint is not atomic. If an error occurs midway through
a bulk delete, you will <strong>not</strong> be able to revert any changes made
up to this point.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Specifying any messages more than 14 days old will cause the call
to fail, potentially with partial completion.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BulkDeleteError'>BulkDeleteError</a></code></dt>
<dd>An error containing the messages successfully deleted, and the
messages that were not removed. The
<code>BaseException.__cause__</code> of the exception will be the
original error that terminated this process.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1246-L1292" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_messages(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    /,
    *messages: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    &#34;&#34;&#34;Bulk-delete messages from the channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to bulk delete the messages in. This may be
        the object or the ID of an existing channel.
    *messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The messages to delete. This may be one or more
        objects or IDs of existing messages.

    !!! note
        This API endpoint will only be able to delete 100 messages
        at a time. For anything more than this, multiple requests will
        be executed one-after-the-other, since the rate limits for this
        endpoint do not favour more than one request per bucket.

        If one message is left over from chunking per 100 messages, or
        only one message is passed to this coroutine function, then the
        logic is expected to defer to `delete_message`. The implication
        of this is that the `delete_message` endpoint is ratelimited
        by a different bucket with different usage rates.

    !!! warning
        This endpoint is not atomic. If an error occurs midway through
        a bulk delete, you will **not** be able to revert any changes made
        up to this point.

    !!! warning
        Specifying any messages more than 14 days old will cause the call
        to fail, potentially with partial completion.

    Raises
    ------
    hikari.errors.BulkDeleteError
        An error containing the messages successfully deleted, and the
        messages that were not removed. The
        `builtins.BaseException.__cause__` of the exception will be the
        original error that terminated this process.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_my_reaction" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_my_reaction" href="#hikari.api.rest.RESTClient.delete_my_reaction" id="hikari.api.rest.RESTClient.delete_my_reaction">delete_my_reaction</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete a reaction that your application user created.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete the reaction from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete a reaction from. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to remove your reaction from.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1342-L1384" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_my_reaction(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    emoji: emojis.Emojiish,
) -&gt; None:
    &#34;&#34;&#34;Delete a reaction that your application user created.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel where the message to delete the reaction from is.
        This may be the object or the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to delete a reaction from. This may be the
        object or the ID of an existing message.
    emoji : hikari.emojis.Emojiish
        The emoji to remove your reaction from.

    Raises
    ------
    hikari.errors.BadRequestError
        If an invalid unicode emoji is given, or if the given custom emoji
        does not exist.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the channel or message is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_permission_overwrite" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_permission_overwrite" href="#hikari.api.rest.RESTClient.delete_permission_overwrite" id="hikari.api.rest.RESTClient.delete_permission_overwrite">delete_permission_overwrite</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
    target: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>, <a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>]],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete a custom permission for an entity in a given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to delete a permission overwrite in. This may be the
object, or the ID of an existing channel.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>, <a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>]</code></dt>
<dd>The channel overwrite to delete.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_PERMISSIONS</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the target is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L402-L441" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_permission_overwrite(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    target: snowflakes.SnowflakeishOr[
        typing.Union[channels.PermissionOverwrite, guilds.PartialRole, users.PartialUser, snowflakes.Snowflakeish]
    ],
) -&gt; None:
    &#34;&#34;&#34;Delete a custom permission for an entity in a given guild channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
        The channel to delete a permission overwrite in. This may be the
        object, or the ID of an existing channel.
    target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]
        The channel overwrite to delete.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_PERMISSIONS` permission in the channel.
    hikari.errors.NotFoundError
        If the channel is not found or the target is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_reaction" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_reaction" href="#hikari.api.rest.RESTClient.delete_reaction" id="hikari.api.rest.RESTClient.delete_reaction">delete_reaction</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete a reaction from a message.</p>
<p>If you are looking to delete your own applications reaction, use
<code>delete_my_reaction</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete the reaction from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete a reaction from. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to delete all reactions from.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1432-L1480" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_reaction(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    emoji: emojis.Emojiish,
    user: snowflakes.SnowflakeishOr[users.PartialUser],
) -&gt; None:
    &#34;&#34;&#34;Delete a reaction from a message.

    If you are looking to delete your own applications reaction, use
    `delete_my_reaction`.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel where the message to delete the reaction from is.
        This may be the object or the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to delete a reaction from. This may be the
        object or the ID of an existing message.
    emoji : hikari.emojis.Emojiish
        The emoji to delete all reactions from.

    Raises
    ------
    hikari.errors.BadRequestError
        If an invalid unicode emoji is given, or if the given custom emoji
        does not exist.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_MESSAGES` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the channel or message is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_role" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_role" href="#hikari.api.rest.RESTClient.delete_role" id="hikari.api.rest.RESTClient.delete_role">delete_role</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete a role.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to delete the role in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>The role to delete. This may be the object or the
ID of an existing role.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or role are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4322-L4360" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_role(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
) -&gt; None:
    &#34;&#34;&#34;Delete a role.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to delete the role in. This may be the
        object or the ID of an existing guild.
    role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
        The role to delete. This may be the object or the
        ID of an existing role.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_ROLES` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or role are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.delete_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="delete_webhook" href="#hikari.api.rest.RESTClient.delete_webhook" id="hikari.api.rest.RESTClient.delete_webhook">delete_webhook</a>(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>],
    *,
    token: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Delete a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The webhook to delete. This may be the object or the
ID of an existing webhook.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the webhoook token that will be used to delete
the webhook instead of the token the client was initialized with.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not
using a token.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhoook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1838-L1881" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def delete_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
    *,
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Delete a webhook.

    Parameters
    ----------
    webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
        The webhook to delete. This may be the object or the
        ID of an existing webhook.

    Other Parameters
    ----------------
    token : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the webhoook token that will be used to delete
        the webhook instead of the token the client was initialized with.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_WEBHOOKS` permission when not
        using a token.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the webhoook is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_channel" href="#hikari.api.rest.RESTClient.edit_channel" id="hikari.api.rest.RESTClient.edit_channel">edit_channel</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
    /,
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    position: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    topic: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    nsfw: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    bitrate: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    user_limit: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    rate_limit_per_user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    permission_overwrites: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>]] = UNDEFINED,
    parent_category: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>channels.GuildCategory</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>: ...</code></pre>
</dt>
<dd>
<p>Edit a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to edit. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>hikari.undefined.UndefinedOr[[builtins.str]</code></dt>
<dd>If provided, the new name for the channel.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>hikari.undefined.UndefinedOr[[builtins.int]</code></dt>
<dd>If provided, the new position for the channel.</dd>
<dt><strong><code>topic</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new topic for the channel.</dd>
<dt><strong><code>nsfw</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the channel should be marked as NSFW or not.</dd>
<dt><strong><code>bitrate</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the new bitrate for the channel.</dd>
<dt><strong><code>user_limit</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, the new user limit in the channel.</dd>
<dt><strong><code>rate_limit_per_user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>Intervalish</a>]</code></dt>
<dd>If provided, the new rate limit per user in the channel.</dd>
<dt><strong><code>permission_overwrites</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>]]</code></dt>
<dd>If provided, the new permission overwrites for the channel.</dd>
<dt><strong><code>parent_category</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildCategory'>GuildCategory</a>]]</code></dt>
<dd>If provided, the new guild category for the channel.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code></dt>
<dd>The edited channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing permissions to edit the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L142-L221" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_channel(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    /,
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    position: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    topic: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    nsfw: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    bitrate: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    user_limit: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    rate_limit_per_user: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    permission_overwrites: undefined.UndefinedOr[
        typing.Sequence[channels.PermissionOverwrite]
    ] = undefined.UNDEFINED,
    parent_category: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildCategory]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; channels.PartialChannel:
    &#34;&#34;&#34;Edit a channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
        The channel to edit. This may be the object or the ID of an
        existing channel.

    Other Parameters
    ----------------
    name : hikari.undefined.UndefinedOr[[builtins.str]
        If provided, the new name for the channel.
    position : hikari.undefined.UndefinedOr[[builtins.int]
        If provided, the new position for the channel.
    topic : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the new topic for the channel.
    nsfw : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether the channel should be marked as NSFW or not.
    bitrate : hikari.undefined.UndefinedOr[builtins.int]
        If provided, the new bitrate for the channel.
    user_limit : hikari.undefined.UndefinedOr[builtins.int]
        If provided, the new user limit in the channel.
    rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
        If provided, the new rate limit per user in the channel.
    permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]
        If provided, the new permission overwrites for the channel.
    parent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]
        If provided, the new guild category for the channel.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.channels.PartialChannel
        The edited channel.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing permissions to edit the channel.
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_emoji" href="#hikari.api.rest.RESTClient.edit_emoji" id="hikari.api.rest.RESTClient.edit_emoji">edit_emoji</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    emoji: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>: ...</code></pre>
</dt>
<dd>
<p>Edit an emoji in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit the emoji on. This can be a
guild object or the ID of an existing guild.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]</code></dt>
<dd>The emoji to edit. This can be a <code><a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a></code>
or the ID of an existing emoji.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name for the emoji.</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]]</code></dt>
<dd>If provided, the new collection of roles that will be able to
use this emoji. This can be a <code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> or
the ID of an existing role.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The edited emoji.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing <code>MANAGE_EMOJIS</code> in the server.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the emoji are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2769-L2832" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; emojis.KnownCustomEmoji:
    &#34;&#34;&#34;Edit an emoji in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to edit the emoji on. This can be a
        guild object or the ID of an existing guild.
    emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]
        The emoji to edit. This can be a `hikari.emojis.CustomEmoji`
        or the ID of an existing emoji.

    Other Parameters
    ----------------
    name : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the new name for the emoji.
    roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
        If provided, the new collection of roles that will be able to
        use this emoji. This can be a `hikari.guilds.PartialRole` or
        the ID of an existing role.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.emojis.KnownCustomEmoji
        The edited emoji.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing `MANAGE_EMOJIS` in the server.
    hikari.errors.NotFoundError
        If the guild or the emoji are not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_guild" href="#hikari.api.rest.RESTClient.edit_guild" id="hikari.api.rest.RESTClient.edit_guild">edit_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    region: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../voices.html#hikari.voices.VoiceRegionish'>voices.VoiceRegionish</a>] = UNDEFINED,
    verification_level: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildVerificationLevel'>guilds.GuildVerificationLevel</a>] = UNDEFINED,
    default_message_notifications: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildMessageNotificationsLevel'>guilds.GuildMessageNotificationsLevel</a>] = UNDEFINED,
    explicit_content_filter_level: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildExplicitContentFilterLevel'>guilds.GuildExplicitContentFilterLevel</a>] = UNDEFINED,
    afk_channel: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>channels.GuildVoiceChannel</a>]] = UNDEFINED,
    afk_timeout: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>time.Intervalish</a>] = UNDEFINED,
    icon: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    owner: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]] = UNDEFINED,
    splash: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    banner: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    system_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>channels.GuildTextChannel</a>]] = UNDEFINED,
    rules_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>channels.GuildTextChannel</a>]] = UNDEFINED,
    public_updates_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>channels.GuildTextChannel</a>]] = UNDEFINED,
    preferred_locale: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.RESTGuild'>guilds.RESTGuild</a>: ...</code></pre>
</dt>
<dd>
<p>Edit a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name for the guild.</dd>
<dt><strong><code>region</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../voices.html#hikari.voices.VoiceRegionish'>VoiceRegionish</a>]</code></dt>
<dd>If provided, the new voice region for the guild.</dd>
<dt><strong><code>verification_level</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildVerificationLevel'>GuildVerificationLevel</a>]</code></dt>
<dd>If provided, the new verification level.</dd>
<dt><strong><code>default_message_notifications</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildMessageNotificationsLevel'>GuildMessageNotificationsLevel</a>]</code></dt>
<dd>If provided, the new default message notifications level.</dd>
<dt><strong><code>explicit_content_filter_level</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../guilds.html#hikari.guilds.GuildExplicitContentFilterLevel'>GuildExplicitContentFilterLevel</a>]</code></dt>
<dd>If provided, the new explicit content filter level.</dd>
<dt><strong><code>afk_channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a>]]</code></dt>
<dd>If provided, the new afk channel. Requires <code>afk_timeout</code> to
be set to work.</dd>
<dt><strong><code>afk_timeout</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../internal/time.html#hikari.internal.time.Intervalish'>Intervalish</a>]</code></dt>
<dd>If provided, the new afk timeout.</dd>
<dt><strong><code>icon</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new guild icon. Must be a 1024x1024 image or can be
an animated gif when the guild has the <code>ANIMATED_ICON</code> feature.</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]]</code></dt>
<dd>
<p>If provided, the new guild owner.</p>
<div class="admonition warn">
<p class="admonition-title">Warn</p>
<p>You need to be the owner of the server to use this.</p>
</div>
</dd>
<dt><strong><code>splash</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new guild splash. Must be a 16:9 image and the
guild must have the <code>INVITE_SPLASH</code> feature.</dd>
<dt><strong><code>banner</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new guild banner. Must be a 16:9 image and the
guild must have the <code>BANNER</code> feature.</dd>
<dt><strong><code>system_channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>]]</code></dt>
<dd>If provided, the new system channel.</dd>
<dt><strong><code>rules_channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>]]</code></dt>
<dd>If provided, the new rules channel.</dd>
<dt><strong><code>public_updates_channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a>]]</code></dt>
<dd>If provided, the new public updates channel.</dd>
<dt><strong><code>preferred_locale</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new preferred locale.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.RESTGuild'>RESTGuild</a></code></dt>
<dd>The edited guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value. Or
you are missing the</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission or if you tried to
pass ownership without being the server owner.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2998-L3111" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_guild(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    region: undefined.UndefinedOr[voices.VoiceRegionish] = undefined.UNDEFINED,
    verification_level: undefined.UndefinedOr[guilds.GuildVerificationLevel] = undefined.UNDEFINED,
    default_message_notifications: undefined.UndefinedOr[
        guilds.GuildMessageNotificationsLevel
    ] = undefined.UNDEFINED,
    explicit_content_filter_level: undefined.UndefinedOr[
        guilds.GuildExplicitContentFilterLevel
    ] = undefined.UNDEFINED,
    afk_channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]] = undefined.UNDEFINED,
    afk_timeout: undefined.UndefinedOr[time.Intervalish] = undefined.UNDEFINED,
    icon: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    owner: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
    splash: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    banner: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    system_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels.GuildTextChannel]
    ] = undefined.UNDEFINED,
    rules_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels.GuildTextChannel]
    ] = undefined.UNDEFINED,
    public_updates_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels.GuildTextChannel]
    ] = undefined.UNDEFINED,
    preferred_locale: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.RESTGuild:
    &#34;&#34;&#34;Edit a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to edit. This may be the object
        or the ID of an existing guild.

    Other Parameters
    ----------------
    name : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the new name for the guild.
    region : hikari.undefined.UndefinedOr[hikari.voices.VoiceRegionish]
        If provided, the new voice region for the guild.
    verification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel]
        If provided, the new verification level.
    default_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel]
        If provided, the new default message notifications level.
    explicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel]
        If provided, the new explicit content filter level.
    afk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]
        If provided, the new afk channel. Requires `afk_timeout` to
        be set to work.
    afk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]
        If provided, the new afk timeout.
    icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]
        If provided, the new guild icon. Must be a 1024x1024 image or can be
        an animated gif when the guild has the `ANIMATED_ICON` feature.
    owner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]]
        If provided, the new guild owner.

        !!! warn
            You need to be the owner of the server to use this.
    splash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]
        If provided, the new guild splash. Must be a 16:9 image and the
        guild must have the `INVITE_SPLASH` feature.
    banner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]
        If provided, the new guild banner. Must be a 16:9 image and the
        guild must have the `BANNER` feature.
    system_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]
        If provided, the new system channel.
    rules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]
        If provided, the new rules channel.
    public_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]
        If provided, the new public updates channel.
    preferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str]
        If provided, the new preferred locale.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.guilds.RESTGuild
        The edited guild.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value. Or
        you are missing the
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_GUILD` permission or if you tried to
        pass ownership without being the server owner.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_member" href="#hikari.api.rest.RESTClient.edit_member" id="hikari.api.rest.RESTClient.edit_member">edit_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    nick: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
    mute: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    deaf: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    voice_channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>channels.GuildVoiceChannel</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Edit a guild member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit. This may be the object
or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>nick</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>
<p>If provided, the new nick for the member. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>,
will remove the members nick.</p>
<p>Requires the <code>MANAGE_NICKNAMES</code> permission.</p>
</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]]</code></dt>
<dd>
<p>If provided, the new roles for the member.</p>
<p>Requires the <code>MANAGE_ROLES</code> permission.</p>
</dd>
<dt><strong><code>mute</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, the new server mute state for the member.</p>
<p>Requires the <code>MUTE_MEMBERS</code> permission.</p>
</dd>
<dt><strong><code>deaf</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>
<p>If provided, the new server deaf state for the member.</p>
<p>Requires the <code>DEAFEN_MEMBERS</code> permission.</p>
</dd>
<dt><strong><code>voice_channel</code></strong> :&ensp;<code>hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]]</code></dt>
<dd>
<p>If provided, <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> or the object or the ID of
an existing voice channel to move the member to.
If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, will disconnect the member from voice.</p>
<p>Requires the <code>MOVE_MEMBERS</code> permission and the <code>CONNECT</code>
permission in the original voice channel and the target
voice channel.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>If the member is not in a voice channel, this will
take no effect.</p>
</div>
</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing a permission to do an action.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3609-L3695" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    nick: undefined.UndefinedNoneOr[str] = undefined.UNDEFINED,
    roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
    mute: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    deaf: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    voice_channel: undefined.UndefinedNoneOr[
        snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]
    ] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Edit a guild member.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to edit. This may be the object
        or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to edit. This may be the object
        or the ID of an existing guild.

    Other Parameters
    ----------------
    nick : hikari.undefined.UndefinedNoneOr[builtins.str]
        If provided, the new nick for the member. If `builtins.None`,
        will remove the members nick.

        Requires the `MANAGE_NICKNAMES` permission.
    roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
        If provided, the new roles for the member.

        Requires the `MANAGE_ROLES` permission.
    mute : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, the new server mute state for the member.

        Requires the `MUTE_MEMBERS` permission.
    deaf : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, the new server deaf state for the member.

        Requires the `DEAFEN_MEMBERS` permission.
    voice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]]
        If provided, `builtins.None` or the object or the ID of
        an existing voice channel to move the member to.
        If `builtins.None`, will disconnect the member from voice.

        Requires the `MOVE_MEMBERS` permission and the `CONNECT`
        permission in the original voice channel and the target
        voice channel.

        !!! note
            If the member is not in a voice channel, this will
            take no effect.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing a permission to do an action.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or the user are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_message" href="#hikari.api.rest.RESTClient.edit_message" id="hikari.api.rest.RESTClient.edit_message">edit_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    flags: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../messages.html#hikari.messages.MessageFlag'>messages_.MessageFlag</a>] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p>Edit an existing message in a given channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to create the message in. This may be
the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to edit. This may be the object or the ID
of an existing message.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message content to update with. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the content will not
be changed. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the content will be removed.</p>
<p>Any other value will be cast to a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> before sending.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> kwarg is
provided, then this will instead update the embed. This allows for
simpler syntax when sending an embed alone.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the embed to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, the previous embed if
present is not changed. If this is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, then the embed
is removed if present. Otherwise, the new embed value that was
provided will be used as the replacement.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, sanitation for <code>@everyone</code> mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, then <code>@everyone</code>/<code>@here</code> mentions
in the message content will show up as mentioning everyone that can
view the chat.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>
<p>If provided, sanitation for user mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all valid user mentions will behave
as mentions. If <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all valid user mentions will not
behave as mentions.</p>
<p>You may alternatively pass a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code> user IDs, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code>-derived objects.</p>
</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>
<p>If provided, sanitation for role mentions. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then the previous setting is
not changed. If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all valid role mentions will behave
as mentions. If <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all valid role mentions will not
behave as mentions.</p>
<p>You may alternatively pass a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code> role IDs, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code>-derived objects.</p>
</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../messages.html#hikari.messages.MessageFlag'>MessageFlag</a>]</code></dt>
<dd>
<p>If provided, optional flags to set on the message. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing is changed.</p>
<p>Note that some flags may not be able to be set. Currently the only
flags that can be set are <code>NONE</code> and <code>SUPPRESS_EMBEDS</code>. If you
have <code>MANAGE_MESSAGES</code> permissions, you can use this call to
suppress embeds on another user's message.</p>
</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Mentioning everyone, roles, or users in message edits currently
will not send a push notification showing a new mention to people
on Discord. It will still highlight in their chat as if they
were mentioned, however.</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>There is currently no documented way to clear attachments or edit
attachments from a previously sent message on Discord's API. To
do this, <code>delete</code> the message and re-send it. This also applies
to embed attachments.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If you specify one of <code>mentions_everyone</code>, <code>user_mentions</code>, or
<code>role_mentions</code>, then all others will default to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>,
even if they were enabled previously.</p>
<p>This is a limitation of Discord's design. If in doubt, specify all three of
them each time.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>If the message was not sent by your user, the only parameter
you may provide to this call is the <code>flags</code> parameter. Anything
else will result in a <code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code> being raised.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The edited message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no embeds; messages with more than 2000 characters
in them, embeds that exceed one of the many embed
limits; invalid image URLs in embeds; users in <code>user_mentions</code> not
being mentioned in the message content; roles in <code>role_mentions</code> not
being mentioned in the message content.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>SEND_MESSAGES</code> in the channel; if you try to
change the contents of another user's message; or if you try to edit
the flags on another user's message without the <code>MANAGE_MESSAGES</code>
permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1061-L1203" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    embed: undefined.UndefinedNoneOr[embeds_.Embed] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
    ] = undefined.UNDEFINED,
    flags: undefined.UndefinedOr[messages_.MessageFlag] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    &#34;&#34;&#34;Edit an existing message in a given channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to create the message in. This may be
        the object or the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to edit. This may be the object or the ID
        of an existing message.
    content : hikari.undefined.UndefinedOr[typing.Any]
        If provided, the message content to update with. If
        `hikari.undefined.UNDEFINED`, then the content will not
        be changed. If `builtins.None`, then the content will be removed.

        Any other value will be cast to a `builtins.str` before sending.

        If this is a `hikari.embeds.Embed` and no `embed` kwarg is
        provided, then this will instead update the embed. This allows for
        simpler syntax when sending an embed alone.

    Other Parameters
    ----------------
    embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]
        If provided, the embed to set on the message. If
        `hikari.undefined.UNDEFINED`, the previous embed if
        present is not changed. If this is `builtins.None`, then the embed
        is removed if present. Otherwise, the new embed value that was
        provided will be used as the replacement.
    mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, sanitation for `@everyone` mentions. If
        `hikari.undefined.UNDEFINED`, then the previous setting is
        not changed. If `builtins.True`, then `@everyone`/`@here` mentions
        in the message content will show up as mentioning everyone that can
        view the chat.
    user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]], builtins.bool]]
        If provided, sanitation for user mentions. If
        `hikari.undefined.UNDEFINED`, then the previous setting is
        not changed. If `builtins.True`, all valid user mentions will behave
        as mentions. If `builtins.False`, all valid user mentions will not
        behave as mentions.

        You may alternatively pass a collection of
        `hikari.snowflakes.Snowflake` user IDs, or
        `hikari.users.PartialUser`-derived objects.
    role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]], builtins.bool]]
        If provided, sanitation for role mentions. If
        `hikari.undefined.UNDEFINED`, then the previous setting is
        not changed. If `builtins.True`, all valid role mentions will behave
        as mentions. If `builtins.False`, all valid role mentions will not
        behave as mentions.

        You may alternatively pass a collection of
        `hikari.snowflakes.Snowflake` role IDs, or
        `hikari.guilds.PartialRole`-derived objects.
    flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag]
        If provided, optional flags to set on the message. If
        `hikari.undefined.UNDEFINED`, then nothing is changed.

        Note that some flags may not be able to be set. Currently the only
        flags that can be set are `NONE` and `SUPPRESS_EMBEDS`. If you
        have `MANAGE_MESSAGES` permissions, you can use this call to
        suppress embeds on another user&#39;s message.

    !!! note
        Mentioning everyone, roles, or users in message edits currently
        will not send a push notification showing a new mention to people
        on Discord. It will still highlight in their chat as if they
        were mentioned, however.

    !!! note
        There is currently no documented way to clear attachments or edit
        attachments from a previously sent message on Discord&#39;s API. To
        do this, `delete` the message and re-send it. This also applies
        to embed attachments.

    !!! warning
        If you specify one of `mentions_everyone`, `user_mentions`, or
        `role_mentions`, then all others will default to `builtins.False`,
        even if they were enabled previously.

        This is a limitation of Discord&#39;s design. If in doubt, specify all three of
        them each time.

    !!! warning
        If the message was not sent by your user, the only parameter
        you may provide to this call is the `flags` parameter. Anything
        else will result in a `hikari.errors.ForbiddenError` being raised.

    Returns
    -------
    hikari.messages.Message
        The edited message.

    Raises
    ------
    hikari.errors.BadRequestError
        This may be raised in several discrete situations, such as messages
        being empty with no embeds; messages with more than 2000 characters
        in them, embeds that exceed one of the many embed
        limits; invalid image URLs in embeds; users in `user_mentions` not
        being mentioned in the message content; roles in `role_mentions` not
        being mentioned in the message content.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `SEND_MESSAGES` in the channel; if you try to
        change the contents of another user&#39;s message; or if you try to edit
        the flags on another user&#39;s message without the `MANAGE_MESSAGES`
        permission.
    hikari.errors.NotFoundError
        If the channel or message is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_my_nick" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_my_nick" href="#hikari.api.rest.RESTClient.edit_my_nick" id="hikari.api.rest.RESTClient.edit_my_nick">edit_my_nick</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.Guild'>guilds.Guild</a>],
    nick: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Edit the associated token's member nick.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit. This may be the object
or the ID of an existing guild.</dd>
<dt><strong><code>nick</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>The new nick. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>,
will remove the nick.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>CHANGE_NICKNAME</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3697-L3743" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_my_nick(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.Guild],
    nick: typing.Optional[str],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Edit the associated token&#39;s member nick.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to edit. This may be the object
        or the ID of an existing guild.
    nick : typing.Optional[builtins.str]
        The new nick. If `builtins.None`,
        will remove the nick.

    Other Parameters
    ----------------
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `CHANGE_NICKNAME` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_my_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_my_user" href="#hikari.api.rest.RESTClient.edit_my_user" id="hikari.api.rest.RESTClient.edit_my_user">edit_my_user</a>(
    *,
    username: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
) -> <a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>: ...</code></pre>
</dt>
<dd>
<p>Edit the token's associated user.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new username.</dd>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new avatar. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>,
the avatar will be removed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The edited token's associated user.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>
<p>If any of the fields that are passed have an invalid value.</p>
<p>Discord also returns this on a ratelimit:
<a href="https://github.com/discord/discord-api-docs/issues/1462">https://github.com/discord/discord-api-docs/issues/1462</a></p>
</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2188-L2221" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_my_user(
    self,
    *,
    username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
) -&gt; users.OwnUser:
    &#34;&#34;&#34;Edit the token&#39;s associated user.

    Other Parameters
    ----------------
    username : undefined.UndefinedOr[builtins.str]
        If provided, the new username.
    avatar : undefined.UndefinedNoneOr[hikari.files.Resourceish]
        If provided, the new avatar. If `builtins.None`,
        the avatar will be removed.

    Returns
    -------
    hikari.users.OwnUser
        The edited token&#39;s associated user.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.

        Discord also returns this on a ratelimit:
        https://github.com/discord/discord-api-docs/issues/1462
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_permission_overwrites" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_permission_overwrites" href="#hikari.api.rest.RESTClient.edit_permission_overwrites" id="hikari.api.rest.RESTClient.edit_permission_overwrites">edit_permission_overwrites</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
    target: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>snowflakes.Snowflakeish</a>, <a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>, <a href='../channels.html#hikari.channels.PermissionOverwrite'>channels.PermissionOverwrite</a>],
    *,
    target_type: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../channels.html#hikari.channels.PermissionOverwriteType'>channels.PermissionOverwriteType</a>] = UNDEFINED,
    allow: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    deny: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Edit permissions for a specific entity in the given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to edit a permission overwrite in. This may be the
object, or the ID of an existing channel.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>, <a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>, <a href='../channels.html#hikari.channels.PermissionOverwrite'>PermissionOverwrite</a>, <a href='../snowflakes.html#hikari.snowflakes.Snowflakeish'>Snowflakeish</a>]</code></dt>
<dd>The channel overwrite to edit. This may be the object or the ID of an
existing overwrite.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>target_type</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../channels.html#hikari.channels.PermissionOverwriteType'>PermissionOverwriteType</a>]</code></dt>
<dd>If provided, the type of the target to update. If unset, will attempt to get
the type from <code><a href='https://docs.python.org/3/reference/simple_stmts.html#grammar-token-target'>target</a></code>.</dd>
<dt><strong><code>allow</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>If provided, the new vale of all allowed permissions.</dd>
<dt><strong><code>deny</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>If provided, the new vale of all disallowed permissions.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If <code>target_type</code> is unset and we were unable to determine the type
from <code><a href='https://docs.python.org/3/reference/simple_stmts.html#grammar-token-target'>target</a></code>.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_PERMISSIONS</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the target is not found if it is
a role.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L336-L400" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_permission_overwrites(
    self,
    channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
    target: typing.Union[
        snowflakes.Snowflakeish, users.PartialUser, guilds.PartialRole, channels.PermissionOverwrite
    ],
    *,
    target_type: undefined.UndefinedOr[channels.PermissionOverwriteType] = undefined.UNDEFINED,
    allow: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    deny: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Edit permissions for a specific entity in the given guild channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
        The channel to edit a permission overwrite in. This may be the
        object, or the ID of an existing channel.
    target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]
        The channel overwrite to edit. This may be the object or the ID of an
        existing overwrite.

    Other Parameters
    ----------------
    target_type : hikari.undefined.UndefinedOr[hikari.channels.PermissionOverwriteType]
        If provided, the type of the target to update. If unset, will attempt to get
        the type from `target`.
    allow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
        If provided, the new vale of all allowed permissions.
    deny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
        If provided, the new vale of all disallowed permissions.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    builtins.TypeError
        If `target_type` is unset and we were unable to determine the type
        from `target`.
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_PERMISSIONS` permission in the channel.
    hikari.errors.NotFoundError
        If the channel is not found or the target is not found if it is
        a role.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_role" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_role" href="#hikari.api.rest.RESTClient.edit_role" id="hikari.api.rest.RESTClient.edit_role">edit_role</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    *,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    permissions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>permissions_.Permissions</a>] = UNDEFINED,
    color: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    colour: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>colors.Colorish</a>] = UNDEFINED,
    hoist: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentionable: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>: ...</code></pre>
</dt>
<dd>
<p>Edit a role.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit the role in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>The role to edit. This may be the object or the
ID of an existing role.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new name for the role.</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../permissions.html#hikari.permissions.Permissions'>Permissions</a>]</code></dt>
<dd>If provided, the new permissions for the role.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>Colorish</a>]</code></dt>
<dd>If provided, the new color for the role.</dd>
<dt><strong><code>colour</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../colors.html#hikari.colors.Colorish'>Colorish</a>]</code></dt>
<dd>An alias for <code>color</code>.</dd>
<dt><strong><code>hoist</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to hoist the role.</dd>
<dt><strong><code>mentionable</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to make the role mentionable.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Role'>Role</a></code></dt>
<dd>The edited role.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>color</code> and <code>colour</code> are specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or role are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4247-L4320" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_role(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    *,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    permissions: undefined.UndefinedOr[permissions_.Permissions] = undefined.UNDEFINED,
    color: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    colour: undefined.UndefinedOr[colors.Colorish] = undefined.UNDEFINED,
    hoist: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentionable: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.Role:
    &#34;&#34;&#34;Edit a role.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to edit the role in. This may be the
        object or the ID of an existing guild.
    role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
        The role to edit. This may be the object or the
        ID of an existing role.

    Other Parameters
    ----------------
    name : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the new name for the role.
    permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]
        If provided, the new permissions for the role.
    color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
        If provided, the new color for the role.
    colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]
        An alias for `color`.
    hoist : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether to hoist the role.
    mentionable : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether to make the role mentionable.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.guilds.Role
        The edited role.

    Raises
    ------
    builtins.TypeError
        If both `color` and `colour` are specified.
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_ROLES` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or role are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_webhook" href="#hikari.api.rest.RESTClient.edit_webhook" id="hikari.api.rest.RESTClient.edit_webhook">edit_webhook</a>(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>],
    *,
    token: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    name: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    channel: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>]] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>: ...</code></pre>
</dt>
<dd>
<p>Edit a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The webhook to edit. This may be the object or the
ID of an existing webhook.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the webhoook token that will be used to edit
the webhook instead of the token the client was initialized with.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the new webhook name.</dd>
<dt><strong><code>avatar</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]</code></dt>
<dd>If provided, the new webhook avatar. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, will
remove the webhook avatar.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]]</code></dt>
<dd>If provided, the text channel to move the webhook to.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code></dt>
<dd>The edited webhook.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not
using a token.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1774-L1836" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
    *,
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    name: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar: undefined.UndefinedNoneOr[files.Resourceish] = undefined.UNDEFINED,
    channel: undefined.UndefinedOr[snowflakes.SnowflakeishOr[channels.TextChannel]] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; webhooks.Webhook:
    &#34;&#34;&#34;Edit a webhook.

    Parameters
    ----------
    webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
        The webhook to edit. This may be the object or the
        ID of an existing webhook.

    Other Parameters
    ----------------
    token : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the webhoook token that will be used to edit
        the webhook instead of the token the client was initialized with.
    name : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the new webhook name.
    avatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]
        If provided, the new webhook avatar. If `builtins.None`, will
        remove the webhook avatar.
    channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]]
        If provided, the text channel to move the webhook to.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.webhooks.Webhook
        The edited webhook.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_WEBHOOKS` permission when not
        using a token.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the webhook is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.edit_widget" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="edit_widget" href="#hikari.api.rest.RESTClient.edit_widget" id="hikari.api.rest.RESTClient.edit_widget">edit_widget</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    channel: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>]] = UNDEFINED,
    enabled: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../guilds.html#hikari.guilds.GuildWidget'>guilds.GuildWidget</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a guilds's widget.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to edit the widget in. This can be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]]</code></dt>
<dd>If provided, the channel to set the widget to. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>,
will not set to any.</dd>
<dt><strong><code>enabled</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to enable the widget.</dd>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.GuildWidget'>GuildWidget</a></code></dt>
<dd>The edited guild widget.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4650-L4704" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def edit_widget(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    channel: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[channels.GuildChannel]] = undefined.UNDEFINED,
    enabled: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; guilds.GuildWidget:
    &#34;&#34;&#34;Fetch a guilds&#39;s widget.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to edit the widget in. This can be the object
        or the ID of an existing guild.

    Other Parameters
    ----------------
    channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]
        If provided, the channel to set the widget to. If `builtins.None`,
        will not set to any.
    enabled : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether to enable the widget.
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Returns
    -------
    hikari.guilds.GuildWidget
        The edited guild widget.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_GUILD` permission.
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.estimate_guild_prune_count" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="estimate_guild_prune_count" href="#hikari.api.rest.RESTClient.estimate_guild_prune_count" id="hikari.api.rest.RESTClient.estimate_guild_prune_count">estimate_guild_prune_count</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    days: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = UNDEFINED,
    include_roles: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/functions.html#int'>int</a>: ...</code></pre>
</dt>
<dd>
<p>Estimate the guild prune count.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to estimate the guild prune count for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>days</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>If provided, number of days to count prune for.</dd>
<dt><strong><code>include_roles</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]]</code></dt>
<dd>If provided, the role(s) to include. By default, this endpoint will
not count users with roles. Providing roles using this attribute
will make members with the specified roles also get included into
the count.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The estimated guild prune count.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4362-L4418" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def estimate_guild_prune_count(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    days: undefined.UndefinedOr[int] = undefined.UNDEFINED,
    include_roles: undefined.UndefinedOr[
        typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]]
    ] = undefined.UNDEFINED,
) -&gt; int:
    &#34;&#34;&#34;Estimate the guild prune count.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to estimate the guild prune count for. This may be the object
        or the ID of an existing guild.

    Other Parameters
    ----------------
    days : hikari.undefined.UndefinedOr[builtins.int]
        If provided, number of days to count prune for.
    include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]]
        If provided, the role(s) to include. By default, this endpoint will
        not count users with roles. Providing roles using this attribute
        will make members with the specified roles also get included into
        the count.

    Returns
    -------
    builtins.int
        The estimated guild prune count.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `KICK_MEMBERS` permission.
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.execute_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="execute_webhook" href="#hikari.api.rest.RESTClient.execute_webhook" id="hikari.api.rest.RESTClient.execute_webhook">execute_webhook</a>(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>],
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    content: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>] = UNDEFINED,
    *,
    username: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    avatar_url: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
    embed: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>] = UNDEFINED,
    embeds: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../embeds.html#hikari.embeds.Embed'>embeds_.Embed</a>]] = UNDEFINED,
    attachment: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>] = UNDEFINED,
    attachments: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>files.Resourceish</a>]] = UNDEFINED,
    tts: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    mentions_everyone: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    user_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
    role_mentions: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]] = UNDEFINED,
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p>Execute a webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The webhook to execute. This may be the object
or the ID of an existing webhook</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The webhook token.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>
<p>If provided, the message contents. If
<code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code>, then nothing will be sent
in the content. Any other value here will be cast to a
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If this is a <code><a href='../embeds.html#hikari.embeds.Embed'>Embed</a></code> and no <code>embed</code> nor
no <code>embeds</code> kwarg is provided, then this will instead
update the embed. This allows for simpler syntax when
sending an embed alone.</p>
<p>Likewise, if this is a <code><a href='../files.html#hikari.files.Resource'>Resource</a></code>, then the
content is instead treated as an attachment if no <code>attachment</code> and
no <code>attachments</code> kwargs are provided.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>embed</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the message embed.</dd>
<dt><strong><code>embeds</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../embeds.html#hikari.embeds.Embed'>Embed</a>]</code></dt>
<dd>If provided, the message embeds.</dd>
<dt><strong><code>attachment</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>],</code></dt>
<dd>If provided, the message attachment. This can be a resource,
or string of a path on your computer or a URL.</dd>
<dt><strong><code>attachments</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../files.html#hikari.files.Resourceish'>Resourceish</a>]],</code></dt>
<dd>If provided, the message attachments. These can be resources, or
strings consisting of paths on your computer or URLs.</dd>
<dt><strong><code>tts</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message will be read out by a screen
reader using Discord's TTS (text-to-speech) system.</dd>
<dt><strong><code>nonce</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>An arbitrary identifier to associate with the message. This
can be used to identify it later in received events. If provided,
this must be less than 32 bytes. If not provided, then
a null value is placed on the message instead. All users can
see this value.</dd>
<dt><strong><code>mentions_everyone</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether the message should parse @everyone/@here
mentions.</dd>
<dt><strong><code>user_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all user mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all user mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../users.html#hikari.users.PartialUser'>PartialUser</a></code> derivatives to enforce mentioning
specific users.</dd>
<dt><strong><code>role_mentions</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]], <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]]</code></dt>
<dd>If provided, and <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, all role mentions will be detected.
If provided, and <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, all role mentions will be ignored
if appearing in the message body.
Alternatively this may be a collection of
<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code>, or
<code><a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a></code> derivatives to enforce mentioning
specific roles.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Attachments can be passed as many different things, to aid in
convenience.</p>
<ul>
<li>If a <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> to a valid URL, the
resource at the given URL will be streamed to Discord when
sending the message. Subclasses of
<code><a href='../files.html#hikari.files.WebResource'>WebResource</a></code> such as
<code><a href='../files.html#hikari.files.URL'>URL</a></code>,
<code><a href='../messages.html#hikari.messages.Attachment'>Attachment</a></code>,
<code><a href='../emojis.html#hikari.emojis.Emoji'>Emoji</a></code>,
<code>EmbedResource</code>, etc will also be uploaded this way.
This will use bit-inception, so only a small percentage of the
resource will remain in memory at any one time, thus aiding in
scalability.</li>
<li>If a <code><a href='../files.html#hikari.files.Bytes'>Bytes</a></code> is passed, or a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>
that contains a valid data URI is passed, then this is uploaded
with a randomized file name if not provided.</li>
<li>If a <code><a href='../files.html#hikari.files.File'>File</a></code>, <code><a href='https://docs.python.org/3/library/pathlib.html#pathlib.PurePath'>pathlib.PurePath</a></code> or
<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> that is an absolute or relative path to a file
on your file system is passed, then this resource is uploaded
as an attachment using non-blocking code internally and streamed
using bit-inception where possible. This depends on the
type of <code><a href='https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor'>concurrent.futures.Executor</a></code> that is being used for
the application (default is a thread pool which supports this
behaviour).</li>
</ul>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The created message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>If more than 100 unique objects/entities are passed for
<code>role_mentions</code> or <code>user_mentions</code>.</dd>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If both <code>attachment</code> and <code>attachments</code> are specified or if both
<code>embed</code> and <code>embeds</code> are specified.</dd>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>This may be raised in several discrete situations, such as messages
being empty with no attachments or embeds; messages with more than
2000 characters in them, embeds that exceed one of the many embed
limits; too many attachments; attachments that are too large;
invalid image URLs in embeds; users in <code>user_mentions</code> not being
mentioned in the message content; roles in <code>role_mentions</code> not
being mentioned in the message content.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1883-L2035" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def execute_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
    token: str,
    content: undefined.UndefinedOr[typing.Any] = undefined.UNDEFINED,
    *,
    username: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    avatar_url: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    embed: undefined.UndefinedOr[embeds_.Embed] = undefined.UNDEFINED,
    embeds: undefined.UndefinedOr[typing.Sequence[embeds_.Embed]] = undefined.UNDEFINED,
    attachment: undefined.UndefinedOr[files.Resourceish] = undefined.UNDEFINED,
    attachments: undefined.UndefinedOr[typing.Sequence[files.Resourceish]] = undefined.UNDEFINED,
    tts: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    mentions_everyone: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    user_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[users.PartialUser]], bool]
    ] = undefined.UNDEFINED,
    role_mentions: undefined.UndefinedOr[
        typing.Union[typing.Collection[snowflakes.SnowflakeishOr[guilds.PartialRole]], bool]
    ] = undefined.UNDEFINED,
) -&gt; messages_.Message:
    &#34;&#34;&#34;Execute a webhook.

    Parameters
    ----------
    webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
        The webhook to execute. This may be the object
        or the ID of an existing webhook
    token: builtins.str
        The webhook token.
    content : hikari.undefined.UndefinedOr[typing.Any]
        If provided, the message contents. If
        `hikari.undefined.UNDEFINED`, then nothing will be sent
        in the content. Any other value here will be cast to a
        `builtins.str`.

        If this is a `hikari.embeds.Embed` and no `embed` nor
        no `embeds` kwarg is provided, then this will instead
        update the embed. This allows for simpler syntax when
        sending an embed alone.

        Likewise, if this is a `hikari.files.Resource`, then the
        content is instead treated as an attachment if no `attachment` and
        no `attachments` kwargs are provided.

    Other Parameters
    ----------------
    embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
        If provided, the message embed.
    embeds : hikari.undefined.UndefinedOr[hikari.embeds.Embed]
        If provided, the message embeds.
    attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],
        If provided, the message attachment. This can be a resource,
        or string of a path on your computer or a URL.
    attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],
        If provided, the message attachments. These can be resources, or
        strings consisting of paths on your computer or URLs.
    tts : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether the message will be read out by a screen
        reader using Discord&#39;s TTS (text-to-speech) system.
    nonce : hikari.undefined.UndefinedOr[builtins.str]
        An arbitrary identifier to associate with the message. This
        can be used to identify it later in received events. If provided,
        this must be less than 32 bytes. If not provided, then
        a null value is placed on the message instead. All users can
        see this value.
    mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether the message should parse @everyone/@here
        mentions.
    user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]], builtins.bool]]
        If provided, and `builtins.True`, all user mentions will be detected.
        If provided, and `builtins.False`, all user mentions will be ignored
        if appearing in the message body.
        Alternatively this may be a collection of
        `hikari.snowflakes.Snowflake`, or
        `hikari.users.PartialUser` derivatives to enforce mentioning
        specific users.
    role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]], builtins.bool]]
        If provided, and `builtins.True`, all role mentions will be detected.
        If provided, and `builtins.False`, all role mentions will be ignored
        if appearing in the message body.
        Alternatively this may be a collection of
        `hikari.snowflakes.Snowflake`, or
        `hikari.guilds.PartialRole` derivatives to enforce mentioning
        specific roles.

    !!! note
        Attachments can be passed as many different things, to aid in
        convenience.

        - If a `pathlib.PurePath` or `builtins.str` to a valid URL, the
            resource at the given URL will be streamed to Discord when
            sending the message. Subclasses of
            `hikari.files.WebResource` such as
            `hikari.files.URL`,
            `hikari.messages.Attachment`,
            `hikari.emojis.Emoji`,
            `EmbedResource`, etc will also be uploaded this way.
            This will use bit-inception, so only a small percentage of the
            resource will remain in memory at any one time, thus aiding in
            scalability.
        - If a `hikari.files.Bytes` is passed, or a `builtins.str`
            that contains a valid data URI is passed, then this is uploaded
            with a randomized file name if not provided.
        - If a `hikari.files.File`, `pathlib.PurePath` or
            `builtins.str` that is an absolute or relative path to a file
            on your file system is passed, then this resource is uploaded
            as an attachment using non-blocking code internally and streamed
            using bit-inception where possible. This depends on the
            type of `concurrent.futures.Executor` that is being used for
            the application (default is a thread pool which supports this
            behaviour).

    Returns
    -------
    hikari.messages.Message
        The created message.

    Raises
    ------
    builtins.ValueError
        If more than 100 unique objects/entities are passed for
        `role_mentions` or `user_mentions`.
    builtins.TypeError
        If both `attachment` and `attachments` are specified or if both
        `embed` and `embeds` are specified.
    hikari.errors.BadRequestError
        This may be raised in several discrete situations, such as messages
        being empty with no attachments or embeds; messages with more than
        2000 characters in them, embeds that exceed one of the many embed
        limits; too many attachments; attachments that are too large;
        invalid image URLs in embeds; users in `user_mentions` not being
        mentioned in the message content; roles in `role_mentions` not
        being mentioned in the message content.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_application" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_application" href="#hikari.api.rest.RESTClient.fetch_application" id="hikari.api.rest.RESTClient.fetch_application">fetch_application</a>() -> <a href='../applications.html#hikari.applications.Application'>applications.Application</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch the token's associated application.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.Application'>Application</a></code></dt>
<dd>The token's associated application.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2376-L2402" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_application(self) -&gt; applications.Application:
    &#34;&#34;&#34;Fetch the token&#39;s associated application.

    Returns
    -------
    hikari.applications.Application
        The token&#39;s associated application.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_audit_log" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_audit_log" href="#hikari.api.rest.RESTClient.fetch_audit_log" id="hikari.api.rest.RESTClient.fetch_audit_log">fetch_audit_log</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    before: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
    user: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>]] = UNDEFINED,
    event_type: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLogEventType'>audit_logs.AuditLogEventType</a>] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLog'>audit_logs.AuditLog</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the guild's audit log.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the audit logs from. This can be a
guild object or the ID of an existing guild.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>before</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, filter to only actions after this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]]</code></dt>
<dd>If provided, the user to filter for.</dd>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLogEventType'>AuditLogEventType</a>]</code></dt>
<dd>If provided, the event type to filter for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../audit_logs.html#hikari.audit_logs.AuditLog'>AuditLog</a>]</code></dt>
<dd>The guild's audit log.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
</div>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>VIEW_AUDIT_LOG</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the
result is awaited or iterated over. Invoking this function
itself will not raise anything.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2556-L2620" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def fetch_audit_log(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    user: undefined.UndefinedOr[snowflakes.SnowflakeishOr[users.PartialUser]] = undefined.UNDEFINED,
    event_type: undefined.UndefinedOr[audit_logs.AuditLogEventType] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[audit_logs.AuditLog]:
    &#34;&#34;&#34;Fetch the guild&#39;s audit log.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the audit logs from. This can be a
        guild object or the ID of an existing guild.

    Other Parameters
    ----------------
    before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
        If provided, filter to only actions after this snowflake. If you provide
        a datetime object, it will be transformed into a snowflake. This
        may be any other Discord entity that has an ID. In this case, the
        date the object was first created will be used.
    user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]
        If provided, the user to filter for.
    event_type : hikari.undefined.UndefinedOr[hikari.audit_logs.AuditLogEventType]
        If provided, the event type to filter for.

    Returns
    -------
    hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog]
        The guild&#39;s audit log.

    !!! note
       This call is not a coroutine function, it returns a special type of
       lazy iterator that will perform API calls as you iterate across it.
       See `hikari.iterators` for the full API for this iterator type.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.ForbiddenError
        If you are missing the `VIEW_AUDIT_LOG` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.

    !!! note
        The exceptions on this endpoint will only be raised once the
        result is awaited or iterated over. Invoking this function
        itself will not raise anything.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_ban" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_ban" href="#hikari.api.rest.RESTClient.fetch_ban" id="hikari.api.rest.RESTClient.fetch_ban">fetch_ban</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='../guilds.html#hikari.guilds.GuildMemberBan'>guilds.GuildMemberBan</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch the guild's ban info for a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the ban from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to fetch the ban of. This may be the
object or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.GuildMemberBan'>GuildMemberBan</a></code></dt>
<dd>The requested ban info.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found or if the user
is not banned.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4008-L4052" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_ban(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
) -&gt; guilds.GuildMemberBan:
    &#34;&#34;&#34;Fetch the guild&#39;s ban info for a user.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the ban from. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to fetch the ban of. This may be the
        object or the ID of an existing user.

    Returns
    -------
    hikari.guilds.GuildMemberBan
        The requested ban info.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `BAN_MEMBERS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or user are not found or if the user
        is not banned.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_bans" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_bans" href="#hikari.api.rest.RESTClient.fetch_bans" id="hikari.api.rest.RESTClient.fetch_bans">fetch_bans</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.GuildMemberBan'>guilds.GuildMemberBan</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the bans of a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the bans from. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.GuildMemberBan'>GuildMemberBan</a>]</code></dt>
<dd>The requested bans.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4054-L4093" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_bans(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[guilds.GuildMemberBan]:
    &#34;&#34;&#34;Fetch the bans of a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the bans from. This may be the
        object or the ID of an existing guild.

    Returns
    -------
    typing.Sequence[hikari.guilds.GuildMemberBan]
        The requested bans.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `BAN_MEMBERS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel" href="#hikari.api.rest.RESTClient.fetch_channel" id="hikari.api.rest.RESTClient.fetch_channel">fetch_channel</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>],
) -> <a href='../channels.html#hikari.channels.PartialChannel'>channels.PartialChannel</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a>]</code></dt>
<dd>The channel to fetch. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code></dt>
<dd>
<p>The channel. This will be a <em>derivative</em> of
<code><a href='../channels.html#hikari.channels.PartialChannel'>PartialChannel</a></code>, depending on the type of
channel you request for.</p>
<p>This means that you may get one of
<code><a href='../channels.html#hikari.channels.DMChannel'>DMChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GroupDMChannel'>GroupDMChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildTextChannel'>GuildTextChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildStoreChannel'>GuildStoreChannel</a></code>,
<code><a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a></code>.</p>
<p>Likewise, the <code><a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a></code> can be used to
determine if a channel is guild-bound, and
<code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> can be used to determine
if the channel provides textual functionality to the application.</p>
<p>You can check for these using the <code><a href='https://docs.python.org/3/library/functions.html#isinstance'>isinstance</a></code>
builtin function.</p>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGES</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L81-L140" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_channel(
    self, channel: snowflakes.SnowflakeishOr[channels.PartialChannel]
) -&gt; channels.PartialChannel:
    &#34;&#34;&#34;Fetch a channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]
        The channel to fetch. This may be the object or the ID of an
        existing channel.

    Returns
    -------
    hikari.channels.PartialChannel
        The channel. This will be a _derivative_ of
        `hikari.channels.PartialChannel`, depending on the type of
        channel you request for.

        This means that you may get one of
        `hikari.channels.DMChannel`,
        `hikari.channels.GroupDMChannel`,
        `hikari.channels.GuildTextChannel`,
        `hikari.channels.GuildVoiceChannel`,
        `hikari.channels.GuildStoreChannel`,
        `hikari.channels.GuildNewsChannel`.

        Likewise, the `hikari.channels.GuildChannel` can be used to
        determine if a channel is guild-bound, and
        `hikari.channels.TextChannel` can be used to determine
        if the channel provides textual functionality to the application.

        You can check for these using the `builtins.isinstance`
        builtin function.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `READ_MESSAGES` permission in the channel.
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_channel_invites" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel_invites" href="#hikari.api.rest.RESTClient.fetch_channel_invites" id="hikari.api.rest.RESTClient.fetch_channel_invites">fetch_channel_invites</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch all invites pointing to the given guild channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The channel to fetch the invites from. This may be a channel
object, or the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>The invites pointing to the given guild channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found in any guilds you are a member of.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L443-L481" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_channel_invites(
    self, channel: snowflakes.SnowflakeishOr[channels.GuildChannel]
) -&gt; typing.Sequence[invites.InviteWithMetadata]:
    &#34;&#34;&#34;Fetch all invites pointing to the given guild channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
        The channel to fetch the invites from. This may be a channel
        object, or the ID of an existing channel.

    Returns
    -------
    typing.Sequence[hikari.invites.InviteWithMetadata]
        The invites pointing to the given guild channel.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_CHANNEL` permission in the channel.
    hikari.errors.NotFoundError
        If the channel is not found in any guilds you are a member of.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_channel_webhooks" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_channel_webhooks" href="#hikari.api.rest.RESTClient.fetch_channel_webhooks" id="hikari.api.rest.RESTClient.fetch_channel_webhooks">fetch_channel_webhooks</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch all channel webhooks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to fetch the webhooks for. This
may be a <code><a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a></code> or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The fetched webhooks.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1691-L1731" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_channel_webhooks(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
) -&gt; typing.Sequence[webhooks.Webhook]:
    &#34;&#34;&#34;Fetch all channel webhooks.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to fetch the webhooks for. This
        may be a `hikari.channels.TextChannel` or the ID of an
        existing channel.

    Returns
    -------
    typing.Sequence[hikari.webhooks.Webhook]
        The fetched webhooks.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_WEBHOOKS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_emoji" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_emoji" href="#hikari.api.rest.RESTClient.fetch_emoji" id="hikari.api.rest.RESTClient.fetch_emoji">fetch_emoji</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    emoji: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>emojis.CustomEmoji</a>],
) -> <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a guild emoji.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the emoji from. This can be a
guild object or the ID of an existing guild.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a>]</code></dt>
<dd>The emoji to fetch. This can be a <code><a href='../emojis.html#hikari.emojis.CustomEmoji'>CustomEmoji</a></code>
or the ID of an existing emoji.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The requested emoji.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the emoji are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2622-L2663" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_emoji(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    emoji: snowflakes.SnowflakeishOr[emojis.CustomEmoji],
) -&gt; emojis.KnownCustomEmoji:
    &#34;&#34;&#34;Fetch a guild emoji.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the emoji from. This can be a
        guild object or the ID of an existing guild.
    emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]
        The emoji to fetch. This can be a `hikari.emojis.CustomEmoji`
        or the ID of an existing emoji.

    Returns
    -------
    hikari.emojis.KnownCustomEmoji
        The requested emoji.

    Raises
    ------
    hikari.errors.NotFoundError
        If the guild or the emoji are not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_gateway_bot" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_gateway_bot" href="#hikari.api.rest.RESTClient.fetch_gateway_bot" id="hikari.api.rest.RESTClient.fetch_gateway_bot">fetch_gateway_bot</a>() -> <a href='../sessions.html#hikari.sessions.GatewayBot'>sessions.GatewayBot</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch the gateway gateway info for the bot.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../sessions.html#hikari.sessions.GatewayBot'>GatewayBot</a></code></dt>
<dd>The gateway bot.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2061-L2087" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_gateway_bot(self) -&gt; sessions.GatewayBot:
    &#34;&#34;&#34;Fetch the gateway gateway info for the bot.

    Returns
    -------
    hikari.sessions.GatewayBot
        The gateway bot.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_gateway_url" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_gateway_url" href="#hikari.api.rest.RESTClient.fetch_gateway_url" id="hikari.api.rest.RESTClient.fetch_gateway_url">fetch_gateway_url</a>() -> <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch the gateway url.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This endpoint does not require any valid authorization.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2037-L2059" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_gateway_url(self) -&gt; str:
    &#34;&#34;&#34;Fetch the gateway url.

    !!! note
        This endpoint does not require any valid authorization.

    Raises
    ------
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild" href="#hikari.api.rest.RESTClient.fetch_guild" id="hikari.api.rest.RESTClient.fetch_guild">fetch_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.RESTGuild'>guilds.RESTGuild</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch. This can be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.RESTGuild'>RESTGuild</a></code></dt>
<dd>The requested guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2921-L2957" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.RESTGuild:
    &#34;&#34;&#34;Fetch a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch. This can be the object
        or the ID of an existing guild.

    Returns
    -------
    hikari.guilds.RESTGuild
        The requested guild.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are not part of the guild.
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_guild_channels" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_channels" href="#hikari.api.rest.RESTClient.fetch_guild_channels" id="hikari.api.rest.RESTClient.fetch_guild_channels">fetch_guild_channels</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the channels in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the channels from. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The requested channels.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3146-L3182" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_guild_channels(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[channels.GuildChannel]:
    &#34;&#34;&#34;Fetch the channels in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the channels from. This may be the
        object or the ID of an existing guild.

    Returns
    -------
    typing.Sequence[hikari.channels.GuildChannel]
        The requested channels.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_guild_emojis" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_emojis" href="#hikari.api.rest.RESTClient.fetch_guild_emojis" id="hikari.api.rest.RESTClient.fetch_guild_emojis">fetch_guild_emojis</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the emojis of a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the emojis from. This can be a
guild object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>The requested emojis.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2665-L2701" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_guild_emojis(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; typing.Sequence[emojis.KnownCustomEmoji]:
    &#34;&#34;&#34;Fetch the emojis of a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the emojis from. This can be a
        guild object or the ID of an existing guild.

    Returns
    -------
    typing.Sequence[hikari.emojis.KnownCustomEmoji]
        The requested emojis.

    Raises
    ------
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_guild_invites" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_invites" href="#hikari.api.rest.RESTClient.fetch_guild_invites" id="hikari.api.rest.RESTClient.fetch_guild_invites">fetch_guild_invites</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the guild's invites.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the invites for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>The invites for the guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4530-L4569" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_guild_invites(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[invites.InviteWithMetadata]:
    &#34;&#34;&#34;Fetch the guild&#39;s invites.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the invites for. This may be the object
        or the ID of an existing guild.

    Returns
    -------
    typing.Sequence[hikari.invites.InviteWithMetadata]
        The invites for the guild.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_GUILD` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_guild_preview" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_preview" href="#hikari.api.rest.RESTClient.fetch_guild_preview" id="hikari.api.rest.RESTClient.fetch_guild_preview">fetch_guild_preview</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.GuildPreview'>guilds.GuildPreview</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a guild preview.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the preview of. This can be a
guild object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.GuildPreview'>GuildPreview</a></code></dt>
<dd>The requested guild preview.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will only work for guilds you are a part of or are public.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2959-L2996" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_guild_preview(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildPreview:
    &#34;&#34;&#34;Fetch a guild preview.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the preview of. This can be a
        guild object or the ID of an existing guild.

    Returns
    -------
    hikari.guilds.GuildPreview
        The requested guild preview.

    !!! note
        This will only work for guilds you are a part of or are public.

    Raises
    ------
    hikari.errors.NotFoundError
        If the guild is not found or you are not part of the guild.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_guild_voice_regions" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_voice_regions" href="#hikari.api.rest.RESTClient.fetch_guild_voice_regions" id="hikari.api.rest.RESTClient.fetch_guild_voice_regions">fetch_guild_voice_regions</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>voices.VoiceRegion</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the available voice regions for a guild.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Unlike <code><a href='#hikari.api.rest.RESTClient.fetch_voice_regions'>fetch_voice_regions</a></code>, this will
return the VIP regions if the guild has access to them.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the voice regions for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>VoiceRegion</a>]</code></dt>
<dd>The available voice regions for the guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4487-L4528" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_guild_voice_regions(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[voices.VoiceRegion]:
    &#34;&#34;&#34;Fetch the available voice regions for a guild.

    !!! note
        Unlike `RESTClient.fetch_voice_regions`, this will
        return the VIP regions if the guild has access to them.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the voice regions for. This may be the object
        or the ID of an existing guild.

    Returns
    -------
    typing.Sequence[hikari.voices.VoiceRegion]
        The available voice regions for the guild.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_guild_webhooks" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_guild_webhooks" href="#hikari.api.rest.RESTClient.fetch_guild_webhooks" id="hikari.api.rest.RESTClient.fetch_guild_webhooks">fetch_guild_webhooks</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch all guild webhooks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the webhooks for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The fetched webhooks.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1733-L1772" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_guild_webhooks(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[webhooks.Webhook]:
    &#34;&#34;&#34;Fetch all guild webhooks.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the webhooks for. This may be the object
        or the ID of an existing guild.

    Returns
    -------
    typing.Sequence[hikari.webhooks.Webhook]
        The fetched webhooks.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_WEBHOOKS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_integrations" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_integrations" href="#hikari.api.rest.RESTClient.fetch_integrations" id="hikari.api.rest.RESTClient.fetch_integrations">fetch_integrations</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.Integration'>guilds.Integration</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the guild's integrations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the integrations for. This may be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.Integration'>Integration</a>]</code></dt>
<dd>The integrations for the guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4571-L4610" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_integrations(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[guilds.Integration]:
    &#34;&#34;&#34;Fetch the guild&#39;s integrations.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the integrations for. This may be the object
        or the ID of an existing guild.

    Returns
    -------
    typing.Sequence[hikari.guilds.Integration]
        The integrations for the guild.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_GUILD` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_invite" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_invite" href="#hikari.api.rest.RESTClient.fetch_invite" id="hikari.api.rest.RESTClient.fetch_invite">fetch_invite</a>(
    invite: <a href='../invites.html#hikari.invites.Inviteish'>invites.Inviteish</a>,
) -> <a href='../invites.html#hikari.invites.Invite'>invites.Invite</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch an existing invite.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='../invites.html#hikari.invites.Inviteish'>Inviteish</a></code></dt>
<dd>The invite to fetch. This may be an invite object or
the code of an existing invite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../invites.html#hikari.invites.Invite'>Invite</a></code></dt>
<dd>The requested invite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the invite is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2089-L2123" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_invite(self, invite: invites.Inviteish) -&gt; invites.Invite:
    &#34;&#34;&#34;Fetch an existing invite.

    Parameters
    ----------
    invite : hikari.invites.Inviteish
        The invite to fetch. This may be an invite object or
        the code of an existing invite.

    Returns
    -------
    hikari.invites.Invite
        The requested invite.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the invite is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_member" href="#hikari.api.rest.RESTClient.fetch_member" id="hikari.api.rest.RESTClient.fetch_member">fetch_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a guild member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to get the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to get the member for. This may be the
object or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code></dt>
<dd>The requested member.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or the user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3518-L3559" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
) -&gt; guilds.Member:
    &#34;&#34;&#34;Fetch a guild member.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to get the member from. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to get the member for. This may be the
        object or the ID of an existing user.

    Returns
    -------
    hikari.guilds.Member
        The requested member.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or the user are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_members" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_members" href="#hikari.api.rest.RESTClient.fetch_members" id="hikari.api.rest.RESTClient.fetch_members">fetch_members</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the members from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the members of. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>An iterator to fetch the members.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
</div>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the
result is awaited or iterated over. Invoking this function
itself will not raise anything.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3561-L3607" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def fetch_members(
    self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]
) -&gt; iterators.LazyIterator[guilds.Member]:
    &#34;&#34;&#34;Fetch the members from a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the members of. This may be the
        object or the ID of an existing guild.

    Returns
    -------
    hikari.iterators.LazyIterator[hikari.guilds.Member]
        An iterator to fetch the members.

    !!! note
       This call is not a coroutine function, it returns a special type of
       lazy iterator that will perform API calls as you iterate across it.
       See `hikari.iterators` for the full API for this iterator type.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.

    !!! note
        The exceptions on this endpoint will only be raised once the
        result is awaited or iterated over. Invoking this function
        itself will not raise anything.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_message" href="#hikari.api.rest.RESTClient.fetch_message" id="hikari.api.rest.RESTClient.fetch_message">fetch_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='../messages.html#hikari.messages.Message'>messages_.Message</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a specific message in the given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to fetch messages in. This may be the object or
the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to fetch. This may be the object or the ID of an
existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../messages.html#hikari.messages.Message'>Message</a></code></dt>
<dd>The requested message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the message is not found in the
given text channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L816-L860" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; messages_.Message:
    &#34;&#34;&#34;Fetch a specific message in the given text channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to fetch messages in. This may be the object or
        the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to fetch. This may be the object or the ID of an
        existing channel.

    Returns
    -------
    hikari.messages.Message
        The requested message.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `READ_MESSAGE_HISTORY` in the channel.
    hikari.errors.NotFoundError
        If the channel is not found or the message is not found in the
        given text channel.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_messages" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_messages" href="#hikari.api.rest.RESTClient.fetch_messages" id="hikari.api.rest.RESTClient.fetch_messages">fetch_messages</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    *,
    before: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
    after: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
    around: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>]: ...</code></pre>
</dt>
<dd>
<p>Browse the message history for a given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to fetch messages in. This may be the object or
the ID of an existing channel.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>before</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, fetch messages before this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
<dt><strong><code>after</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, fetch messages after this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
<dt><strong><code>around</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>If provided, fetch messages around this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may be any other Discord entity that has an ID. In this case, the
date the object was first created will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>An iterator to fetch the messages.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
</div>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code></dt>
<dd>If you specify more than one of <code>before</code>, <code>after</code>, <code><a href='https://docs.python.org/3/about.html'>about</a></code>.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint (other than <code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code>) will only
be raised once the result is awaited or iterated over. Invoking
this function itself will not raise anything (other than
<code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code>).</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L740-L814" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def fetch_messages(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    *,
    before: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    after: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
    around: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[snowflakes.Unique]] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[messages_.Message]:
    &#34;&#34;&#34;Browse the message history for a given text channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to fetch messages in. This may be the object or
        the ID of an existing channel.

    Other Parameters
    ----------------
    before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
        If provided, fetch messages before this snowflake. If you provide
        a datetime object, it will be transformed into a snowflake. This
        may be any other Discord entity that has an ID. In this case, the
        date the object was first created will be used.
    after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
        If provided, fetch messages after this snowflake. If you provide
        a datetime object, it will be transformed into a snowflake. This
        may be any other Discord entity that has an ID. In this case, the
        date the object was first created will be used.
    around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]
        If provided, fetch messages around this snowflake. If you provide
        a datetime object, it will be transformed into a snowflake. This
        may be any other Discord entity that has an ID. In this case, the
        date the object was first created will be used.

    Returns
    -------
    hikari.iterators.LazyIterator[hikari.messages.Message]
        An iterator to fetch the messages.

    !!! note
       This call is not a coroutine function, it returns a special type of
       lazy iterator that will perform API calls as you iterate across it.
       See `hikari.iterators` for the full API for this iterator type.

    Raises
    ------
    builtins.TypeError
        If you specify more than one of `before`, `after`, `about`.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `READ_MESSAGE_HISTORY` in the channel.
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.

    !!! note
        The exceptions on this endpoint (other than `builtins.TypeError`) will only
        be raised once the result is awaited or iterated over. Invoking
        this function itself will not raise anything (other than
        `builtins.TypeError`).
    &#34;&#34;&#34;  # noqa: E501 - Line too long</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_my_connections" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_my_connections" href="#hikari.api.rest.RESTClient.fetch_my_connections" id="hikari.api.rest.RESTClient.fetch_my_connections">fetch_my_connections</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../applications.html#hikari.applications.OwnConnection'>applications.OwnConnection</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the token's associated connections.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../applications.html#hikari.applications.OwnConnection'>OwnConnection</a></code></dt>
<dd>The token's associated connections.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2223-L2249" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_my_connections(self) -&gt; typing.Sequence[applications.OwnConnection]:
    &#34;&#34;&#34;Fetch the token&#39;s associated connections.

    Returns
    -------
    hikari.applications.OwnConnection
        The token&#39;s associated connections.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_my_guilds" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_my_guilds" href="#hikari.api.rest.RESTClient.fetch_my_guilds" id="hikari.api.rest.RESTClient.fetch_my_guilds">fetch_my_guilds</a>(
    *,
    newest_first: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    start_at: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>snowflakes.SearchableSnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>]] = UNDEFINED,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../applications.html#hikari.applications.OwnGuild'>applications.OwnGuild</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the token's associated guilds.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>newest_first</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Whether to fetch the newest first or the olders first.
Defaults to <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</dd>
<dt><strong><code>start_at</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SearchableSnowflakeishOr'>SearchableSnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]]</code></dt>
<dd>If provided, will start at this snowflake. If you provide
a datetime object, it will be transformed into a snowflake. This
may also be a guild object. In this case, the
date the object was first created will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../applications.html#hikari.applications.OwnGuild'>OwnGuild</a>]</code></dt>
<dd>The token's associated guilds.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
</div>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the
result is awaited or iterated over. Invoking this function
itself will not raise anything.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2251-L2305" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def fetch_my_guilds(
    self,
    *,
    newest_first: bool = False,
    start_at: undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[guilds.PartialGuild]] = undefined.UNDEFINED,
) -&gt; iterators.LazyIterator[applications.OwnGuild]:
    &#34;&#34;&#34;Fetch the token&#39;s associated guilds.

    Other Parameters
    ----------------
    newest_first : builtins.bool
        Whether to fetch the newest first or the olders first.
        Defaults to `builtins.False`.
    start_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild]]
        If provided, will start at this snowflake. If you provide
        a datetime object, it will be transformed into a snowflake. This
        may also be a guild object. In this case, the
        date the object was first created will be used.

    Returns
    -------
    hikari.iterators.LazyIterator[hikari.applications.OwnGuild]
        The token&#39;s associated guilds.

    !!! note
       This call is not a coroutine function, it returns a special type of
       lazy iterator that will perform API calls as you iterate across it.
       See `hikari.iterators` for the full API for this iterator type.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.

    !!! note
        The exceptions on this endpoint will only be raised once the
        result is awaited or iterated over. Invoking this function
        itself will not raise anything.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_my_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_my_user" href="#hikari.api.rest.RESTClient.fetch_my_user" id="hikari.api.rest.RESTClient.fetch_my_user">fetch_my_user</a>() -> <a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch the token's associated user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The token's associated user.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2160-L2186" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_my_user(self) -&gt; users.OwnUser:
    &#34;&#34;&#34;Fetch the token&#39;s associated user.

    Returns
    -------
    hikari.users.OwnUser
        The token&#39;s associated user.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_pins" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_pins" href="#hikari.api.rest.RESTClient.fetch_pins" id="hikari.api.rest.RESTClient.fetch_pins">fetch_pins</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../messages.html#hikari.messages.Message'>messages_.Message</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the pinned messages in this text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to fetch pins from. This may be the object or
the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../messages.html#hikari.messages.Message'>Message</a>]</code></dt>
<dd>The pinned messages in this text channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>READ_MESSAGES</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L618-L656" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_pins(
    self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
) -&gt; typing.Sequence[messages_.Message]:
    &#34;&#34;&#34;Fetch the pinned messages in this text channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to fetch pins from. This may be the object or
        the ID of an existing channel.

    Returns
    -------
    typing.Sequence[hikari.messages.Message]
        The pinned messages in this text channel.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `READ_MESSAGES` in the channel.
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_reactions_for_emoji" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_reactions_for_emoji" href="#hikari.api.rest.RESTClient.fetch_reactions_for_emoji" id="hikari.api.rest.RESTClient.fetch_reactions_for_emoji">fetch_reactions_for_emoji</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
    emoji: <a href='../emojis.html#hikari.emojis.Emojiish'>emojis.Emojiish</a>,
) -> <a href='../iterators.html#hikari.iterators.LazyIterator'>iterators.LazyIterator</a>[<a href='../users.html#hikari.users.User'>users.User</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch reactions for an emoji from a message.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel where the message to delete all reactions from is.
This may be the object or the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to delete all reaction from. This may be the
object or the ID of an existing message.</dd>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.Emojiish'>Emojiish</a></code></dt>
<dd>The emoji to filter reactions by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../iterators.html#hikari.iterators.LazyIterator'>LazyIterator</a>[<a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>An iterator to fetch the users.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
</div>
<p>This call is not a coroutine function, it returns a special type of
lazy iterator that will perform API calls as you iterate across it.
See <code><a href='../iterators.html'>hikari.iterators</a></code> for the full API for this iterator type.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If an invalid unicode emoji is given, or if the given custom emoji
does not exist.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel or message is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the
result is awaited or iterated over. Invoking this function
itself will not raise anything.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1525-L1582" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def fetch_reactions_for_emoji(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
    emoji: emojis.Emojiish,
) -&gt; iterators.LazyIterator[users.User]:
    &#34;&#34;&#34;Fetch reactions for an emoji from a message.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel where the message to delete all reactions from is.
        This may be the object or the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to delete all reaction from. This may be the
        object or the ID of an existing message.
    emoji : hikari.emojis.Emojiish
        The emoji to filter reactions by.

    Returns
    -------
    hikari.iterators.LazyIterator[hikari.users.User]
        An iterator to fetch the users.

    !!! note
       This call is not a coroutine function, it returns a special type of
       lazy iterator that will perform API calls as you iterate across it.
       See `hikari.iterators` for the full API for this iterator type.

    Raises
    ------
    hikari.errors.BadRequestError
        If an invalid unicode emoji is given, or if the given custom emoji
        does not exist.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the channel or message is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.

    !!! note
        The exceptions on this endpoint will only be raised once the
        result is awaited or iterated over. Invoking this function
        itself will not raise anything.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_roles" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_roles" href="#hikari.api.rest.RESTClient.fetch_roles" id="hikari.api.rest.RESTClient.fetch_roles">fetch_roles</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch the roles of a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the roles from. This may be the
object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>The requested roles.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4095-L4132" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_roles(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
) -&gt; typing.Sequence[guilds.Role]:
    &#34;&#34;&#34;Fetch the roles of a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the roles from. This may be the
        object or the ID of an existing guild.

    Returns
    -------
    typing.Sequence[hikari.guilds.Role]
        The requested roles.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_user" href="#hikari.api.rest.RESTClient.fetch_user" id="hikari.api.rest.RESTClient.fetch_user">fetch_user</a>(
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
) -> <a href='../users.html#hikari.users.User'>users.User</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to fetch. This can be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../users.html#hikari.users.User'>User</a></code></dt>
<dd>The requested user</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the user is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2520-L2554" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_user(self, user: snowflakes.SnowflakeishOr[users.PartialUser]) -&gt; users.User:
    &#34;&#34;&#34;Fetch a user.

    Parameters
    ----------
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to fetch. This can be the object
        or the ID of an existing user.

    Returns
    -------
    hikari.users.User
        The requested user

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the user is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_vanity_url" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_vanity_url" href="#hikari.api.rest.RESTClient.fetch_vanity_url" id="hikari.api.rest.RESTClient.fetch_vanity_url">fetch_vanity_url</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../invites.html#hikari.invites.VanityURL'>invites.VanityURL</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a guild's vanity url.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the vanity url from. This can
be the object or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../invites.html#hikari.invites.VanityURL'>VanityURL</a></code></dt>
<dd>The requested invite.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are not part of the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4706-L4742" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_vanity_url(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; invites.VanityURL:
    &#34;&#34;&#34;Fetch a guild&#39;s vanity url.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the vanity url from. This can
        be the object or the ID of an existing guild.

    Returns
    -------
    hikari.invites.VanityURL
        The requested invite.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are not part of the guild.
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_voice_regions" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_voice_regions" href="#hikari.api.rest.RESTClient.fetch_voice_regions" id="hikari.api.rest.RESTClient.fetch_voice_regions">fetch_voice_regions</a>() -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>voices.VoiceRegion</a>]: ...</code></pre>
</dt>
<dd>
<p>Fetch available voice regions.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This endpoint doesn't return VIP voice regions.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../voices.html#hikari.voices.VoiceRegion'>VoiceRegion</a>]</code></dt>
<dd>The available voice regions.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2489-L2518" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_voice_regions(self) -&gt; typing.Sequence[voices.VoiceRegion]:
    &#34;&#34;&#34;Fetch available voice regions.

    !!! note
        This endpoint doesn&#39;t return VIP voice regions.

    Returns
    -------
    typing.Sequence[hikari.voices.VoiceRegion]
        The available voice regions.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_webhook" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_webhook" href="#hikari.api.rest.RESTClient.fetch_webhook" id="hikari.api.rest.RESTClient.fetch_webhook">fetch_webhook</a>(
    webhook: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>],
    *,
    token: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='../webhooks.html#hikari.webhooks.Webhook'>webhooks.Webhook</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch an existing webhook.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>webhook</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a>]</code></dt>
<dd>The webhook to fetch. This may be the object or the ID
of an existing webhook.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the webhoook token that will be used to fetch
the webhook instead of the token the client was initialized with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../webhooks.html#hikari.webhooks.Webhook'>Webhook</a></code></dt>
<dd>The requested webhook.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not
using a token.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the webhook is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L1641-L1689" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_webhook(
    self,
    webhook: snowflakes.SnowflakeishOr[webhooks.Webhook],
    *,
    token: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; webhooks.Webhook:
    &#34;&#34;&#34;Fetch an existing webhook.

    Parameters
    ----------
    webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook]
        The webhook to fetch. This may be the object or the ID
        of an existing webhook.

    Other Parameters
    ----------------
    token : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the webhoook token that will be used to fetch
        the webhook instead of the token the client was initialized with.

    Returns
    -------
    hikari.webhooks.Webhook
        The requested webhook.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_WEBHOOKS` permission when not
        using a token.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the webhook is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.fetch_widget" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="fetch_widget" href="#hikari.api.rest.RESTClient.fetch_widget" id="hikari.api.rest.RESTClient.fetch_widget">fetch_widget</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
) -> <a href='../guilds.html#hikari.guilds.GuildWidget'>guilds.GuildWidget</a>: ...</code></pre>
</dt>
<dd>
<p>Fetch a guilds's widget.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to fetch the widget from. This can be the object
or the ID of an existing guild.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../guilds.html#hikari.guilds.GuildWidget'>GuildWidget</a></code></dt>
<dd>The requested guild widget.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_GUILD</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4612-L4648" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def fetch_widget(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild]) -&gt; guilds.GuildWidget:
    &#34;&#34;&#34;Fetch a guilds&#39;s widget.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to fetch the widget from. This can be the object
        or the ID of an existing guild.

    Returns
    -------
    hikari.guilds.GuildWidget
        The requested guild widget.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_GUILD` permission.
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.follow_channel" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="follow_channel" href="#hikari.api.rest.RESTClient.follow_channel" id="hikari.api.rest.RESTClient.follow_channel">follow_channel</a>(
    news_channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>channels.GuildNewsChannel</a>],
    target_channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>],
) -> <a href='../channels.html#hikari.channels.ChannelFollow'>channels.ChannelFollow</a>: ...</code></pre>
</dt>
<dd>
<p>Follow a news channel to send messages to a target channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>news_channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildNewsChannel'>GuildNewsChannel</a>]</code></dt>
<dd>The object or ID of the news channel to follow.</dd>
<dt><strong><code>target_channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The object or ID of the channel to target.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../channels.html#hikari.channels.ChannelFollow'>ChannelFollow</a></code></dt>
<dd>Information about the new relationship that was made.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If you try to follow a channel that's not a news channel or if the
target channel has reached it's webhook limit, which is 10 at the
time of writing.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_WEBHOOKS</code> permission in the target
channel or are missing the <code>VIEW_CHANNEL</code> permission in the origin
channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the origin or target channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L223-L270" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def follow_channel(
    self,
    news_channel: snowflakes.SnowflakeishOr[channels.GuildNewsChannel],
    target_channel: snowflakes.SnowflakeishOr[channels.GuildChannel],
) -&gt; channels.ChannelFollow:
    &#34;&#34;&#34;Follow a news channel to send messages to a target channel.

    Parameters
    ----------
    news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]
        The object or ID of the news channel to follow.
    target_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]
        The object or ID of the channel to target.

    Returns
    -------
    hikari.channels.ChannelFollow
        Information about the new relationship that was made.

    Raises
    ------
    hikari.errors.BadRequestError
        If you try to follow a channel that&#39;s not a news channel or if the
        target channel has reached it&#39;s webhook limit, which is 10 at the
        time of writing.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_WEBHOOKS` permission in the target
        channel or are missing the `VIEW_CHANNEL` permission in the origin
        channel.
    hikari.errors.NotFoundError
        If the origin or target channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.guild_builder" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="guild_builder" href="#hikari.api.rest.RESTClient.guild_builder" id="hikari.api.rest.RESTClient.guild_builder">guild_builder</a>(
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    /,
) -> <a href='special_endpoints.html#hikari.api.special_endpoints.GuildBuilder'>special_endpoints.GuildBuilder</a>: ...</code></pre>
</dt>
<dd>
<p>Make a guild builder to create a guild with.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The new guilds name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='special_endpoints.html#hikari.api.special_endpoints.GuildBuilder'>GuildBuilder</a></code></dt>
<dd>The guild builder to use. This will allow to create a guild
later with <code><a href='special_endpoints.html#hikari.api.special_endpoints.GuildBuilder.create'>create</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.BadRequestError'>BadRequestError</a></code></dt>
<dd>If any of the fields that are passed have an invalid value.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once
<code><a href='special_endpoints.html#hikari.api.special_endpoints.GuildBuilder.create'>create</a></code> is called.
Invoking this function itself will not raise any of
the above types.</p>
</div>
<h2 id="see-also">See Also</h2>
<p><code>Guild builder: </code>hikari.api.special_endpoints.GuildBuilder``</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2875-L2919" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def guild_builder(self, name: str, /) -&gt; special_endpoints.GuildBuilder:
    &#34;&#34;&#34;Make a guild builder to create a guild with.

    Parameters
    ----------
    name : builtins.str
        The new guilds name.

    Returns
    -------
    hikari.api.special_endpoints.GuildBuilder
        The guild builder to use. This will allow to create a guild
        later with `hikari.api.special_endpoints.GuildBuilder.create`.

    Raises
    ------
    hikari.errors.BadRequestError
        If any of the fields that are passed have an invalid value.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.

    !!! note
        The exceptions on this endpoint will only be raised once
        `hikari.api.special_endpoints.GuildBuilder.create` is called.
        Invoking this function itself will not raise any of
        the above types.

    See Also
    --------
    Guild builder: `hikari.api.special_endpoints.GuildBuilder`
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.kick_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="kick_member" href="#hikari.api.rest.RESTClient.kick_user" id="hikari.api.rest.RESTClient.kick_member">kick_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Kick a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to kick the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to kick. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3849-L3895" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def kick_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Kick a member from a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to kick the member from. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to kick. This may be the object
        or the ID of an existing user.

    Other Parameters
    ----------------
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `KICK_MEMBERS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or user are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.kick_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="kick_user" href="#hikari.api.rest.RESTClient.kick_user" id="hikari.api.rest.RESTClient.kick_user">kick_user</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Kick a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to kick the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to kick. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>KICK_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3849-L3895" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def kick_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Kick a member from a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to kick the member from. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to kick. This may be the object
        or the ID of an existing user.

    Other Parameters
    ----------------
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `KICK_MEMBERS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or user are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.leave_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="leave_guild" href="#hikari.api.rest.RESTClient.leave_guild" id="hikari.api.rest.RESTClient.leave_guild">leave_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Leave a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to leave. This may be the object or
the ID of an existing guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found or you own the guild.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L2307-L2336" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def leave_guild(self, guild: snowflakes.SnowflakeishOr[guilds.PartialGuild], /) -&gt; None:
    &#34;&#34;&#34;Leave a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to leave. This may be the object or
        the ID of an existing guild.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found or you own the guild.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.pin_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="pin_message" href="#hikari.api.rest.RESTClient.pin_message" id="hikari.api.rest.RESTClient.pin_message">pin_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Pin an existing message in the given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to pin a message in. This may be the object or
the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to pin. This may be the object or the ID
of an existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found, or if the message does not exist in
the given channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L658-L697" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def pin_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    &#34;&#34;&#34;Pin an existing message in the given text channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to pin a message in. This may be the object or
        the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to pin. This may be the object or the ID
        of an existing message.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_MESSAGES` in the channel.
    hikari.errors.NotFoundError
        If the channel is not found, or if the message does not exist in
        the given channel.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.remove_role_from_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="remove_role_from_member" href="#hikari.api.rest.RESTClient.remove_role_from_member" id="hikari.api.rest.RESTClient.remove_role_from_member">remove_role_from_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    role: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Remove a role from a member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild where the member is in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to remove the role from. This may be the
object or the ID of an existing user.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]</code></dt>
<dd>The role to remove. This may be the object or the
ID of an existing role.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild, user or role are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3797-L3847" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def remove_role_from_member(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    role: snowflakes.SnowflakeishOr[guilds.PartialRole],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Remove a role from a member.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild where the member is in. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to remove the role from. This may be the
        object or the ID of an existing user.
    role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]
        The role to remove. This may be the object or the
        ID of an existing role.

    Other Parameters
    ----------------
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_ROLES` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild, user or role are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.reposition_channels" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="reposition_channels" href="#hikari.api.rest.RESTClient.reposition_channels" id="hikari.api.rest.RESTClient.reposition_channels">reposition_channels</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    positions: <a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>]],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Reposition the channels in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to reposition the channels in. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]]</code></dt>
<dd>A mapping of of the object or the ID of an existing channel to
the new position, relative to their parent category, if any.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_CHANNEL</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3478-L3516" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def reposition_channels(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    positions: typing.Mapping[int, snowflakes.SnowflakeishOr[channels.GuildChannel]],
) -&gt; None:
    &#34;&#34;&#34;Reposition the channels in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to reposition the channels in. This may be the
        object or the ID of an existing guild.
    positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]
        A mapping of of the object or the ID of an existing channel to
        the new position, relative to their parent category, if any.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_CHANNEL` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.reposition_roles" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="reposition_roles" href="#hikari.api.rest.RESTClient.reposition_roles" id="hikari.api.rest.RESTClient.reposition_roles">reposition_roles</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    positions: <a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>guilds.PartialRole</a>]],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Reposition the roles in a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to reposition the roles in. This may be
the object or the ID of an existing guild.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Mapping'>Mapping</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialRole'>PartialRole</a>]]</code></dt>
<dd>A mapping of the position to the role.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_ROLES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L4208-L4245" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def reposition_roles(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    positions: typing.Mapping[int, snowflakes.SnowflakeishOr[guilds.PartialRole]],
) -&gt; None:
    &#34;&#34;&#34;Reposition the roles in a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to reposition the roles in. This may be
        the object or the ID of an existing guild.
    positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]
        A mapping of the position to the role.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_ROLES` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.trigger_typing" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="trigger_typing" href="#hikari.api.rest.RESTClient.trigger_typing" id="hikari.api.rest.RESTClient.trigger_typing">trigger_typing</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
) -> <a href='special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>special_endpoints.TypingIndicator</a>: ...</code></pre>
</dt>
<dd>
<p>Trigger typing in a text channel.</p>
<p>The result of this call can be awaited to trigger typing once, or
can be used as an async context manager to continually type until the
context manager is left.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-py"># Trigger typing just once.
await rest.trigger_typing(channel)

# Trigger typing repeatedly for 1 minute.
async with rest.trigger_typing(channel):
    await asyncio.sleep(60)
</code></pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Sending a message to the channel will cause the typing indicator
to disappear until it is re-triggered.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to trigger typing in. This may be the object or
the ID of an existing channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='special_endpoints.html#hikari.api.special_endpoints.TypingIndicator'>TypingIndicator</a></code></dt>
<dd>A typing indicator to use.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>SEND_MESSAGES</code> in the channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The exceptions on this endpoint will only be raised once the result
is awaited or iterated over. Invoking this function itself will
not raise any of the above types.</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L554-L616" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def trigger_typing(
    self, channel: snowflakes.SnowflakeishOr[channels.TextChannel]
) -&gt; special_endpoints.TypingIndicator:
    &#34;&#34;&#34;Trigger typing in a text channel.

    The result of this call can be awaited to trigger typing once, or
    can be used as an async context manager to continually type until the
    context manager is left.

    Examples
    --------
    ```py
    # Trigger typing just once.
    await rest.trigger_typing(channel)

    # Trigger typing repeatedly for 1 minute.
    async with rest.trigger_typing(channel):
        await asyncio.sleep(60)
    ```

    !!! warning
        Sending a message to the channel will cause the typing indicator
        to disappear until it is re-triggered.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to trigger typing in. This may be the object or
        the ID of an existing channel.

    Returns
    -------
    hikari.api.special_endpoints.TypingIndicator
        A typing indicator to use.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `SEND_MESSAGES` in the channel.
    hikari.errors.NotFoundError
        If the channel is not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.

    !!! note
        The exceptions on this endpoint will only be raised once the result
        is awaited or iterated over. Invoking this function itself will
        not raise any of the above types.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.unban_member" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="unban_member" href="#hikari.api.rest.RESTClient.unban_user" id="hikari.api.rest.RESTClient.unban_member">unban_member</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Unban a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to unban the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to unban. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3957-L4003" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def unban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Unban a member from a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to unban the member from. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to unban. This may be the object
        or the ID of an existing user.

    Other Parameters
    ----------------
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `BAN_MEMBERS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or user are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.unban_user" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="unban_user" href="#hikari.api.rest.RESTClient.unban_user" id="hikari.api.rest.RESTClient.unban_user">unban_user</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    user: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>users.PartialUser</a>],
    *,
    reason: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Unban a member from a guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild to unban the member from. This may be the
object or the ID of an existing guild.</dd>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.PartialUser'>PartialUser</a>]</code></dt>
<dd>The user to unban. This may be the object
or the ID of an existing user.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the reason that will be recorded in the audit logs.
Maximum of 512 characters.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>BAN_MEMBERS</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the guild or user are not found.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L3957-L4003" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def unban_user(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    user: snowflakes.SnowflakeishOr[users.PartialUser],
    *,
    reason: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    &#34;&#34;&#34;Unban a member from a guild.

    Parameters
    ----------
    guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]
        The guild to unban the member from. This may be the
        object or the ID of an existing guild.
    user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]
        The user to unban. This may be the object
        or the ID of an existing user.

    Other Parameters
    ----------------
    reason : hikari.undefined.UndefinedOr[builtins.str]
        If provided, the reason that will be recorded in the audit logs.
        Maximum of 512 characters.

    Raises
    ------
    hikari.errors.ForbiddenError
        If you are missing the `BAN_MEMBERS` permission.
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.NotFoundError
        If the guild or user are not found.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.rest.RESTClient.unpin_message" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="unpin_message" href="#hikari.api.rest.RESTClient.unpin_message" id="hikari.api.rest.RESTClient.unpin_message">unpin_message</a>(
    channel: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>channels.TextChannel</a>],
    message: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>messages_.PartialMessage</a>],
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Unpin a given message from a given text channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.TextChannel'>TextChannel</a>]</code></dt>
<dd>The channel to unpin a message in. This may be the object or
the ID of an existing channel.</dd>
<dt><strong><code>message</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../messages.html#hikari.messages.PartialMessage'>PartialMessage</a>]</code></dt>
<dd>The message to unpin. This may be the object or the ID of an
existing message.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='../errors.html#hikari.errors.UnauthorizedError'>UnauthorizedError</a></code></dt>
<dd>If you are unauthorized to make the request (invalid/missing token).</dd>
<dt><code><a href='../errors.html#hikari.errors.ForbiddenError'>ForbiddenError</a></code></dt>
<dd>If you are missing the <code>MANAGE_MESSAGES</code> permission.</dd>
<dt><code><a href='../errors.html#hikari.errors.NotFoundError'>NotFoundError</a></code></dt>
<dd>If the channel is not found or the message is not a pinned message
in the given channel.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitTooLongError'>RateLimitTooLongError</a></code></dt>
<dd>Raised in the event that a rate limit occurs that is
longer than <code>max_rate_limit</code> when making a request.</dd>
<dt><code><a href='../errors.html#hikari.errors.RateLimitedError'>RateLimitedError</a></code></dt>
<dd>Usually, Hikari will handle and retry on hitting
rate-limits automatically. This includes most bucket-specific
rate-limits and global rate-limits. In some rare edge cases,
however, Discord implements other undocumented rules for
rate-limiting, such as limits per attribute. These cannot be
detected or handled normally by Hikari due to their undocumented
nature, and will trigger this exception if they occur.</dd>
<dt><code><a href='../errors.html#hikari.errors.InternalServerError'>InternalServerError</a></code></dt>
<dd>If an internal error occurs on Discord while handling the request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/rest.py#L699-L738" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def unpin_message(
    self,
    channel: snowflakes.SnowflakeishOr[channels.TextChannel],
    message: snowflakes.SnowflakeishOr[messages_.PartialMessage],
) -&gt; None:
    &#34;&#34;&#34;Unpin a given message from a given text channel.

    Parameters
    ----------
    channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel]
        The channel to unpin a message in. This may be the object or
        the ID of an existing channel.
    message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]
        The message to unpin. This may be the object or the ID of an
        existing message.

    Raises
    ------
    hikari.errors.UnauthorizedError
        If you are unauthorized to make the request (invalid/missing token).
    hikari.errors.ForbiddenError
        If you are missing the `MANAGE_MESSAGES` permission.
    hikari.errors.NotFoundError
        If the channel is not found or the message is not a pinned message
        in the given channel.
    hikari.errors.RateLimitTooLongError
        Raised in the event that a rate limit occurs that is
        longer than `max_rate_limit` when making a request.
    hikari.errors.RateLimitedError
        Usually, Hikari will handle and retry on hitting
        rate-limits automatically. This includes most bucket-specific
        rate-limits and global rate-limits. In some rare edge cases,
        however, Discord implements other undocumented rules for
        rate-limiting, such as limits per attribute. These cannot be
        detected or handled normally by Hikari due to their undocumented
        nature, and will trigger this exception if they occur.
    hikari.errors.InternalServerError
        If an internal error occurs on Discord while handling the request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</dl>
</section>
</div>
</div>
</div>
<!-- Search script and dependencies -->
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../search.html#' + encodeURIComponent(query);
window.location.href = url;
};
</script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>