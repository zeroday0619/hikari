<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.api.chunker API documentation</title>
<meta name="description" content="Component that provides the ability manage guild chunking." />
<meta property="og:title" content="hikari.api.chunker module documentation" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png" />
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions" />
<meta property="theme-color" content="#ff029a" />
<link rel="shortcut icon" type="image/png" href="https://hikari-py.github.io/hikari/logo.png"/>
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet"/>
<style>
* {
scrollbar-color: #202324 #454a4d;
scroll-behavior: smooth;
}
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
}
small.smaller {
font-size: 0.75em;
}
body {
background-color: #181A1B;
color: #C9C5C0;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<!-- body.mako -->
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="https://hikari-py.github.io/hikari/logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small>v2.0.0.dev92</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/hikari/index.html">Home</a></li>
<li class="nav-item active"><a class="nav-link" href="/hikari/hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" >
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.api -- Interfaces for components that make up Hikari applications …" href="index.html"
>api</a></li>
<li class="breadcrumb-item active"><a href="#">chunker</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Component that provides the ability manage guild chunking.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="GuildChunker -- Component specialization that is used to manage guild chunking." href="#hikari.api.chunker.GuildChunker"
>GuildChunker</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- Close the guild chunker." href="#hikari.api.chunker.GuildChunker.close"
>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="consume_chunk_event -- Listen to chunk events …" href="#hikari.api.chunker.GuildChunker.consume_chunk_event"
>consume_chunk_event</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="fetch_members_for_guild -- Request for a guild chunk …" href="#hikari.api.chunker.GuildChunker.fetch_members_for_guild"
>fetch_members_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="get_request_status -- Return the status of a request …" href="#hikari.api.chunker.GuildChunker.get_request_status"
>get_request_status</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="list_requests_for_guild -- List the statuses of requests made for a specific guild …" href="#hikari.api.chunker.GuildChunker.list_requests_for_guild"
>list_requests_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="list_requests_for_shard -- List the statuses of requests made for a specific shard …" href="#hikari.api.chunker.GuildChunker.list_requests_for_shard"
>list_requests_for_shard</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="request_guild_members -- Request for a guild chunk …" href="#hikari.api.chunker.GuildChunker.request_guild_members"
>request_guild_members</a>
</li>
<br />
</ul>
</li>
<li class="monospaced">
<small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="RequestInformation -- Information about a member request that's being tracked …" href="#hikari.api.chunker.RequestInformation"
>RequestInformation</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="average_chunk_size -- Average amount of members that are being received per chunk …" href="#hikari.api.chunker.RequestInformation.average_chunk_size"
>average_chunk_size</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="chunk_count -- Amount of chunks that are expected for this request …" href="#hikari.api.chunker.RequestInformation.chunk_count"
>chunk_count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="guild_id -- Snowflake ID of the guild this chunk request is for …" href="#hikari.api.chunker.RequestInformation.guild_id"
>guild_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_complete -- Whether this chunk request is finished or not …" href="#hikari.api.chunker.RequestInformation.is_complete"
>is_complete</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="last_received -- Datetime of when we last received a chunk for this event …" href="#hikari.api.chunker.RequestInformation.last_received"
>last_received</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="missing_chunk_indexes -- Sequence of the indexes of chunks we haven't received yet …" href="#hikari.api.chunker.RequestInformation.missing_chunk_indexes"
>missing_chunk_indexes</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="nonce -- Automatically generated unique identifier of the this chunk's event …" href="#hikari.api.chunker.RequestInformation.nonce"
>nonce</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="not_found_ids -- Sequence of the snowflakes that were requested but not found …" href="#hikari.api.chunker.RequestInformation.not_found_ids"
>not_found_ids</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="received_chunks -- Count of how many chunks have been received so far …" href="#hikari.api.chunker.RequestInformation.received_chunks"
>received_chunks</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L0-L343" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Component that provides the ability manage guild chunking.&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.List[str] = [&#34;GuildChunker&#34;, &#34;RequestInformation&#34;]

import abc
import typing

from hikari import undefined

if typing.TYPE_CHECKING:
    import datetime

    from hikari import event_stream
    from hikari import guilds
    from hikari import snowflakes
    from hikari import users as users_
    from hikari.api import shard as gateway_shard
    from hikari.events import shard_events


class RequestInformation(typing.Protocol):
    &#34;&#34;&#34;Information about a member request that&#39;s being tracked.

    This protocol defines the fields that should be exported by a `GuildChunker`
    implementation when getting the tracked information about a request.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @property
    def average_chunk_size(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;Average amount of members that are being received per chunk.

        Returns
        -------
        typing.Optional[builtins.int]
            The `builtins.int` average size of each chunk for this request
            or `builtins.None` if we haven&#39;t received a response to pull
            information from yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def chunk_count(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;Amount of chunks that are expected for this request.

        Returns
        -------
        typing.Optional[builtins.int]
            The `builtins.int` count of how many chunk events should be received
            for this request or `builtins.None` if we haven&#39;t received a
            response to pull information from yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def guild_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;Snowflake ID of the guild this chunk request is for.

        Returns
        -------
        hikari.snowflakes.Snowflake
            The ID of the guild this request is for.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def is_complete(self) -&gt; bool:
        &#34;&#34;&#34;Whether this chunk request is finished or not.

        A chunk request may be considered finished after all chunks have been
        received or after it&#39;s timed out.

        Returns
        -------
        builtins.bool
            Whether this chunk request is considered to be finished or not yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def last_received(self) -&gt; typing.Optional[datetime.datetime]:
        &#34;&#34;&#34;Datetime of when we last received a chunk for this event.

        Returns
        -------
        typing.Optional[datetime.datetime]
            A datetime object of when we last received a chunk event for this
            request or `builtins.None` if we haven&#39;t received any chunk events
            in response to this request yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def missing_chunk_indexes(self) -&gt; typing.Optional[typing.Sequence[int]]:
        &#34;&#34;&#34;Sequence of the indexes of chunks we haven&#39;t received yet.

        Returns
        -------
        typing.Optional[typing.Sequence[builtins.int]]
            A sequence of `builtins.int` indexes of the chunk events we haven&#39;t
            received for this request or `builtins.None` if we haven&#39;t received
            a response to pull information from yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def nonce(self) -&gt; str:
        &#34;&#34;&#34;Automatically generated unique identifier of the this chunk&#39;s event.

        Returns
        -------
        builtins.str
            The unique nonce that was generated for this request.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def not_found_ids(self) -&gt; typing.Sequence[snowflakes.Snowflake]:
        &#34;&#34;&#34;Sequence of the snowflakes that were requested but not found.

        !!! note
            If no IDs were requested then this will be empty.

        typing.Sequence[hikari.snowflakes.Snowflake]
            A sequence of the snowflake IDs that were explicitly requested but
            weren&#39;t found.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def received_chunks(self) -&gt; int:
        &#34;&#34;&#34;Count of how many chunks have been received so far.

        Returns
        -------
        builtins.int
            The `builtins.int` count of how many chunks events we&#39;ve received in
            response to this request so far.
        &#34;&#34;&#34;
        raise NotImplementedError


class GuildChunker(abc.ABC):
    &#34;&#34;&#34;Component specialization that is used to manage guild chunking.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    def fetch_members_for_guild(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.GatewayGuild],
        *,
        timeout: typing.Union[int, float, None],
        limit: typing.Optional[int] = None,
        include_presences: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        query_limit: int = 0,
        query: str = &#34;&#34;,
        users: undefined.UndefinedOr[typing.Sequence[snowflakes.SnowflakeishOr[users_.User]]] = undefined.UNDEFINED,
    ) -&gt; event_stream.Streamer[shard_events.MemberChunkEvent]:
        &#34;&#34;&#34;Request for a guild chunk.

        Parameters
        ----------
        guild : hikari.guilds.Guild
            The guild to request chunk for.

        Other Parameters
        ----------------
        timeout : typing.Union[builtins.int, builtins.float, builtins.None]
            The maximum amount of time the returned stream should spend waiting
            for the next chunk event to be received before ending the iteration.
            If `builtins.None` then this will never timeout between events.
        limit : typing.Optional[builtins.int]
            The limit for how many events the streamer should queue before
            dropping extra received events. Leave as `builtins.None` for this to
            be unlimited.
        include_presences : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to request presences.
        query : builtins.str
            If not `&#34;&#34;`, request the members which username starts with the string.
        query_limit : builtins.int
            Maximum number of members to send matching the query.
        users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User]]]
            If provided, the users to request for.

        !!! note
            To request the full list of members, set `query` to `&#34;&#34;` (empty
            string) and `limit` to `0`.

        !!! note
            The chunk request will not be sent off until the returned stream is
            opened.

        !!! warning
            Validation errors like `builtins.ValueError` and
            `hikari.errors.MissingIntentError` will be delayed until you open
            the returned stream.

        Returns
        -------
        hikari.event_stream.Streamer[hikari.events.shard_events.MemberChunkEvent]
            A stream of chunk events for the generated request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def get_request_status(self, nonce: str, /) -&gt; typing.Optional[RequestInformation]:
        &#34;&#34;&#34;Return the status of a request.

        Parameters
        ----------
        nonce : str
            The unique identifier for the tracked request to get.

        Returns
        -------
        typing.Optional[RequestInformation]
            Information about the request if found, else `builtins.None`.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def list_requests_for_shard(
        self, shard: typing.Union[gateway_shard.GatewayShard, int], /
    ) -&gt; typing.Sequence[RequestInformation]:
        &#34;&#34;&#34;List the statuses of requests made for a specific shard.

        Parameters
        ----------
        shard : typing.Union[hikari.api.shard.GatewayShard, builtins.int]
            The object or ID of the shard to get the tracked requests for.

        Returns
        -------
        typing.Sequence[RequestInformation]
            A sequence of data objects of information about the tracked requests
            for the given shard.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def list_requests_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.GatewayGuild], /
    ) -&gt; typing.Sequence[RequestInformation]:
        &#34;&#34;&#34;List the statuses of requests made for a specific guild.

        Parameters
        ----------
        guild: hikari.snowflakes.SnowflakeishOr[hikari.guilds.GatewayGuild]
            The object or ID of the guild to get the tracked requests for.

        Returns
        -------
        typing.Sequence[RequestInformation]
            A sequence of data objects of information about the tracked requests
            for the given guild.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def consume_chunk_event(self, event: shard_events.MemberChunkEvent, /) -&gt; None:
        &#34;&#34;&#34;Listen to chunk events.

        Parameters
        ----------
        event : hikari.events.shard_events.MemberChunkEvent
            The object of the chunk event that&#39;s being consumed.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def request_guild_members(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.GatewayGuild],
        /,
        include_presences: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        limit: int = 0,
        query: str = &#34;&#34;,
        users: undefined.UndefinedOr[typing.Sequence[snowflakes.SnowflakeishOr[users_.User]]] = undefined.UNDEFINED,
    ) -&gt; str:
        &#34;&#34;&#34;Request for a guild chunk.

        !!! note
            For the chunker to track a request the request may need to be made
            using this method rather than using
            `hikari.api.shard.GatewayShard.request_guild_members`.

        Parameters
        ----------
        guild : hikari.guilds.Guild
            The guild to request chunk for.

        Other Parameters
        ----------------
        include_presences : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to request presences.
        query : builtins.str
            If not `&#34;&#34;`, request the members which username starts with the string.
        limit : builtins.int
            Maximum number of members to send matching the query.
        users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User]]]
            If provided, the users to request for.

        !!! note
            To request the full list of members, set `query` to `&#34;&#34;` (empty
            string) and `limit` to `0`.

        Returns
        -------
        builtins.str
            The generated unique nonce used for tracking this request.

        Raises
        ------
        ValueError
            When trying to specify `users` with `query`/`limit`, if `limit` is not between
            0 and 100, both inclusive or if `users` length is over 100.
        hikari.errors.MissingIntentError
            When trying to request presences without the `GUILD_MEMBERS` or when trying to
            request the full list of members without `GUILD_PRESENCES`.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the guild chunker.&#34;&#34;&#34;</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="GuildChunker -- Component specialization that is used to manage guild chunking." href="#hikari.api.chunker.GuildChunker"
>GuildChunker</a></h4>
</dt>
<dd>
<pre><code id="hikari.api.chunker.GuildChunker" class="hljs python"><abbr title='A standard Python type.'>class</abbr> GuildChunker: ...</code></pre>
<p>Component specialization that is used to manage guild chunking.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L167-L344" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class GuildChunker(abc.ABC):
    &#34;&#34;&#34;Component specialization that is used to manage guild chunking.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @abc.abstractmethod
    def fetch_members_for_guild(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.GatewayGuild],
        *,
        timeout: typing.Union[int, float, None],
        limit: typing.Optional[int] = None,
        include_presences: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        query_limit: int = 0,
        query: str = &#34;&#34;,
        users: undefined.UndefinedOr[typing.Sequence[snowflakes.SnowflakeishOr[users_.User]]] = undefined.UNDEFINED,
    ) -&gt; event_stream.Streamer[shard_events.MemberChunkEvent]:
        &#34;&#34;&#34;Request for a guild chunk.

        Parameters
        ----------
        guild : hikari.guilds.Guild
            The guild to request chunk for.

        Other Parameters
        ----------------
        timeout : typing.Union[builtins.int, builtins.float, builtins.None]
            The maximum amount of time the returned stream should spend waiting
            for the next chunk event to be received before ending the iteration.
            If `builtins.None` then this will never timeout between events.
        limit : typing.Optional[builtins.int]
            The limit for how many events the streamer should queue before
            dropping extra received events. Leave as `builtins.None` for this to
            be unlimited.
        include_presences : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to request presences.
        query : builtins.str
            If not `&#34;&#34;`, request the members which username starts with the string.
        query_limit : builtins.int
            Maximum number of members to send matching the query.
        users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User]]]
            If provided, the users to request for.

        !!! note
            To request the full list of members, set `query` to `&#34;&#34;` (empty
            string) and `limit` to `0`.

        !!! note
            The chunk request will not be sent off until the returned stream is
            opened.

        !!! warning
            Validation errors like `builtins.ValueError` and
            `hikari.errors.MissingIntentError` will be delayed until you open
            the returned stream.

        Returns
        -------
        hikari.event_stream.Streamer[hikari.events.shard_events.MemberChunkEvent]
            A stream of chunk events for the generated request.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def get_request_status(self, nonce: str, /) -&gt; typing.Optional[RequestInformation]:
        &#34;&#34;&#34;Return the status of a request.

        Parameters
        ----------
        nonce : str
            The unique identifier for the tracked request to get.

        Returns
        -------
        typing.Optional[RequestInformation]
            Information about the request if found, else `builtins.None`.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def list_requests_for_shard(
        self, shard: typing.Union[gateway_shard.GatewayShard, int], /
    ) -&gt; typing.Sequence[RequestInformation]:
        &#34;&#34;&#34;List the statuses of requests made for a specific shard.

        Parameters
        ----------
        shard : typing.Union[hikari.api.shard.GatewayShard, builtins.int]
            The object or ID of the shard to get the tracked requests for.

        Returns
        -------
        typing.Sequence[RequestInformation]
            A sequence of data objects of information about the tracked requests
            for the given shard.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def list_requests_for_guild(
        self, guild: snowflakes.SnowflakeishOr[guilds.GatewayGuild], /
    ) -&gt; typing.Sequence[RequestInformation]:
        &#34;&#34;&#34;List the statuses of requests made for a specific guild.

        Parameters
        ----------
        guild: hikari.snowflakes.SnowflakeishOr[hikari.guilds.GatewayGuild]
            The object or ID of the guild to get the tracked requests for.

        Returns
        -------
        typing.Sequence[RequestInformation]
            A sequence of data objects of information about the tracked requests
            for the given guild.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def consume_chunk_event(self, event: shard_events.MemberChunkEvent, /) -&gt; None:
        &#34;&#34;&#34;Listen to chunk events.

        Parameters
        ----------
        event : hikari.events.shard_events.MemberChunkEvent
            The object of the chunk event that&#39;s being consumed.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def request_guild_members(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.GatewayGuild],
        /,
        include_presences: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        limit: int = 0,
        query: str = &#34;&#34;,
        users: undefined.UndefinedOr[typing.Sequence[snowflakes.SnowflakeishOr[users_.User]]] = undefined.UNDEFINED,
    ) -&gt; str:
        &#34;&#34;&#34;Request for a guild chunk.

        !!! note
            For the chunker to track a request the request may need to be made
            using this method rather than using
            `hikari.api.shard.GatewayShard.request_guild_members`.

        Parameters
        ----------
        guild : hikari.guilds.Guild
            The guild to request chunk for.

        Other Parameters
        ----------------
        include_presences : hikari.undefined.UndefinedOr[builtins.bool]
            If provided, whether to request presences.
        query : builtins.str
            If not `&#34;&#34;`, request the members which username starts with the string.
        limit : builtins.int
            Maximum number of members to send matching the query.
        users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User]]]
            If provided, the users to request for.

        !!! note
            To request the full list of members, set `query` to `&#34;&#34;` (empty
            string) and `limit` to `0`.

        Returns
        -------
        builtins.str
            The generated unique nonce used for tracking this request.

        Raises
        ------
        ValueError
            When trying to specify `users` with `query`/`limit`, if `limit` is not between
            0 and 100, both inclusive or if `users` length is over 100.
        hikari.errors.MissingIntentError
            When trying to request presences without the `GUILD_MEMBERS` or when trying to
            request the full list of members without `GUILD_PRESENCES`.
        &#34;&#34;&#34;

    @abc.abstractmethod
    async def close(self) -&gt; None:
        &#34;&#34;&#34;Close the guild chunker.&#34;&#34;&#34;</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="StatefulGuildChunkerImpl -- Guild chunker implementation …" href="../impl/stateful_guild_chunker.html#hikari.impl.stateful_guild_chunker.StatefulGuildChunkerImpl"
>StatefulGuildChunkerImpl</a></dt>
<dd class="nested"><p>Guild chunker implementation …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="StatelessGuildChunkerImpl -- Stateless guild chunker …" href="../impl/stateless_guild_chunker.html#hikari.impl.stateless_guild_chunker.StatelessGuildChunkerImpl"
>StatelessGuildChunkerImpl</a></dt>
<dd class="nested"><p>Stateless guild chunker …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="GuildChunker -- Component specialization that is used to manage guild chunking." href="#hikari.api.chunker.GuildChunker"
>GuildChunker</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.api.chunker.GuildChunker.close" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="close" href="#hikari.api.chunker.GuildChunker.close" id="hikari.api.chunker.GuildChunker.close">close</a>() -> None: ...</code></pre>
</dt>
<dd>
<p>Close the guild chunker.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L342-L344" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def close(self) -&gt; None:
    &#34;&#34;&#34;Close the guild chunker.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.chunker.GuildChunker.consume_chunk_event" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="consume_chunk_event" href="#hikari.api.chunker.GuildChunker.consume_chunk_event" id="hikari.api.chunker.GuildChunker.consume_chunk_event">consume_chunk_event</a>(
    event: <a href='../events/shard_events.html#hikari.events.shard_events.MemberChunkEvent'>shard_events.MemberChunkEvent</a>,
    /,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p>Listen to chunk events.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code><a href='../events/shard_events.html#hikari.events.shard_events.MemberChunkEvent'>MemberChunkEvent</a></code></dt>
<dd>The object of the chunk event that's being consumed.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L280-L288" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def consume_chunk_event(self, event: shard_events.MemberChunkEvent, /) -&gt; None:
    &#34;&#34;&#34;Listen to chunk events.

    Parameters
    ----------
    event : hikari.events.shard_events.MemberChunkEvent
        The object of the chunk event that&#39;s being consumed.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.chunker.GuildChunker.fetch_members_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="fetch_members_for_guild" href="#hikari.api.chunker.GuildChunker.fetch_members_for_guild" id="hikari.api.chunker.GuildChunker.fetch_members_for_guild">fetch_members_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>],
    *,
    timeout: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, <a href='https://docs.python.org/3/library/functions.html#float'>float</a>, <a href='https://docs.python.org/3/library/constants.html#None'>None</a>],
    limit: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>] = None,
    include_presences: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    query_limit: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 0,
    query: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a> = '',
    users: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.User'>users_.User</a>]]] = UNDEFINED,
) -> <a href='../event_stream.html#hikari.event_stream.Streamer'>event_stream.Streamer</a>[<a href='../events/shard_events.html#hikari.events.shard_events.MemberChunkEvent'>shard_events.MemberChunkEvent</a>]: ...</code></pre>
</dt>
<dd>
<p>Request for a guild chunk.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Guild'>Guild</a></code></dt>
<dd>The guild to request chunk for.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>typing.Union[builtins.int, builtins.float, builtins.None]</code></dt>
<dd>The maximum amount of time the returned stream should spend waiting
for the next chunk event to be received before ending the iteration.
If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> then this will never timeout between events.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>The limit for how many events the streamer should queue before
dropping extra received events. Leave as <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> for this to
be unlimited.</dd>
<dt><strong><code>include_presences</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to request presences.</dd>
<dt><strong><code>query</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>If not <code>""</code>, request the members which username starts with the string.</dd>
<dt><strong><code>query_limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Maximum number of members to send matching the query.</dd>
<dt><strong><code>users</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.User'>User</a>]]]</code></dt>
<dd>If provided, the users to request for.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>To request the full list of members, set <code>query</code> to <code>""</code> (empty
string) and <code>limit</code> to <code>0</code>.</p>
</div>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>The chunk request will not be sent off until the returned stream is
opened.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Validation errors like <code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code> and
<code><a href='../errors.html#hikari.errors.MissingIntentError'>MissingIntentError</a></code> will be delayed until you open
the returned stream.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../event_stream.html#hikari.event_stream.Streamer'>Streamer</a>[<a href='../events/shard_events.html#hikari.events.shard_events.MemberChunkEvent'>MemberChunkEvent</a>]</code></dt>
<dd>A stream of chunk events for the generated request.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L172-L227" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
def fetch_members_for_guild(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.GatewayGuild],
    *,
    timeout: typing.Union[int, float, None],
    limit: typing.Optional[int] = None,
    include_presences: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    query_limit: int = 0,
    query: str = &#34;&#34;,
    users: undefined.UndefinedOr[typing.Sequence[snowflakes.SnowflakeishOr[users_.User]]] = undefined.UNDEFINED,
) -&gt; event_stream.Streamer[shard_events.MemberChunkEvent]:
    &#34;&#34;&#34;Request for a guild chunk.

    Parameters
    ----------
    guild : hikari.guilds.Guild
        The guild to request chunk for.

    Other Parameters
    ----------------
    timeout : typing.Union[builtins.int, builtins.float, builtins.None]
        The maximum amount of time the returned stream should spend waiting
        for the next chunk event to be received before ending the iteration.
        If `builtins.None` then this will never timeout between events.
    limit : typing.Optional[builtins.int]
        The limit for how many events the streamer should queue before
        dropping extra received events. Leave as `builtins.None` for this to
        be unlimited.
    include_presences : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether to request presences.
    query : builtins.str
        If not `&#34;&#34;`, request the members which username starts with the string.
    query_limit : builtins.int
        Maximum number of members to send matching the query.
    users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User]]]
        If provided, the users to request for.

    !!! note
        To request the full list of members, set `query` to `&#34;&#34;` (empty
        string) and `limit` to `0`.

    !!! note
        The chunk request will not be sent off until the returned stream is
        opened.

    !!! warning
        Validation errors like `builtins.ValueError` and
        `hikari.errors.MissingIntentError` will be delayed until you open
        the returned stream.

    Returns
    -------
    hikari.event_stream.Streamer[hikari.events.shard_events.MemberChunkEvent]
        A stream of chunk events for the generated request.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.chunker.GuildChunker.get_request_status" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="get_request_status" href="#hikari.api.chunker.GuildChunker.get_request_status" id="hikari.api.chunker.GuildChunker.get_request_status">get_request_status</a>(
    nonce: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    /,
) -> Union[<a href='#hikari.api.chunker.RequestInformation'>RequestInformation</a>, None]: ...</code></pre>
</dt>
<dd>
<p>Return the status of a request.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nonce</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The unique identifier for the tracked request to get.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='#hikari.api.chunker.RequestInformation'>RequestInformation</a>]</code></dt>
<dd>Information about the request if found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L229-L242" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def get_request_status(self, nonce: str, /) -&gt; typing.Optional[RequestInformation]:
    &#34;&#34;&#34;Return the status of a request.

    Parameters
    ----------
    nonce : str
        The unique identifier for the tracked request to get.

    Returns
    -------
    typing.Optional[RequestInformation]
        Information about the request if found, else `builtins.None`.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.chunker.GuildChunker.list_requests_for_guild" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="list_requests_for_guild" href="#hikari.api.chunker.GuildChunker.list_requests_for_guild" id="hikari.api.chunker.GuildChunker.list_requests_for_guild">list_requests_for_guild</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.api.chunker.RequestInformation'>RequestInformation</a>]: ...</code></pre>
</dt>
<dd>
<p>List the statuses of requests made for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object or ID of the guild to get the tracked requests for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.api.chunker.RequestInformation'>RequestInformation</a>]</code></dt>
<dd>A sequence of data objects of information about the tracked requests
for the given guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L262-L278" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def list_requests_for_guild(
    self, guild: snowflakes.SnowflakeishOr[guilds.GatewayGuild], /
) -&gt; typing.Sequence[RequestInformation]:
    &#34;&#34;&#34;List the statuses of requests made for a specific guild.

    Parameters
    ----------
    guild: hikari.snowflakes.SnowflakeishOr[hikari.guilds.GatewayGuild]
        The object or ID of the guild to get the tracked requests for.

    Returns
    -------
    typing.Sequence[RequestInformation]
        A sequence of data objects of information about the tracked requests
        for the given guild.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.chunker.GuildChunker.list_requests_for_shard" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="list_requests_for_shard" href="#hikari.api.chunker.GuildChunker.list_requests_for_shard" id="hikari.api.chunker.GuildChunker.list_requests_for_shard">list_requests_for_shard</a>(
    shard: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='shard.html#hikari.api.shard.GatewayShard'>gateway_shard.GatewayShard</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>],
    /,
) -> <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.api.chunker.RequestInformation'>RequestInformation</a>]: ...</code></pre>
</dt>
<dd>
<p>List the statuses of requests made for a specific shard.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shard</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[<a href='shard.html#hikari.api.shard.GatewayShard'>GatewayShard</a>, <a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>The object or ID of the shard to get the tracked requests for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='#hikari.api.chunker.RequestInformation'>RequestInformation</a>]</code></dt>
<dd>A sequence of data objects of information about the tracked requests
for the given shard.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L244-L260" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def list_requests_for_shard(
    self, shard: typing.Union[gateway_shard.GatewayShard, int], /
) -&gt; typing.Sequence[RequestInformation]:
    &#34;&#34;&#34;List the statuses of requests made for a specific shard.

    Parameters
    ----------
    shard : typing.Union[hikari.api.shard.GatewayShard, builtins.int]
        The object or ID of the shard to get the tracked requests for.

    Returns
    -------
    typing.Sequence[RequestInformation]
        A sequence of data objects of information about the tracked requests
        for the given shard.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.api.chunker.GuildChunker.request_guild_members" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="request_guild_members" href="#hikari.api.chunker.GuildChunker.request_guild_members" id="hikari.api.chunker.GuildChunker.request_guild_members">request_guild_members</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>],
    /,
    include_presences: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    limit: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 0,
    query: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a> = '',
    users: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.User'>users_.User</a>]]] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>: ...</code></pre>
</dt>
<dd>
<p>Request for a guild chunk.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>For the chunker to track a request the request may need to be made
using this method rather than using
<code><a href='shard.html#hikari.api.shard.GatewayShard.request_guild_members'>request_guild_members</a></code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Guild'>Guild</a></code></dt>
<dd>The guild to request chunk for.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>include_presences</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to request presences.</dd>
<dt><strong><code>query</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>If not <code>""</code>, request the members which username starts with the string.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Maximum number of members to send matching the query.</dd>
<dt><strong><code>users</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.User'>User</a>]]]</code></dt>
<dd>If provided, the users to request for.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>To request the full list of members, set <code>query</code> to <code>""</code> (empty
string) and <code>limit</code> to <code>0</code>.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The generated unique nonce used for tracking this request.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>When trying to specify <code>users</code> with <code>query</code>/<code>limit</code>, if <code>limit</code> is not between
0 and 100, both inclusive or if <code>users</code> length is over 100.</dd>
<dt><code><a href='../errors.html#hikari.errors.MissingIntentError'>MissingIntentError</a></code></dt>
<dd>When trying to request presences without the <code>GUILD_MEMBERS</code> or when trying to
request the full list of members without <code>GUILD_PRESENCES</code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L290-L340" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">@abc.abstractmethod
async def request_guild_members(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.GatewayGuild],
    /,
    include_presences: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    limit: int = 0,
    query: str = &#34;&#34;,
    users: undefined.UndefinedOr[typing.Sequence[snowflakes.SnowflakeishOr[users_.User]]] = undefined.UNDEFINED,
) -&gt; str:
    &#34;&#34;&#34;Request for a guild chunk.

    !!! note
        For the chunker to track a request the request may need to be made
        using this method rather than using
        `hikari.api.shard.GatewayShard.request_guild_members`.

    Parameters
    ----------
    guild : hikari.guilds.Guild
        The guild to request chunk for.

    Other Parameters
    ----------------
    include_presences : hikari.undefined.UndefinedOr[builtins.bool]
        If provided, whether to request presences.
    query : builtins.str
        If not `&#34;&#34;`, request the members which username starts with the string.
    limit : builtins.int
        Maximum number of members to send matching the query.
    users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User]]]
        If provided, the users to request for.

    !!! note
        To request the full list of members, set `query` to `&#34;&#34;` (empty
        string) and `limit` to `0`.

    Returns
    -------
    builtins.str
        The generated unique nonce used for tracking this request.

    Raises
    ------
    ValueError
        When trying to specify `users` with `query`/`limit`, if `limit` is not between
        0 and 100, both inclusive or if `users` length is over 100.
    hikari.errors.MissingIntentError
        When trying to request presences without the `GUILD_MEMBERS` or when trying to
        request the full list of members without `GUILD_PRESENCES`.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
<dt>
<h4><small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="RequestInformation -- Information about a member request that's being tracked …" href="#hikari.api.chunker.RequestInformation"
>RequestInformation</a></h4>
</dt>
<dd>
<pre><code id="hikari.api.chunker.RequestInformation" class="hljs python"><abbr title='A standard Python type.'>class</abbr> RequestInformation: ...</code></pre>
<p>Information about a member request that's being tracked.</p>
<p>This protocol defines the fields that should be exported by a <code><a href='#hikari.api.chunker.GuildChunker'>GuildChunker</a></code>
implementation when getting the tracked information about a request.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/api/chunker.py#L44-L164" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class RequestInformation(typing.Protocol):
    &#34;&#34;&#34;Information about a member request that&#39;s being tracked.

    This protocol defines the fields that should be exported by a `GuildChunker`
    implementation when getting the tracked information about a request.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    @property
    def average_chunk_size(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;Average amount of members that are being received per chunk.

        Returns
        -------
        typing.Optional[builtins.int]
            The `builtins.int` average size of each chunk for this request
            or `builtins.None` if we haven&#39;t received a response to pull
            information from yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def chunk_count(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;Amount of chunks that are expected for this request.

        Returns
        -------
        typing.Optional[builtins.int]
            The `builtins.int` count of how many chunk events should be received
            for this request or `builtins.None` if we haven&#39;t received a
            response to pull information from yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def guild_id(self) -&gt; snowflakes.Snowflake:
        &#34;&#34;&#34;Snowflake ID of the guild this chunk request is for.

        Returns
        -------
        hikari.snowflakes.Snowflake
            The ID of the guild this request is for.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def is_complete(self) -&gt; bool:
        &#34;&#34;&#34;Whether this chunk request is finished or not.

        A chunk request may be considered finished after all chunks have been
        received or after it&#39;s timed out.

        Returns
        -------
        builtins.bool
            Whether this chunk request is considered to be finished or not yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def last_received(self) -&gt; typing.Optional[datetime.datetime]:
        &#34;&#34;&#34;Datetime of when we last received a chunk for this event.

        Returns
        -------
        typing.Optional[datetime.datetime]
            A datetime object of when we last received a chunk event for this
            request or `builtins.None` if we haven&#39;t received any chunk events
            in response to this request yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def missing_chunk_indexes(self) -&gt; typing.Optional[typing.Sequence[int]]:
        &#34;&#34;&#34;Sequence of the indexes of chunks we haven&#39;t received yet.

        Returns
        -------
        typing.Optional[typing.Sequence[builtins.int]]
            A sequence of `builtins.int` indexes of the chunk events we haven&#39;t
            received for this request or `builtins.None` if we haven&#39;t received
            a response to pull information from yet.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def nonce(self) -&gt; str:
        &#34;&#34;&#34;Automatically generated unique identifier of the this chunk&#39;s event.

        Returns
        -------
        builtins.str
            The unique nonce that was generated for this request.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def not_found_ids(self) -&gt; typing.Sequence[snowflakes.Snowflake]:
        &#34;&#34;&#34;Sequence of the snowflakes that were requested but not found.

        !!! note
            If no IDs were requested then this will be empty.

        typing.Sequence[hikari.snowflakes.Snowflake]
            A sequence of the snowflake IDs that were explicitly requested but
            weren&#39;t found.
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def received_chunks(self) -&gt; int:
        &#34;&#34;&#34;Count of how many chunks have been received so far.

        Returns
        -------
        builtins.int
            The `builtins.int` count of how many chunks events we&#39;ve received in
            response to this request so far.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A structural supertype (similar to an ABC, but with implicit inheritance)'>trait</abbr></em></small> <a title="RequestInformation -- Information about a member request that's being tracked …" href="#hikari.api.chunker.RequestInformation"
>RequestInformation</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Protocol -- Base class for protocol classes …" href="https://docs.python.org/3/library/typing.html#typing.Protocol"
>Protocol</a></dt>
<dd class="nested"><p>Base class for protocol classes …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="average_chunk_size -- Average amount of members that are being received per chunk …" href="#hikari.api.chunker.RequestInformation.average_chunk_size" id="hikari.api.chunker.RequestInformation.average_chunk_size" >average_chunk_size</a> : Union[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, None]</code></pre>
</dt>
<dd><p>Average amount of members that are being received per chunk.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>The <code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code> average size of each chunk for this request
or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if we haven't received a response to pull
information from yet.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="chunk_count -- Amount of chunks that are expected for this request …" href="#hikari.api.chunker.RequestInformation.chunk_count" id="hikari.api.chunker.RequestInformation.chunk_count" >chunk_count</a> : Union[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>, None]</code></pre>
</dt>
<dd><p>Amount of chunks that are expected for this request.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]</code></dt>
<dd>The <code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code> count of how many chunk events should be received
for this request or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if we haven't received a
response to pull information from yet.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="guild_id -- Snowflake ID of the guild this chunk request is for …" href="#hikari.api.chunker.RequestInformation.guild_id" id="hikari.api.chunker.RequestInformation.guild_id" >guild_id</a> : <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a></code></pre>
</dt>
<dd><p>Snowflake ID of the guild this chunk request is for.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild this request is for.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_complete -- Whether this chunk request is finished or not …" href="#hikari.api.chunker.RequestInformation.is_complete" id="hikari.api.chunker.RequestInformation.is_complete" >is_complete</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd><p>Whether this chunk request is finished or not.</p>
<p>A chunk request may be considered finished after all chunks have been
received or after it's timed out.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Whether this chunk request is considered to be finished or not yet.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="last_received -- Datetime of when we last received a chunk for this event …" href="#hikari.api.chunker.RequestInformation.last_received" id="hikari.api.chunker.RequestInformation.last_received" >last_received</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>]</code></pre>
</dt>
<dd><p>Datetime of when we last received a chunk for this event.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>]</code></dt>
<dd>A datetime object of when we last received a chunk event for this
request or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if we haven't received any chunk events
in response to this request yet.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="missing_chunk_indexes -- Sequence of the indexes of chunks we haven't received yet …" href="#hikari.api.chunker.RequestInformation.missing_chunk_indexes" id="hikari.api.chunker.RequestInformation.missing_chunk_indexes" >missing_chunk_indexes</a> : Union[Sequence[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>], None]</code></pre>
</dt>
<dd><p>Sequence of the indexes of chunks we haven't received yet.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='https://docs.python.org/3/library/functions.html#int'>int</a>]]</code></dt>
<dd>A sequence of <code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code> indexes of the chunk events we haven't
received for this request or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if we haven't received
a response to pull information from yet.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="nonce -- Automatically generated unique identifier of the this chunk's event …" href="#hikari.api.chunker.RequestInformation.nonce" id="hikari.api.chunker.RequestInformation.nonce" >nonce</a> : <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></pre>
</dt>
<dd><p>Automatically generated unique identifier of the this chunk's event.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The unique nonce that was generated for this request.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="not_found_ids -- Sequence of the snowflakes that were requested but not found …" href="#hikari.api.chunker.RequestInformation.not_found_ids" id="hikari.api.chunker.RequestInformation.not_found_ids" >not_found_ids</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>]</code></pre>
</dt>
<dd><p>Sequence of the snowflakes that were requested but not found.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>If no IDs were requested then this will be empty.</p>
</div>
<p>typing.Sequence[hikari.snowflakes.Snowflake]
A sequence of the snowflake IDs that were explicitly requested but
weren't found.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="received_chunks -- Count of how many chunks have been received so far …" href="#hikari.api.chunker.RequestInformation.received_chunks" id="hikari.api.chunker.RequestInformation.received_chunks" >received_chunks</a> : <a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></pre>
</dt>
<dd><p>Count of how many chunks have been received so far.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The <code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code> count of how many chunks events we've received in
response to this request so far.</dd>
</dl></dd>
</dl>
<div class="sep"></div>
</dd>
</dl>
</section>
</div>
</div>
</div>
<!-- Search script and dependencies -->
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../search.html#' + encodeURIComponent(query);
window.location.href = url;
};
</script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>