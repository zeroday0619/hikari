<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.internal.data_binding API documentation</title>
<meta name="description" content="Data binding utilities." />
<meta property="og:title" content="hikari.internal.data_binding module documentation" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png" />
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions" />
<meta property="theme-color" content="#ff029a" />
<link rel="shortcut icon" type="image/png" href="https://hikari-py.github.io/hikari/logo.png"/>
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet"/>
<style>
* {
scrollbar-color: #202324 #454a4d;
scroll-behavior: smooth;
}
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
}
small.smaller {
font-size: 0.75em;
}
body {
background-color: #181A1B;
color: #C9C5C0;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<!-- body.mako -->
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="https://hikari-py.github.io/hikari/logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small>v2.0.0.dev92</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/hikari/index.html">Home</a></li>
<li class="nav-item active"><a class="nav-link" href="/hikari/hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" >
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.internal -- Package containing internal utilities used within this API." href="index.html"
>internal</a></li>
<li class="breadcrumb-item active"><a href="#">data_binding</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Data binding utilities.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="Headers -- Type hint for HTTP headers." href="#hikari.internal.data_binding.Headers"
>Headers</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="JSONArray -- Type hint for a JSON-decoded array representation as a sequence." href="#hikari.internal.data_binding.JSONArray"
>JSONArray</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="JSONObject -- Type hint for a JSON-decoded object representation as a mapping." href="#hikari.internal.data_binding.JSONObject"
>JSONObject</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="JSONish -- Type hint for any valid JSON-decoded type." href="#hikari.internal.data_binding.JSONish"
>JSONish</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="Query -- Type hint for HTTP query string." href="#hikari.internal.data_binding.Query"
>Query</a></li>
</ul>
<ul class="list-unstyled text-truncate">
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="cast_json_array -- Cast a JSON array to a given generic collection type …" href="#hikari.internal.data_binding.cast_json_array"
>cast_json_array</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="dump_json -- Serialize ``obj`` to a JSON formatted ``str`` …" href="#hikari.internal.data_binding.dump_json"
>dump_json</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="load_json -- Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
containing a JSON document) to a Python object …" href="#hikari.internal.data_binding.load_json"
>load_json</a></li>
</ul>
<ul class="list-unstyled text-truncate">
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ContentDisposition -- Method generated by attrs for class ContentDisposition." href="#hikari.internal.data_binding.ContentDisposition"
>ContentDisposition</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Return an attribute of instance, which is of type owner." href="#hikari.internal.data_binding.ContentDisposition.filename"
>filename</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="parameters -- Return an attribute of instance, which is of type owner." href="#hikari.internal.data_binding.ContentDisposition.parameters"
>parameters</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- Return an attribute of instance, which is of type owner." href="#hikari.internal.data_binding.ContentDisposition.type"
>type</a>
</li>
<br />
</ul>
</li>
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="URLEncodedForm -- Helper class for multipart/form-data and
application/x-www-form-urlencoded body generation." href="#hikari.internal.data_binding.FormData"
>URLEncodedForm</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="add_field -- " href="#hikari.internal.data_binding.FormData.add_field"
>add_field</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="add_fields -- " href="#hikari.internal.data_binding.FormData.add_fields"
>add_fields</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_multipart -- " href="#hikari.internal.data_binding.FormData.is_multipart"
>is_multipart</a>
</li>
<br />
</ul>
</li>
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="MultipartForm -- Helper class for multipart/form-data and
application/x-www-form-urlencoded body generation." href="#hikari.internal.data_binding.FormData"
>MultipartForm</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="add_field -- " href="#hikari.internal.data_binding.FormData.add_field"
>add_field</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="add_fields -- " href="#hikari.internal.data_binding.FormData.add_fields"
>add_fields</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_multipart -- " href="#hikari.internal.data_binding.FormData.is_multipart"
>is_multipart</a>
</li>
<br />
</ul>
</li>
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="JSONObjectBuilder -- Helper class used to quickly build JSON objects from various values …" href="#hikari.internal.data_binding.JSONObjectBuilder"
>JSONObjectBuilder</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="put -- Put a JSON value …" href="#hikari.internal.data_binding.JSONObjectBuilder.put"
>put</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="put_array -- Put a JSON array …" href="#hikari.internal.data_binding.JSONObjectBuilder.put_array"
>put_array</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="put_snowflake -- Put a key with a snowflake value into the builder …" href="#hikari.internal.data_binding.JSONObjectBuilder.put_snowflake"
>put_snowflake</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="put_snowflake_array -- Put an array of snowflakes with the given key into this builder …" href="#hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array"
>put_snowflake_array</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/internal/data_binding.py#L0-L335" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Data binding utilities.&#34;&#34;&#34;
from __future__ import annotations

__all__: typing.List[str] = [
    &#34;Headers&#34;,
    &#34;Query&#34;,
    &#34;JSONObject&#34;,
    &#34;JSONArray&#34;,
    &#34;JSONish&#34;,
    &#34;URLEncodedForm&#34;,
    &#34;MultipartForm&#34;,
    &#34;ContentDisposition&#34;,
    &#34;dump_json&#34;,
    &#34;load_json&#34;,
    &#34;JSONObjectBuilder&#34;,
    &#34;cast_json_array&#34;,
]

import json
import typing

import aiohttp.client_reqrep
import aiohttp.typedefs
import multidict

from hikari import snowflakes
from hikari import undefined

T = typing.TypeVar(&#34;T&#34;, covariant=True)

Headers = typing.Mapping[str, str]
&#34;&#34;&#34;Type hint for HTTP headers.&#34;&#34;&#34;

Query = typing.Union[typing.Dict[str, str], multidict.MultiDict[str]]
&#34;&#34;&#34;Type hint for HTTP query string.&#34;&#34;&#34;

URLEncodedForm = aiohttp.FormData
&#34;&#34;&#34;Type hint for content of type application/x-www-form-encoded.&#34;&#34;&#34;

MultipartForm = aiohttp.FormData
&#34;&#34;&#34;Type hint for content of type multipart/form-data.&#34;&#34;&#34;

ContentDisposition = aiohttp.client_reqrep.ContentDisposition
&#34;&#34;&#34;Type hint for content disposition information.&#34;&#34;&#34;

# MyPy does not support recursive types yet. This has been ongoing for a long time, unfortunately.
# See https://github.com/python/typing/issues/182

JSONObject = typing.Dict[str, typing.Any]
&#34;&#34;&#34;Type hint for a JSON-decoded object representation as a mapping.&#34;&#34;&#34;

JSONArray = typing.List[typing.Any]
&#34;&#34;&#34;Type hint for a JSON-decoded array representation as a sequence.&#34;&#34;&#34;

JSONish = typing.Union[str, int, float, bool, None, JSONArray, JSONObject]
&#34;&#34;&#34;Type hint for any valid JSON-decoded type.&#34;&#34;&#34;

if typing.TYPE_CHECKING:

    def dump_json(_: typing.Union[JSONArray, JSONObject]) -&gt; str:
        &#34;&#34;&#34;Convert a Python type to a JSON string.&#34;&#34;&#34;

    def load_json(_: typing.AnyStr) -&gt; typing.Union[JSONArray, JSONObject]:
        &#34;&#34;&#34;Convert a JSON string to a Python type.&#34;&#34;&#34;


else:
    dump_json = json.dumps
    &#34;&#34;&#34;Convert a Python type to a JSON string.&#34;&#34;&#34;

    load_json = json.loads
    &#34;&#34;&#34;Convert a JSON string to a Python type.&#34;&#34;&#34;


@typing.final
class StringMapBuilder(multidict.MultiDict[str]):
    &#34;&#34;&#34;Helper class used to quickly build query strings or header maps.

    This will consume any items that are not `hikari.undefined.UndefinedType`.
    If a value _is_ unspecified, it will be ignored when inserting it. This reduces
    the amount of boilerplate needed for generating the headers and query strings for
    low-level HTTP API interaction, amongst other things.

    !!! warn
        Because this subclasses `builtins.dict`, you should not use the
        index operator to set items on this object. Doing so will skip any
        form of validation on the type. Use the `put*` methods instead.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def __init__(self) -&gt; None:
        super().__init__()

    def put(
        self,
        key: str,
        value: undefined.UndefinedOr[typing.Any],
        /,
        *,
        conversion: typing.Optional[typing.Callable[[typing.Any], typing.Any]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add a key and value to the string map.

        Parameters
        ----------
        key : builtins.str
            The string key.
        value : hikari.undefined.UndefinedOr[typing.Any]
            The value to set.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], typing.Any]]
            An optional conversion to perform.

        !!! note
            The value will always be cast to a `builtins.str` before inserting it.

            `builtins.True` will be translated to `&#34;true&#34;`, `builtins.False`
            ill be translated to `&#34;false&#34;`, and `builtins.None` will be
            translated to `&#34;null&#34;`.
        &#34;&#34;&#34;
        if value is not undefined.UNDEFINED:
            if conversion is not None:
                value = conversion(value)

            if value is True:
                value = &#34;true&#34;
            elif value is False:
                value = &#34;false&#34;
            elif value is None:
                value = &#34;null&#34;
            elif isinstance(value, snowflakes.Unique):
                value = str(value.id)
            else:
                value = str(value)

            # __setitem__ just overwrites the previous value.
            self.add(key, value)


@typing.final
class JSONObjectBuilder(typing.Dict[str, JSONish]):
    &#34;&#34;&#34;Helper class used to quickly build JSON objects from various values.

    If provided with any values that are `hikari.undefined.UndefinedType`,
    then these values will be ignored.

    This speeds up generation of JSON payloads for low level HTTP and websocket
    API interaction.

    !!! warn
        Because this subclasses `builtins.dict`, you should not use the
        index operator to set items on this object. Doing so will skip any
        form of validation on the type. Use the `put*` methods instead.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def __init__(self) -&gt; None:
        # Only allow use of empty constructor here.
        super().__init__()

    def put(
        self,
        key: str,
        value: typing.Any,
        /,
        *,
        conversion: typing.Optional[typing.Callable[[typing.Any], JSONish]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Put a JSON value.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        value : hikari.undefined.UndefinedOr[typing.Any]
            The JSON type to put. This may be a non-JSON type if a conversion
            is also specified. This may alternatively be undefined. In the latter
            case, nothing is performed.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], JSONish]]
            The optional conversion to apply.
        &#34;&#34;&#34;
        if value is undefined.UNDEFINED:
            return

        if conversion is not None:
            self[key] = conversion(value)
        else:
            self[key] = value

    def put_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[T]],
        /,
        *,
        conversion: typing.Optional[typing.Callable[[T], JSONish]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Put a JSON array.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        If provided, a conversion will be applied to each item.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        values : hikari.undefined.UndefinedOr[typing.Iterable[T]]
            The JSON types to put. This may be an iterable of non-JSON types if
            a conversion is also specified. This may alternatively be undefined.
            In the latter case, nothing is performed.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], JSONType]]
            The optional conversion to apply.
        &#34;&#34;&#34;
        if values is not undefined.UNDEFINED:
            if conversion is not None:
                self[key] = [conversion(value) for value in values]
            else:
                self[key] = list(values)

    def put_snowflake(
        self, key: str, value: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[snowflakes.Unique]], /
    ) -&gt; None:
        &#34;&#34;&#34;Put a key with a snowflake value into the builder.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        value : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]
            The JSON type to put. This may alternatively be undefined, in this
            case, nothing is performed. This may also be `builtins.None`, in this
            case the value isn&#39;t cast.
        &#34;&#34;&#34;
        if value is not undefined.UNDEFINED and value is not None:
            self[key] = str(int(value))
        elif value is None:
            self[key] = value

    def put_snowflake_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[snowflakes.SnowflakeishOr[snowflakes.Unique]]],
        /,
    ) -&gt; None:
        &#34;&#34;&#34;Put an array of snowflakes with the given key into this builder.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Each snowflake should be castable to an `builtins.int`.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        values : hikari.undefined.UndefinedOr[typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]]
            The JSON snowflakes to put. This may alternatively be undefined.
            In the latter case, nothing is performed.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        if values is not undefined.UNDEFINED:
            self[key] = [str(int(value)) for value in values]


def cast_json_array(array: JSONArray, /, cast: typing.Callable[..., T], **kwargs: typing.Any) -&gt; typing.List[T]:
    &#34;&#34;&#34;Cast a JSON array to a given generic collection type.

    This will perform casts on each internal item individually.

    Note that

        &gt;&gt;&gt; cast_json_array(raw_list, foo, bar=&#34;OK&#34;)

    ...is equivalent to doing....

        &gt;&gt;&gt; [foo(item, bar=&#34;OK&#34;) for item in raw_list]

    Parameters
    ----------
    array : JSONArray
        The raw JSON-decoded array.
    cast : typing.Callable[[JSONish], T]
        The cast to apply to each item in the array. This should
        consume any valid JSON-decoded type and return the type
        corresponding to the generic type of the provided collection.
    **kwargs : typing.Any
        Extra keyword arguments to be passed during every call to cast.

    Returns
    -------
    typing.List[T]
        The generated list.

    Example
    -------
    ```py
    &gt;&gt;&gt; arr = [123, 456, 789, 123]
    &gt;&gt;&gt; cast_json_array(arr, str)
    [&#34;123&#34;, &#34;456&#34;, &#34;789&#34;, &#34;123&#34;]
    ```
    &#34;&#34;&#34;
    return [cast(item, **kwargs) for item in array]</code></pre>
</details>
</div>
</div>
<h2 id="variables-heading">Variables and Type Hints</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="Headers -- Type hint for HTTP headers." href="#hikari.internal.data_binding.Headers" id="hikari.internal.data_binding.Headers" >Headers</a> = typing.Mapping[str, str]</code></pre>
</dt>
<dd><p>Type hint for HTTP headers.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="JSONArray -- Type hint for a JSON-decoded array representation as a sequence." href="#hikari.internal.data_binding.JSONArray" id="hikari.internal.data_binding.JSONArray" >JSONArray</a> = typing.List[typing.Any]</code></pre>
</dt>
<dd><p>Type hint for a JSON-decoded array representation as a sequence.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="JSONObject -- Type hint for a JSON-decoded object representation as a mapping." href="#hikari.internal.data_binding.JSONObject" id="hikari.internal.data_binding.JSONObject" >JSONObject</a> = typing.Dict[str, typing.Any]</code></pre>
</dt>
<dd><p>Type hint for a JSON-decoded object representation as a mapping.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="JSONish -- Type hint for any valid JSON-decoded type." href="#hikari.internal.data_binding.JSONish" id="hikari.internal.data_binding.JSONish" >JSONish</a> = typing.Union[str, int, float, bool, NoneType, typing.List[typing.Any], typing.Dict[str, typing.Any]]</code></pre>
</dt>
<dd><p>Type hint for any valid JSON-decoded type.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A type hint that is usable by static-type checkers like MyPy, but otherwise serves no functional purpose.'>type hint</abbr> </em></small> <a title="Query -- Type hint for HTTP query string." href="#hikari.internal.data_binding.Query" id="hikari.internal.data_binding.Query" >Query</a> = typing.Union[typing.Dict[str, str], multidict._multidict.MultiDict]</code></pre>
</dt>
<dd><p>Type hint for HTTP query string.</p></dd>
</dl>
</section>
<h2 id="functions-heading">Functions</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<pre><code id="hikari.internal.data_binding.cast_json_array" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="cast_json_array" href="#hikari.internal.data_binding.cast_json_array" id="hikari.internal.data_binding.cast_json_array">cast_json_array</a>(
    array: <a href='#hikari.internal.data_binding.JSONArray'>JSONArray</a>,
    /,
    cast: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[<a href='https://docs.python.org/3/glossary.html#term-1'>...</a>, T],
    **kwargs: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
) -> List[+T]: ...</code></pre>
</dt>
<dd>
<p>Cast a JSON array to a given generic collection type.</p>
<p>This will perform casts on each internal item individually.</p>
<p>Note that</p>
<pre><code>&gt;&gt;&gt; cast_json_array(raw_list, foo, bar="OK")
</code></pre>
<p>&hellip;is equivalent to doing....</p>
<pre><code>&gt;&gt;&gt; [foo(item, bar="OK") for item in raw_list]
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code><a href='#hikari.internal.data_binding.JSONArray'>JSONArray</a></code></dt>
<dd>The raw JSON-decoded array.</dd>
<dt><strong><code>cast</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='#hikari.internal.data_binding.JSONish'>JSONish</a>], T]</code></dt>
<dd>The cast to apply to each item in the array. This should
consume any valid JSON-decoded type and return the type
corresponding to the generic type of the provided collection.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a></code></dt>
<dd>Extra keyword arguments to be passed during every call to cast.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.List'>List</a>[T]</code></dt>
<dd>The generated list.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-py">&gt;&gt;&gt; arr = [123, 456, 789, 123]
&gt;&gt;&gt; cast_json_array(arr, str)
[&quot;123&quot;, &quot;456&quot;, &quot;789&quot;, &quot;123&quot;]
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/internal/data_binding.py#L299-L336" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def cast_json_array(array: JSONArray, /, cast: typing.Callable[..., T], **kwargs: typing.Any) -&gt; typing.List[T]:
    &#34;&#34;&#34;Cast a JSON array to a given generic collection type.

    This will perform casts on each internal item individually.

    Note that

        &gt;&gt;&gt; cast_json_array(raw_list, foo, bar=&#34;OK&#34;)

    ...is equivalent to doing....

        &gt;&gt;&gt; [foo(item, bar=&#34;OK&#34;) for item in raw_list]

    Parameters
    ----------
    array : JSONArray
        The raw JSON-decoded array.
    cast : typing.Callable[[JSONish], T]
        The cast to apply to each item in the array. This should
        consume any valid JSON-decoded type and return the type
        corresponding to the generic type of the provided collection.
    **kwargs : typing.Any
        Extra keyword arguments to be passed during every call to cast.

    Returns
    -------
    typing.List[T]
        The generated list.

    Example
    -------
    ```py
    &gt;&gt;&gt; arr = [123, 456, 789, 123]
    &gt;&gt;&gt; cast_json_array(arr, str)
    [&#34;123&#34;, &#34;456&#34;, &#34;789&#34;, &#34;123&#34;]
    ```
    &#34;&#34;&#34;
    return [cast(item, **kwargs) for item in array]</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.internal.data_binding.dump_json" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="dump_json" href="#hikari.internal.data_binding.dump_json" id="hikari.internal.data_binding.dump_json">dump_json</a>(
    obj,
    *,
    skipkeys=False,
    ensure_ascii=True,
    check_circular=True,
    allow_nan=True,
    cls=None,
    indent=None,
    separators=None,
    default=None,
    sort_keys=False,
    **kw,
): ...</code></pre>
</dt>
<dd>
<p>Serialize <code>obj</code> to a JSON formatted <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>.</p>
<p>If <code>skipkeys</code> is true then <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code> keys that are not basic types
(<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>, <code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code>, <code><a href='https://docs.python.org/3/library/functions.html#float'>float</a></code>, <code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code>, <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>) will be skipped
instead of raising a <code><a href='https://docs.python.org/3/library/exceptions.html#TypeError'>TypeError</a></code>.</p>
<p>If <code>ensure_ascii</code> is false, then the return value can contain non-ASCII
characters if they appear in strings contained in <code>obj</code>. Otherwise, all
such characters are escaped in JSON strings.</p>
<p>If <code>check_circular</code> is false, then the circular reference check
for container types will be skipped and a circular reference will
result in an <code><a href='https://docs.python.org/3/library/exceptions.html#OverflowError'>OverflowError</a></code> (or worse).</p>
<p>If <code>allow_nan</code> is false, then it will be a <code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code> to
serialize out of range <code><a href='https://docs.python.org/3/library/functions.html#float'>float</a></code> values (<code><a href='https://docs.python.org/3/library/functions.html#grammar-token-nan'>nan</a></code>, <code>inf</code>, <code>-inf</code>) in
strict compliance of the JSON specification, instead of using the
JavaScript equivalents (<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>).</p>
<p>If <code>indent</code> is a non-negative integer, then JSON array elements and
object members will be pretty-printed with that indent level. An indent
level of 0 will only insert newlines. <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> is the most compact
representation.</p>
<p>If specified, <code>separators</code> should be an <code>(item_separator, key_separator)</code>
tuple.
The default is <code>(', ', ': ')</code> if <em>indent</em> is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> and
<code>(',', ': ')</code> otherwise.
To get the most compact JSON representation,
you should specify <code>(',', ':')</code> to eliminate whitespace.</p>
<p><code>default(obj)</code> is a function that should return a serializable version
of obj or raise TypeError. The default simply raises TypeError.</p>
<p>If <em>sort_keys</em> is true (default: <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>), then the output of
dictionaries will be sorted by key.</p>
<p>To use a custom <code>JSONEncoder</code> subclass (e.g. one that overrides the
<code>.default()</code> method to serialize additional types), specify it with
the <code>cls</code> kwarg; otherwise <code>JSONEncoder</code> is used.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,
        allow_nan=True, cls=None, indent=None, separators=None,
        default=None, sort_keys=False, **kw):
    &#34;&#34;&#34;Serialize ``obj`` to a JSON formatted ``str``.

    If ``skipkeys`` is true then ``dict`` keys that are not basic types
    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
    instead of raising a ``TypeError``.

    If ``ensure_ascii`` is false, then the return value can contain non-ASCII
    characters if they appear in strings contained in ``obj``. Otherwise, all
    such characters are escaped in JSON strings.

    If ``check_circular`` is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``OverflowError`` (or worse).

    If ``allow_nan`` is false, then it will be a ``ValueError`` to
    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
    strict compliance of the JSON specification, instead of using the
    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).

    If ``indent`` is a non-negative integer, then JSON array elements and
    object members will be pretty-printed with that indent level. An indent
    level of 0 will only insert newlines. ``None`` is the most compact
    representation.

    If specified, ``separators`` should be an ``(item_separator, key_separator)``
    tuple.  The default is ``(&#39;, &#39;, &#39;: &#39;)`` if *indent* is ``None`` and
    ``(&#39;,&#39;, &#39;: &#39;)`` otherwise.  To get the most compact JSON representation,
    you should specify ``(&#39;,&#39;, &#39;:&#39;)`` to eliminate whitespace.

    ``default(obj)`` is a function that should return a serializable version
    of obj or raise TypeError. The default simply raises TypeError.

    If *sort_keys* is true (default: ``False``), then the output of
    dictionaries will be sorted by key.

    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.

    &#34;&#34;&#34;
    # cached encoder
    if (not skipkeys and ensure_ascii and
        check_circular and allow_nan and
        cls is None and indent is None and separators is None and
        default is None and not sort_keys and not kw):
        return _default_encoder.encode(obj)
    if cls is None:
        cls = JSONEncoder
    return cls(
        skipkeys=skipkeys, ensure_ascii=ensure_ascii,
        check_circular=check_circular, allow_nan=allow_nan, indent=indent,
        separators=separators, default=default, sort_keys=sort_keys,
        **kw).encode(obj)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.internal.data_binding.load_json" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="load_json" href="#hikari.internal.data_binding.load_json" id="hikari.internal.data_binding.load_json">load_json</a>(
    s,
    *,
    cls=None,
    object_hook=None,
    parse_float=None,
    parse_int=None,
    parse_constant=None,
    object_pairs_hook=None,
    **kw,
): ...</code></pre>
</dt>
<dd>
<p>Deserialize <code>s</code> (a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code>, <code><a href='https://docs.python.org/3/library/stdtypes.html#bytes'>bytes</a></code> or <code><a href='https://docs.python.org/3/library/stdtypes.html#bytearray'>bytearray</a></code> instance
containing a JSON document) to a Python object.</p>
<p><code>object_hook</code> is an optional function that will be called with the
result of any object literal decode (a <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code>). The return value of
<code>object_hook</code> will be used instead of the <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code>. This feature
can be used to implement custom decoders (e.g. JSON-RPC class hinting).</p>
<p><code>object_pairs_hook</code> is an optional function that will be called with the
result of any object literal decoded with an ordered list of pairs.
The
return value of <code>object_pairs_hook</code> will be used instead of the <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code>.
This feature can be used to implement custom decoders.
If <code>object_hook</code>
is also defined, the <code>object_pairs_hook</code> takes priority.</p>
<p><code>parse_float</code>, if specified, will be called with the string
of every JSON float to be decoded. By default this is equivalent to
float(num_str). This can be used to use another datatype or parser
for JSON floats (e.g. decimal.Decimal).</p>
<p><code>parse_int</code>, if specified, will be called with the string
of every JSON int to be decoded. By default this is equivalent to
int(num_str). This can be used to use another datatype or parser
for JSON integers (e.g. float).</p>
<p><code>parse_constant</code>, if specified, will be called with one of the
following strings: -Infinity, Infinity, NaN.
This can be used to raise an exception if invalid JSON numbers
are encountered.</p>
<p>To use a custom <code>JSONDecoder</code> subclass, specify it with the <code>cls</code>
kwarg; otherwise <code>JSONDecoder</code> is used.</p>
<p>The <code>encoding</code> argument is ignored and deprecated since Python 3.1.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loads(s, *, cls=None, object_hook=None, parse_float=None,
        parse_int=None, parse_constant=None, object_pairs_hook=None, **kw):
    &#34;&#34;&#34;Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
    containing a JSON document) to a Python object.

    ``object_hook`` is an optional function that will be called with the
    result of any object literal decode (a ``dict``). The return value of
    ``object_hook`` will be used instead of the ``dict``. This feature
    can be used to implement custom decoders (e.g. JSON-RPC class hinting).

    ``object_pairs_hook`` is an optional function that will be called with the
    result of any object literal decoded with an ordered list of pairs.  The
    return value of ``object_pairs_hook`` will be used instead of the ``dict``.
    This feature can be used to implement custom decoders.  If ``object_hook``
    is also defined, the ``object_pairs_hook`` takes priority.

    ``parse_float``, if specified, will be called with the string
    of every JSON float to be decoded. By default this is equivalent to
    float(num_str). This can be used to use another datatype or parser
    for JSON floats (e.g. decimal.Decimal).

    ``parse_int``, if specified, will be called with the string
    of every JSON int to be decoded. By default this is equivalent to
    int(num_str). This can be used to use another datatype or parser
    for JSON integers (e.g. float).

    ``parse_constant``, if specified, will be called with one of the
    following strings: -Infinity, Infinity, NaN.
    This can be used to raise an exception if invalid JSON numbers
    are encountered.

    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
    kwarg; otherwise ``JSONDecoder`` is used.

    The ``encoding`` argument is ignored and deprecated since Python 3.1.
    &#34;&#34;&#34;
    if isinstance(s, str):
        if s.startswith(&#39;\ufeff&#39;):
            raise JSONDecodeError(&#34;Unexpected UTF-8 BOM (decode using utf-8-sig)&#34;,
                                  s, 0)
    else:
        if not isinstance(s, (bytes, bytearray)):
            raise TypeError(f&#39;the JSON object must be str, bytes or bytearray, &#39;
                            f&#39;not {s.__class__.__name__}&#39;)
        s = s.decode(detect_encoding(s), &#39;surrogatepass&#39;)

    if &#34;encoding&#34; in kw:
        import warnings
        warnings.warn(
            &#34;&#39;encoding&#39; is ignored and deprecated. It will be removed in Python 3.9&#34;,
            DeprecationWarning,
            stacklevel=2
        )
        del kw[&#39;encoding&#39;]

    if (cls is None and object_hook is None and
            parse_int is None and parse_float is None and
            parse_constant is None and object_pairs_hook is None and not kw):
        return _default_decoder.decode(s)
    if cls is None:
        cls = JSONDecoder
    if object_hook is not None:
        kw[&#39;object_hook&#39;] = object_hook
    if object_pairs_hook is not None:
        kw[&#39;object_pairs_hook&#39;] = object_pairs_hook
    if parse_float is not None:
        kw[&#39;parse_float&#39;] = parse_float
    if parse_int is not None:
        kw[&#39;parse_int&#39;] = parse_int
    if parse_constant is not None:
        kw[&#39;parse_constant&#39;] = parse_constant
    return cls(**kw).decode(s)</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
</section>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ContentDisposition -- Method generated by attrs for class ContentDisposition." href="#hikari.internal.data_binding.ContentDisposition"
>ContentDisposition</a></h4>
</dt>
<dd>
<pre><code id="hikari.internal.data_binding.ContentDisposition" class="hljs python"><abbr title='A standard Python type.'>class</abbr> ContentDisposition (
    type: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    parameters: mappingproxy,
    filename: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
): ...</code></pre>
<p>Method generated by attrs for class ContentDisposition.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/.nox/pdoc3/lib/python3.8/site-packages/aiohttp/client_reqrep.py#L87-L90" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class ContentDisposition:
    type = attr.ib(type=str)  # type: Optional[str]
    parameters = attr.ib(type=MappingProxyType)  # type: MappingProxyType[str, str]  # noqa
    filename = attr.ib(type=str)  # type: Optional[str]</code></pre>
</details>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="filename -- Return an attribute of instance, which is of type owner." href="#hikari.internal.data_binding.ContentDisposition.filename" id="hikari.internal.data_binding.ContentDisposition.filename" >filename</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="parameters -- Return an attribute of instance, which is of type owner." href="#hikari.internal.data_binding.ContentDisposition.parameters" id="hikari.internal.data_binding.ContentDisposition.parameters" >parameters</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="type -- Return an attribute of instance, which is of type owner." href="#hikari.internal.data_binding.ContentDisposition.type" id="hikari.internal.data_binding.ContentDisposition.type" >type</a></code></pre>
</dt>
<dd><p>Return an attribute of instance, which is of type owner.</p></dd>
</dl>
<div class="sep"></div>
</dd>
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="URLEncodedForm -- Helper class for multipart/form-data and
application/x-www-form-urlencoded body generation." href="#hikari.internal.data_binding.FormData"
>URLEncodedForm</a></h4>
</dt>
<dd>
<pre><code id="hikari.internal.data_binding.FormData" class="hljs python"><abbr title='A standard Python type.'>class</abbr> URLEncodedForm (
    fields: Iterable[Any] = (),
    quote_fields: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = True,
    charset: Union[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, NoneType] = None,
): ...</code></pre>
<p>Helper class for multipart/form-data and
application/x-www-form-urlencoded body generation.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/.nox/pdoc3/lib/python3.8/site-packages/aiohttp/formdata.py#L14-L150" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class FormData:
    &#34;&#34;&#34;Helper class for multipart/form-data and
    application/x-www-form-urlencoded body generation.&#34;&#34;&#34;

    def __init__(self, fields:
                 Iterable[Any]=(),
                 quote_fields: bool=True,
                 charset: Optional[str]=None) -&gt; None:
        self._writer = multipart.MultipartWriter(&#39;form-data&#39;)
        self._fields = []  # type: List[Any]
        self._is_multipart = False
        self._quote_fields = quote_fields
        self._charset = charset

        if isinstance(fields, dict):
            fields = list(fields.items())
        elif not isinstance(fields, (list, tuple)):
            fields = (fields,)
        self.add_fields(*fields)

    @property
    def is_multipart(self) -&gt; bool:
        return self._is_multipart

    def add_field(self, name: str, value: Any, *,
                  content_type: Optional[str]=None,
                  filename: Optional[str]=None,
                  content_transfer_encoding: Optional[str]=None) -&gt; None:

        if isinstance(value, io.IOBase):
            self._is_multipart = True
        elif isinstance(value, (bytes, bytearray, memoryview)):
            if filename is None and content_transfer_encoding is None:
                filename = name

        type_options = MultiDict({&#39;name&#39;: name})
        if filename is not None and not isinstance(filename, str):
            raise TypeError(&#39;filename must be an instance of str. &#39;
                            &#39;Got: %s&#39; % filename)
        if filename is None and isinstance(value, io.IOBase):
            filename = guess_filename(value, name)
        if filename is not None:
            type_options[&#39;filename&#39;] = filename
            self._is_multipart = True

        headers = {}
        if content_type is not None:
            if not isinstance(content_type, str):
                raise TypeError(&#39;content_type must be an instance of str. &#39;
                                &#39;Got: %s&#39; % content_type)
            headers[hdrs.CONTENT_TYPE] = content_type
            self._is_multipart = True
        if content_transfer_encoding is not None:
            if not isinstance(content_transfer_encoding, str):
                raise TypeError(&#39;content_transfer_encoding must be an instance&#39;
                                &#39; of str. Got: %s&#39; % content_transfer_encoding)
            headers[hdrs.CONTENT_TRANSFER_ENCODING] = content_transfer_encoding
            self._is_multipart = True

        self._fields.append((type_options, headers, value))

    def add_fields(self, *fields: Any) -&gt; None:
        to_add = list(fields)

        while to_add:
            rec = to_add.pop(0)

            if isinstance(rec, io.IOBase):
                k = guess_filename(rec, &#39;unknown&#39;)
                self.add_field(k, rec)  # type: ignore

            elif isinstance(rec, (MultiDictProxy, MultiDict)):
                to_add.extend(rec.items())

            elif isinstance(rec, (list, tuple)) and len(rec) == 2:
                k, fp = rec
                self.add_field(k, fp)  # type: ignore

            else:
                raise TypeError(&#39;Only io.IOBase, multidict and (name, file) &#39;
                                &#39;pairs allowed, use .add_field() for passing &#39;
                                &#39;more complex parameters, got {!r}&#39;
                                .format(rec))

    def _gen_form_urlencoded(self) -&gt; payload.BytesPayload:
        # form data (x-www-form-urlencoded)
        data = []
        for type_options, _, value in self._fields:
            data.append((type_options[&#39;name&#39;], value))

        charset = self._charset if self._charset is not None else &#39;utf-8&#39;

        if charset == &#39;utf-8&#39;:
            content_type = &#39;application/x-www-form-urlencoded&#39;
        else:
            content_type = (&#39;application/x-www-form-urlencoded; &#39;
                            &#39;charset=%s&#39; % charset)

        return payload.BytesPayload(
            urlencode(data, doseq=True, encoding=charset).encode(),
            content_type=content_type)

    def _gen_form_data(self) -&gt; multipart.MultipartWriter:
        &#34;&#34;&#34;Encode a list of fields using the multipart/form-data MIME format&#34;&#34;&#34;
        for dispparams, headers, value in self._fields:
            try:
                if hdrs.CONTENT_TYPE in headers:
                    part = payload.get_payload(
                        value, content_type=headers[hdrs.CONTENT_TYPE],
                        headers=headers, encoding=self._charset)
                else:
                    part = payload.get_payload(
                        value, headers=headers, encoding=self._charset)
            except Exception as exc:
                raise TypeError(
                    &#39;Can not serialize value type: %r\n &#39;
                    &#39;headers: %r\n value: %r&#39; % (
                        type(value), headers, value)) from exc

            if dispparams:
                part.set_content_disposition(
                    &#39;form-data&#39;, quote_fields=self._quote_fields, **dispparams
                )
                # FIXME cgi.FieldStorage doesn&#39;t likes body parts with
                # Content-Length which were sent via chunked transfer encoding
                assert part.headers is not None
                part.headers.popall(hdrs.CONTENT_LENGTH, None)

            self._writer.append_payload(part)

        return self._writer

    def __call__(self) -&gt; Payload:
        if self._is_multipart:
            return self._gen_form_data()
        else:
            return self._gen_form_urlencoded()</code></pre>
</details>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_multipart -- " href="#hikari.internal.data_binding.FormData.is_multipart" id="hikari.internal.data_binding.FormData.is_multipart" >is_multipart</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.internal.data_binding.FormData.add_field" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="add_field" href="#hikari.internal.data_binding.FormData.add_field" id="hikari.internal.data_binding.FormData.add_field">add_field</a>(
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    value: Any,
    *,
    content_type: Union[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, NoneType] = None,
    filename: Union[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, NoneType] = None,
    content_transfer_encoding: Union[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, NoneType] = None,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/.nox/pdoc3/lib/python3.8/site-packages/aiohttp/formdata.py#L38-L73" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def add_field(self, name: str, value: Any, *,
              content_type: Optional[str]=None,
              filename: Optional[str]=None,
              content_transfer_encoding: Optional[str]=None) -&gt; None:

    if isinstance(value, io.IOBase):
        self._is_multipart = True
    elif isinstance(value, (bytes, bytearray, memoryview)):
        if filename is None and content_transfer_encoding is None:
            filename = name

    type_options = MultiDict({&#39;name&#39;: name})
    if filename is not None and not isinstance(filename, str):
        raise TypeError(&#39;filename must be an instance of str. &#39;
                        &#39;Got: %s&#39; % filename)
    if filename is None and isinstance(value, io.IOBase):
        filename = guess_filename(value, name)
    if filename is not None:
        type_options[&#39;filename&#39;] = filename
        self._is_multipart = True

    headers = {}
    if content_type is not None:
        if not isinstance(content_type, str):
            raise TypeError(&#39;content_type must be an instance of str. &#39;
                            &#39;Got: %s&#39; % content_type)
        headers[hdrs.CONTENT_TYPE] = content_type
        self._is_multipart = True
    if content_transfer_encoding is not None:
        if not isinstance(content_transfer_encoding, str):
            raise TypeError(&#39;content_transfer_encoding must be an instance&#39;
                            &#39; of str. Got: %s&#39; % content_transfer_encoding)
        headers[hdrs.CONTENT_TRANSFER_ENCODING] = content_transfer_encoding
        self._is_multipart = True

    self._fields.append((type_options, headers, value))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.internal.data_binding.FormData.add_fields" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="add_fields" href="#hikari.internal.data_binding.FormData.add_fields" id="hikari.internal.data_binding.FormData.add_fields">add_fields</a>(
    *fields: Any,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/.nox/pdoc3/lib/python3.8/site-packages/aiohttp/formdata.py#L75-L96" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def add_fields(self, *fields: Any) -&gt; None:
    to_add = list(fields)

    while to_add:
        rec = to_add.pop(0)

        if isinstance(rec, io.IOBase):
            k = guess_filename(rec, &#39;unknown&#39;)
            self.add_field(k, rec)  # type: ignore

        elif isinstance(rec, (MultiDictProxy, MultiDict)):
            to_add.extend(rec.items())

        elif isinstance(rec, (list, tuple)) and len(rec) == 2:
            k, fp = rec
            self.add_field(k, fp)  # type: ignore

        else:
            raise TypeError(&#39;Only io.IOBase, multidict and (name, file) &#39;
                            &#39;pairs allowed, use .add_field() for passing &#39;
                            &#39;more complex parameters, got {!r}&#39;
                            .format(rec))</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="MultipartForm -- Helper class for multipart/form-data and
application/x-www-form-urlencoded body generation." href="#hikari.internal.data_binding.FormData"
>MultipartForm</a></h4>
</dt>
<dd>
<pre><code id="hikari.internal.data_binding.FormData" class="hljs python"><abbr title='A standard Python type.'>class</abbr> MultipartForm (
    fields: Iterable[Any] = (),
    quote_fields: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = True,
    charset: Union[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, NoneType] = None,
): ...</code></pre>
<p>Helper class for multipart/form-data and
application/x-www-form-urlencoded body generation.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/.nox/pdoc3/lib/python3.8/site-packages/aiohttp/formdata.py#L14-L150" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class FormData:
    &#34;&#34;&#34;Helper class for multipart/form-data and
    application/x-www-form-urlencoded body generation.&#34;&#34;&#34;

    def __init__(self, fields:
                 Iterable[Any]=(),
                 quote_fields: bool=True,
                 charset: Optional[str]=None) -&gt; None:
        self._writer = multipart.MultipartWriter(&#39;form-data&#39;)
        self._fields = []  # type: List[Any]
        self._is_multipart = False
        self._quote_fields = quote_fields
        self._charset = charset

        if isinstance(fields, dict):
            fields = list(fields.items())
        elif not isinstance(fields, (list, tuple)):
            fields = (fields,)
        self.add_fields(*fields)

    @property
    def is_multipart(self) -&gt; bool:
        return self._is_multipart

    def add_field(self, name: str, value: Any, *,
                  content_type: Optional[str]=None,
                  filename: Optional[str]=None,
                  content_transfer_encoding: Optional[str]=None) -&gt; None:

        if isinstance(value, io.IOBase):
            self._is_multipart = True
        elif isinstance(value, (bytes, bytearray, memoryview)):
            if filename is None and content_transfer_encoding is None:
                filename = name

        type_options = MultiDict({&#39;name&#39;: name})
        if filename is not None and not isinstance(filename, str):
            raise TypeError(&#39;filename must be an instance of str. &#39;
                            &#39;Got: %s&#39; % filename)
        if filename is None and isinstance(value, io.IOBase):
            filename = guess_filename(value, name)
        if filename is not None:
            type_options[&#39;filename&#39;] = filename
            self._is_multipart = True

        headers = {}
        if content_type is not None:
            if not isinstance(content_type, str):
                raise TypeError(&#39;content_type must be an instance of str. &#39;
                                &#39;Got: %s&#39; % content_type)
            headers[hdrs.CONTENT_TYPE] = content_type
            self._is_multipart = True
        if content_transfer_encoding is not None:
            if not isinstance(content_transfer_encoding, str):
                raise TypeError(&#39;content_transfer_encoding must be an instance&#39;
                                &#39; of str. Got: %s&#39; % content_transfer_encoding)
            headers[hdrs.CONTENT_TRANSFER_ENCODING] = content_transfer_encoding
            self._is_multipart = True

        self._fields.append((type_options, headers, value))

    def add_fields(self, *fields: Any) -&gt; None:
        to_add = list(fields)

        while to_add:
            rec = to_add.pop(0)

            if isinstance(rec, io.IOBase):
                k = guess_filename(rec, &#39;unknown&#39;)
                self.add_field(k, rec)  # type: ignore

            elif isinstance(rec, (MultiDictProxy, MultiDict)):
                to_add.extend(rec.items())

            elif isinstance(rec, (list, tuple)) and len(rec) == 2:
                k, fp = rec
                self.add_field(k, fp)  # type: ignore

            else:
                raise TypeError(&#39;Only io.IOBase, multidict and (name, file) &#39;
                                &#39;pairs allowed, use .add_field() for passing &#39;
                                &#39;more complex parameters, got {!r}&#39;
                                .format(rec))

    def _gen_form_urlencoded(self) -&gt; payload.BytesPayload:
        # form data (x-www-form-urlencoded)
        data = []
        for type_options, _, value in self._fields:
            data.append((type_options[&#39;name&#39;], value))

        charset = self._charset if self._charset is not None else &#39;utf-8&#39;

        if charset == &#39;utf-8&#39;:
            content_type = &#39;application/x-www-form-urlencoded&#39;
        else:
            content_type = (&#39;application/x-www-form-urlencoded; &#39;
                            &#39;charset=%s&#39; % charset)

        return payload.BytesPayload(
            urlencode(data, doseq=True, encoding=charset).encode(),
            content_type=content_type)

    def _gen_form_data(self) -&gt; multipart.MultipartWriter:
        &#34;&#34;&#34;Encode a list of fields using the multipart/form-data MIME format&#34;&#34;&#34;
        for dispparams, headers, value in self._fields:
            try:
                if hdrs.CONTENT_TYPE in headers:
                    part = payload.get_payload(
                        value, content_type=headers[hdrs.CONTENT_TYPE],
                        headers=headers, encoding=self._charset)
                else:
                    part = payload.get_payload(
                        value, headers=headers, encoding=self._charset)
            except Exception as exc:
                raise TypeError(
                    &#39;Can not serialize value type: %r\n &#39;
                    &#39;headers: %r\n value: %r&#39; % (
                        type(value), headers, value)) from exc

            if dispparams:
                part.set_content_disposition(
                    &#39;form-data&#39;, quote_fields=self._quote_fields, **dispparams
                )
                # FIXME cgi.FieldStorage doesn&#39;t likes body parts with
                # Content-Length which were sent via chunked transfer encoding
                assert part.headers is not None
                part.headers.popall(hdrs.CONTENT_LENGTH, None)

            self._writer.append_payload(part)

        return self._writer

    def __call__(self) -&gt; Payload:
        if self._is_multipart:
            return self._gen_form_data()
        else:
            return self._gen_form_urlencoded()</code></pre>
</details>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_multipart -- " href="#hikari.internal.data_binding.FormData.is_multipart" id="hikari.internal.data_binding.FormData.is_multipart" >is_multipart</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.internal.data_binding.FormData.add_field" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="add_field" href="#hikari.internal.data_binding.FormData.add_field" id="hikari.internal.data_binding.FormData.add_field">add_field</a>(
    name: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    value: Any,
    *,
    content_type: Union[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, NoneType] = None,
    filename: Union[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, NoneType] = None,
    content_transfer_encoding: Union[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, NoneType] = None,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/.nox/pdoc3/lib/python3.8/site-packages/aiohttp/formdata.py#L38-L73" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def add_field(self, name: str, value: Any, *,
              content_type: Optional[str]=None,
              filename: Optional[str]=None,
              content_transfer_encoding: Optional[str]=None) -&gt; None:

    if isinstance(value, io.IOBase):
        self._is_multipart = True
    elif isinstance(value, (bytes, bytearray, memoryview)):
        if filename is None and content_transfer_encoding is None:
            filename = name

    type_options = MultiDict({&#39;name&#39;: name})
    if filename is not None and not isinstance(filename, str):
        raise TypeError(&#39;filename must be an instance of str. &#39;
                        &#39;Got: %s&#39; % filename)
    if filename is None and isinstance(value, io.IOBase):
        filename = guess_filename(value, name)
    if filename is not None:
        type_options[&#39;filename&#39;] = filename
        self._is_multipart = True

    headers = {}
    if content_type is not None:
        if not isinstance(content_type, str):
            raise TypeError(&#39;content_type must be an instance of str. &#39;
                            &#39;Got: %s&#39; % content_type)
        headers[hdrs.CONTENT_TYPE] = content_type
        self._is_multipart = True
    if content_transfer_encoding is not None:
        if not isinstance(content_transfer_encoding, str):
            raise TypeError(&#39;content_transfer_encoding must be an instance&#39;
                            &#39; of str. Got: %s&#39; % content_transfer_encoding)
        headers[hdrs.CONTENT_TRANSFER_ENCODING] = content_transfer_encoding
        self._is_multipart = True

    self._fields.append((type_options, headers, value))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.internal.data_binding.FormData.add_fields" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="add_fields" href="#hikari.internal.data_binding.FormData.add_fields" id="hikari.internal.data_binding.FormData.add_fields">add_fields</a>(
    *fields: Any,
) -> None: ...</code></pre>
</dt>
<dd>
<p>None</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/.nox/pdoc3/lib/python3.8/site-packages/aiohttp/formdata.py#L75-L96" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def add_fields(self, *fields: Any) -&gt; None:
    to_add = list(fields)

    while to_add:
        rec = to_add.pop(0)

        if isinstance(rec, io.IOBase):
            k = guess_filename(rec, &#39;unknown&#39;)
            self.add_field(k, rec)  # type: ignore

        elif isinstance(rec, (MultiDictProxy, MultiDict)):
            to_add.extend(rec.items())

        elif isinstance(rec, (list, tuple)) and len(rec) == 2:
            k, fp = rec
            self.add_field(k, fp)  # type: ignore

        else:
            raise TypeError(&#39;Only io.IOBase, multidict and (name, file) &#39;
                            &#39;pairs allowed, use .add_field() for passing &#39;
                            &#39;more complex parameters, got {!r}&#39;
                            .format(rec))</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="JSONObjectBuilder -- Helper class used to quickly build JSON objects from various values …" href="#hikari.internal.data_binding.JSONObjectBuilder"
>JSONObjectBuilder</a></h4>
</dt>
<dd>
<pre><code id="hikari.internal.data_binding.JSONObjectBuilder" class="hljs python"><abbr title='A standard Python type.'>class</abbr> JSONObjectBuilder: ...</code></pre>
<p>Helper class used to quickly build JSON objects from various values.</p>
<p>If provided with any values that are <code><a href='../undefined.html#hikari.undefined.UndefinedType'>UndefinedType</a></code>,
then these values will be ignored.</p>
<p>This speeds up generation of JSON payloads for low level HTTP and websocket
API interaction.</p>
<div class="admonition warn">
<p class="admonition-title">Warn</p>
<p>Because this subclasses <code><a href='https://docs.python.org/3/library/stdtypes.html#dict'>dict</a></code>, you should not use the
index operator to set items on this object. Doing so will skip any
form of validation on the type. Use the <code>put*</code> methods instead.</p>
</div>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/internal/data_binding.py#L165-L296" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class JSONObjectBuilder(typing.Dict[str, JSONish]):
    &#34;&#34;&#34;Helper class used to quickly build JSON objects from various values.

    If provided with any values that are `hikari.undefined.UndefinedType`,
    then these values will be ignored.

    This speeds up generation of JSON payloads for low level HTTP and websocket
    API interaction.

    !!! warn
        Because this subclasses `builtins.dict`, you should not use the
        index operator to set items on this object. Doing so will skip any
        form of validation on the type. Use the `put*` methods instead.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def __init__(self) -&gt; None:
        # Only allow use of empty constructor here.
        super().__init__()

    def put(
        self,
        key: str,
        value: typing.Any,
        /,
        *,
        conversion: typing.Optional[typing.Callable[[typing.Any], JSONish]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Put a JSON value.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        value : hikari.undefined.UndefinedOr[typing.Any]
            The JSON type to put. This may be a non-JSON type if a conversion
            is also specified. This may alternatively be undefined. In the latter
            case, nothing is performed.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], JSONish]]
            The optional conversion to apply.
        &#34;&#34;&#34;
        if value is undefined.UNDEFINED:
            return

        if conversion is not None:
            self[key] = conversion(value)
        else:
            self[key] = value

    def put_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[T]],
        /,
        *,
        conversion: typing.Optional[typing.Callable[[T], JSONish]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Put a JSON array.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        If provided, a conversion will be applied to each item.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        values : hikari.undefined.UndefinedOr[typing.Iterable[T]]
            The JSON types to put. This may be an iterable of non-JSON types if
            a conversion is also specified. This may alternatively be undefined.
            In the latter case, nothing is performed.

        Other Parameters
        ----------------
        conversion : typing.Optional[typing.Callable[[typing.Any], JSONType]]
            The optional conversion to apply.
        &#34;&#34;&#34;
        if values is not undefined.UNDEFINED:
            if conversion is not None:
                self[key] = [conversion(value) for value in values]
            else:
                self[key] = list(values)

    def put_snowflake(
        self, key: str, value: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[snowflakes.Unique]], /
    ) -&gt; None:
        &#34;&#34;&#34;Put a key with a snowflake value into the builder.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        value : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]
            The JSON type to put. This may alternatively be undefined, in this
            case, nothing is performed. This may also be `builtins.None`, in this
            case the value isn&#39;t cast.
        &#34;&#34;&#34;
        if value is not undefined.UNDEFINED and value is not None:
            self[key] = str(int(value))
        elif value is None:
            self[key] = value

    def put_snowflake_array(
        self,
        key: str,
        values: undefined.UndefinedOr[typing.Iterable[snowflakes.SnowflakeishOr[snowflakes.Unique]]],
        /,
    ) -&gt; None:
        &#34;&#34;&#34;Put an array of snowflakes with the given key into this builder.

        If the value is `hikari.undefined.UNDEFINED` it will not be stored.

        Each snowflake should be castable to an `builtins.int`.

        Parameters
        ----------
        key : builtins.str
            The key to give the element.
        values : hikari.undefined.UndefinedOr[typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]]
            The JSON snowflakes to put. This may alternatively be undefined.
            In the latter case, nothing is performed.
        &#34;&#34;&#34;  # noqa: E501 - Line too long
        if values is not undefined.UNDEFINED:
            self[key] = [str(int(value)) for value in values]</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="JSONObjectBuilder -- Helper class used to quickly build JSON objects from various values …" href="#hikari.internal.data_binding.JSONObjectBuilder"
>JSONObjectBuilder</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="builtins.dict -- dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -> new …" href="https://docs.python.org/3/library/stdtypes.html#dict"
>dict</a></dt>
<dd class="nested"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.internal.data_binding.JSONObjectBuilder.put" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="put" href="#hikari.internal.data_binding.JSONObjectBuilder.put" id="hikari.internal.data_binding.JSONObjectBuilder.put">put</a>(
    key: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    value: <a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>,
    /,
    *,
    conversion: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='#hikari.internal.data_binding.JSONish'>JSONish</a>]] = None,
) -> None: ...</code></pre>
</dt>
<dd>
<p>Put a JSON value.</p>
<p>If the value is <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> it will not be stored.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The key to give the element.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>]</code></dt>
<dd>The JSON type to put. This may be a non-JSON type if a conversion
is also specified. This may alternatively be undefined. In the latter
case, nothing is performed.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>conversion</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], <a href='#hikari.internal.data_binding.JSONish'>JSONish</a>]]</code></dt>
<dd>The optional conversion to apply.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/internal/data_binding.py#L186-L218" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def put(
    self,
    key: str,
    value: typing.Any,
    /,
    *,
    conversion: typing.Optional[typing.Callable[[typing.Any], JSONish]] = None,
) -&gt; None:
    &#34;&#34;&#34;Put a JSON value.

    If the value is `hikari.undefined.UNDEFINED` it will not be stored.

    Parameters
    ----------
    key : builtins.str
        The key to give the element.
    value : hikari.undefined.UndefinedOr[typing.Any]
        The JSON type to put. This may be a non-JSON type if a conversion
        is also specified. This may alternatively be undefined. In the latter
        case, nothing is performed.

    Other Parameters
    ----------------
    conversion : typing.Optional[typing.Callable[[typing.Any], JSONish]]
        The optional conversion to apply.
    &#34;&#34;&#34;
    if value is undefined.UNDEFINED:
        return

    if conversion is not None:
        self[key] = conversion(value)
    else:
        self[key] = value</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.internal.data_binding.JSONObjectBuilder.put_array" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="put_array" href="#hikari.internal.data_binding.JSONObjectBuilder.put_array" id="hikari.internal.data_binding.JSONObjectBuilder.put_array">put_array</a>(
    key: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    values: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[T]],
    /,
    *,
    conversion: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[T], <a href='#hikari.internal.data_binding.JSONish'>JSONish</a>]] = None,
) -> None: ...</code></pre>
</dt>
<dd>
<p>Put a JSON array.</p>
<p>If the value is <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> it will not be stored.</p>
<p>If provided, a conversion will be applied to each item.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The key to give the element.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[T]]</code></dt>
<dd>The JSON types to put. This may be an iterable of non-JSON types if
a conversion is also specified. This may alternatively be undefined.
In the latter case, nothing is performed.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>conversion</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='https://docs.python.org/3/library/typing.html#typing.Any'>Any</a>], JSONType]]</code></dt>
<dd>The optional conversion to apply.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/internal/data_binding.py#L220-L252" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def put_array(
    self,
    key: str,
    values: undefined.UndefinedOr[typing.Iterable[T]],
    /,
    *,
    conversion: typing.Optional[typing.Callable[[T], JSONish]] = None,
) -&gt; None:
    &#34;&#34;&#34;Put a JSON array.

    If the value is `hikari.undefined.UNDEFINED` it will not be stored.

    If provided, a conversion will be applied to each item.

    Parameters
    ----------
    key : builtins.str
        The key to give the element.
    values : hikari.undefined.UndefinedOr[typing.Iterable[T]]
        The JSON types to put. This may be an iterable of non-JSON types if
        a conversion is also specified. This may alternatively be undefined.
        In the latter case, nothing is performed.

    Other Parameters
    ----------------
    conversion : typing.Optional[typing.Callable[[typing.Any], JSONType]]
        The optional conversion to apply.
    &#34;&#34;&#34;
    if values is not undefined.UNDEFINED:
        if conversion is not None:
            self[key] = [conversion(value) for value in values]
        else:
            self[key] = list(values)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.internal.data_binding.JSONObjectBuilder.put_snowflake" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="put_snowflake" href="#hikari.internal.data_binding.JSONObjectBuilder.put_snowflake" id="hikari.internal.data_binding.JSONObjectBuilder.put_snowflake">put_snowflake</a>(
    key: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    value: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]],
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p>Put a key with a snowflake value into the builder.</p>
<p>If the value is <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> it will not be stored.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The key to give the element.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]</code></dt>
<dd>The JSON type to put. This may alternatively be undefined, in this
case, nothing is performed. This may also be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, in this
case the value isn't cast.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/internal/data_binding.py#L254-L273" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def put_snowflake(
    self, key: str, value: undefined.UndefinedNoneOr[snowflakes.SnowflakeishOr[snowflakes.Unique]], /
) -&gt; None:
    &#34;&#34;&#34;Put a key with a snowflake value into the builder.

    If the value is `hikari.undefined.UNDEFINED` it will not be stored.

    Parameters
    ----------
    key : builtins.str
        The key to give the element.
    value : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]
        The JSON type to put. This may alternatively be undefined, in this
        case, nothing is performed. This may also be `builtins.None`, in this
        case the value isn&#39;t cast.
    &#34;&#34;&#34;
    if value is not undefined.UNDEFINED and value is not None:
        self[key] = str(int(value))
    elif value is None:
        self[key] = value</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="put_snowflake_array" href="#hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array" id="hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array">put_snowflake_array</a>(
    key: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    values: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>snowflakes.Unique</a>]]],
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p>Put an array of snowflakes with the given key into this builder.</p>
<p>If the value is <code><a href='../undefined.html#hikari.undefined.UNDEFINED'>UNDEFINED</a></code> it will not be stored.</p>
<p>Each snowflake should be castable to an <code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The key to give the element.</dd>
<dt><strong><code>values</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Iterable'>Iterable</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../snowflakes.html#hikari.snowflakes.Unique'>Unique</a>]]]</code></dt>
<dd>The JSON snowflakes to put. This may alternatively be undefined.
In the latter case, nothing is performed.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/internal/data_binding.py#L275-L296" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def put_snowflake_array(
    self,
    key: str,
    values: undefined.UndefinedOr[typing.Iterable[snowflakes.SnowflakeishOr[snowflakes.Unique]]],
    /,
) -&gt; None:
    &#34;&#34;&#34;Put an array of snowflakes with the given key into this builder.

    If the value is `hikari.undefined.UNDEFINED` it will not be stored.

    Each snowflake should be castable to an `builtins.int`.

    Parameters
    ----------
    key : builtins.str
        The key to give the element.
    values : hikari.undefined.UndefinedOr[typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique]]]
        The JSON snowflakes to put. This may alternatively be undefined.
        In the latter case, nothing is performed.
    &#34;&#34;&#34;  # noqa: E501 - Line too long
    if values is not undefined.UNDEFINED:
        self[key] = [str(int(value)) for value in values]</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</dl>
</section>
</div>
</div>
</div>
<!-- Search script and dependencies -->
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../search.html#' + encodeURIComponent(query);
window.location.href = url;
};
</script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>