URLS=[
"index.html",
"snowflakes.html",
"files.html",
"errors.html",
"events/guild_events.html",
"events/shard_events.html",
"events/base_events.html",
"traits.html",
"iterators.html",
"events/channel_events.html",
"channels.html",
"events/message_events.html",
"events/reaction_events.html",
"events/typing_events.html",
"embeds.html",
"guilds.html",
"invites.html",
"emojis.html",
"events/member_events.html",
"audit_logs.html",
"messages.html",
"users.html",
"presences.html",
"colours.html",
"applications.html",
"events/index.html",
"events/lifetime_events.html",
"events/role_events.html",
"events/user_events.html",
"events/voice_events.html",
"urls.html",
"permissions.html",
"colors.html",
"cli.html",
"internal/index.html",
"internal/cache.html",
"internal/spel.html",
"internal/data_binding.html",
"internal/net.html",
"internal/routes.html",
"internal/time.html",
"internal/aio.html",
"internal/ux.html",
"internal/collections.html",
"internal/attr_extensions.html",
"internal/enums.html",
"internal/reflect.html",
"intents.html",
"api/index.html",
"api/voice.html",
"api/cache.html",
"api/rest.html",
"api/chunker.html",
"api/special_endpoints.html",
"api/event_factory.html",
"api/entity_factory.html",
"api/event_dispatcher.html",
"api/shard.html",
"config.html",
"sessions.html",
"undefined.html",
"impl/index.html",
"impl/voice.html",
"impl/bot.html",
"impl/stateless_guild_chunker.html",
"impl/rest.html",
"impl/stateful_cache.html",
"impl/buckets.html",
"impl/rate_limits.html",
"impl/stateful_guild_chunker.html",
"event_stream.html",
"impl/special_endpoints.html",
"impl/event_factory.html",
"impl/stateful_event_manager.html",
"impl/event_manager_base.html",
"impl/entity_factory.html",
"impl/stateless_cache.html",
"impl/stateless_event_manager.html",
"impl/shard.html",
"voices.html",
"webhooks.html"
];
INDEX=[
{
"ref":"hikari.Application.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.Attachment.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.Attachment.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.Attachment.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.Attachment.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.AuditLogEntry.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.BadRequestError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.BadRequestError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.BadRequestError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.BadRequestError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.BadRequestError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.BanCreateEvent.fetch_user",
"url":4,
"doc":"Perform an API call to fetch the user this ban event affects. Returns    - hikari.users.User The user affected by this event.",
"func":1
},
{
"ref":"hikari.BanCreateEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.BanCreateEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.BanCreateEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.BanDeleteEvent.fetch_user",
"url":4,
"doc":"Perform an API call to fetch the user this ban event affects. Returns    - hikari.users.User The user affected by this event.",
"func":1
},
{
"ref":"hikari.BanDeleteEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.BanDeleteEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.BanDeleteEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.BanEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.BanEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.BanEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.BanEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.BanEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.BanEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.BotAware.rest",
"url":7,
"doc":"Return the REST client to use for HTTP requests. Returns    - hikari.api.rest.RESTClient The REST client to use."
},
{
"ref":"hikari.BotAware.entity_factory",
"url":7,
"doc":"Return the entity factory implementation for this object. Returns    - hikari.api.entity_factory.EntityFactory The entity factory component."
},
{
"ref":"hikari.BotAware.http_settings",
"url":7,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.BotAware.proxy_settings",
"url":7,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.BotAware.executor",
"url":7,
"doc":"Return the executor to use for blocking operations. This may return  builtins.None if the default  asyncio thread pool should be used instead. Returns    - typing.Optional[concurrent.futures.Executor] The executor to use, or  builtins.None to use the  asyncio default instead."
},
{
"ref":"hikari.BotAware.cache",
"url":7,
"doc":"Return the immutable cache implementation for this object. Returns    - hikari.api.cache.Cache The cache component for this object."
},
{
"ref":"hikari.BotAware.me",
"url":7,
"doc":"Return the bot user, if known. This should be available as soon as the bot has fired the  hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be  builtins.None . Returns    - typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise  builtins.None ."
},
{
"ref":"hikari.BotAware.heartbeat_latencies",
"url":7,
"doc":"Return a mapping of shard ID to heartbeat latency. Any shards that are not yet started will be  float('nan') . Returns    - typing.Mapping[builtins.int, builtins.float] Each shard ID mapped to the corresponding heartbeat latency. Each latency is measured in seconds."
},
{
"ref":"hikari.BotAware.heartbeat_latency",
"url":7,
"doc":"Return the average heartbeat latency of all started shards. If no shards are started, this will return  float('nan') . Returns    - builtins.float The average heartbeat latency of all started shards, or  float('nan') if no shards are started. This is measured in seconds."
},
{
"ref":"hikari.BotAware.intents",
"url":7,
"doc":"Return the intents registered for the application. Returns    - hikari.intents.Intents The intents registered on this application."
},
{
"ref":"hikari.BotAware.shards",
"url":7,
"doc":"Return a mapping of shards in this application instance. Each shard ID is mapped to the corresponding shard instance. If the application has not started, it is acceptable to assume the result of this call will be an empty mapping. Returns    - typing.Mapping[int, hikari.api.shard.GatewayShard] The shard mapping."
},
{
"ref":"hikari.BotAware.shard_count",
"url":7,
"doc":"Return the number of shards in the total application. This may not be the same as the size of  shards . If the application is auto-sharded, this may be  0 until the shards are started. Returns    - builtins.int The number of shards in the total application."
},
{
"ref":"hikari.BotAware.update_presence",
"url":7,
"doc":"Update the presence on all shards. This call will patch the presence on each shard. This means that unless you explicitly specify a parameter, the previous value will be retained. This means you do not have to track the global presence in your code. Other Parameters         idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed. afk : hikari.undefined.UndefinedOr[builtins.bool] If  builtins.True , the user is marked as AFK. If  builtins.False , the user is marked as being active. If undefined, this will not be changed. activity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed. status : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed.  ! note This will only send the update payloads to shards that are alive. Any shards that are not alive will cache the new presence for when they do start.  ! note If you want to set presences per shard, access the shard you wish to update (e.g. by using  BotApp.shards ), and call  hikari.api.shard.GatewayShard.update_presence on that shard. This method is simply a facade to make performing this in bulk simpler.",
"func":1
},
{
"ref":"hikari.BotAware.chunker",
"url":7,
"doc":"Return the guild chunker component. Returns    - hikari.api.chunker.GuildChunker The guild chunker component."
},
{
"ref":"hikari.BotAware.voice",
"url":7,
"doc":"Return the voice connection manager component for this application. Returns    - hikari.api.voice.VoiceComponent The voice component for the application."
},
{
"ref":"hikari.BotAware.event_factory",
"url":7,
"doc":"Return the event factory component. Returns    - hikari.api.event_factory.EventFactory The event factory component."
},
{
"ref":"hikari.BotAware.dispatcher",
"url":7,
"doc":"Return the event dispatcher for this object. Returns    - hikari.api.event_dispatcher.EventDispatcher The event dispatcher component."
},
{
"ref":"hikari.BufferedLazyIterator.chunk",
"url":8,
"doc":"Return results in chunks of up to  chunk_size amount of entries. Parameters      chunk_size : int The limit for how many results should be returned in each chunk. Returns    - LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.map",
"url":8,
"doc":"Map the values to a different value. Parameters      transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the  . operator. Returns    - LazyIterator[AnotherValueT]  LazyIterator that maps each value to another value.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.for_each",
"url":8,
"doc":"Pass each value to a given consumer immediately.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.filter",
"url":8,
"doc":"Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item that this iterator would return when it is requested. All conditions must evaluate to  builtins.True for the item to be returned. If this is not met, then the item is discared and ignored, the next matching item will be returned instead, if there is one. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.filter \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT]  LazyIterator that only emits values where all conditions are matched.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.take_while",
"url":8,
"doc":"Return each item until any conditions fail or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.take_until",
"url":8,
"doc":"Return each item until any conditions pass or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.skip_while",
"url":8,
"doc":"Discard items while all conditions are True. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.skip_until",
"url":8,
"doc":"Discard items while all conditions are False. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.enumerate",
"url":8,
"doc":"Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of  builtins.enumerate which uses much less memory than collecting all the results first and calling  builtins.enumerate across them. Parameters      start : builtins.int Optional int to start at. If omitted, this is  0 . Examples     >>> async for i, item in paginated_results.enumerate():  . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9):  . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3):  . print(i, item) (9, foo) (10, bar) (11, baz) Returns    - LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.limit",
"url":8,
"doc":"Limit the number of items you receive from this async iterator. Parameters      limit : builtins.int The number of items to get. This must be greater than zero. Examples     >>> async for item in paginated_results.limit(3):  . print(item) Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.skip",
"url":8,
"doc":"Drop the given number of items, then yield anything after. Parameters      number : builtins.int The max number of items to drop before any items are yielded. Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.next",
"url":8,
"doc":"Return the next element of this iterator only. Returns    - ValueT The next result. Raises    builtins.LookupError If no more results exist.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.last",
"url":8,
"doc":"Return the last element of this iterator only. Returns    - ValueT The last result.  ! note This method will consume the whole iterator if run. Raises    builtins.LookupError If no result exists.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.reversed",
"url":8,
"doc":"Return a lazy iterator of the remainder of this iterator's values reversed. Returns    - LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.sort",
"url":8,
"doc":"Collect all results, then sort the collection before returning it.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.collect",
"url":8,
"doc":"Collect the results into a given type and return it. Parameters      collector A function that consumes a sequence of values and returns a collection.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.count",
"url":8,
"doc":"Count the number of results. Returns    - builtins.int Number of results found.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.flat_map",
"url":8,
"doc":"Perform a flat mapping operation. This will pass each item in the iterator to the given  function parameter, expecting a new  typing.Iterable or  typing.AsyncIterator to be returned as the result. This means you can map to a new  LazyIterator ,  typing.AsyncIterator ,  typing.Iterable , async generator, or generator. Remember that  typing.Iterator implicitly provides  typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement reactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded lazily. Parameters      flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example    - The following example generates a distinct collection of all mentioned users in the given channel from the past 500 messages.   def iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\" \", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct() )   Returns    - LazyIterator[AnotherValueT] The new lazy iterator to return.",
"func":1
},
{
"ref":"hikari.BufferedLazyIterator.awaiting",
"url":8,
"doc":"Await each item concurrently in a fixed size window. Parameters      window_size : int The window size of how many tasks to await at once. You can set this to  0 to await everything at once, but see the below warning. Returns    - LazyIterator[ValueT] The new lazy iterator to return.  ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the  fetch_user endpoint seems to be notorious for doing this).  ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a  builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.",
"func":1
},
{
"ref":"hikari.Bytes.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.Bytes.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.ChannelCreateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.PartialChannel A derivative of  hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.ChannelCreateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ChannelCreateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.ChannelDeleteEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.PartialChannel A derivative of  hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.ChannelDeleteEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ChannelDeleteEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.ChannelEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ChannelEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.ChannelOverwriteEntryInfo.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.ChannelUpdateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.PartialChannel A derivative of  hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.ChannelUpdateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ChannelUpdateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.CustomEmoji.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.CustomEmoji.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.CustomEmoji.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.CustomEmoji.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.DMChannel.last_message_id",
"url":10,
"doc":"The ID of the last message sent in this channel.  ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."
},
{
"ref":"hikari.DMChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.DMChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.DMChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.DMChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.DMChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.DMChannel.history",
"url":10,
"doc":"Browse the message history for a given text channel. Other Parameters         before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises    builtins.TypeError If you specify more than one of  before ,  after ,  about . hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to read message history in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint (other than  builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than  builtins.TypeError ).",
"func":1
},
{
"ref":"hikari.DMChannel.send",
"url":10,
"doc":"Create a message in the channel this message belongs to. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.DMChannel.trigger_typing",
"url":10,
"doc":"Trigger typing in a given channel. This returns an object that can either be  await ed to trigger typing once, or used as an async context manager to keep typing until the block completes.   await channel.trigger_typing()  type for 10s async with channel.trigger_typing(): await asyncio.sleep(35)  keep typing until this finishes    ! note Sending a message to this channel will stop the typing indicator. If using an  async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns    - hikari.api.special_endpoints.TypingIndicator The typing indicator object.",
"func":1
},
{
"ref":"hikari.DMChannelEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.DMChannelEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.DMChannelEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.DMMessageCreateEvent.author",
"url":11,
"doc":"User that sent the message. Returns    - hikari.users.User The user that sent the message."
},
{
"ref":"hikari.DMMessageCreateEvent.author_id",
"url":11,
"doc":"ID of the author of the message this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the author."
},
{
"ref":"hikari.DMMessageCreateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.DMMessageCreateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - typing.Optional[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent)."
},
{
"ref":"hikari.DMMessageCreateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - typing.Sequence[hikari.embeds.Embed] The embeds in the message."
},
{
"ref":"hikari.DMMessageCreateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - builtins.bool  builtins.True if from a bot, or  builtins.False otherwise."
},
{
"ref":"hikari.DMMessageCreateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - builtins.bool  builtins.True if from a human user, or  builtins.False otherwise."
},
{
"ref":"hikari.DMMessageCreateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.DMMessageCreateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.DMMessageDeleteEvent.channel",
"url":11,
"doc":"Get the cached channel the messages were sent in, if known. Returns    - typing.Union[builtins.None, hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel] The channel the messages were sent in, or  builtins.None if not known/cached. This otherwise will always be a  hikari.channels.GuildTextChannel if it is a normal message, or  hikari.channels.GuildNewsChannel if sent in an announcement channel."
},
{
"ref":"hikari.DMMessageDeleteEvent.message_id",
"url":11,
"doc":"Get the ID of the first deleted message. This is contextually useful if you know this is not a bulk deletion event. For all other purposes, this is the same as running  next(iter(event.message_ids  . Returns    - hikari.snowflakes.Snowflake The first deleted message ID."
},
{
"ref":"hikari.DMMessageUpdateEvent.author",
"url":11,
"doc":"User that sent the message. Returns    - typing.Optional[hikari.users.User] The user that sent the message. This will be  builtins.None in some cases, such as when Discord updates a message with an embed for a URL preview."
},
{
"ref":"hikari.DMMessageUpdateEvent.author_id",
"url":11,
"doc":"ID of the author that triggered this event. Returns    - typing.Optional[hikari.snowflakes.Snowflake] The ID of the author that triggered this event concerns. This will be  builtins.None in some cases, such as when Discord updates a message with an embed for a URL preview."
},
{
"ref":"hikari.DMMessageUpdateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.DMMessageUpdateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - hikari.undefined.UndefinedNoneOr[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent). If not part of the update, then this will be  hikari.undefined.UNDEFINED instead."
},
{
"ref":"hikari.DMMessageUpdateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed The embeds in the message. If the embeds were not changed in this event, then this may instead be  hikari.undefined.UNDEFINED ."
},
{
"ref":"hikari.DMMessageUpdateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - typing.Optional[builtins.bool]  builtins.True if from a bot, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this will return  builtins.None instead."
},
{
"ref":"hikari.DMMessageUpdateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - typing.Optional[builtins.bool]  builtins.True if from a human user, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this may return  builtins.None instead."
},
{
"ref":"hikari.DMMessageUpdateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.DMMessageUpdateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.DMPinsUpdateEvent.fetch_pins",
"url":9,
"doc":"Perform an API call to fetch the pinned messages in this channel. Returns    - typing.Sequence[hikari.messages.Message] The pinned messages in this channel.",
"func":1
},
{
"ref":"hikari.DMReactionEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.DMReactionEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.DMReactionEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.DMReactionEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.DMTypingEvent.trigger_typing",
"url":13,
"doc":"Return a typing indicator for this channel that can be awaited. Returns    - hikari.api.special_endpoints.TypingIndicator A typing indicator context manager and awaitable to trigger typing in a channel with.",
"func":1
},
{
"ref":"hikari.EmbedImage.proxy_resource",
"url":14,
"doc":"The proxied version of the resource, or  builtins.None if not present.  ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."
},
{
"ref":"hikari.EmbedImage.url",
"url":14,
"doc":"URL of the resource."
},
{
"ref":"hikari.EmbedImage.filename",
"url":14,
"doc":"Filename of the resource."
},
{
"ref":"hikari.EmbedImage.stream",
"url":14,
"doc":"Produce a stream of data for the resource. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.",
"func":1
},
{
"ref":"hikari.EmbedImage.resource",
"url":14,
"doc":"The resource this object wraps around."
},
{
"ref":"hikari.EmbedImage.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.EmbedImage.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.EmbedResource.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.EmbedResource.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.EmbedResourceWithProxy.url",
"url":14,
"doc":"URL of the resource."
},
{
"ref":"hikari.EmbedResourceWithProxy.filename",
"url":14,
"doc":"Filename of the resource."
},
{
"ref":"hikari.EmbedResourceWithProxy.stream",
"url":14,
"doc":"Produce a stream of data for the resource. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.",
"func":1
},
{
"ref":"hikari.EmbedResourceWithProxy.resource",
"url":14,
"doc":"The resource this object wraps around."
},
{
"ref":"hikari.EmbedResourceWithProxy.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.EmbedResourceWithProxy.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.EmbedVideo.url",
"url":14,
"doc":"URL of the resource."
},
{
"ref":"hikari.EmbedVideo.filename",
"url":14,
"doc":"Filename of the resource."
},
{
"ref":"hikari.EmbedVideo.stream",
"url":14,
"doc":"Produce a stream of data for the resource. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.",
"func":1
},
{
"ref":"hikari.EmbedVideo.resource",
"url":14,
"doc":"The resource this object wraps around."
},
{
"ref":"hikari.EmbedVideo.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.EmbedVideo.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.Emoji.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.Emoji.filename",
"url":2,
"doc":"Filename of the resource."
},
{
"ref":"hikari.Emoji.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.Emoji.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.EmojisUpdateEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.EmojisUpdateEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.EmojisUpdateEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.File.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.File.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.chunk",
"url":8,
"doc":"Return results in chunks of up to  chunk_size amount of entries. Parameters      chunk_size : int The limit for how many results should be returned in each chunk. Returns    - LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.map",
"url":8,
"doc":"Map the values to a different value. Parameters      transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the  . operator. Returns    - LazyIterator[AnotherValueT]  LazyIterator that maps each value to another value.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.for_each",
"url":8,
"doc":"Pass each value to a given consumer immediately.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.filter",
"url":8,
"doc":"Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item that this iterator would return when it is requested. All conditions must evaluate to  builtins.True for the item to be returned. If this is not met, then the item is discared and ignored, the next matching item will be returned instead, if there is one. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.filter \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT]  LazyIterator that only emits values where all conditions are matched.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.take_while",
"url":8,
"doc":"Return each item until any conditions fail or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.take_until",
"url":8,
"doc":"Return each item until any conditions pass or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.skip_while",
"url":8,
"doc":"Discard items while all conditions are True. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.skip_until",
"url":8,
"doc":"Discard items while all conditions are False. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.enumerate",
"url":8,
"doc":"Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of  builtins.enumerate which uses much less memory than collecting all the results first and calling  builtins.enumerate across them. Parameters      start : builtins.int Optional int to start at. If omitted, this is  0 . Examples     >>> async for i, item in paginated_results.enumerate():  . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9):  . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3):  . print(i, item) (9, foo) (10, bar) (11, baz) Returns    - LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.limit",
"url":8,
"doc":"Limit the number of items you receive from this async iterator. Parameters      limit : builtins.int The number of items to get. This must be greater than zero. Examples     >>> async for item in paginated_results.limit(3):  . print(item) Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.skip",
"url":8,
"doc":"Drop the given number of items, then yield anything after. Parameters      number : builtins.int The max number of items to drop before any items are yielded. Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.next",
"url":8,
"doc":"Return the next element of this iterator only. Returns    - ValueT The next result. Raises    builtins.LookupError If no more results exist.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.last",
"url":8,
"doc":"Return the last element of this iterator only. Returns    - ValueT The last result.  ! note This method will consume the whole iterator if run. Raises    builtins.LookupError If no result exists.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.reversed",
"url":8,
"doc":"Return a lazy iterator of the remainder of this iterator's values reversed. Returns    - LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.sort",
"url":8,
"doc":"Collect all results, then sort the collection before returning it.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.collect",
"url":8,
"doc":"Collect the results into a given type and return it. Parameters      collector A function that consumes a sequence of values and returns a collection.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.count",
"url":8,
"doc":"Count the number of results. Returns    - builtins.int Number of results found.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.flat_map",
"url":8,
"doc":"Perform a flat mapping operation. This will pass each item in the iterator to the given  function parameter, expecting a new  typing.Iterable or  typing.AsyncIterator to be returned as the result. This means you can map to a new  LazyIterator ,  typing.AsyncIterator ,  typing.Iterable , async generator, or generator. Remember that  typing.Iterator implicitly provides  typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement reactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded lazily. Parameters      flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example    - The following example generates a distinct collection of all mentioned users in the given channel from the past 500 messages.   def iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\" \", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct() )   Returns    - LazyIterator[AnotherValueT] The new lazy iterator to return.",
"func":1
},
{
"ref":"hikari.FlatLazyIterator.awaiting",
"url":8,
"doc":"Await each item concurrently in a fixed size window. Parameters      window_size : int The window size of how many tasks to await at once. You can set this to  0 to await everything at once, but see the below warning. Returns    - LazyIterator[ValueT] The new lazy iterator to return.  ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the  fetch_user endpoint seems to be notorious for doing this).  ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a  builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.",
"func":1
},
{
"ref":"hikari.ForbiddenError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.ForbiddenError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.ForbiddenError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.ForbiddenError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.ForbiddenError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.GatewayGuild.banner_url",
"url":15,
"doc":"Banner for the guild, if set."
},
{
"ref":"hikari.GatewayGuild.discovery_splash_url",
"url":15,
"doc":"Discovery splash for the guild, if set."
},
{
"ref":"hikari.GatewayGuild.splash_url",
"url":15,
"doc":"Splash for the guild, if set."
},
{
"ref":"hikari.GatewayGuild.format_banner",
"url":15,
"doc":"Generate the guild's banner image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL of the banner, or  builtins.None if no banner is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.GatewayGuild.format_discovery_splash",
"url":15,
"doc":"Generate the guild's discovery splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The string URL. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.GatewayGuild.format_splash",
"url":15,
"doc":"Generate the guild's splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the splash, or  builtins.None if not set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.GatewayGuild.afk_channel_id",
"url":15,
"doc":"The ID for the channel that AFK voice users get sent to. If  builtins.None , then no AFK channel is set up for this guild."
},
{
"ref":"hikari.GatewayGuild.afk_timeout",
"url":15,
"doc":"Timeout for activity before a member is classed as AFK. How long a voice user has to be AFK for before they are classed as being AFK and are moved to the AFK channel ( Guild.afk_channel_id )."
},
{
"ref":"hikari.GatewayGuild.application_id",
"url":15,
"doc":"The ID of the application that created this guild. This will always be  builtins.None for guilds that weren't created by a bot."
},
{
"ref":"hikari.GatewayGuild.banner_hash",
"url":15,
"doc":"The hash for the guild's banner. This is only present if the guild has  GuildFeature.BANNER in  Guild.features for this guild. For all other purposes, it is  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.default_message_notifications",
"url":15,
"doc":"The default setting for message notifications in this guild."
},
{
"ref":"hikari.GatewayGuild.description",
"url":15,
"doc":"The guild's description. This is only present if certain  GuildFeature 's are set in  Guild.features for this guild. Otherwise, this will always be  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.discovery_splash_hash",
"url":15,
"doc":"The hash of the discovery splash for the guild, if there is one."
},
{
"ref":"hikari.GatewayGuild.explicit_content_filter",
"url":15,
"doc":"The setting for the explicit content filter in this guild."
},
{
"ref":"hikari.GatewayGuild.is_widget_enabled",
"url":15,
"doc":"Describes whether the guild widget is enabled or not. If this information is not present, this will be  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.max_video_channel_users",
"url":15,
"doc":"The maximum number of users allowed in a video channel together. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.mfa_level",
"url":15,
"doc":"The required MFA level for users wishing to participate in this guild."
},
{
"ref":"hikari.GatewayGuild.owner_id",
"url":15,
"doc":"The ID of the owner of this guild."
},
{
"ref":"hikari.GatewayGuild.preferred_locale",
"url":15,
"doc":"The preferred locale to use for this guild. This can only be change if  GuildFeature.PUBLIC is in  Guild.features for this guild and will otherwise default to  en-US ."
},
{
"ref":"hikari.GatewayGuild.premium_subscription_count",
"url":15,
"doc":"The number of nitro boosts that the server currently has. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.premium_tier",
"url":15,
"doc":"The premium tier for this guild."
},
{
"ref":"hikari.GatewayGuild.public_updates_channel_id",
"url":15,
"doc":"The channel ID of the channel where admins and moderators receive notices from Discord. This is only present if  GuildFeature.PUBLIC is in  Guild.features for this guild. For all other purposes, it should be considered to be  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.region",
"url":15,
"doc":"The voice region for the guild."
},
{
"ref":"hikari.GatewayGuild.rules_channel_id",
"url":15,
"doc":"The ID of the channel where guilds with the  GuildFeature.PUBLIC  features display rules and guidelines. If the  GuildFeature.PUBLIC feature is not defined, then this is  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.splash_hash",
"url":15,
"doc":"The hash of the splash for the guild, if there is one."
},
{
"ref":"hikari.GatewayGuild.system_channel_flags",
"url":15,
"doc":"Return flags for the guild system channel. These are used to describe which notifications are suppressed. Returns    - GuildSystemChannelFlag The system channel flags for this channel."
},
{
"ref":"hikari.GatewayGuild.system_channel_id",
"url":15,
"doc":"The ID of the system channel or  builtins.None if it is not enabled. Welcome messages and Nitro boost messages may be sent to this channel."
},
{
"ref":"hikari.GatewayGuild.vanity_url_code",
"url":15,
"doc":"The vanity URL code for the guild's vanity URL. This is only present if  GuildFeature.VANITY_URL is in  Guild.features for this guild. If not, this will always be  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.verification_level",
"url":15,
"doc":"The verification level needed for a user to participate in this guild."
},
{
"ref":"hikari.GatewayGuild.widget_channel_id",
"url":15,
"doc":"The channel ID that the widget's generated invite will send the user to. If this information is unavailable or this is not enabled for the guild then this will be  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.GatewayGuild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.GatewayGuild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.GatewayGuild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.GatewayGuild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.GatewayGuild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.GatewayGuild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.GatewayGuild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.GatewayGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.GatewayServerClosedConnectionError.reason",
"url":3,
"doc":"A string to explain the issue."
},
{
"ref":"hikari.GroupDMChannel.last_message_id",
"url":10,
"doc":"The ID of the last message sent in this channel.  ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."
},
{
"ref":"hikari.GroupDMChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.GroupDMChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.GroupDMChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.GroupDMChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.GroupDMChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.Guild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.Guild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.Guild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.Guild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.Guild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.Guild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.Guild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.Guild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.Guild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.GuildAvailableEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildAvailableEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildCategory.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.GuildCategory.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.GuildCategory.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.GuildCategory.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.GuildCategory.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.GuildCategory.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.GuildChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.GuildChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.GuildChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.GuildChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.GuildChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.GuildChannelCreateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.GuildChannelCreateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildChannelCreateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.GuildChannelCreateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.GuildChannelDeleteEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.GuildChannelDeleteEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildChannelDeleteEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.GuildChannelDeleteEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.GuildChannelEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.GuildChannelEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.GuildChannelEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.GuildChannelUpdateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.GuildChannelUpdateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildChannelUpdateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.GuildChannelUpdateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.GuildEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.GuildEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.GuildLeaveEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.GuildLeaveEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildLeaveEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildMessageCreateEvent.author_id",
"url":11,
"doc":"ID of the author of the message this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the author."
},
{
"ref":"hikari.GuildMessageCreateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.GuildMessageCreateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - typing.Optional[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent)."
},
{
"ref":"hikari.GuildMessageCreateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - typing.Sequence[hikari.embeds.Embed] The embeds in the message."
},
{
"ref":"hikari.GuildMessageCreateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - builtins.bool  builtins.True if from a bot, or  builtins.False otherwise."
},
{
"ref":"hikari.GuildMessageCreateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - builtins.bool  builtins.True if from a human user, or  builtins.False otherwise."
},
{
"ref":"hikari.GuildMessageCreateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.GuildMessageCreateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.GuildMessageDeleteEvent.channel",
"url":11,
"doc":"Get the cached channel the messages were sent in, if known. Returns    - typing.Union[builtins.None, hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel] The channel the messages were sent in, or  builtins.None if not known/cached. This otherwise will always be a  hikari.channels.GuildTextChannel if it is a normal message, or  hikari.channels.GuildNewsChannel if sent in an announcement channel."
},
{
"ref":"hikari.GuildMessageDeleteEvent.message_id",
"url":11,
"doc":"Get the ID of the first deleted message. This is contextually useful if you know this is not a bulk deletion event. For all other purposes, this is the same as running  next(iter(event.message_ids  . Returns    - hikari.snowflakes.Snowflake The first deleted message ID."
},
{
"ref":"hikari.GuildMessageUpdateEvent.author_id",
"url":11,
"doc":"ID of the author that triggered this event. Returns    - typing.Optional[hikari.snowflakes.Snowflake] The ID of the author that triggered this event concerns. This will be  builtins.None in some cases, such as when Discord updates a message with an embed for a URL preview."
},
{
"ref":"hikari.GuildMessageUpdateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.GuildMessageUpdateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - hikari.undefined.UndefinedNoneOr[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent). If not part of the update, then this will be  hikari.undefined.UNDEFINED instead."
},
{
"ref":"hikari.GuildMessageUpdateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed The embeds in the message. If the embeds were not changed in this event, then this may instead be  hikari.undefined.UNDEFINED ."
},
{
"ref":"hikari.GuildMessageUpdateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - typing.Optional[builtins.bool]  builtins.True if from a bot, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this will return  builtins.None instead."
},
{
"ref":"hikari.GuildMessageUpdateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - typing.Optional[builtins.bool]  builtins.True if from a human user, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this may return  builtins.None instead."
},
{
"ref":"hikari.GuildMessageUpdateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.GuildMessageUpdateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.GuildNewsChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.GuildNewsChannel.guild_id",
"url":10,
"doc":"The ID of the guild the channel belongs to."
},
{
"ref":"hikari.GuildNewsChannel.is_nsfw",
"url":10,
"doc":"Whether the channel is marked as NSFW.  ! warning This will be  builtins.None when received over the gateway in certain events (e.g Guild Create)."
},
{
"ref":"hikari.GuildNewsChannel.parent_id",
"url":10,
"doc":"The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be  builtins.None ."
},
{
"ref":"hikari.GuildNewsChannel.permission_overwrites",
"url":10,
"doc":"The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."
},
{
"ref":"hikari.GuildNewsChannel.position",
"url":10,
"doc":"The sorting position of the channel. Higher numbers appear further down the channel list."
},
{
"ref":"hikari.GuildNewsChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.GuildNewsChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.GuildNewsChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.GuildNewsChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.GuildNewsChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.GuildNewsChannel.history",
"url":10,
"doc":"Browse the message history for a given text channel. Other Parameters         before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises    builtins.TypeError If you specify more than one of  before ,  after ,  about . hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to read message history in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint (other than  builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than  builtins.TypeError ).",
"func":1
},
{
"ref":"hikari.GuildNewsChannel.send",
"url":10,
"doc":"Create a message in the channel this message belongs to. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.GuildNewsChannel.trigger_typing",
"url":10,
"doc":"Trigger typing in a given channel. This returns an object that can either be  await ed to trigger typing once, or used as an async context manager to keep typing until the block completes.   await channel.trigger_typing()  type for 10s async with channel.trigger_typing(): await asyncio.sleep(35)  keep typing until this finishes    ! note Sending a message to this channel will stop the typing indicator. If using an  async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns    - hikari.api.special_endpoints.TypingIndicator The typing indicator object.",
"func":1
},
{
"ref":"hikari.GuildPinsUpdateEvent.fetch_pins",
"url":9,
"doc":"Perform an API call to fetch the pinned messages in this channel. Returns    - typing.Sequence[hikari.messages.Message] The pinned messages in this channel.",
"func":1
},
{
"ref":"hikari.GuildPinsUpdateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.GuildPinsUpdateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildPreview.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.GuildPreview.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.GuildPreview.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.GuildPreview.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.GuildPreview.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.GuildPreview.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.GuildPreview.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.GuildPreview.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.GuildPreview.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.GuildReactionEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.GuildReactionEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.GuildReactionEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.GuildReactionEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.GuildStoreChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.GuildStoreChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.GuildStoreChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.GuildStoreChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.GuildStoreChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.GuildStoreChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.GuildTextChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.GuildTextChannel.guild_id",
"url":10,
"doc":"The ID of the guild the channel belongs to."
},
{
"ref":"hikari.GuildTextChannel.is_nsfw",
"url":10,
"doc":"Whether the channel is marked as NSFW.  ! warning This will be  builtins.None when received over the gateway in certain events (e.g Guild Create)."
},
{
"ref":"hikari.GuildTextChannel.parent_id",
"url":10,
"doc":"The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be  builtins.None ."
},
{
"ref":"hikari.GuildTextChannel.permission_overwrites",
"url":10,
"doc":"The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."
},
{
"ref":"hikari.GuildTextChannel.position",
"url":10,
"doc":"The sorting position of the channel. Higher numbers appear further down the channel list."
},
{
"ref":"hikari.GuildTextChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.GuildTextChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.GuildTextChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.GuildTextChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.GuildTextChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.GuildTextChannel.history",
"url":10,
"doc":"Browse the message history for a given text channel. Other Parameters         before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises    builtins.TypeError If you specify more than one of  before ,  after ,  about . hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to read message history in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint (other than  builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than  builtins.TypeError ).",
"func":1
},
{
"ref":"hikari.GuildTextChannel.send",
"url":10,
"doc":"Create a message in the channel this message belongs to. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.GuildTextChannel.trigger_typing",
"url":10,
"doc":"Trigger typing in a given channel. This returns an object that can either be  await ed to trigger typing once, or used as an async context manager to keep typing until the block completes.   await channel.trigger_typing()  type for 10s async with channel.trigger_typing(): await asyncio.sleep(35)  keep typing until this finishes    ! note Sending a message to this channel will stop the typing indicator. If using an  async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns    - hikari.api.special_endpoints.TypingIndicator The typing indicator object.",
"func":1
},
{
"ref":"hikari.GuildTypingEvent.trigger_typing",
"url":13,
"doc":"Return a typing indicator for this channel that can be awaited. Returns    - hikari.api.special_endpoints.TypingIndicator A typing indicator context manager and awaitable to trigger typing in a channel with.",
"func":1
},
{
"ref":"hikari.GuildUnavailableEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.GuildUnavailableEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildUnavailableEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildUpdateEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildUpdateEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildVisibilityEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.GuildVisibilityEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.GuildVisibilityEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildVisibilityEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.GuildVisibilityEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.GuildVisibilityEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.GuildVoiceChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.GuildVoiceChannel.guild_id",
"url":10,
"doc":"The ID of the guild the channel belongs to."
},
{
"ref":"hikari.GuildVoiceChannel.is_nsfw",
"url":10,
"doc":"Whether the channel is marked as NSFW.  ! warning This will be  builtins.None when received over the gateway in certain events (e.g Guild Create)."
},
{
"ref":"hikari.GuildVoiceChannel.parent_id",
"url":10,
"doc":"The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be  builtins.None ."
},
{
"ref":"hikari.GuildVoiceChannel.permission_overwrites",
"url":10,
"doc":"The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."
},
{
"ref":"hikari.GuildVoiceChannel.position",
"url":10,
"doc":"The sorting position of the channel. Higher numbers appear further down the channel list."
},
{
"ref":"hikari.GuildVoiceChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.GuildVoiceChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.GuildVoiceChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.GuildVoiceChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.GuildVoiceChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.Integration.account",
"url":15,
"doc":"The account connected to this integration."
},
{
"ref":"hikari.Integration.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.Integration.name",
"url":15,
"doc":"The name of this integration."
},
{
"ref":"hikari.Integration.type",
"url":15,
"doc":"The type of this integration."
},
{
"ref":"hikari.Integration.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.IntegrationsUpdateEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.IntegrationsUpdateEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.IntegrationsUpdateEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.InviteCreateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.InviteCreateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.InviteCreateEvent.channel",
"url":9,
"doc":"Get the cached channel that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return  builtins.None instead."
},
{
"ref":"hikari.InviteCreateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.InviteDeleteEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.InviteDeleteEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.InviteDeleteEvent.channel",
"url":9,
"doc":"Get the cached channel that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return  builtins.None instead."
},
{
"ref":"hikari.InviteDeleteEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.InviteGuild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.InviteGuild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.InviteGuild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.InviteGuild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.InviteGuild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.InviteGuild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.InviteGuild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.InviteGuild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.InviteGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.InviteWithMetadata.app",
"url":16,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.InviteWithMetadata.approximate_active_member_count",
"url":16,
"doc":"The approximate amount of presences in this invite's guild. This is only present when  with_counts is passed as  builtins.True to the GET Invites endpoint."
},
{
"ref":"hikari.InviteWithMetadata.approximate_member_count",
"url":16,
"doc":"The approximate amount of members in this invite's guild. This is only present when  with_counts is passed as  builtins.True to the GET Invites endpoint."
},
{
"ref":"hikari.InviteWithMetadata.channel",
"url":16,
"doc":"The partial object of the channel this invite targets. Will be  builtins.None for invite objects that are attached to gateway events, in which case you should refer to  Invite.channel_id ."
},
{
"ref":"hikari.InviteWithMetadata.channel_id",
"url":16,
"doc":"The ID of the channel this invite targets."
},
{
"ref":"hikari.InviteWithMetadata.code",
"url":16,
"doc":"The code for this invite."
},
{
"ref":"hikari.InviteWithMetadata.guild",
"url":16,
"doc":"The partial object of the guild this invite belongs to. Will be  builtins.None for group DM invites and when attached to a gateway event; for invites received over the gateway you should refer to  Invite.guild_id ."
},
{
"ref":"hikari.InviteWithMetadata.guild_id",
"url":16,
"doc":"The ID of the guild this invite belongs to. Will be  builtins.None for group DM invites."
},
{
"ref":"hikari.InviteWithMetadata.inviter",
"url":16,
"doc":"The object of the user who created this invite."
},
{
"ref":"hikari.InviteWithMetadata.target_user",
"url":16,
"doc":"The object of the user who this invite targets, if set."
},
{
"ref":"hikari.InviteWithMetadata.target_user_type",
"url":16,
"doc":"The type of user target this invite is, if applicable."
},
{
"ref":"hikari.KnownCustomEmoji.filename",
"url":17,
"doc":"Filename of the resource."
},
{
"ref":"hikari.KnownCustomEmoji.url_name",
"url":17,
"doc":"Name of the part of the emoji to use in requests."
},
{
"ref":"hikari.KnownCustomEmoji.mention",
"url":17,
"doc":"Mention string to use to mention the emoji with."
},
{
"ref":"hikari.KnownCustomEmoji.is_mentionable",
"url":17,
"doc":"Whether the emoji can be mentioned or not."
},
{
"ref":"hikari.KnownCustomEmoji.url",
"url":17,
"doc":"URL of the emoji image to display in clients."
},
{
"ref":"hikari.KnownCustomEmoji.parse",
"url":17,
"doc":"Parse a given string into an emoji object. Parameters      string : builtins.str The emoji object to parse. Returns    - Emoji The parsed emoji object. This will be a  CustomEmoji if a custom emoji ID or mention, or a  UnicodeEmoji otherwise. Raises    builtins.ValueError If a mention is given that has an invalid format.",
"func":1
},
{
"ref":"hikari.KnownCustomEmoji.id",
"url":17,
"doc":"The ID of this entity."
},
{
"ref":"hikari.KnownCustomEmoji.name",
"url":17,
"doc":"The name of the emoji."
},
{
"ref":"hikari.KnownCustomEmoji.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.KnownCustomEmoji.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.KnownCustomEmoji.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.KnownCustomEmoji.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.Member.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.MemberCreateEvent.user_id",
"url":18,
"doc":"ID of the user that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the user that this event relates to."
},
{
"ref":"hikari.MemberCreateEvent.guild",
"url":18,
"doc":"Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else  builtins.None ."
},
{
"ref":"hikari.MemberDeleteEvent.user_id",
"url":18,
"doc":"ID of the user that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the user that this event relates to."
},
{
"ref":"hikari.MemberDeleteEvent.guild",
"url":18,
"doc":"Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else  builtins.None ."
},
{
"ref":"hikari.MemberEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.MemberEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.MemberMoveEntryInfo.count",
"url":19,
"doc":"The amount of members who were disconnected from voice in this entry."
},
{
"ref":"hikari.MemberUpdateEvent.user_id",
"url":18,
"doc":"ID of the user that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the user that this event relates to."
},
{
"ref":"hikari.MemberUpdateEvent.guild",
"url":18,
"doc":"Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else  builtins.None ."
},
{
"ref":"hikari.Message.link",
"url":20,
"doc":"Jump link to the message. Returns    - builtins.str The jump link to the message."
},
{
"ref":"hikari.Message.fetch_channel",
"url":20,
"doc":"Fetch the channel this message was created in. Returns    - hikari.channels.PartialChannel The object of the channel this message belongs to. Raises    hikari.errors.BadRequestError If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. hikari.errors.ForbiddenError If you don't have access to the channel this message belongs to. hikari.errors.NotFoundError If the channel this message was created in does not exist.",
"func":1
},
{
"ref":"hikari.Message.edit",
"url":20,
"doc":"Edit an existing message in a given channel. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] The message content to update with. If  hikari.undefined.UNDEFINED , then the content will not be changed. If  builtins.None , then the content will be removed. Any other value will be cast to a  builtins.str before sending. If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Other Parameters         embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] The embed to set on the message. If  hikari.undefined.UNDEFINED , the previous embed if present is not changed. If this is  builtins.None , then the embed is removed if present. Otherwise, the new embed value that was provided will be used as the replacement. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] Sanitation for  @everyone mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , then  @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool Sanitation for user mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid user mentions will behave as mentions. If  builtins.False , all valid user mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake user IDs, or  hikari.users.PartialUser -derived objects. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool Sanitation for role mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid role mentions will behave as mentions. If  builtins.False , all valid role mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake role IDs, or  hikari.guilds.PartialRole -derived objects. flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag] Optional flags to set on the message. If  hikari.undefined.UNDEFINED , then nothing is changed. Note that some flags may not be able to be set. Currently the only flags that can be set are  NONE and  SUPPRESS_EMBEDS . If you have  MANAGE_MESSAGES permissions, you can use this call to suppress embeds on another user's message.  ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however.  ! note There is currently no documented way to clear attachments or edit attachments from a previously sent message on Discord's API. To do this,  delete the message and re-send it.  ! warning If the message was not sent by your user, the only parameter you may provide to this call is the  flags parameter. Anything else will result in a  hikari.errors.ForbiddenError being raised. Returns    - hikari.messages.Message The edited message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the permissions to manage messages. hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.Message.reply",
"url":20,
"doc":"Create a message in the given channel. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.Message.delete",
"url":20,
"doc":"Delete this message. Raises    hikari.errors.NotFoundError If the channel this message was created in is not found, or if the message has already been deleted. hikari.errors.ForbiddenError If you lack the permissions to delete the message.",
"func":1
},
{
"ref":"hikari.Message.add_reaction",
"url":20,
"doc":"Add a reaction to this message. Parameters      emoji : hikari.emojis.Emojiish The emoji to add. This may be a unicode emoji string, the  name:id of a custom emoji, or a subclass of  hikari.emojis.Emoji . Note that if the emoji is an  hikari.emojis.CustomEmoji and is not from a guild the bot user is in, then this will fail. Examples        Using a unicode emoji. await message.add_reaction(\"\ud83d\udc4c\")  Using a unicode emoji name. await message.add_reaction(\"\\N{OK HAND SIGN}\")  Using the  name:id format. await message.add_reaction(\"rooAYAYA:705837374319493284\")  Using a raw custom emoji mention (unanimated and animated) await message.add_reaction(\" \") await message.add_reaction(\" \")  Using an Emoji-derived object. await message.add_reaction(some_emoji_object)   Raises    hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. hikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the  ADD_REACTIONS permission. If you lack  READ_MESSAGE_HISTORY , this may also raise this error. hikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found. This will also occur if you try to add an emoji from a guild you are not part of if no one else has previously reacted with the same emoji.",
"func":1
},
{
"ref":"hikari.Message.remove_reaction",
"url":20,
"doc":"Remove a reaction from this message. Parameters      emoji : hikari.emojis.Emojiish The emoji to remove. Other Parameters         user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser The user of the reaction to remove. If unspecified, then the bot's reaction is removed instead. Examples      Using a unicode emoji and removing the bot's reaction from this  reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\")  Using a unicode emoji and removing a specific user from this  reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\", some_user)  Using a raw custom emoji mention (unanimated and animated) await message.remove_reaction(\" \", some_user) await message.remove_reaction(\" \", some_user)  Using an Emoji object and removing a specific user from this  reaction. await message.remove_reaction(some_emoji_object, some_user) Raises    hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. hikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the  ADD_REACTIONS permission. If you lack  READ_MESSAGE_HISTORY , this may also raise this error. If you remove the reaction of another user without  MANAGE_MESSAGES , this will be raised. hikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found.",
"func":1
},
{
"ref":"hikari.Message.remove_all_reactions",
"url":20,
"doc":"Remove all users' reactions for a specific emoji from the message. Other Parameters         emoji : hikari.undefined.UndefinedOr[hikari.emojis.Emojiish] The emoji to remove all reactions for. If not specified, then all emojis are removed. Example      Using a unicode emoji and removing all \ud83d\udc4c reacts from the message.  reaction. await message.remove_all_reactions(\"\\N{OK HAND SIGN}\")  Using a raw custom emoji mention (unanimated and animated) await message.remove_all_reactions(\" \") await message.remove_all_reactions(\" \")  Removing all reactions entirely. await message.remove_all_reactions() Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission, or the permission to view the channel hikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found. hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.",
"func":1
},
{
"ref":"hikari.Message.app",
"url":20,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.Message.channel_id",
"url":20,
"doc":"The ID of the channel that the message was sent in."
},
{
"ref":"hikari.Message.id",
"url":20,
"doc":"The ID of this entity."
},
{
"ref":"hikari.Message.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.MessageCreateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.MessageCreateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.MessageDeleteEntryInfo.count",
"url":19,
"doc":"The amount of messages that were deleted."
},
{
"ref":"hikari.MessageDeleteEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.MessageDeleteEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.MessageDeleteEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.MessageEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.MessageEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.MessageUpdateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.MessageUpdateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.NotFoundError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.NotFoundError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.NotFoundError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.NotFoundError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.NotFoundError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.OwnGuild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.OwnGuild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.OwnGuild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.OwnGuild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.OwnGuild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.OwnGuild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.OwnGuild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.OwnGuild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.OwnGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.OwnUser.app",
"url":21,
"doc":"Client application that models may use for procedures."
},
{
"ref":"hikari.OwnUser.avatar_hash",
"url":21,
"doc":"Avatar hash for the user, if they have one, otherwise  builtins.None ."
},
{
"ref":"hikari.OwnUser.avatar_url",
"url":21,
"doc":"Avatar URL for the user, if they have one set. May be  builtins.None if no custom avatar is set. In this case, you should use  default_avatar_url instead."
},
{
"ref":"hikari.OwnUser.default_avatar_url",
"url":21,
"doc":"Default avatar for this user."
},
{
"ref":"hikari.OwnUser.discriminator",
"url":21,
"doc":"Discriminator for the user."
},
{
"ref":"hikari.OwnUser.flags",
"url":21,
"doc":"Flag bits that are set for the user."
},
{
"ref":"hikari.OwnUser.is_bot",
"url":21,
"doc":" builtins.True if this user is a bot account,  builtins.False otherwise."
},
{
"ref":"hikari.OwnUser.is_system",
"url":21,
"doc":" builtins.True if this user is a system account,  builtins.False otherwise."
},
{
"ref":"hikari.OwnUser.mention",
"url":21,
"doc":"Return a raw mention string for the given user. Example    -   >>> some_user.mention ' '   Returns    - builtins.str The mention string to use."
},
{
"ref":"hikari.OwnUser.username",
"url":21,
"doc":"Username for the user."
},
{
"ref":"hikari.OwnUser.format_avatar",
"url":21,
"doc":"Generate the avatar for this user, if set. If no custom avatar is set, this returns  builtins.None . You can then use the  default_avatar_url attribute instead to fetch the displayed URL. Parameters      ext : typing.Optional[builtins.str] The ext to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). Will be ignored for default avatars which can only be  png . If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns    - typing.Optional[hikari.files.URL] The URL to the avatar, or  builtins.None if not present. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.OwnUser.id",
"url":1,
"doc":"Return the ID of this entity. Returns    - Snowflake The snowflake ID of this object."
},
{
"ref":"hikari.OwnUser.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.PartialChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.PartialGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.PartialIntegration.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.PartialMessage.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.PartialRole.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.PartialUser.id",
"url":1,
"doc":"Return the ID of this entity. Returns    - Snowflake The snowflake ID of this object."
},
{
"ref":"hikari.PartialUser.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.PermissionOverwrite.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.PinsUpdateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.PinsUpdateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.PinsUpdateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.PrivateChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.PrivateChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.PrivateChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.PrivateChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.PrivateChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.RESTAware.entity_factory",
"url":7,
"doc":"Return the entity factory implementation for this object. Returns    - hikari.api.entity_factory.EntityFactory The entity factory component."
},
{
"ref":"hikari.RESTAware.http_settings",
"url":7,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.RESTAware.proxy_settings",
"url":7,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.RESTAware.executor",
"url":7,
"doc":"Return the executor to use for blocking operations. This may return  builtins.None if the default  asyncio thread pool should be used instead. Returns    - typing.Optional[concurrent.futures.Executor] The executor to use, or  builtins.None to use the  asyncio default instead."
},
{
"ref":"hikari.RESTAware.cache",
"url":7,
"doc":"Return the immutable cache implementation for this object. Returns    - hikari.api.cache.Cache The cache component for this object."
},
{
"ref":"hikari.RESTAware.me",
"url":7,
"doc":"Return the bot user, if known. This should be available as soon as the bot has fired the  hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be  builtins.None . Returns    - typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise  builtins.None ."
},
{
"ref":"hikari.RESTGuild.banner_url",
"url":15,
"doc":"Banner for the guild, if set."
},
{
"ref":"hikari.RESTGuild.discovery_splash_url",
"url":15,
"doc":"Discovery splash for the guild, if set."
},
{
"ref":"hikari.RESTGuild.splash_url",
"url":15,
"doc":"Splash for the guild, if set."
},
{
"ref":"hikari.RESTGuild.format_banner",
"url":15,
"doc":"Generate the guild's banner image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL of the banner, or  builtins.None if no banner is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.RESTGuild.format_discovery_splash",
"url":15,
"doc":"Generate the guild's discovery splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The string URL. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.RESTGuild.format_splash",
"url":15,
"doc":"Generate the guild's splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the splash, or  builtins.None if not set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.RESTGuild.afk_channel_id",
"url":15,
"doc":"The ID for the channel that AFK voice users get sent to. If  builtins.None , then no AFK channel is set up for this guild."
},
{
"ref":"hikari.RESTGuild.afk_timeout",
"url":15,
"doc":"Timeout for activity before a member is classed as AFK. How long a voice user has to be AFK for before they are classed as being AFK and are moved to the AFK channel ( Guild.afk_channel_id )."
},
{
"ref":"hikari.RESTGuild.application_id",
"url":15,
"doc":"The ID of the application that created this guild. This will always be  builtins.None for guilds that weren't created by a bot."
},
{
"ref":"hikari.RESTGuild.banner_hash",
"url":15,
"doc":"The hash for the guild's banner. This is only present if the guild has  GuildFeature.BANNER in  Guild.features for this guild. For all other purposes, it is  builtins.None ."
},
{
"ref":"hikari.RESTGuild.default_message_notifications",
"url":15,
"doc":"The default setting for message notifications in this guild."
},
{
"ref":"hikari.RESTGuild.description",
"url":15,
"doc":"The guild's description. This is only present if certain  GuildFeature 's are set in  Guild.features for this guild. Otherwise, this will always be  builtins.None ."
},
{
"ref":"hikari.RESTGuild.discovery_splash_hash",
"url":15,
"doc":"The hash of the discovery splash for the guild, if there is one."
},
{
"ref":"hikari.RESTGuild.explicit_content_filter",
"url":15,
"doc":"The setting for the explicit content filter in this guild."
},
{
"ref":"hikari.RESTGuild.is_widget_enabled",
"url":15,
"doc":"Describes whether the guild widget is enabled or not. If this information is not present, this will be  builtins.None ."
},
{
"ref":"hikari.RESTGuild.max_video_channel_users",
"url":15,
"doc":"The maximum number of users allowed in a video channel together. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.RESTGuild.mfa_level",
"url":15,
"doc":"The required MFA level for users wishing to participate in this guild."
},
{
"ref":"hikari.RESTGuild.owner_id",
"url":15,
"doc":"The ID of the owner of this guild."
},
{
"ref":"hikari.RESTGuild.preferred_locale",
"url":15,
"doc":"The preferred locale to use for this guild. This can only be change if  GuildFeature.PUBLIC is in  Guild.features for this guild and will otherwise default to  en-US ."
},
{
"ref":"hikari.RESTGuild.premium_subscription_count",
"url":15,
"doc":"The number of nitro boosts that the server currently has. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.RESTGuild.premium_tier",
"url":15,
"doc":"The premium tier for this guild."
},
{
"ref":"hikari.RESTGuild.public_updates_channel_id",
"url":15,
"doc":"The channel ID of the channel where admins and moderators receive notices from Discord. This is only present if  GuildFeature.PUBLIC is in  Guild.features for this guild. For all other purposes, it should be considered to be  builtins.None ."
},
{
"ref":"hikari.RESTGuild.region",
"url":15,
"doc":"The voice region for the guild."
},
{
"ref":"hikari.RESTGuild.rules_channel_id",
"url":15,
"doc":"The ID of the channel where guilds with the  GuildFeature.PUBLIC  features display rules and guidelines. If the  GuildFeature.PUBLIC feature is not defined, then this is  builtins.None ."
},
{
"ref":"hikari.RESTGuild.splash_hash",
"url":15,
"doc":"The hash of the splash for the guild, if there is one."
},
{
"ref":"hikari.RESTGuild.system_channel_flags",
"url":15,
"doc":"Return flags for the guild system channel. These are used to describe which notifications are suppressed. Returns    - GuildSystemChannelFlag The system channel flags for this channel."
},
{
"ref":"hikari.RESTGuild.system_channel_id",
"url":15,
"doc":"The ID of the system channel or  builtins.None if it is not enabled. Welcome messages and Nitro boost messages may be sent to this channel."
},
{
"ref":"hikari.RESTGuild.vanity_url_code",
"url":15,
"doc":"The vanity URL code for the guild's vanity URL. This is only present if  GuildFeature.VANITY_URL is in  Guild.features for this guild. If not, this will always be  builtins.None ."
},
{
"ref":"hikari.RESTGuild.verification_level",
"url":15,
"doc":"The verification level needed for a user to participate in this guild."
},
{
"ref":"hikari.RESTGuild.widget_channel_id",
"url":15,
"doc":"The channel ID that the widget's generated invite will send the user to. If this information is unavailable or this is not enabled for the guild then this will be  builtins.None ."
},
{
"ref":"hikari.RESTGuild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.RESTGuild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.RESTGuild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.RESTGuild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.RESTGuild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.RESTGuild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.RESTGuild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.RESTGuild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.RESTGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.RateLimitedError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.RateLimitedError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.RateLimitedError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.RateLimitedError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.ReactionAddEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.ReactionAddEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.ReactionAddEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ReactionAddEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.ReactionDeleteAllEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.ReactionDeleteAllEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.ReactionDeleteAllEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ReactionDeleteAllEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.ReactionDeleteEmojiEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.ReactionDeleteEmojiEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.ReactionDeleteEmojiEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ReactionDeleteEmojiEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.ReactionDeleteEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.ReactionDeleteEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.ReactionDeleteEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ReactionDeleteEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.ReactionEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ReactionEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.RichActivity.name",
"url":22,
"doc":"The activity name."
},
{
"ref":"hikari.RichActivity.type",
"url":22,
"doc":"The activity type."
},
{
"ref":"hikari.RichActivity.url",
"url":22,
"doc":"The activity URL. Only valid for  STREAMING activities."
},
{
"ref":"hikari.Role.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.Role.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.Role.name",
"url":15,
"doc":"The role's name."
},
{
"ref":"hikari.Role.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.RoleEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.RoleEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.ShardAware.http_settings",
"url":7,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.ShardAware.proxy_settings",
"url":7,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.ShardAware.executor",
"url":7,
"doc":"Return the executor to use for blocking operations. This may return  builtins.None if the default  asyncio thread pool should be used instead. Returns    - typing.Optional[concurrent.futures.Executor] The executor to use, or  builtins.None to use the  asyncio default instead."
},
{
"ref":"hikari.ShardAware.cache",
"url":7,
"doc":"Return the immutable cache implementation for this object. Returns    - hikari.api.cache.Cache The cache component for this object."
},
{
"ref":"hikari.ShardAware.me",
"url":7,
"doc":"Return the bot user, if known. This should be available as soon as the bot has fired the  hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be  builtins.None . Returns    - typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise  builtins.None ."
},
{
"ref":"hikari.ShardAware.chunker",
"url":7,
"doc":"Return the guild chunker component. Returns    - hikari.api.chunker.GuildChunker The guild chunker component."
},
{
"ref":"hikari.ShardAware.voice",
"url":7,
"doc":"Return the voice connection manager component for this application. Returns    - hikari.api.voice.VoiceComponent The voice component for the application."
},
{
"ref":"hikari.ShardEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.ShardStateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.ShardStateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.Team.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.TextChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.TextChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.TextChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.TextChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.TextChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.TypingEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.TypingEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.URL.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.URL.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.URL.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.UnauthorizedError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.UnauthorizedError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.UnauthorizedError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.UnauthorizedError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.UnauthorizedError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.UnicodeEmoji.is_mentionable",
"url":17,
"doc":"Whether the emoji can be mentioned or not."
},
{
"ref":"hikari.UnicodeEmoji.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.UnicodeEmoji.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.UnicodeEmoji.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.User.fetch_self",
"url":21,
"doc":"Get this user's up-to-date object by performing an API call. Returns    - hikari.users.User The requested user object. Raises    hikari.errors.NotFoundError If the user is not found.",
"func":1
},
{
"ref":"hikari.User.id",
"url":1,
"doc":"Return the ID of this entity. Returns    - Snowflake The snowflake ID of this object."
},
{
"ref":"hikari.User.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.VoiceEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.VoiceEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.Webhook.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.WebhookUpdateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.WebhookUpdateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.WebhookUpdateEvent.channel",
"url":9,
"doc":"Get the cached channel that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return  builtins.None instead."
},
{
"ref":"hikari.WebhookUpdateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.audit_logs",
"url":19,
"doc":"Application and entities that are used to describe audit logs on Discord."
},
{
"ref":"hikari.audit_logs.AuditLog",
"url":19,
"doc":"Represents a guilds audit log. Method generated by attrs for class AuditLog."
},
{
"ref":"hikari.audit_logs.AuditLog.entries",
"url":19,
"doc":"A mapping of snowflake IDs to the audit log's entries."
},
{
"ref":"hikari.audit_logs.AuditLog.integrations",
"url":19,
"doc":"A mapping of the partial objects of integrations found in this audit log."
},
{
"ref":"hikari.audit_logs.AuditLog.users",
"url":19,
"doc":"A mapping of the objects of users found in this audit log."
},
{
"ref":"hikari.audit_logs.AuditLog.webhooks",
"url":19,
"doc":"A mapping of the objects of webhooks found in this audit log."
},
{
"ref":"hikari.audit_logs.AuditLogChange",
"url":19,
"doc":"Represents a change made to an audit log entry's target entity. Method generated by attrs for class AuditLogChange."
},
{
"ref":"hikari.audit_logs.AuditLogChange.key",
"url":19,
"doc":"The name of the audit log change's key."
},
{
"ref":"hikari.audit_logs.AuditLogChange.new_value",
"url":19,
"doc":"The new value of the key, if something was added or changed."
},
{
"ref":"hikari.audit_logs.AuditLogChange.old_value",
"url":19,
"doc":"The old value of the key, if something was removed or changed."
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey",
"url":19,
"doc":"Commonly known and documented keys for audit log change objects. Others may exist. These should be expected to default to the raw string Discord provided us. These are defined for documentation purposes and can be treated as regular strings for all other purposes."
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.name",
"url":19,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.value",
"url":19,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.NAME",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.ICON_HASH",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.SPLASH_HASH",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.OWNER_ID",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.REGION",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.AFK_CHANNEL_ID",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.AFK_TIMEOUT",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.MFA_LEVEL",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.VERIFICATION_LEVEL",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.EXPLICIT_CONTENT_FILTER",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.DEFAULT_MESSAGE_NOTIFICATIONS",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.VANITY_URL_CODE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.PRUNE_DELETE_DAYS",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.WIDGET_ENABLED",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.WIDGET_CHANNEL_ID",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.POSITION",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.TOPIC",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.BITRATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.PERMISSION_OVERWRITES",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.NSFW",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.APPLICATION_ID",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.PERMISSIONS",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.COLOR",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.HOIST",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.MENTIONABLE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.ALLOW",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.DENY",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.INVITE_CODE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.CHANNEL_ID",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.INVITER_ID",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.MAX_USES",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.USES",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.MAX_AGE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.TEMPORARY",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.DEAF",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.MUTE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.NICK",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.AVATAR_HASH",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.ID",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.TYPE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.ENABLE_EMOTICONS",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.EXPIRE_BEHAVIOR",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.EXPIRE_GRACE_PERIOD",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.RATE_LIMIT_PER_USER",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.SYSTEM_CHANNEL_ID",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.ADD_ROLE_TO_MEMBER",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.REMOVE_ROLE_FROM_MEMBER",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogChangeKey.COLOUR",
"url":19,
"doc":"Alias for \"COLOR"
},
{
"ref":"hikari.audit_logs.AuditLogEntry",
"url":19,
"doc":"Represents an entry in a guild's audit log. Method generated by attrs for class AuditLogEntry."
},
{
"ref":"hikari.audit_logs.AuditLogEntry.action_type",
"url":19,
"doc":"The type of action this entry represents."
},
{
"ref":"hikari.audit_logs.AuditLogEntry.app",
"url":19,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.audit_logs.AuditLogEntry.changes",
"url":19,
"doc":"A sequence of the changes made to  AuditLogEntry.target_id ."
},
{
"ref":"hikari.audit_logs.AuditLogEntry.id",
"url":19,
"doc":"The ID of this entity."
},
{
"ref":"hikari.audit_logs.AuditLogEntry.options",
"url":19,
"doc":"Extra information about this entry. Only be provided for certain  event_type ."
},
{
"ref":"hikari.audit_logs.AuditLogEntry.reason",
"url":19,
"doc":"The reason for this change, if set (between 0-512 characters)."
},
{
"ref":"hikari.audit_logs.AuditLogEntry.target_id",
"url":19,
"doc":"The ID of the entity affected by this change, if applicable."
},
{
"ref":"hikari.audit_logs.AuditLogEntry.user_id",
"url":19,
"doc":"The ID of the user who made this change."
},
{
"ref":"hikari.audit_logs.AuditLogEntry.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.audit_logs.AuditLogEventType",
"url":19,
"doc":"The type of event that occurred."
},
{
"ref":"hikari.audit_logs.AuditLogEventType.name",
"url":19,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.audit_logs.AuditLogEventType.value",
"url":19,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.audit_logs.AuditLogEventType.GUILD_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.CHANNEL_CREATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.CHANNEL_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.CHANNEL_DELETE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.CHANNEL_OVERWRITE_CREATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.CHANNEL_OVERWRITE_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.CHANNEL_OVERWRITE_DELETE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MEMBER_KICK",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MEMBER_PRUNE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MEMBER_BAN_ADD",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MEMBER_BAN_REMOVE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MEMBER_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MEMBER_ROLE_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MEMBER_MOVE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MEMBER_DISCONNECT",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.BOT_ADD",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.ROLE_CREATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.ROLE_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.ROLE_DELETE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.INVITE_CREATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.INVITE_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.INVITE_DELETE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.WEBHOOK_CREATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.WEBHOOK_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.WEBHOOK_DELETE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.EMOJI_CREATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.EMOJI_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.EMOJI_DELETE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MESSAGE_DELETE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MESSAGE_BULK_DELETE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MESSAGE_PIN",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.MESSAGE_UNPIN",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.INTEGRATION_CREATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.INTEGRATION_UPDATE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.AuditLogEventType.INTEGRATION_DELETE",
"url":19,
"doc":""
},
{
"ref":"hikari.audit_logs.BaseAuditLogEntryInfo",
"url":19,
"doc":"A base object that all audit log entry info objects will inherit from. Method generated by attrs for class BaseAuditLogEntryInfo."
},
{
"ref":"hikari.audit_logs.ChannelOverwriteEntryInfo",
"url":19,
"doc":"Represents the extra information for overwrite related audit log entries. Will be attached to the overwrite create, update and delete audit log entries. Method generated by attrs for class ChannelOverwriteEntryInfo."
},
{
"ref":"hikari.audit_logs.ChannelOverwriteEntryInfo.id",
"url":19,
"doc":"The ID of this entity."
},
{
"ref":"hikari.audit_logs.ChannelOverwriteEntryInfo.role_name",
"url":19,
"doc":"The name of the role this overwrite targets, if it targets a role."
},
{
"ref":"hikari.audit_logs.ChannelOverwriteEntryInfo.type",
"url":19,
"doc":"The type of entity this overwrite targets."
},
{
"ref":"hikari.audit_logs.ChannelOverwriteEntryInfo.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.audit_logs.MemberDisconnectEntryInfo",
"url":19,
"doc":"Extra information for the voice chat member disconnect entry. Method generated by attrs for class MemberDisconnectEntryInfo."
},
{
"ref":"hikari.audit_logs.MemberDisconnectEntryInfo.count",
"url":19,
"doc":"The amount of members who were disconnected from voice in this entry."
},
{
"ref":"hikari.audit_logs.MemberMoveEntryInfo",
"url":19,
"doc":"Extra information for the voice chat based member move entry. Method generated by attrs for class MemberMoveEntryInfo."
},
{
"ref":"hikari.audit_logs.MemberMoveEntryInfo.channel_id",
"url":19,
"doc":"The amount of members who were disconnected from voice in this entry."
},
{
"ref":"hikari.audit_logs.MemberMoveEntryInfo.count",
"url":19,
"doc":"The amount of members who were disconnected from voice in this entry."
},
{
"ref":"hikari.audit_logs.MemberPruneEntryInfo",
"url":19,
"doc":"Extra information attached to guild prune log entries. Method generated by attrs for class MemberPruneEntryInfo."
},
{
"ref":"hikari.audit_logs.MemberPruneEntryInfo.delete_member_days",
"url":19,
"doc":"The timedelta of how many days members were pruned for inactivity based on."
},
{
"ref":"hikari.audit_logs.MemberPruneEntryInfo.members_removed",
"url":19,
"doc":"The number of members who were removed by this prune."
},
{
"ref":"hikari.audit_logs.MessageBulkDeleteEntryInfo",
"url":19,
"doc":"Extra information for the message bulk delete audit entry. Method generated by attrs for class MessageBulkDeleteEntryInfo."
},
{
"ref":"hikari.audit_logs.MessageBulkDeleteEntryInfo.count",
"url":19,
"doc":"The amount of messages that were deleted."
},
{
"ref":"hikari.audit_logs.MessageDeleteEntryInfo",
"url":19,
"doc":"Extra information attached to the message delete audit entry. Method generated by attrs for class MessageDeleteEntryInfo."
},
{
"ref":"hikari.audit_logs.MessageDeleteEntryInfo.channel_id",
"url":19,
"doc":"The guild text based channel where these message(s) were deleted."
},
{
"ref":"hikari.audit_logs.MessageDeleteEntryInfo.count",
"url":19,
"doc":"The amount of messages that were deleted."
},
{
"ref":"hikari.audit_logs.MessagePinEntryInfo",
"url":19,
"doc":"The extra information for message pin related audit log entries. Will be attached to the message pin and message unpin audit log entries. Method generated by attrs for class MessagePinEntryInfo."
},
{
"ref":"hikari.audit_logs.MessagePinEntryInfo.channel_id",
"url":19,
"doc":"The ID of the text based channel where a pinned message is being targeted."
},
{
"ref":"hikari.audit_logs.MessagePinEntryInfo.message_id",
"url":19,
"doc":"The ID of the message that's being pinned or unpinned."
},
{
"ref":"hikari.audit_logs.UnrecognisedAuditLogEntryInfo",
"url":19,
"doc":"Audit log entry options that haven't been implemented in the library. The attributes on this object are undocumented and dynamic. Example    - >>> entry_info.foobar.baz  ! note This model has no slots and will have arbitrary undocumented attributes (in it's  __dict__ based on the received payload). Method generated by attrs for class BaseAuditLogEntryInfo."
},
{
"ref":"hikari.colours",
"url":23,
"doc":"Alias for the  hikari.colors module."
},
{
"ref":"hikari.colours.Color",
"url":23,
"doc":"Representation of a color. This value is immutable. This is a specialization of  builtins.int which provides alternative overrides for common methods and color system conversions. This currently supports:  RGB  RGB (float)  3-digit hex codes (e.g. 0xF1A  web safe)  6-digit hex codes (e.g. 0xFF11AA)  3-digit RGB strings (e.g.  1A2  web safe)  6-digit RGB hash strings (e.g.  1A2B3C) Examples     Examples of conversions to given formats include:   >>> c = Color(0xFF051A) Color(r=0xff, g=0x5, b=0x1a) >>> hex(c) 0xff051a >>> c.hex_code  FF051A >>> str(c)  FF051A >>> int(c) 16712986 >>> c.rgb (255, 5, 26) >>> c.rgb_float (1.0, 0.0196078431372549, 0.10196078431372549)   Alternatively, if you have an arbitrary input in one of the above formats that you wish to become a color, you can use  Color.of on the class itself to automatically attempt to resolve the color:   >>> Color.of(0xFF051A) Color(r=0xff, g=0x5, b=0x1a) >>> Color.of(16712986) Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of 255, 5, 26 Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of(255, 5, 26) Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of([0xFF, 0x5, 0x1a]) Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of(\" 1a2b3c\") Color(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.of(\" 1AB\") Color(r=0x11, g=0xaa, b=0xbb) >>> c = Color.of 1.0, 0.0196078431372549, 0.10196078431372549 Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of([1.0, 0.0196078431372549, 0.10196078431372549]) Color(r=0xff, g=0x5, b=0x1a)   Examples of initialization of Color objects from given formats include:   >>> c = Color(16712986) Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.from_rgb(255, 5, 26) Color(r=0xff, g=0x5, b=1xa) >>> c = Color.from_hex_code(\" 1a2b3c\") Color(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.from_hex_code(\" 1AB\") Color(r=0x11, g=0xaa, b=0xbb) >>> c = Color.from_rgb_float(1.0, 0.0196078431372549, 0.10196078431372549) Color(r=0xff, g=0x5, b=0x1a)  "
},
{
"ref":"hikari.colours.Color.rgb",
"url":23,
"doc":"The RGB representation of this Color. Represented as a tuple of R, G, B. Each value is in the range [0, 0xFF]. Example    -  (123, 234, 47) "
},
{
"ref":"hikari.colours.Color.rgb_float",
"url":23,
"doc":"Return the floating-point RGB representation of this Color. Represented as a tuple of R, G, B. Each value is in the range [0, 1]. Example    -  (0.1, 0.2, 0.76) "
},
{
"ref":"hikari.colours.Color.hex_code",
"url":23,
"doc":"Six-digit hexadecimal color code for this Color. This is prepended with a  symbol, and will be in upper case. Example    -  1A2B3C "
},
{
"ref":"hikari.colours.Color.raw_hex_code",
"url":23,
"doc":"Raw hex code. Example    -  1A2B3C "
},
{
"ref":"hikari.colours.Color.is_web_safe",
"url":23,
"doc":" builtins.True if the color is web safe,  builtins.False otherwise."
},
{
"ref":"hikari.colours.Color.from_rgb",
"url":23,
"doc":"Convert the given RGB to a  Color object. Each channel must be withing the range [0, 255] (0x0, 0xFF). Parameters      red : builtins.int Red channel. green : builtins.int Green channel. blue : builtins.int Blue channel. Returns    - Color A Color object. Raises    builtins.ValueError If red, green, or blue are outside the range [0x0, 0xFF].",
"func":1
},
{
"ref":"hikari.colours.Color.from_rgb_float",
"url":23,
"doc":"Convert the given RGB to a  Color object. The color-space represented values have to be within the range [0, 1]. Parameters      red : builtins.float Red channel. green : builtins.float Green channel. blue : builtins.float Blue channel. Returns    - Color A Color object. Raises    builtins.ValueError If red, green or blue are outside the range [0, 1].",
"func":1
},
{
"ref":"hikari.colours.Color.from_hex_code",
"url":23,
"doc":"Convert the given hexadecimal color code to a  Color . The inputs may be of the following format (case insensitive):  1a2 ,  1a2 ,  0x1a2 (for web-safe colors), or  1a2b3c ,  1a2b3c ,  0x1a2b3c (for regular 3-byte color-codes). Parameters      hex_code : builtins.str A hexadecimal color code to parse. This may optionally start with a case insensitive  0x or  . Returns    - Color A corresponding Color object. Raises    builtins.ValueError If  hex_code is not a hexadecimal or is a invalid length.",
"func":1
},
{
"ref":"hikari.colours.Color.from_int",
"url":23,
"doc":"Convert the given  typing.SupportsInt to a  Color . Parameters      integer : typing.SupportsInt The raw color integer. Returns    - Color The Color object.",
"func":1
},
{
"ref":"hikari.colours.Color.from_tuple_string",
"url":23,
"doc":"Convert a string in a tuple-like format to a  Color . This allows formats that are optionally enclosed by  () ,  {} , or  [] , and contain three floats or ints, either space separated or comma separated. If comma separated, trailing and leading whitespace around each member is truncated. This is provided to allow command frontends to directly pass user input for representing a given colour into this class safely. Examples        Floats \"1.0 1.0 1.0\" \"(1.0 1.0 1.0)\" \"[1.0 1.0 1.0]\" \"{1.0 1.0 1.0}\" \"1.0, 1.0, 1.0\" \"(1.0, 1.0, 1.0)\" \"[1.0, 1.0, 1.0]\" \"{1.0, 1.0, 1.0}\"  Ints \"252 252 252\" \"(252 252 252)\" \"[252 252 252]\" \"{252 252 252}\" \"252, 252, 252\" \"(252, 252, 252)\" \"[252, 252, 252]\" \"{252, 252, 252}\"   Parameters      tuple_str : builtins.str The string to parse. Returns    - Color The parsed colour object. Raises    ValueError If an invalid format is given, or if any values exceed 1.0 for floats or 255 for ints.",
"func":1
},
{
"ref":"hikari.colours.Color.from_bytes",
"url":23,
"doc":"Convert the bytes to a  Color . Parameters      bytes_ : typing.Iterable[builtins.int] A iterable of int byte values. byteorder : builtins.str The endianess of the value represented by the bytes. Can be  \"big\" endian or  \"little\" endian. signed : builtins.bool Whether the value is signed or unsigned. Returns    - Color The Color object.",
"func":1
},
{
"ref":"hikari.colours.Color.of",
"url":23,
"doc":"Convert the value to a  Color . This attempts to determine the correct data format based on the information provided. Parameters      value : Colorish A color compatible values. Examples       >>> Color.of(0xFF051A) Color(r=0xff, g=0x5, b=0x1a) >>> Color.of(16712986) Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of 255, 5, 26 Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of([0xFF, 0x5, 0x1a]) Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of(\" 1a2b3c\") Color(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.of(\" 1AB\") Color(r=0x11, g=0xaa, b=0xbb) >>> c = Color.of 1.0, 0.0196078431372549, 0.10196078431372549 Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of([1.0, 0.0196078431372549, 0.10196078431372549]) Color(r=0xff, g=0x5, b=0x1a)  Commas and brackets are optional, whitespace is ignored, and these  are compatible with all-ints between 0-255 or all-floats between  0.0 and 1.0 only. >>> c = Color.of(\"5, 22, 33\") Color(r=0x5, g=0x16, b=0x21) >>> c = Color.of(\"(5, 22, 33)\") Color(r=0x5, g=0x16, b=0x21) >>> c = Color.of(\"[5, 22, 33]\") Color(r=0x5, g=0x16, b=0x21) >>> c = Color.of(\"{5, 22, 33}\") Color(r=0x5, g=0x16, b=0x21)   Returns    - Color The Color object.",
"func":1
},
{
"ref":"hikari.colours.Color.to_bytes",
"url":23,
"doc":"Convert the color code to bytes. Parameters      length : builtins.int The number of bytes to produce. Should be around  3 , but not less. byteorder : builtins.str The endianess of the value represented by the bytes. Can be  \"big\" endian or  \"little\" endian. signed : builtins.bool Whether the value is signed or unsigned. Returns    - builtins.bytes The bytes representation of the Color.",
"func":1
},
{
"ref":"hikari.users",
"url":21,
"doc":"Application and entities that are used to describe Users on Discord."
},
{
"ref":"hikari.users.PartialUser",
"url":21,
"doc":"A partial interface for a user. Fields may or may not be present, and should be explicitly checked before using them to ensure they are not  hikari.undefined.UNDEFINED . This is used for endpoints and events that only expose partial user information. For full user info, consider calling the  fetch_self method to perform an API call. Method generated by attrs for class PartialUser."
},
{
"ref":"hikari.users.PartialUser.app",
"url":21,
"doc":"Client application that models may use for procedures."
},
{
"ref":"hikari.users.PartialUser.avatar_hash",
"url":21,
"doc":"Avatar hash for the user, if they have one, otherwise  builtins.None ."
},
{
"ref":"hikari.users.PartialUser.discriminator",
"url":21,
"doc":"Discriminator for the user."
},
{
"ref":"hikari.users.PartialUser.username",
"url":21,
"doc":"Username for the user."
},
{
"ref":"hikari.users.PartialUser.is_bot",
"url":21,
"doc":" builtins.True if this user is a bot account,  builtins.False otherwise."
},
{
"ref":"hikari.users.PartialUser.is_system",
"url":21,
"doc":" builtins.True if this user is a system account,  builtins.False otherwise."
},
{
"ref":"hikari.users.PartialUser.flags",
"url":21,
"doc":"Flag bits that are set for the user."
},
{
"ref":"hikari.users.PartialUser.mention",
"url":21,
"doc":"Return a raw mention string for the given user. Example    -   >>> some_user.mention ' '   Returns    - builtins.str The mention string to use."
},
{
"ref":"hikari.users.PartialUser.fetch_self",
"url":21,
"doc":"Get this user's up-to-date object by performing an API call. Returns    - hikari.users.User The requested user object. Raises    hikari.errors.NotFoundError If the user is not found.",
"func":1
},
{
"ref":"hikari.users.PartialUser.id",
"url":1,
"doc":"Return the ID of this entity. Returns    - Snowflake The snowflake ID of this object."
},
{
"ref":"hikari.users.PartialUser.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.users.User",
"url":21,
"doc":"Interface for any user-like object. This does not include partial users, as they may not be fully formed. Method generated by attrs for class User."
},
{
"ref":"hikari.users.User.app",
"url":21,
"doc":"Client application that models may use for procedures."
},
{
"ref":"hikari.users.User.avatar_hash",
"url":21,
"doc":"Avatar hash for the user, if they have one, otherwise  builtins.None ."
},
{
"ref":"hikari.users.User.avatar_url",
"url":21,
"doc":"Avatar URL for the user, if they have one set. May be  builtins.None if no custom avatar is set. In this case, you should use  default_avatar_url instead."
},
{
"ref":"hikari.users.User.default_avatar_url",
"url":21,
"doc":"Default avatar for this user."
},
{
"ref":"hikari.users.User.discriminator",
"url":21,
"doc":"Discriminator for the user."
},
{
"ref":"hikari.users.User.flags",
"url":21,
"doc":"Flag bits that are set for the user."
},
{
"ref":"hikari.users.User.is_bot",
"url":21,
"doc":" builtins.True if this user is a bot account,  builtins.False otherwise."
},
{
"ref":"hikari.users.User.is_system",
"url":21,
"doc":" builtins.True if this user is a system account,  builtins.False otherwise."
},
{
"ref":"hikari.users.User.mention",
"url":21,
"doc":"Return a raw mention string for the given user. Example    -   >>> some_user.mention ' '   Returns    - builtins.str The mention string to use."
},
{
"ref":"hikari.users.User.username",
"url":21,
"doc":"Username for the user."
},
{
"ref":"hikari.users.User.format_avatar",
"url":21,
"doc":"Generate the avatar for this user, if set. If no custom avatar is set, this returns  builtins.None . You can then use the  default_avatar_url attribute instead to fetch the displayed URL. Parameters      ext : typing.Optional[builtins.str] The ext to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). Will be ignored for default avatars which can only be  png . If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns    - typing.Optional[hikari.files.URL] The URL to the avatar, or  builtins.None if not present. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.users.User.fetch_self",
"url":21,
"doc":"Get this user's up-to-date object by performing an API call. Returns    - hikari.users.User The requested user object. Raises    hikari.errors.NotFoundError If the user is not found.",
"func":1
},
{
"ref":"hikari.users.User.id",
"url":1,
"doc":"Return the ID of this entity. Returns    - Snowflake The snowflake ID of this object."
},
{
"ref":"hikari.users.User.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.users.OwnUser",
"url":21,
"doc":"Represents a user with extended OAuth2 information. Method generated by attrs for class OwnUser."
},
{
"ref":"hikari.users.OwnUser.fetch_self",
"url":21,
"doc":"Get this user's up-to-date object. Returns    - hikari.users.OwnUser The requested user object.",
"func":1
},
{
"ref":"hikari.users.OwnUser.email",
"url":21,
"doc":"The user's set email. Will be  builtins.None if retrieved through OAuth2 flow without the  email scope. Will always be  builtins.None for bot users."
},
{
"ref":"hikari.users.OwnUser.is_mfa_enabled",
"url":21,
"doc":"Whether the user's account has multi-factor authentication enabled."
},
{
"ref":"hikari.users.OwnUser.is_verified",
"url":21,
"doc":"Whether the email for this user's account has been verified. Will be  builtins.None if retrieved through the OAuth2 flow without the  email scope."
},
{
"ref":"hikari.users.OwnUser.locale",
"url":21,
"doc":"The user's set language. This is not provided by the  READY event."
},
{
"ref":"hikari.users.OwnUser.premium_type",
"url":21,
"doc":"The type of Nitro Subscription this user account had. This will always be  builtins.None for bots."
},
{
"ref":"hikari.users.OwnUser.app",
"url":21,
"doc":"Client application that models may use for procedures."
},
{
"ref":"hikari.users.OwnUser.avatar_hash",
"url":21,
"doc":"Avatar hash for the user, if they have one, otherwise  builtins.None ."
},
{
"ref":"hikari.users.OwnUser.avatar_url",
"url":21,
"doc":"Avatar URL for the user, if they have one set. May be  builtins.None if no custom avatar is set. In this case, you should use  default_avatar_url instead."
},
{
"ref":"hikari.users.OwnUser.default_avatar_url",
"url":21,
"doc":"Default avatar for this user."
},
{
"ref":"hikari.users.OwnUser.discriminator",
"url":21,
"doc":"Discriminator for the user."
},
{
"ref":"hikari.users.OwnUser.flags",
"url":21,
"doc":"Flag bits that are set for the user."
},
{
"ref":"hikari.users.OwnUser.is_bot",
"url":21,
"doc":" builtins.True if this user is a bot account,  builtins.False otherwise."
},
{
"ref":"hikari.users.OwnUser.is_system",
"url":21,
"doc":" builtins.True if this user is a system account,  builtins.False otherwise."
},
{
"ref":"hikari.users.OwnUser.mention",
"url":21,
"doc":"Return a raw mention string for the given user. Example    -   >>> some_user.mention ' '   Returns    - builtins.str The mention string to use."
},
{
"ref":"hikari.users.OwnUser.username",
"url":21,
"doc":"Username for the user."
},
{
"ref":"hikari.users.OwnUser.format_avatar",
"url":21,
"doc":"Generate the avatar for this user, if set. If no custom avatar is set, this returns  builtins.None . You can then use the  default_avatar_url attribute instead to fetch the displayed URL. Parameters      ext : typing.Optional[builtins.str] The ext to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). Will be ignored for default avatars which can only be  png . If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns    - typing.Optional[hikari.files.URL] The URL to the avatar, or  builtins.None if not present. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.users.OwnUser.id",
"url":1,
"doc":"Return the ID of this entity. Returns    - Snowflake The snowflake ID of this object."
},
{
"ref":"hikari.users.OwnUser.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.users.UserFlag",
"url":21,
"doc":"The known user flags that represent account badges."
},
{
"ref":"hikari.users.UserFlag.name",
"url":21,
"doc":"Return the name of the flag combination as a  builtins.str ."
},
{
"ref":"hikari.users.UserFlag.value",
"url":21,
"doc":"Return the  builtins.int value of the flag."
},
{
"ref":"hikari.users.UserFlag.all",
"url":21,
"doc":"Check if all of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.users.UserFlag.any",
"url":21,
"doc":"Check if any of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.users.UserFlag.difference",
"url":21,
"doc":"Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction  - operator.",
"func":1
},
{
"ref":"hikari.users.UserFlag.intersection",
"url":21,
"doc":"Return a combination of flags that are set for both given values. Equivalent to using the \"AND\"  & operator.",
"func":1
},
{
"ref":"hikari.users.UserFlag.invert",
"url":21,
"doc":"Return a set of all flags not in the current set.",
"func":1
},
{
"ref":"hikari.users.UserFlag.is_disjoint",
"url":21,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.users.UserFlag.is_subset",
"url":21,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.users.UserFlag.is_superset",
"url":21,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.users.UserFlag.none",
"url":21,
"doc":"Check if none of the given flags are part of this value.  ! note This is essentially the opposite of  Flag.any . Returns    - builtins.bool  builtins.True if none of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.users.UserFlag.split",
"url":21,
"doc":"Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted  typing.Sequence of each membe",
"func":1
},
{
"ref":"hikari.users.UserFlag.symmetric_difference",
"url":21,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.users.UserFlag.union",
"url":21,
"doc":"Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\"  ~ operator.",
"func":1
},
{
"ref":"hikari.users.UserFlag.isdisjoint",
"url":21,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.users.UserFlag.issubset",
"url":21,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.users.UserFlag.issuperset",
"url":21,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.users.UserFlag.symmetricdifference",
"url":21,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.users.UserFlag.NONE",
"url":21,
"doc":"None"
},
{
"ref":"hikari.users.UserFlag.DISCORD_EMPLOYEE",
"url":21,
"doc":"Discord Employee."
},
{
"ref":"hikari.users.UserFlag.PARTNERED_SERVER_OWNER",
"url":21,
"doc":"Owner of a partnered Discord server."
},
{
"ref":"hikari.users.UserFlag.HYPESQUAD_EVENTS",
"url":21,
"doc":"HypeSquad Events."
},
{
"ref":"hikari.users.UserFlag.BUG_HUNTER_LEVEL_1",
"url":21,
"doc":"Bug Hunter Level 1."
},
{
"ref":"hikari.users.UserFlag.HYPESQUAD_BRAVERY",
"url":21,
"doc":"House of Bravery."
},
{
"ref":"hikari.users.UserFlag.HYPESQUAD_BRILLIANCE",
"url":21,
"doc":"House of Brilliance."
},
{
"ref":"hikari.users.UserFlag.HYPESQUAD_BALANCE",
"url":21,
"doc":"House of Balance."
},
{
"ref":"hikari.users.UserFlag.EARLY_SUPPORTER",
"url":21,
"doc":"Early Supporter."
},
{
"ref":"hikari.users.UserFlag.TEAM_USER",
"url":21,
"doc":"Team user."
},
{
"ref":"hikari.users.UserFlag.SYSTEM",
"url":21,
"doc":"System user."
},
{
"ref":"hikari.users.UserFlag.BUG_HUNTER_LEVEL_2",
"url":21,
"doc":"Bug Hunter Level 2."
},
{
"ref":"hikari.users.UserFlag.VERIFIED_BOT",
"url":21,
"doc":"Verified Bot."
},
{
"ref":"hikari.users.UserFlag.EARLY_VERIFIED_DEVELOPER",
"url":21,
"doc":"Early verified Bot Developer. Only applies to users that verified their account before 20th August 2019."
},
{
"ref":"hikari.users.PremiumType",
"url":21,
"doc":"The types of Nitro."
},
{
"ref":"hikari.users.PremiumType.name",
"url":21,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.users.PremiumType.value",
"url":21,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.users.PremiumType.NONE",
"url":21,
"doc":"No premium."
},
{
"ref":"hikari.users.PremiumType.NITRO_CLASSIC",
"url":21,
"doc":"Premium including basic perks like animated emojis and avatars."
},
{
"ref":"hikari.users.PremiumType.NITRO",
"url":21,
"doc":"Premium including all perks (e.g. 2 server boosts)."
},
{
"ref":"hikari.presences",
"url":22,
"doc":"Application and entities that are used to describe guilds on Discord."
},
{
"ref":"hikari.presences.Activity",
"url":22,
"doc":"Represents a regular activity that can be associated with a presence. Method generated by attrs for class Activity."
},
{
"ref":"hikari.presences.Activity.name",
"url":22,
"doc":"The activity name."
},
{
"ref":"hikari.presences.Activity.type",
"url":22,
"doc":"The activity type."
},
{
"ref":"hikari.presences.Activity.url",
"url":22,
"doc":"The activity URL. Only valid for  STREAMING activities."
},
{
"ref":"hikari.presences.ActivityAssets",
"url":22,
"doc":"Used to represent possible assets for an activity. Method generated by attrs for class ActivityAssets."
},
{
"ref":"hikari.presences.ActivityAssets.large_image",
"url":22,
"doc":"The ID of the asset's large image, if set."
},
{
"ref":"hikari.presences.ActivityAssets.large_text",
"url":22,
"doc":"The text that'll appear when hovering over the large image, if set."
},
{
"ref":"hikari.presences.ActivityAssets.small_image",
"url":22,
"doc":"The ID of the asset's small image, if set."
},
{
"ref":"hikari.presences.ActivityAssets.small_text",
"url":22,
"doc":"The text that'll appear when hovering over the small image, if set."
},
{
"ref":"hikari.presences.ActivityFlag",
"url":22,
"doc":"Flags that describe what an activity includes. This can be more than one using bitwise-combinations."
},
{
"ref":"hikari.presences.ActivityFlag.name",
"url":22,
"doc":"Return the name of the flag combination as a  builtins.str ."
},
{
"ref":"hikari.presences.ActivityFlag.value",
"url":22,
"doc":"Return the  builtins.int value of the flag."
},
{
"ref":"hikari.presences.ActivityFlag.all",
"url":22,
"doc":"Check if all of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.any",
"url":22,
"doc":"Check if any of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.difference",
"url":22,
"doc":"Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction  - operator.",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.intersection",
"url":22,
"doc":"Return a combination of flags that are set for both given values. Equivalent to using the \"AND\"  & operator.",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.invert",
"url":22,
"doc":"Return a set of all flags not in the current set.",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.is_disjoint",
"url":22,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.is_subset",
"url":22,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.is_superset",
"url":22,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.none",
"url":22,
"doc":"Check if none of the given flags are part of this value.  ! note This is essentially the opposite of  Flag.any . Returns    - builtins.bool  builtins.True if none of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.split",
"url":22,
"doc":"Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted  typing.Sequence of each membe",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.symmetric_difference",
"url":22,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.union",
"url":22,
"doc":"Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\"  ~ operator.",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.isdisjoint",
"url":22,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.issubset",
"url":22,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.issuperset",
"url":22,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.symmetricdifference",
"url":22,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.presences.ActivityFlag.INSTANCE",
"url":22,
"doc":"Instance"
},
{
"ref":"hikari.presences.ActivityFlag.JOIN",
"url":22,
"doc":"Join"
},
{
"ref":"hikari.presences.ActivityFlag.SPECTATE",
"url":22,
"doc":"Spectate"
},
{
"ref":"hikari.presences.ActivityFlag.JOIN_REQUEST",
"url":22,
"doc":"Join Request"
},
{
"ref":"hikari.presences.ActivityFlag.SYNC",
"url":22,
"doc":"Sync"
},
{
"ref":"hikari.presences.ActivityFlag.PLAY",
"url":22,
"doc":"Play"
},
{
"ref":"hikari.presences.ActivitySecret",
"url":22,
"doc":"The secrets used for interacting with an activity party. Method generated by attrs for class ActivitySecret."
},
{
"ref":"hikari.presences.ActivitySecret.join",
"url":22,
"doc":"The secret used for joining a party, if applicable."
},
{
"ref":"hikari.presences.ActivitySecret.match",
"url":22,
"doc":"The secret used for matching a party, if applicable."
},
{
"ref":"hikari.presences.ActivitySecret.spectate",
"url":22,
"doc":"The secret used for spectating a party, if applicable."
},
{
"ref":"hikari.presences.ActivityTimestamps",
"url":22,
"doc":"The datetimes for the start and/or end of an activity session. Method generated by attrs for class ActivityTimestamps."
},
{
"ref":"hikari.presences.ActivityTimestamps.end",
"url":22,
"doc":"When this activity's session will end, if applicable."
},
{
"ref":"hikari.presences.ActivityTimestamps.start",
"url":22,
"doc":"When this activity's session was started, if applicable."
},
{
"ref":"hikari.presences.ActivityType",
"url":22,
"doc":"The activity type."
},
{
"ref":"hikari.presences.ActivityType.name",
"url":22,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.presences.ActivityType.value",
"url":22,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.presences.ActivityType.PLAYING",
"url":22,
"doc":"Shows up as  Playing   "
},
{
"ref":"hikari.presences.ActivityType.STREAMING",
"url":22,
"doc":"Shows up as  Streaming and links to a Twitch or YouTube stream/video.  ! warning You  MUST provide a valid Twitch or YouTube stream URL to the activity you create in order for this to be valid. If you fail to do this, then the activity  WILL NOT update."
},
{
"ref":"hikari.presences.ActivityType.LISTENING",
"url":22,
"doc":"Shows up as  Listening to   ."
},
{
"ref":"hikari.presences.ActivityType.WATCHING",
"url":22,
"doc":"Shows up as  Watching   .  ! warning This is not documented by Discord, and was supposedly going to be removed a long time ago, but that never happened. This may be removed at any time without warning by Discord, so use this at your own risk."
},
{
"ref":"hikari.presences.ActivityType.CUSTOM",
"url":22,
"doc":"A custom status. To set an emoji with the status, place a unicode emoji or Discord emoji ( :smiley: ) as the first part of the status activity name.  ! warning Bots  DO NOT support setting custom statuses."
},
{
"ref":"hikari.presences.ActivityType.COMPETING",
"url":22,
"doc":"Shows up as  Competing in   ."
},
{
"ref":"hikari.presences.ActivityParty",
"url":22,
"doc":"Used to represent activity groups of users. Method generated by attrs for class ActivityParty."
},
{
"ref":"hikari.presences.ActivityParty.current_size",
"url":22,
"doc":"Current size of this party, if applicable."
},
{
"ref":"hikari.presences.ActivityParty.id",
"url":22,
"doc":"The string id of this party instance, if set."
},
{
"ref":"hikari.presences.ActivityParty.max_size",
"url":22,
"doc":"Maximum size of this party, if applicable."
},
{
"ref":"hikari.presences.ClientStatus",
"url":22,
"doc":"The client statuses for this member. Method generated by attrs for class ClientStatus."
},
{
"ref":"hikari.presences.ClientStatus.desktop",
"url":22,
"doc":"The status of the target user's desktop session."
},
{
"ref":"hikari.presences.ClientStatus.mobile",
"url":22,
"doc":"The status of the target user's mobile session."
},
{
"ref":"hikari.presences.ClientStatus.web",
"url":22,
"doc":"The status of the target user's web session."
},
{
"ref":"hikari.presences.MemberPresence",
"url":22,
"doc":"Used to represent a guild member's presence. Method generated by attrs for class MemberPresence."
},
{
"ref":"hikari.presences.MemberPresence.activities",
"url":22,
"doc":"All active user activities. You can assume the first activity is the one that the GUI Discord client will show."
},
{
"ref":"hikari.presences.MemberPresence.app",
"url":22,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.presences.MemberPresence.client_status",
"url":22,
"doc":"Platform-specific user-statuses."
},
{
"ref":"hikari.presences.MemberPresence.guild_id",
"url":22,
"doc":"The ID of the guild this presence belongs to."
},
{
"ref":"hikari.presences.MemberPresence.user_id",
"url":22,
"doc":"The ID of the user this presence belongs to."
},
{
"ref":"hikari.presences.MemberPresence.visible_status",
"url":22,
"doc":"This user's current status being displayed by the client."
},
{
"ref":"hikari.presences.RichActivity",
"url":22,
"doc":"Represents a rich activity that can be associated with a presence. Method generated by attrs for class RichActivity."
},
{
"ref":"hikari.presences.RichActivity.application_id",
"url":22,
"doc":"The ID of the application this activity is for, if applicable."
},
{
"ref":"hikari.presences.RichActivity.assets",
"url":22,
"doc":"Images and their hover over text for the activity."
},
{
"ref":"hikari.presences.RichActivity.created_at",
"url":22,
"doc":"When this activity was added to the user's session."
},
{
"ref":"hikari.presences.RichActivity.details",
"url":22,
"doc":"The text that describes what the activity's target is doing, if set."
},
{
"ref":"hikari.presences.RichActivity.emoji",
"url":22,
"doc":"The emoji of this activity, if it is a custom status and set."
},
{
"ref":"hikari.presences.RichActivity.flags",
"url":22,
"doc":"Flags that describe what the activity includes, if present."
},
{
"ref":"hikari.presences.RichActivity.is_instance",
"url":22,
"doc":"Whether this activity is an instanced game session."
},
{
"ref":"hikari.presences.RichActivity.party",
"url":22,
"doc":"Information about the party associated with this activity, if set."
},
{
"ref":"hikari.presences.RichActivity.secrets",
"url":22,
"doc":"Secrets for Rich Presence joining and spectating."
},
{
"ref":"hikari.presences.RichActivity.state",
"url":22,
"doc":"The current status of this activity's target, if set."
},
{
"ref":"hikari.presences.RichActivity.timestamps",
"url":22,
"doc":"The timestamps for when this activity's current state will start and end, if applicable."
},
{
"ref":"hikari.presences.RichActivity.name",
"url":22,
"doc":"The activity name."
},
{
"ref":"hikari.presences.RichActivity.type",
"url":22,
"doc":"The activity type."
},
{
"ref":"hikari.presences.RichActivity.url",
"url":22,
"doc":"The activity URL. Only valid for  STREAMING activities."
},
{
"ref":"hikari.presences.Status",
"url":22,
"doc":"The status of a member."
},
{
"ref":"hikari.presences.Status.name",
"url":22,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.presences.Status.value",
"url":22,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.presences.Status.ONLINE",
"url":22,
"doc":"Online/green."
},
{
"ref":"hikari.presences.Status.IDLE",
"url":22,
"doc":"Idle/yellow."
},
{
"ref":"hikari.presences.Status.DO_NOT_DISTURB",
"url":22,
"doc":"Do not disturb/red."
},
{
"ref":"hikari.presences.Status.OFFLINE",
"url":22,
"doc":"Offline or invisible/grey."
},
{
"ref":"hikari.applications",
"url":24,
"doc":"Application and entities related to discord's Oauth2 flow."
},
{
"ref":"hikari.applications.Application",
"url":24,
"doc":"Represents the information of an Oauth2 Application. Method generated by attrs for class Application."
},
{
"ref":"hikari.applications.Application.icon_url",
"url":24,
"doc":"Team icon, if there is one. Returns    - typing.Optional[hikari.files.URL] The URL, or  builtins.None if no icon exists."
},
{
"ref":"hikari.applications.Application.format_icon",
"url":24,
"doc":"Generate the icon for this application. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL, or  builtins.None if no icon exists. Raises    builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).",
"func":1
},
{
"ref":"hikari.applications.Application.cover_image_url",
"url":24,
"doc":"Cover image used on the store. Returns    - typing.Optional[hikari.files.URL] The URL, or  builtins.None if no cover image exists."
},
{
"ref":"hikari.applications.Application.format_cover_image",
"url":24,
"doc":"Generate the cover image used in the store, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL, or  builtins.None if no cover image exists. Raises    builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).",
"func":1
},
{
"ref":"hikari.applications.Application.app",
"url":24,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.applications.Application.cover_image_hash",
"url":24,
"doc":"The CDN's hash of this application's cover image, used on the store."
},
{
"ref":"hikari.applications.Application.description",
"url":24,
"doc":"The description of this application, or an empty string if undefined."
},
{
"ref":"hikari.applications.Application.guild_id",
"url":24,
"doc":"The ID of the guild this application is linked to if sold on Discord."
},
{
"ref":"hikari.applications.Application.icon_hash",
"url":24,
"doc":"The CDN hash of this application's icon, if set."
},
{
"ref":"hikari.applications.Application.id",
"url":24,
"doc":"The ID of this entity."
},
{
"ref":"hikari.applications.Application.is_bot_code_grant_required",
"url":24,
"doc":" builtins.True if this application's bot is requiring code grant for invites. Will be  builtins.None if this application doesn't have a bot."
},
{
"ref":"hikari.applications.Application.is_bot_public",
"url":24,
"doc":" builtins.True if the bot associated with this application is public. Will be  builtins.None if this application doesn't have an associated bot."
},
{
"ref":"hikari.applications.Application.name",
"url":24,
"doc":"The name of this application."
},
{
"ref":"hikari.applications.Application.owner",
"url":24,
"doc":"The application's owner. This should always be  builtins.None in application objects retrieved outside Discord's oauth2 flow."
},
{
"ref":"hikari.applications.Application.primary_sku_id",
"url":24,
"doc":"The ID of the primary \"Game SKU\" of a game that's sold on Discord."
},
{
"ref":"hikari.applications.Application.rpc_origins",
"url":24,
"doc":"A collection of this application's RPC origin URLs, if RPC is enabled."
},
{
"ref":"hikari.applications.Application.slug",
"url":24,
"doc":"The URL \"slug\" that is used to point to this application's store page. Only applicable to applications sold on Discord."
},
{
"ref":"hikari.applications.Application.summary",
"url":24,
"doc":"This summary for this application's primary SKU if it's sold on Discord. Will be an empty string if undefined."
},
{
"ref":"hikari.applications.Application.team",
"url":24,
"doc":"The team this application belongs to. If the application is not part of a team, this will be  builtins.None ."
},
{
"ref":"hikari.applications.Application.verify_key",
"url":24,
"doc":"The base64 encoded key used for the GameSDK's  GetTicket ."
},
{
"ref":"hikari.applications.Application.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.applications.ConnectionVisibility",
"url":24,
"doc":"Describes who can see a connection with a third party account."
},
{
"ref":"hikari.applications.ConnectionVisibility.name",
"url":24,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.applications.ConnectionVisibility.value",
"url":24,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.applications.ConnectionVisibility.NONE",
"url":24,
"doc":"Implies that only you can see the corresponding connection."
},
{
"ref":"hikari.applications.ConnectionVisibility.EVERYONE",
"url":24,
"doc":"Everyone can see the connection."
},
{
"ref":"hikari.applications.OAuth2Scope",
"url":24,
"doc":"OAuth2 Scopes that Discord allows. These are categories of permissions for applications using the OAuth2 API directly. Most users will only ever need the  BOT scope when developing bots."
},
{
"ref":"hikari.applications.OAuth2Scope.name",
"url":24,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.applications.OAuth2Scope.value",
"url":24,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.applications.OAuth2Scope.ACTIVITIES_READ",
"url":24,
"doc":"Enables fetching the \"Now Playing/Recently Played\" list.  ! note You must be whitelisted to use this scope."
},
{
"ref":"hikari.applications.OAuth2Scope.ACTIVITIES_WRITE",
"url":24,
"doc":"Enables updating a user's activity.  ! note You must be whitelisted to use this scope.  ! note This is not required to use the GameSDK activity manager."
},
{
"ref":"hikari.applications.OAuth2Scope.APPLICATIONS_BUILDS_READ",
"url":24,
"doc":"Enables reading build data for a user's applications.  ! note You must be whitelisted to use this scope."
},
{
"ref":"hikari.applications.OAuth2Scope.APPLICATIONS_BUILDS_UPLOAD",
"url":24,
"doc":"Enables uploading/updating builds for a user's applications.  ! note You must be whitelisted to use this scope."
},
{
"ref":"hikari.applications.OAuth2Scope.APPLICATIONS_ENTITLEMENTS",
"url":24,
"doc":"Enables reading entitlements for a user's applications."
},
{
"ref":"hikari.applications.OAuth2Scope.APPLICATIONS_STORE_UPDATE",
"url":24,
"doc":"Enables reading/updating store data for the user's applications. This includes store listings, achievements, SKU's, etc.  ! note The store API is deprecated and may be removed in the future."
},
{
"ref":"hikari.applications.OAuth2Scope.BOT",
"url":24,
"doc":"Enables adding a bot application to a guild.  ! note This requires you to have set up a bot account for your application."
},
{
"ref":"hikari.applications.OAuth2Scope.CONNECTIONS",
"url":24,
"doc":"Enables viewing third-party linked accounts such as Twitch."
},
{
"ref":"hikari.applications.OAuth2Scope.EMAIL",
"url":24,
"doc":"Enable the application to view the user's email and application info."
},
{
"ref":"hikari.applications.OAuth2Scope.GROUP_DM_JOIN",
"url":24,
"doc":"Enables joining users into a group DM.  ! warn This cannot add the bot to a group DM."
},
{
"ref":"hikari.applications.OAuth2Scope.GUILDS",
"url":24,
"doc":"Enables viewing the guilds the user is in."
},
{
"ref":"hikari.applications.OAuth2Scope.GUILDS_JOIN",
"url":24,
"doc":"Enables adding the user to a specific guild.  ! note This requires you to have set up a bot account for your application."
},
{
"ref":"hikari.applications.OAuth2Scope.IDENTIFY",
"url":24,
"doc":"Enables viewing info about itself.  ! note This does not include email address info. Use the  EMAIL scope instead to retrieve this information."
},
{
"ref":"hikari.applications.OAuth2Scope.RELATIONSHIPS_READ",
"url":24,
"doc":"Enables viewing a user's friend list.  ! note You must be whitelisted to use this scope."
},
{
"ref":"hikari.applications.OAuth2Scope.RPC",
"url":24,
"doc":"Enables the RPC application to control the local user's Discord client.  ! note You must be whitelisted to use this scope."
},
{
"ref":"hikari.applications.OAuth2Scope.RPC_API",
"url":24,
"doc":"Enables the RPC application to access the RPC API as the local user.  ! note You must be whitelisted to use this scope."
},
{
"ref":"hikari.applications.OAuth2Scope.RPC_MESSAGES_READ",
"url":24,
"doc":"Enables the RPC application to read messages from all channels the user is in."
},
{
"ref":"hikari.applications.OAuth2Scope.RPC_NOTIFICATIONS_READ",
"url":24,
"doc":"Enables the RPC application to read from all channels the user is in.  ! note You must be whitelisted to use this scope."
},
{
"ref":"hikari.applications.OAuth2Scope.WEBHOOK_INCOMING",
"url":24,
"doc":"Used to generate a webhook that is returned in the OAuth2 token response. This is used during authorization code grants."
},
{
"ref":"hikari.applications.OwnConnection",
"url":24,
"doc":"Represents a user's connection with a third party account. Returned by the  GET Current User Connections endpoint. Method generated by attrs for class OwnConnection."
},
{
"ref":"hikari.applications.OwnConnection.id",
"url":24,
"doc":"The string ID of the third party connected account.  ! warning Seeing as this is a third party ID, it will not be a snowflakes."
},
{
"ref":"hikari.applications.OwnConnection.integrations",
"url":24,
"doc":"A sequence of the partial guild integration objects this connection has."
},
{
"ref":"hikari.applications.OwnConnection.is_activity_visible",
"url":24,
"doc":" builtins.True if this connection's activities are shown in the user's presence."
},
{
"ref":"hikari.applications.OwnConnection.is_friend_sync_enabled",
"url":24,
"doc":" builtins.True if friends should be added based on this connection."
},
{
"ref":"hikari.applications.OwnConnection.is_revoked",
"url":24,
"doc":" builtins.True if the connection has been revoked."
},
{
"ref":"hikari.applications.OwnConnection.is_verified",
"url":24,
"doc":" builtins.True if the connection has been verified."
},
{
"ref":"hikari.applications.OwnConnection.name",
"url":24,
"doc":"The username of the connected account."
},
{
"ref":"hikari.applications.OwnConnection.type",
"url":24,
"doc":"The type of service this connection is for."
},
{
"ref":"hikari.applications.OwnConnection.visibility",
"url":24,
"doc":"The visibility of the connection."
},
{
"ref":"hikari.applications.OwnGuild",
"url":24,
"doc":"Represents a user bound partial guild object. Method generated by attrs for class OwnGuild."
},
{
"ref":"hikari.applications.OwnGuild.is_owner",
"url":24,
"doc":" builtins.True when the current user owns this guild."
},
{
"ref":"hikari.applications.OwnGuild.my_permissions",
"url":24,
"doc":"The guild-level permissions that apply to the current user or bot."
},
{
"ref":"hikari.applications.OwnGuild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.applications.OwnGuild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.applications.OwnGuild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.applications.OwnGuild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.applications.OwnGuild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.applications.OwnGuild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.applications.OwnGuild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.applications.OwnGuild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.applications.OwnGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.applications.Team",
"url":24,
"doc":"Represents a development team, along with all its members. Method generated by attrs for class Team."
},
{
"ref":"hikari.applications.Team.icon_url",
"url":24,
"doc":"Team icon. Returns    - typing.Optional[hikari.files.URL] The URL, or  builtins.None if no icon exists."
},
{
"ref":"hikari.applications.Team.format_icon",
"url":24,
"doc":"Generate the icon for this team if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between  16 and  4096 inclusive. Returns    - typing.Optional[hikari.files.URL] The URL, or  builtins.None if no icon exists. Raises    builtins.ValueError If the size is not an integer power of 2 between 16 and 4096 (inclusive).",
"func":1
},
{
"ref":"hikari.applications.Team.app",
"url":24,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.applications.Team.icon_hash",
"url":24,
"doc":"The CDN hash of this team's icon. If no icon is provided, this will be  builtins.None ."
},
{
"ref":"hikari.applications.Team.id",
"url":24,
"doc":"The ID of this entity."
},
{
"ref":"hikari.applications.Team.members",
"url":24,
"doc":"A mapping containing each member in this team. The mapping maps keys containing the member's ID to values containing the member object."
},
{
"ref":"hikari.applications.Team.owner_id",
"url":24,
"doc":"The ID of this team's owner."
},
{
"ref":"hikari.applications.Team.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.applications.TeamMember",
"url":24,
"doc":"Represents a member of a Team. Method generated by attrs for class TeamMember."
},
{
"ref":"hikari.applications.TeamMember.app",
"url":24,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.applications.TeamMember.membership_state",
"url":24,
"doc":"The state of this user's membership."
},
{
"ref":"hikari.applications.TeamMember.permissions",
"url":24,
"doc":"This member's permissions within a team. At the time of writing, this will always be a sequence of one  builtins.str , which will always be  \" \" . This may change in the future, however."
},
{
"ref":"hikari.applications.TeamMember.team_id",
"url":24,
"doc":"The ID of the team this member belongs to."
},
{
"ref":"hikari.applications.TeamMember.user",
"url":24,
"doc":"The user representation of this team member."
},
{
"ref":"hikari.applications.TeamMembershipState",
"url":24,
"doc":"Represents the state of a user's team membership."
},
{
"ref":"hikari.applications.TeamMembershipState.name",
"url":24,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.applications.TeamMembershipState.value",
"url":24,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.applications.TeamMembershipState.INVITED",
"url":24,
"doc":"Denotes the user has been invited to the team but has yet to accept."
},
{
"ref":"hikari.applications.TeamMembershipState.ACCEPTED",
"url":24,
"doc":"Denotes the user has accepted the invite and is now a member."
},
{
"ref":"hikari.events",
"url":25,
"doc":"Events that can be fired by Hikari's gateway implementation."
},
{
"ref":"hikari.events.channel_events",
"url":9,
"doc":"Events that fire when channels are modified. This does not include message events, nor reaction events."
},
{
"ref":"hikari.events.channel_events.ChannelEvent",
"url":9,
"doc":"Event base for any channel-bound event in guilds or private messages. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS -  hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class ChannelEvent."
},
{
"ref":"hikari.events.channel_events.ChannelEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.ChannelEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.PartialChannel A derivative of  hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.ChannelEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.ChannelEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.GuildChannelEvent",
"url":9,
"doc":"Event base for any channel-bound event in guilds. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildChannelEvent."
},
{
"ref":"hikari.events.channel_events.GuildChannelEvent.guild_id",
"url":9,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.channel_events.GuildChannelEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.events.channel_events.GuildChannelEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildChannelEvent.channel",
"url":9,
"doc":"Get the cached channel that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return  builtins.None instead."
},
{
"ref":"hikari.events.channel_events.GuildChannelEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildChannelEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.GuildChannelEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.GuildChannelEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.DMChannelEvent",
"url":9,
"doc":"Event base for any channel-bound event in private messages. Method generated by attrs for class DMChannelEvent."
},
{
"ref":"hikari.events.channel_events.DMChannelEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.PrivateChannel A derivative of  hikari.channels.PrivateChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.DMChannelEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.DMChannelEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.DMChannelEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.ChannelCreateEvent",
"url":9,
"doc":"Base event for any channel being created. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS -  hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class ChannelCreateEvent."
},
{
"ref":"hikari.events.channel_events.ChannelCreateEvent.channel",
"url":9,
"doc":"Channel this event represents. Returns    - hikari.channels.PartialChannel The channel that was created."
},
{
"ref":"hikari.events.channel_events.ChannelCreateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.ChannelCreateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.PartialChannel A derivative of  hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.ChannelCreateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.ChannelCreateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.GuildChannelCreateEvent",
"url":9,
"doc":"Event fired when a guild channel is created. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildChannelCreateEvent."
},
{
"ref":"hikari.events.channel_events.GuildChannelCreateEvent.guild_id",
"url":9,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.channel_events.GuildChannelCreateEvent.app",
"url":9,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.GuildChannelCreateEvent.channel",
"url":9,
"doc":"Guild channel that this event represents. Returns    - hikari.channels.GuildChannel The guild channel that was created."
},
{
"ref":"hikari.events.channel_events.GuildChannelCreateEvent.shard",
"url":9,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.GuildChannelCreateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.events.channel_events.GuildChannelCreateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildChannelCreateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildChannelCreateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.ChannelUpdateEvent",
"url":9,
"doc":"Base event for any channel being updated. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS -  hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class ChannelUpdateEvent."
},
{
"ref":"hikari.events.channel_events.ChannelUpdateEvent.channel",
"url":9,
"doc":"Channel this event represents. Returns    - hikari.channels.PartialChannel The channel that was updated."
},
{
"ref":"hikari.events.channel_events.ChannelUpdateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.ChannelUpdateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.PartialChannel A derivative of  hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.ChannelUpdateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.ChannelUpdateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.GuildChannelUpdateEvent",
"url":9,
"doc":"Event fired when a guild channel is edited. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildChannelUpdateEvent."
},
{
"ref":"hikari.events.channel_events.GuildChannelUpdateEvent.guild_id",
"url":9,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.channel_events.GuildChannelUpdateEvent.app",
"url":9,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.GuildChannelUpdateEvent.channel",
"url":9,
"doc":"Guild channel that this event represents. Returns    - hikari.channels.GuildChannel The guild channel that was updated."
},
{
"ref":"hikari.events.channel_events.GuildChannelUpdateEvent.shard",
"url":9,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.GuildChannelUpdateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.events.channel_events.GuildChannelUpdateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildChannelUpdateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildChannelUpdateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.ChannelDeleteEvent",
"url":9,
"doc":"Base event for any channel being deleted. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS -  hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class ChannelDeleteEvent."
},
{
"ref":"hikari.events.channel_events.ChannelDeleteEvent.channel",
"url":9,
"doc":"Channel this event represents. Returns    - hikari.channels.PartialChannel The channel that was deleted."
},
{
"ref":"hikari.events.channel_events.ChannelDeleteEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.ChannelDeleteEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.PartialChannel A derivative of  hikari.channels.PartialChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.ChannelDeleteEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.ChannelDeleteEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.GuildChannelDeleteEvent",
"url":9,
"doc":"Event fired when a guild channel is deleted. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildChannelDeleteEvent."
},
{
"ref":"hikari.events.channel_events.GuildChannelDeleteEvent.guild_id",
"url":9,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.channel_events.GuildChannelDeleteEvent.app",
"url":9,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.GuildChannelDeleteEvent.channel",
"url":9,
"doc":"Guild channel that this event represents. Returns    - hikari.channels.GuildChannel The guild channel that was deleted."
},
{
"ref":"hikari.events.channel_events.GuildChannelDeleteEvent.shard",
"url":9,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.GuildChannelDeleteEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.events.channel_events.GuildChannelDeleteEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildChannelDeleteEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildChannelDeleteEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.PinsUpdateEvent",
"url":9,
"doc":"Base event fired when a message is pinned/unpinned in a channel. Method generated by attrs for class PinsUpdateEvent."
},
{
"ref":"hikari.events.channel_events.PinsUpdateEvent.last_pin_timestamp",
"url":9,
"doc":"Datetime of when the most recent message was pinned in the channel. Will be  builtins.None if nothing is pinned or the information is unavailable. Returns    - typing.Optional[datetime.datetime] The datetime of the most recent pinned message in the channel, or  builtins.None if no pins are available."
},
{
"ref":"hikari.events.channel_events.PinsUpdateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel. Returns    - hikari.channels.TextChannel A derivative of  hikari.channels.TextChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.PinsUpdateEvent.fetch_pins",
"url":9,
"doc":"Perform an API call to fetch the pinned messages in this channel. Returns    - typing.Sequence[hikari.messages.Message] The pinned messages in this channel.",
"func":1
},
{
"ref":"hikari.events.channel_events.PinsUpdateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.PinsUpdateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.PinsUpdateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent",
"url":9,
"doc":"Event fired when a message is pinned/unpinned in a guild channel. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildPinsUpdateEvent."
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.channel",
"url":9,
"doc":"Get the cached channel that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.channels.GuildTextChannel] The cached channel this event relates to. If not known, this will return  builtins.None instead."
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel. Returns    - hikari.channels.GuildTextChannel A derivative of  hikari.channels.GuildTextChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.app",
"url":9,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.guild_id",
"url":9,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.last_pin_timestamp",
"url":9,
"doc":"Datetime of when the most recent message was pinned in the channel. Will be  builtins.None if nothing is pinned or the information is unavailable. Returns    - typing.Optional[datetime.datetime] The datetime of the most recent pinned message in the channel, or  builtins.None if no pins are available."
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.shard",
"url":9,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.fetch_pins",
"url":9,
"doc":"Perform an API call to fetch the pinned messages in this channel. Returns    - typing.Sequence[hikari.messages.Message] The pinned messages in this channel.",
"func":1
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.events.channel_events.GuildPinsUpdateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.events.channel_events.DMPinsUpdateEvent",
"url":9,
"doc":"Event fired when a message is pinned/unpinned in a private channel. Method generated by attrs for class DMPinsUpdateEvent."
},
{
"ref":"hikari.events.channel_events.DMPinsUpdateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel. Returns    - hikari.channels.DMChannel A derivative of  hikari.channels.DMChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.DMPinsUpdateEvent.app",
"url":9,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.DMPinsUpdateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.DMPinsUpdateEvent.last_pin_timestamp",
"url":9,
"doc":"Datetime of when the most recent message was pinned in the channel. Will be  builtins.None if nothing is pinned or the information is unavailable. Returns    - typing.Optional[datetime.datetime] The datetime of the most recent pinned message in the channel, or  builtins.None if no pins are available."
},
{
"ref":"hikari.events.channel_events.DMPinsUpdateEvent.shard",
"url":9,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.DMPinsUpdateEvent.fetch_pins",
"url":9,
"doc":"Perform an API call to fetch the pinned messages in this channel. Returns    - typing.Sequence[hikari.messages.Message] The pinned messages in this channel.",
"func":1
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent",
"url":9,
"doc":"Event fired when an invite is created in a channel. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_INVITES Method generated by attrs for class InviteCreateEvent."
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.guild_id",
"url":9,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.code",
"url":9,
"doc":"Code that is used in the URL for the invite. Returns    - builtins.str The invite code."
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.app",
"url":9,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.invite",
"url":9,
"doc":"Invite that was created. Returns    - hikari.invites.InviteWithMetadata The created invite object."
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.shard",
"url":9,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.channel",
"url":9,
"doc":"Get the cached channel that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return  builtins.None instead."
},
{
"ref":"hikari.events.channel_events.InviteCreateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent",
"url":9,
"doc":"Event fired when an invite is deleted from a channel. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_INVITES Method generated by attrs for class InviteDeleteEvent."
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent.app",
"url":9,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent.code",
"url":9,
"doc":"Code that is used in the URL for the invite. Returns    - builtins.str The invite code."
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent.guild_id",
"url":9,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent.shard",
"url":9,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent.channel",
"url":9,
"doc":"Get the cached channel that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return  builtins.None instead."
},
{
"ref":"hikari.events.channel_events.InviteDeleteEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent",
"url":9,
"doc":"Event fired when a webhook is created/updated/deleted in a channel. Unfortunately, Discord does not provide any information on what webhook actually changed, nor specifically whether it was created/updated/deleted, so this event is pretty useless unless you keep track of the webhooks in the channel manually beforehand. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_WEBHOOKS Method generated by attrs for class WebhookUpdateEvent."
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.fetch_channel_webhooks",
"url":9,
"doc":"Perform an API call to fetch the webhooks for this channel. Returns    - typing.Sequence[hikari.webhooks.Webhook] The webhooks in this channel.",
"func":1
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.fetch_guild_webhooks",
"url":9,
"doc":"Perform an API call to fetch the webhooks for this guild. Returns    - typing.Sequence[hikari.webhooks.Webhook] The webhooks in this guild.",
"func":1
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.app",
"url":9,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.channel_id",
"url":9,
"doc":"ID of the channel the event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the channel this event relates to."
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.guild_id",
"url":9,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.shard",
"url":9,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.guild",
"url":9,
"doc":"Get the cached guild that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The gateway guild this event relates to, if known. Otherwise this will return  builtins.None ."
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.fetch_guild",
"url":9,
"doc":"Perform an API call to fetch the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild that this event occurred in.",
"func":1
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.channel",
"url":9,
"doc":"Get the cached channel that this event relates to, if known. If not, return  builtins.None . Returns    - typing.Optional[hikari.channels.GuildChannel] The cached channel this event relates to. If not known, this will return  builtins.None instead."
},
{
"ref":"hikari.events.channel_events.WebhookUpdateEvent.fetch_channel",
"url":9,
"doc":"Perform an API call to fetch the details about this channel.  ! note For  ChannelDeleteEvent -derived events, this will always raise an exception, since the channel will have already been removed. Returns    - hikari.channels.GuildChannel A derivative of  hikari.channels.GuildChannel . The actual type will vary depending on the type of channel this event concerns.",
"func":1
},
{
"ref":"hikari.events.typing_events",
"url":13,
"doc":"Events fired when users begin typing in channels."
},
{
"ref":"hikari.events.typing_events.TypingEvent",
"url":13,
"doc":"Base event fired when a user begins typing in a channel. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_TYPING -  hikari.intents.Intents.DM_MESSAGE_TYPING Method generated by attrs for class ShardEvent."
},
{
"ref":"hikari.events.typing_events.TypingEvent.channel_id",
"url":13,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.typing_events.TypingEvent.user_id",
"url":13,
"doc":"ID of the user who triggered this typing event. Returns    - hikari.snowflakes.Snowflake ID of the user who is typing."
},
{
"ref":"hikari.events.typing_events.TypingEvent.timestamp",
"url":13,
"doc":"Timestamp of when this typing event started. Returns    - datetime.datetime UTC timestamp of when the user started typing."
},
{
"ref":"hikari.events.typing_events.TypingEvent.user",
"url":13,
"doc":"Get the cached user that is typing, if known. Returns    - typing.Optional[hikari.users.User] The user, if known."
},
{
"ref":"hikari.events.typing_events.TypingEvent.fetch_channel",
"url":13,
"doc":"Perform an API call to fetch an up-to-date image of this channel. Returns    - hikari.channels.TextChannel The channel.",
"func":1
},
{
"ref":"hikari.events.typing_events.TypingEvent.fetch_user",
"url":13,
"doc":"Perform an API call to fetch an up-to-date image of this user. Returns    - hikari.users.User The user.",
"func":1
},
{
"ref":"hikari.events.typing_events.TypingEvent.trigger_typing",
"url":13,
"doc":"Return a typing indicator for this channel that can be awaited. Returns    - hikari.api.special_endpoints.TypingIndicator A typing indicator context manager and awaitable to trigger typing in a channel with.",
"func":1
},
{
"ref":"hikari.events.typing_events.TypingEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.typing_events.TypingEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent",
"url":13,
"doc":"Event fired when a user starts typing in a guild channel. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_TYPING Method generated by attrs for class GuildTypingEvent."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.channel",
"url":13,
"doc":"Get the cached channel object this typing event occurred in. Returns    - typing.Union[hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel] The channel."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.guild",
"url":13,
"doc":"Get the cached object of the guild this typing event occurred in. If the guild is not found then this will return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the gateway guild if found else  builtins.None ."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.user_id",
"url":13,
"doc":"ID of the user who triggered this typing event. Returns    - hikari.snowflakes.Snowflake ID of the user who is typing."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.fetch_channel",
"url":13,
"doc":"Perform an API call to fetch an up-to-date image of this channel. Returns    - typing.Union[hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel] The channel.",
"func":1
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.fetch_guild",
"url":13,
"doc":"Perform an API call to fetch an up-to-date image of this guild. Returns    - hikari.guilds.Guild The guild.",
"func":1
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.fetch_guild_preview",
"url":13,
"doc":"Perform an API call to fetch an up-to-date preview of this guild. Returns    - hikari.guilds.GuildPreview The guild.",
"func":1
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.fetch_user",
"url":13,
"doc":"Perform an API call to fetch an up-to-date image of this member. Returns    - hikari.guilds.Member The member.",
"func":1
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.app",
"url":13,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.channel_id",
"url":13,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.guild_id",
"url":13,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.shard",
"url":13,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.timestamp",
"url":13,
"doc":"Timestamp of when this typing event started. Returns    - datetime.datetime UTC timestamp of when the user started typing."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.user",
"url":13,
"doc":"Member object of the user who triggered this typing event. Unlike on  PrivateTypingEvent instances, Discord will always send this field in any payload. Returns    - hikari.guilds.Member Member of the user who triggered this typing event."
},
{
"ref":"hikari.events.typing_events.GuildTypingEvent.trigger_typing",
"url":13,
"doc":"Return a typing indicator for this channel that can be awaited. Returns    - hikari.api.special_endpoints.TypingIndicator A typing indicator context manager and awaitable to trigger typing in a channel with.",
"func":1
},
{
"ref":"hikari.events.typing_events.DMTypingEvent",
"url":13,
"doc":"Event fired when a user starts typing in a guild channel. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class DMTypingEvent."
},
{
"ref":"hikari.events.typing_events.DMTypingEvent.user",
"url":13,
"doc":"Get the cached user that is typing, if known. Returns    - typing.Optional[hikari.users.User] The user, if known."
},
{
"ref":"hikari.events.typing_events.DMTypingEvent.fetch_channel",
"url":13,
"doc":"Perform an API call to fetch an up-to-date image of this channel. Returns    - hikari.channels.DMChannel The channel.",
"func":1
},
{
"ref":"hikari.events.typing_events.DMTypingEvent.fetch_user",
"url":13,
"doc":"Perform an API call to fetch an up-to-date image of the user. Returns    - hikari.users.User The user.",
"func":1
},
{
"ref":"hikari.events.typing_events.DMTypingEvent.app",
"url":13,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.typing_events.DMTypingEvent.channel_id",
"url":13,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.typing_events.DMTypingEvent.shard",
"url":13,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.typing_events.DMTypingEvent.timestamp",
"url":13,
"doc":"Timestamp of when this typing event started. Returns    - datetime.datetime UTC timestamp of when the user started typing."
},
{
"ref":"hikari.events.typing_events.DMTypingEvent.user_id",
"url":13,
"doc":"ID of the user who triggered this typing event. Returns    - hikari.snowflakes.Snowflake ID of the user who is typing."
},
{
"ref":"hikari.events.typing_events.DMTypingEvent.trigger_typing",
"url":13,
"doc":"Return a typing indicator for this channel that can be awaited. Returns    - hikari.api.special_endpoints.TypingIndicator A typing indicator context manager and awaitable to trigger typing in a channel with.",
"func":1
},
{
"ref":"hikari.events.message_events",
"url":11,
"doc":"Events that fire if messages are sent/updated/deleted."
},
{
"ref":"hikari.events.message_events.MessageEvent",
"url":11,
"doc":"Any event that concerns manipulation of messages. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGES -  hikari.intents.Intents.GUILD_MESSAGES Method generated by attrs for class MessageEvent."
},
{
"ref":"hikari.events.message_events.MessageEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.MessageEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.message_events.MessageEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.MessageEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent",
"url":11,
"doc":"Event that is fired when a message is created. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGES -  hikari.intents.Intents.GUILD_MESSAGES Method generated by attrs for class MessageCreateEvent."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.author",
"url":11,
"doc":"User that sent the message. Returns    - hikari.users.User The user that sent the message."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.author_id",
"url":11,
"doc":"ID of the author of the message this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the author."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - typing.Optional[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent)."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - typing.Sequence[hikari.embeds.Embed] The embeds in the message."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - builtins.bool  builtins.True if from a bot, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - builtins.bool  builtins.True if from a human user, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.message",
"url":11,
"doc":"Message that was sent in the event. Returns    - hikari.messages.Message The message object that was sent with this event."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.MessageCreateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent",
"url":11,
"doc":"Event that is fired when a message is updated.  ! note Less information will be available here than in the creation event due to Discord limitations. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGES -  hikari.intents.Intents.GUILD_MESSAGES Method generated by attrs for class MessageUpdateEvent."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.author",
"url":11,
"doc":"User that sent the message. Returns    - typing.Optional[hikari.users.User] The user that sent the message. This will be  builtins.None in some cases, such as when Discord updates a message with an embed for a URL preview."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.author_id",
"url":11,
"doc":"ID of the author that triggered this event. Returns    - typing.Optional[hikari.snowflakes.Snowflake] The ID of the author that triggered this event concerns. This will be  builtins.None in some cases, such as when Discord updates a message with an embed for a URL preview."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - hikari.undefined.UndefinedNoneOr[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent). If not part of the update, then this will be  hikari.undefined.UNDEFINED instead."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed The embeds in the message. If the embeds were not changed in this event, then this may instead be  hikari.undefined.UNDEFINED ."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - typing.Optional[builtins.bool]  builtins.True if from a bot, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this will return  builtins.None instead."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - typing.Optional[builtins.bool]  builtins.True if from a human user, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this may return  builtins.None instead."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.message",
"url":11,
"doc":"Partial message that was sent in the event. Returns    - hikari.messages.PartialMessage The partial message object that was sent with this event."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.MessageUpdateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.MessageDeleteEvent",
"url":11,
"doc":"Special event that is triggered when one or more messages get deleted.  ! note Due to Discord limitations, most message information is unavailable during deletion events. You can check if the message was in a singular deletion by checking the  is_bulk attribute. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGES -  hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class MessageDeleteEvent."
},
{
"ref":"hikari.events.message_events.MessageDeleteEvent.channel",
"url":11,
"doc":"Get the cached channel the messages were sent in, if known. Returns    - typing.Union[builtins.None, hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel] The channel the messages were sent in, or  builtins.None if not known/cached. This otherwise will always be a  hikari.channels.GuildTextChannel if it is a normal message, or  hikari.channels.GuildNewsChannel if sent in an announcement channel."
},
{
"ref":"hikari.events.message_events.MessageDeleteEvent.message_id",
"url":11,
"doc":"Get the ID of the first deleted message. This is contextually useful if you know this is not a bulk deletion event. For all other purposes, this is the same as running  next(iter(event.message_ids  . Returns    - hikari.snowflakes.Snowflake The first deleted message ID."
},
{
"ref":"hikari.events.message_events.MessageDeleteEvent.message_ids",
"url":11,
"doc":"Set of message IDs that were bulk deleted. Returns    - typing.AbstractSet[hikari.snowflakes.Snowflake] A sequence of message IDs that were bulk deleted."
},
{
"ref":"hikari.events.message_events.MessageDeleteEvent.is_bulk",
"url":11,
"doc":"Flag that determines whether this was a bulk deletion or not. Returns    - builtins.bool  builtins.True if this was a bulk deletion, or  builtins.False if it was a regular message deletion."
},
{
"ref":"hikari.events.message_events.MessageDeleteEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.MessageDeleteEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.MessageDeleteEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent",
"url":11,
"doc":"Event that is fired when a message is created within a guild. This contains the full message in the internal  message attribute. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGES Method generated by attrs for class GuildMessageCreateEvent."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.author",
"url":11,
"doc":"Member or user that sent the message. Returns    - hikari.guilds.Member The member that sent the message."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.channel",
"url":11,
"doc":"Channel that the message was sent in, if known. Returns    - typing.Union[builtins.None, hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel] The channel that the message was sent in, if known and cached, otherwise,  builtins.None ."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.guild",
"url":11,
"doc":"Get the cached guild that this event occurred in, if known.  ! note This will require the  GUILDS intent to be specified on start-up in order to be known. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if cached. Otherwise,  builtins.None instead."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.guild_id",
"url":11,
"doc":"ID of the guild that this event occurred in. Returns    - hikari.snowflakes.Snowflake The ID of the guild that this event occurred in."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.app",
"url":11,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.message",
"url":11,
"doc":"Message that was sent in the event. Returns    - hikari.messages.Message The message object that was sent with this event."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.shard",
"url":11,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.author_id",
"url":11,
"doc":"ID of the author of the message this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the author."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - typing.Optional[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent)."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - typing.Sequence[hikari.embeds.Embed] The embeds in the message."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - builtins.bool  builtins.True if from a bot, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - builtins.bool  builtins.True if from a human user, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.GuildMessageCreateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent",
"url":11,
"doc":"Event that is fired when a message is updated in a guild.  ! note Less information will be available here than in the creation event due to Discord limitations. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGES Method generated by attrs for class GuildMessageUpdateEvent."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.author",
"url":11,
"doc":"Member or user that sent the message. Returns    - typing.Union[builtins.None, hikari.users.User, hikari.guilds.Member] The user that sent the message. If the member is cached (the intents are enabled), then this will be the corresponding member object instead (which is a specialization of the user object you should otherwise expect). This will be  builtins.None in some cases, such as when Discord updates a message with an embed for a URL preview."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.channel",
"url":11,
"doc":"Channel that the message was sent in, if known. Returns    - typing.Union[builtins.None, hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel] The channel that the message was sent in, if known and cached, otherwise,  builtins.None ."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.guild",
"url":11,
"doc":"Get the cached guild that this event occurred in, if known.  ! note This will require the  GUILDS intent to be specified on start-up in order to be known. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if cached. Otherwise,  builtins.None instead."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.guild_id",
"url":11,
"doc":"ID of the guild that this event occurred in. Returns    - hikari.snowflakes.Snowflake The ID of the guild that this event occurred in."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.app",
"url":11,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.message",
"url":11,
"doc":"Partial message that was sent in the event. Returns    - hikari.messages.PartialMessage The partial message object that was sent with this event."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.shard",
"url":11,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.author_id",
"url":11,
"doc":"ID of the author that triggered this event. Returns    - typing.Optional[hikari.snowflakes.Snowflake] The ID of the author that triggered this event concerns. This will be  builtins.None in some cases, such as when Discord updates a message with an embed for a URL preview."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - hikari.undefined.UndefinedNoneOr[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent). If not part of the update, then this will be  hikari.undefined.UNDEFINED instead."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed The embeds in the message. If the embeds were not changed in this event, then this may instead be  hikari.undefined.UNDEFINED ."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - typing.Optional[builtins.bool]  builtins.True if from a bot, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this will return  builtins.None instead."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - typing.Optional[builtins.bool]  builtins.True if from a human user, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this may return  builtins.None instead."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.GuildMessageUpdateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent",
"url":11,
"doc":"Event that is triggered if messages are deleted in a guild.  ! note Due to Discord limitations, most message information is unavailable during deletion events. This is triggered for singular message deletion, and bulk message deletion. You can check if the message was in a singular deletion by checking the  is_bulk attribute. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGES Method generated by attrs for class GuildMessageDeleteEvent."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent.guild",
"url":11,
"doc":"Get the cached guild this event corresponds to, if known.  ! note You will need  hikari.intents.Intents.GUILDS enabled to receive this information. Returns    - hikari.guilds.GatewayGuild The gateway guild that this event corresponds to, if known and cached."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent.app",
"url":11,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent.guild_id",
"url":11,
"doc":"ID of the guild that this event occurred in. Returns    - hikari.snowflakes.Snowflake The ID of the guild."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent.is_bulk",
"url":11,
"doc":"Flag that determines whether this was a bulk deletion or not. Returns    - builtins.bool  builtins.True if this was a bulk deletion, or  builtins.False if it was a regular message deletion."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent.message_ids",
"url":11,
"doc":"Set of message IDs that were bulk deleted. Returns    - typing.AbstractSet[hikari.snowflakes.Snowflake] A sequence of message IDs that were bulk deleted."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent.shard",
"url":11,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent.channel",
"url":11,
"doc":"Get the cached channel the messages were sent in, if known. Returns    - typing.Union[builtins.None, hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel] The channel the messages were sent in, or  builtins.None if not known/cached. This otherwise will always be a  hikari.channels.GuildTextChannel if it is a normal message, or  hikari.channels.GuildNewsChannel if sent in an announcement channel."
},
{
"ref":"hikari.events.message_events.GuildMessageDeleteEvent.message_id",
"url":11,
"doc":"Get the ID of the first deleted message. This is contextually useful if you know this is not a bulk deletion event. For all other purposes, this is the same as running  next(iter(event.message_ids  . Returns    - hikari.snowflakes.Snowflake The first deleted message ID."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent",
"url":11,
"doc":"Event that is fired when a message is created within a DM. This contains the full message in the internal  message attribute. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class DMMessageCreateEvent."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.app",
"url":11,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.message",
"url":11,
"doc":"Message that was sent in the event. Returns    - hikari.messages.Message The message object that was sent with this event."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.shard",
"url":11,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.author",
"url":11,
"doc":"User that sent the message. Returns    - hikari.users.User The user that sent the message."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.author_id",
"url":11,
"doc":"ID of the author of the message this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the author."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - typing.Optional[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent)."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - typing.Sequence[hikari.embeds.Embed] The embeds in the message."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - builtins.bool  builtins.True if from a bot, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - builtins.bool  builtins.True if from a human user, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.DMMessageCreateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent",
"url":11,
"doc":"Event that is fired when a message is updated in a DM.  ! note Less information will be available here than in the creation event due to Discord limitations. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class DMMessageUpdateEvent."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.app",
"url":11,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.message",
"url":11,
"doc":"Partial message that was sent in the event. Returns    - hikari.messages.PartialMessage The partial message object that was sent with this event."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.shard",
"url":11,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.author",
"url":11,
"doc":"User that sent the message. Returns    - typing.Optional[hikari.users.User] The user that sent the message. This will be  builtins.None in some cases, such as when Discord updates a message with an embed for a URL preview."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.author_id",
"url":11,
"doc":"ID of the author that triggered this event. Returns    - typing.Optional[hikari.snowflakes.Snowflake] The ID of the author that triggered this event concerns. This will be  builtins.None in some cases, such as when Discord updates a message with an embed for a URL preview."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.content",
"url":11,
"doc":"Content of the message. Returns    - hikari.undefined.UndefinedNoneOr[builtins.str] The content of the message, if present. This may be  builtins.None or an empty string (or any falsy value) if no content is present (e.g. if only an embed was sent). If not part of the update, then this will be  hikari.undefined.UNDEFINED instead."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.embeds",
"url":11,
"doc":"Sequence of embeds in the message. Returns    - hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed The embeds in the message. If the embeds were not changed in this event, then this may instead be  hikari.undefined.UNDEFINED ."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.is_bot",
"url":11,
"doc":"Return  builtins.True if the message is from a bot. Returns    - typing.Optional[builtins.bool]  builtins.True if from a bot, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this will return  builtins.None instead."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.is_human",
"url":11,
"doc":"Return  builtins.True if the message was created by a human. Returns    - typing.Optional[builtins.bool]  builtins.True if from a human user, or  builtins.False otherwise. If the author is not known, due to the update event being caused by Discord adding an embed preview to accompany a URL, then this may return  builtins.None instead."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.is_webhook",
"url":11,
"doc":"Return  builtins.True if the message was created by a webhook. Returns    - builtins.bool  builtins.True if from a webhook, or  builtins.False otherwise."
},
{
"ref":"hikari.events.message_events.DMMessageUpdateEvent.message_id",
"url":11,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.message_events.DMMessageDeleteEvent",
"url":11,
"doc":"Event that is triggered if messages are deleted in a DM.  ! note Due to Discord limitations, most message information is unavailable during deletion events. This is triggered for singular message deletion, and bulk message deletion, although the latter is not expected to occur in DMs. You can check if the message was in a singular deletion by checking the  is_bulk attribute. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGES Method generated by attrs for class DMMessageDeleteEvent."
},
{
"ref":"hikari.events.message_events.DMMessageDeleteEvent.app",
"url":11,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.message_events.DMMessageDeleteEvent.channel_id",
"url":11,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.message_events.DMMessageDeleteEvent.is_bulk",
"url":11,
"doc":"Flag that determines whether this was a bulk deletion or not. Returns    - builtins.bool  builtins.True if this was a bulk deletion, or  builtins.False if it was a regular message deletion."
},
{
"ref":"hikari.events.message_events.DMMessageDeleteEvent.message_ids",
"url":11,
"doc":"Set of message IDs that were bulk deleted. Returns    - typing.AbstractSet[hikari.snowflakes.Snowflake] A sequence of message IDs that were bulk deleted."
},
{
"ref":"hikari.events.message_events.DMMessageDeleteEvent.shard",
"url":11,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.message_events.DMMessageDeleteEvent.channel",
"url":11,
"doc":"Get the cached channel the messages were sent in, if known. Returns    - typing.Union[builtins.None, hikari.channels.GuildTextChannel, hikari.channels.GuildNewsChannel] The channel the messages were sent in, or  builtins.None if not known/cached. This otherwise will always be a  hikari.channels.GuildTextChannel if it is a normal message, or  hikari.channels.GuildNewsChannel if sent in an announcement channel."
},
{
"ref":"hikari.events.message_events.DMMessageDeleteEvent.message_id",
"url":11,
"doc":"Get the ID of the first deleted message. This is contextually useful if you know this is not a bulk deletion event. For all other purposes, this is the same as running  next(iter(event.message_ids  . Returns    - hikari.snowflakes.Snowflake The first deleted message ID."
},
{
"ref":"hikari.events.shard_events",
"url":5,
"doc":"Events relating to specific shards events."
},
{
"ref":"hikari.events.shard_events.ShardEvent",
"url":5,
"doc":"Base class for any event that was shard-specific. Method generated by attrs for class ShardEvent."
},
{
"ref":"hikari.events.shard_events.ShardEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.shard_events.ShardEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.shard_events.ShardStateEvent",
"url":5,
"doc":"Base class for any event concerning the state/connectivity of a shard. This currently wraps connection/disconnection/ready/resumed events only. Method generated by attrs for class ShardStateEvent."
},
{
"ref":"hikari.events.shard_events.ShardStateEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.shard_events.ShardStateEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.shard_events.ShardConnectedEvent",
"url":5,
"doc":"Event fired when a shard connects. Method generated by attrs for class ShardConnectedEvent."
},
{
"ref":"hikari.events.shard_events.ShardConnectedEvent.app",
"url":5,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.shard_events.ShardConnectedEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.shard_events.ShardDisconnectedEvent",
"url":5,
"doc":"Event fired when a shard disconnects. Method generated by attrs for class ShardDisconnectedEvent."
},
{
"ref":"hikari.events.shard_events.ShardDisconnectedEvent.app",
"url":5,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.shard_events.ShardDisconnectedEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.shard_events.ShardReadyEvent",
"url":5,
"doc":"Event fired when a shard declares it is ready. Method generated by attrs for class ShardReadyEvent."
},
{
"ref":"hikari.events.shard_events.ShardReadyEvent.actual_gateway_version",
"url":5,
"doc":"Actual gateway version being used. Returns    - builtins.int The actual gateway version we are actively using for this protocol."
},
{
"ref":"hikari.events.shard_events.ShardReadyEvent.app",
"url":5,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.shard_events.ShardReadyEvent.my_user",
"url":5,
"doc":"User for the current bot account this connection is authenticated with. Returns    - hikari.users.OwnUser This bot's user."
},
{
"ref":"hikari.events.shard_events.ShardReadyEvent.session_id",
"url":5,
"doc":"ID for this session. Returns    - builtins.str The session ID for this gateway session."
},
{
"ref":"hikari.events.shard_events.ShardReadyEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.shard_events.ShardReadyEvent.unavailable_guilds",
"url":5,
"doc":"Sequence of the IDs for all guilds this bot is currently in. All guilds will start off \"unavailable\" and should become available after a few seconds of connecting one-by-one. Returns    - typing.Sequence[hikari.snowflakes.Snowflake] All guild IDs that the bot is in for this shard."
},
{
"ref":"hikari.events.shard_events.ShardResumedEvent",
"url":5,
"doc":"Event fired when a shard resumes an existing session. Method generated by attrs for class ShardResumedEvent."
},
{
"ref":"hikari.events.shard_events.ShardResumedEvent.app",
"url":5,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.shard_events.ShardResumedEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent",
"url":5,
"doc":"Event fired when a member chunk payload is received on a gateway shard. Method generated by attrs for class MemberChunkEvent."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent.app",
"url":5,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent.chunk_count",
"url":5,
"doc":"Total number of expected chunks for the request this is associated with. Returns    - builtins.int Total number of chunks to be expected."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent.chunk_index",
"url":5,
"doc":"Zero-indexed position of this within the queued up chunks for this request. Returns    - builtins.int The sequence index for this chunk."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent.guild_id",
"url":5,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent.members",
"url":5,
"doc":"Mapping of user IDs to the objects of the members in this chunk. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.guilds.Member] Mapping of user IDs to corresponding member objects."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent.nonce",
"url":5,
"doc":"String nonce used to identify the request member chunks are associated with. This is the nonce value passed while requesting member chunks. Returns    - typing.Optional[builtins.str] The request nonce if set, or  builtins.None otherwise."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent.not_found",
"url":5,
"doc":"Sequence of the snowflakes that were not found while making this request. This is only applicable when user IDs are specified while making the member request the chunk is associated with. Returns    - typing.Sequence[hikari.snowflakes.Snowflake] Sequence of user IDs that were not found."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent.presences",
"url":5,
"doc":"Mapping of user IDs to found member presence objects. This will be empty if no presences are found or  include_presences is not passed as  builtins.True while requesting the member chunks. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] Mapping of user IDs to corresponding presences."
},
{
"ref":"hikari.events.shard_events.MemberChunkEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.lifetime_events",
"url":26,
"doc":"Events that are bound to the lifetime of an application. These are types of hooks that can be invoked on startup or shutdown, which can be used to initialize other resources, fetch information, and perform checks."
},
{
"ref":"hikari.events.lifetime_events.StartingEvent",
"url":26,
"doc":"Event that is triggered before the application connects to discord. This will only fire once per  _rest.run / _rest.start , so is suitable for opening database connections and other resources that need to be initialized within a coroutine function.  ! warning The application will not proceed to connect to Discord until all event handlers for this event have completed/terminated. This prevents the risk of race conditions occurring (e.g. allowing message events to try to access a database that has not yet connected fully). If you want to do something _after_ the application has initialized, you should consider using  StartedEvent instead. See Also      StartedEvent  StoppingEvent  StoppedEvent Method generated by attrs for class StartingEvent."
},
{
"ref":"hikari.events.lifetime_events.StartingEvent.app",
"url":26,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.lifetime_events.StartedEvent",
"url":26,
"doc":"Event that is triggered after the application has started. This will only fire once per  _rest.run / _rest.start , so is suitable for opening database connections and other resources that need to be initialized within a coroutine function. If you want to do something _before_ the application connects, you should consider using  StartingEvent instead. See Also      StartingEvent  StoppingEvent  StoppedEvent Method generated by attrs for class StartedEvent."
},
{
"ref":"hikari.events.lifetime_events.StartedEvent.app",
"url":26,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.lifetime_events.StoppingEvent",
"url":26,
"doc":"Event that is triggered as soon as the application is requested to close. This will fire before the connection is physically disconnected. This will only fire once per  _rest.close , so is suitable for closing database connections and other resources that need to be closed within a coroutine function.  ! warning The application will not proceed to disconnect from Discord until all event handlers for this event have completed/terminated. This prevents the risk of race conditions occurring from code that relies on a connection still being available to complete. If you want to do something _after_ the disconnection has occurred, you should consider using  StoppedEvent instead. See Also      StartingEvent  StartedEvent  StoppedEvent Method generated by attrs for class StoppingEvent."
},
{
"ref":"hikari.events.lifetime_events.StoppingEvent.app",
"url":26,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.lifetime_events.StoppedEvent",
"url":26,
"doc":"Event that is triggered once the application has disconnected. This will only fire once per  _rest.close , so is suitable for closing database connections and other resources that need to be closed within a coroutine function.  ! warning The application will not proceed to leave the  _rest.run call until all event handlers for this event have completed/terminated. This prevents the risk of race conditions occurring where a script may terminate the process before a callback can occur. If you want to do something when the application is preparing to shut down, but _before_ any connection to discord is closed, you should consider using  StoppingEvent instead. See Also      StartingEvent  StartedEvent  StoppingEvent Method generated by attrs for class StoppedEvent."
},
{
"ref":"hikari.events.lifetime_events.StoppedEvent.app",
"url":26,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.role_events",
"url":27,
"doc":"Events pertaining to manipulation of roles within guilds."
},
{
"ref":"hikari.events.role_events.RoleEvent",
"url":27,
"doc":"Event base for any event that involves guild roles. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class RoleEvent."
},
{
"ref":"hikari.events.role_events.RoleEvent.guild_id",
"url":27,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.role_events.RoleEvent.role_id",
"url":27,
"doc":"ID of the role that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the role that relates to this event."
},
{
"ref":"hikari.events.role_events.RoleEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.role_events.RoleEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.role_events.RoleCreateEvent",
"url":27,
"doc":"Event fired when a role is created. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class RoleCreateEvent."
},
{
"ref":"hikari.events.role_events.RoleCreateEvent.guild_id",
"url":27,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.role_events.RoleCreateEvent.role_id",
"url":27,
"doc":"ID of the role that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the role that relates to this event."
},
{
"ref":"hikari.events.role_events.RoleCreateEvent.app",
"url":27,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.role_events.RoleCreateEvent.role",
"url":27,
"doc":"Role that was created. Returns    - hikari.guilds.Role The created role."
},
{
"ref":"hikari.events.role_events.RoleCreateEvent.shard",
"url":27,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.role_events.RoleUpdateEvent",
"url":27,
"doc":"Event fired when a role is updated. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class RoleUpdateEvent."
},
{
"ref":"hikari.events.role_events.RoleUpdateEvent.guild_id",
"url":27,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.role_events.RoleUpdateEvent.role_id",
"url":27,
"doc":"ID of the role that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the role that relates to this event."
},
{
"ref":"hikari.events.role_events.RoleUpdateEvent.app",
"url":27,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.role_events.RoleUpdateEvent.role",
"url":27,
"doc":"Role that was updated. Returns    - hikari.guilds.Role The created role."
},
{
"ref":"hikari.events.role_events.RoleUpdateEvent.shard",
"url":27,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.role_events.RoleDeleteEvent",
"url":27,
"doc":"Event fired when a role is deleted. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class RoleDeleteEvent."
},
{
"ref":"hikari.events.role_events.RoleDeleteEvent.app",
"url":27,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.role_events.RoleDeleteEvent.guild_id",
"url":27,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.role_events.RoleDeleteEvent.role_id",
"url":27,
"doc":"ID of the role that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the role that relates to this event."
},
{
"ref":"hikari.events.role_events.RoleDeleteEvent.shard",
"url":27,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.user_events",
"url":28,
"doc":"Events fired when the account user is updated."
},
{
"ref":"hikari.events.user_events.OwnUserUpdateEvent",
"url":28,
"doc":"Event fired when the account user is updated. Method generated by attrs for class OwnUserUpdateEvent."
},
{
"ref":"hikari.events.user_events.OwnUserUpdateEvent.app",
"url":28,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.user_events.OwnUserUpdateEvent.shard",
"url":28,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.user_events.OwnUserUpdateEvent.user",
"url":28,
"doc":"This application user. Returns    - hikari.users.OwnUser This application user."
},
{
"ref":"hikari.events.reaction_events",
"url":12,
"doc":"Events that fire if messages are reacted to."
},
{
"ref":"hikari.events.reaction_events.ReactionEvent",
"url":12,
"doc":"Event base for any message reaction event. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class ReactionEvent."
},
{
"ref":"hikari.events.reaction_events.ReactionEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.ReactionEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.GuildReactionEvent",
"url":12,
"doc":"Event base for any reaction-bound event in guild messages. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS Method generated by attrs for class GuildReactionEvent."
},
{
"ref":"hikari.events.reaction_events.GuildReactionEvent.guild_id",
"url":12,
"doc":"ID of the guild that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the guild that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.GuildReactionEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.DMReactionEvent",
"url":12,
"doc":"Event base for any reaction-bound event in private messages. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class DMReactionEvent."
},
{
"ref":"hikari.events.reaction_events.DMReactionEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.DMReactionEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.ReactionAddEvent",
"url":12,
"doc":"Event base for any reaction that is added to a message. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class ReactionAddEvent."
},
{
"ref":"hikari.events.reaction_events.ReactionAddEvent.user_id",
"url":12,
"doc":"ID of the user that added this reaction. Returns    - hikari.snowflakes.Snowflake The ID of the user that added this reaction."
},
{
"ref":"hikari.events.reaction_events.ReactionAddEvent.emoji",
"url":12,
"doc":"Emoji that was added. Returns    - hikari.emojis.Emoji The  hikari.emojis.UnicodeEmoji or  hikari.emojis.CustomEmoji that was added to the message."
},
{
"ref":"hikari.events.reaction_events.ReactionAddEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionAddEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionAddEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.ReactionAddEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEvent",
"url":12,
"doc":"Event base for any single reaction that is removed from a message. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class ReactionDeleteEvent."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEvent.user_id",
"url":12,
"doc":"User ID for the user that added this reaction initially. Returns    - hikari.snowflakes.Snowflake The ID of the user that removed this reaction."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEvent.emoji",
"url":12,
"doc":"Emoji that was removed. Returns    - hikari.emojis.Emoji The  hikari.emojis.UnicodeEmoji or  hikari.emojis.CustomEmoji that was removed from the message."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEmojiEvent",
"url":12,
"doc":"Event base fired when all reactions are removed for one emoji. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class ReactionDeleteEmojiEvent."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEmojiEvent.emoji",
"url":12,
"doc":"Emoji that was removed. Returns    - hikari.emojis.Emoji The  hikari.emojis.UnicodeEmoji or  hikari.emojis.CustomEmoji that was removed from the message."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEmojiEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEmojiEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEmojiEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteEmojiEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteAllEvent",
"url":12,
"doc":"Event base fired when all reactions are removed from a message. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class ReactionDeleteAllEvent."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteAllEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteAllEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteAllEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.ReactionDeleteAllEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.GuildReactionAddEvent",
"url":12,
"doc":"Event fired when a reaction is added to a guild message. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS Method generated by attrs for class GuildReactionAddEvent."
},
{
"ref":"hikari.events.reaction_events.GuildReactionAddEvent.guild_id",
"url":12,
"doc":"ID of the guild that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the guild that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionAddEvent.user_id",
"url":12,
"doc":"ID of the user that added this reaction. Returns    - hikari.snowflakes.Snowflake The ID of the user that added this reaction."
},
{
"ref":"hikari.events.reaction_events.GuildReactionAddEvent.app",
"url":12,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.GuildReactionAddEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionAddEvent.emoji",
"url":12,
"doc":"Emoji that was added. Returns    - hikari.emojis.Emoji The  hikari.emojis.UnicodeEmoji or  hikari.emojis.CustomEmoji that was added to the message."
},
{
"ref":"hikari.events.reaction_events.GuildReactionAddEvent.member",
"url":12,
"doc":"Member that added the reaction. Returns    - hikari.guilds.Member The member which added this reaction."
},
{
"ref":"hikari.events.reaction_events.GuildReactionAddEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionAddEvent.shard",
"url":12,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEvent",
"url":12,
"doc":"Event fired when a reaction is removed from a guild message. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS Method generated by attrs for class GuildReactionDeleteEvent."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEvent.app",
"url":12,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEvent.emoji",
"url":12,
"doc":"Emoji that was removed. Returns    - hikari.emojis.Emoji The  hikari.emojis.UnicodeEmoji or  hikari.emojis.CustomEmoji that was removed from the message."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEvent.guild_id",
"url":12,
"doc":"ID of the guild that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the guild that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEvent.shard",
"url":12,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEvent.user_id",
"url":12,
"doc":"User ID for the user that added this reaction initially. Returns    - hikari.snowflakes.Snowflake The ID of the user that removed this reaction."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEmojiEvent",
"url":12,
"doc":"Event fired when an emoji is removed from a guild message's reactions. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS Method generated by attrs for class GuildReactionDeleteEmojiEvent."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.app",
"url":12,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.emoji",
"url":12,
"doc":"Emoji that was removed. Returns    - hikari.emojis.Emoji The  hikari.emojis.UnicodeEmoji or  hikari.emojis.CustomEmoji that was removed from the message."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.guild_id",
"url":12,
"doc":"ID of the guild that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the guild that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteEmojiEvent.shard",
"url":12,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteAllEvent",
"url":12,
"doc":"Event fired when all of a guild message's reactions are removed. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MESSAGE_REACTIONS Method generated by attrs for class GuildReactionDeleteAllEvent."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteAllEvent.app",
"url":12,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteAllEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteAllEvent.guild_id",
"url":12,
"doc":"ID of the guild that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the guild that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteAllEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.GuildReactionDeleteAllEvent.shard",
"url":12,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.DMReactionAddEvent",
"url":12,
"doc":"Event fired when a reaction is added to a private message. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class DMReactionAddEvent."
},
{
"ref":"hikari.events.reaction_events.DMReactionAddEvent.app",
"url":12,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.DMReactionAddEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionAddEvent.emoji",
"url":12,
"doc":"Emoji that was added. Returns    - hikari.emojis.Emoji The  hikari.emojis.UnicodeEmoji or  hikari.emojis.CustomEmoji that was added to the message."
},
{
"ref":"hikari.events.reaction_events.DMReactionAddEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionAddEvent.shard",
"url":12,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.DMReactionAddEvent.user_id",
"url":12,
"doc":"ID of the user that added this reaction. Returns    - hikari.snowflakes.Snowflake The ID of the user that added this reaction."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEvent",
"url":12,
"doc":"Event fired when a reaction is removed from a private message. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class DMReactionDeleteEvent."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEvent.app",
"url":12,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEvent.emoji",
"url":12,
"doc":"Emoji that was removed. Returns    - hikari.emojis.Emoji The  hikari.emojis.UnicodeEmoji or  hikari.emojis.CustomEmoji that was removed from the message."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEvent.shard",
"url":12,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEvent.user_id",
"url":12,
"doc":"User ID for the user that added this reaction initially. Returns    - hikari.snowflakes.Snowflake The ID of the user that removed this reaction."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEmojiEvent",
"url":12,
"doc":"Event fired when an emoji is removed from a private message's reactions. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class DMReactionDeleteEmojiEvent."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEmojiEvent.app",
"url":12,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEmojiEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEmojiEvent.emoji",
"url":12,
"doc":"Emoji that was removed. Returns    - hikari.emojis.Emoji The  hikari.emojis.UnicodeEmoji or  hikari.emojis.CustomEmoji that was removed from the message."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEmojiEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteEmojiEvent.shard",
"url":12,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteAllEvent",
"url":12,
"doc":"Event fired when all of a private message's reactions are removed. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.DM_MESSAGE_REACTIONS Method generated by attrs for class DMReactionDeleteAllEvent."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteAllEvent.app",
"url":12,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteAllEvent.channel_id",
"url":12,
"doc":"ID of the channel that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the channel that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteAllEvent.message_id",
"url":12,
"doc":"ID of the message that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the message that this event concerns."
},
{
"ref":"hikari.events.reaction_events.DMReactionDeleteAllEvent.shard",
"url":12,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.voice_events",
"url":29,
"doc":"Events that fire when voice state changes."
},
{
"ref":"hikari.events.voice_events.VoiceEvent",
"url":29,
"doc":"Base for any voice-related event. Method generated by attrs for class VoiceEvent."
},
{
"ref":"hikari.events.voice_events.VoiceEvent.guild_id",
"url":29,
"doc":"ID of the guild this event is for. Returns    - hikari.snowflakes.Snowflake The guild ID of the guild this event relates to."
},
{
"ref":"hikari.events.voice_events.VoiceEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.voice_events.VoiceEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.voice_events.VoiceStateUpdateEvent",
"url":29,
"doc":"Event fired when a user changes their voice state. Sent when a user joins, leaves or moves voice channel(s). This is also fired for the application user, and is used when preparing to connect to the voice gateway to stream audio or video content. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_VOICE_STATES Method generated by attrs for class VoiceStateUpdateEvent."
},
{
"ref":"hikari.events.voice_events.VoiceStateUpdateEvent.guild_id",
"url":29,
"doc":"ID of the guild this event is for. Returns    - hikari.snowflakes.Snowflake The guild ID of the guild this event relates to."
},
{
"ref":"hikari.events.voice_events.VoiceStateUpdateEvent.app",
"url":29,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.voice_events.VoiceStateUpdateEvent.shard",
"url":29,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.voice_events.VoiceStateUpdateEvent.state",
"url":29,
"doc":"Voice state that this update contained. Returns    - hikari.voices.VoiceState The voice state that was updated."
},
{
"ref":"hikari.events.voice_events.VoiceServerUpdateEvent",
"url":29,
"doc":"Event fired when a voice server is changed. Sent when initially connecting to voice and when the current voice instance falls over to a new server. Method generated by attrs for class VoiceServerUpdateEvent."
},
{
"ref":"hikari.events.voice_events.VoiceServerUpdateEvent.endpoint",
"url":29,
"doc":"URI for this voice server host, with the correct scheme prepended. Returns    - builtins.str The URI to use to connect to the voice gateway."
},
{
"ref":"hikari.events.voice_events.VoiceServerUpdateEvent.app",
"url":29,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.voice_events.VoiceServerUpdateEvent.guild_id",
"url":29,
"doc":"ID of the guild this event is for. Returns    - hikari.snowflakes.Snowflake The guild ID of the guild this event relates to."
},
{
"ref":"hikari.events.voice_events.VoiceServerUpdateEvent.raw_endpoint",
"url":29,
"doc":"Raw endpoint URI that Discord sent.  ! warning This will not contain the scheme to use. Use the  endpoint property to get a representation that has this prepended. Returns    - builtins.str A scheme-less endpoint URI for the endpoint to use for a new voice websocket."
},
{
"ref":"hikari.events.voice_events.VoiceServerUpdateEvent.shard",
"url":29,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.voice_events.VoiceServerUpdateEvent.token",
"url":29,
"doc":"Token that should be used to authenticate with the voice gateway. Returns    - builtins.str The token to use to authenticate with the voice gateway."
},
{
"ref":"hikari.events.guild_events",
"url":4,
"doc":"Events that fire when something occurs within a guild."
},
{
"ref":"hikari.events.guild_events.GuildEvent",
"url":4,
"doc":"Event base for any guild-bound event. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS -  hikari.intents.Intents.GUILD_BANS -  hikari.intents.Intents.GUILD_EMOJIS -  hikari.intents.Intents.GUILD_PRESENCES Method generated by attrs for class GuildEvent."
},
{
"ref":"hikari.events.guild_events.GuildEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.GuildEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.events.guild_events.GuildEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.GuildEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.GuildVisibilityEvent",
"url":4,
"doc":"Event base for any event that changes the visibility of a guild. This includes when a guild becomes available after an outage, when a guild becomes available on startup, when a guild becomes unavailable due to an outage, when the user is kicked/banned/leaves a guild, or when the user joins a new guild. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildVisibilityEvent."
},
{
"ref":"hikari.events.guild_events.GuildVisibilityEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.GuildVisibilityEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.events.guild_events.GuildVisibilityEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildVisibilityEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildVisibilityEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.GuildVisibilityEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent",
"url":4,
"doc":"Event fired when a guild becomes available. This will occur on startup, after outages, and if the bot joins a new guild.  ! note Some fields like  members and  presences are included here but not on the other  GuildUpdateEvent and  GuildUnavailableEvent guild visibility event models. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildAvailableEvent."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.app",
"url":4,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.channels",
"url":4,
"doc":"Mapping of channel IDs to the channels in the guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] The channels in the guild."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.emojis",
"url":4,
"doc":"Mapping of emoji IDs to the emojis in the guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] The emojis in the guild."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.guild",
"url":4,
"doc":"Guild that just became available. Returns    - hikari.guilds.Guild The guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.members",
"url":4,
"doc":"Mapping of user IDs to the members in the guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.guilds.Member] The members in the guild."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.presences",
"url":4,
"doc":"Mapping of user IDs to the presences for the guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] The member presences in the guild."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.roles",
"url":4,
"doc":"Mapping of role IDs to the roles in the guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.guilds.Role] The roles in the guild."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.shard",
"url":4,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.voice_states",
"url":4,
"doc":"Mapping of user IDs to the voice states active in this guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] The voice states active in the guild."
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildAvailableEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildUnavailableEvent",
"url":4,
"doc":"Event fired when a guild becomes unavailable because of an outage. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildUnavailableEvent."
},
{
"ref":"hikari.events.guild_events.GuildUnavailableEvent.app",
"url":4,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.GuildUnavailableEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.GuildUnavailableEvent.shard",
"url":4,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.GuildUnavailableEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.events.guild_events.GuildUnavailableEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildUnavailableEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildLeaveEvent",
"url":4,
"doc":"Event fired when the bot is banned/kicked/leaves a guild. This will also fire if the guild was deleted. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildLeaveEvent."
},
{
"ref":"hikari.events.guild_events.GuildLeaveEvent.app",
"url":4,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.GuildLeaveEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.GuildLeaveEvent.shard",
"url":4,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.GuildLeaveEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.events.guild_events.GuildLeaveEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildLeaveEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildUpdateEvent",
"url":4,
"doc":"Event fired when an existing guild is updated. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILDS Method generated by attrs for class GuildUpdateEvent."
},
{
"ref":"hikari.events.guild_events.GuildUpdateEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.GuildUpdateEvent.app",
"url":4,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.GuildUpdateEvent.emojis",
"url":4,
"doc":"Mapping of emoji IDs to the emojis in the guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] The emojis in the guild."
},
{
"ref":"hikari.events.guild_events.GuildUpdateEvent.guild",
"url":4,
"doc":"Guild that was just updated. Returns    - hikari.guilds.Guild The guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.GuildUpdateEvent.roles",
"url":4,
"doc":"Mapping of role IDs to the roles in the guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.guilds.Role] The roles in the guild."
},
{
"ref":"hikari.events.guild_events.GuildUpdateEvent.shard",
"url":4,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.GuildUpdateEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.GuildUpdateEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanEvent",
"url":4,
"doc":"Event base for any guild ban or unban. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_BANS Method generated by attrs for class BanEvent."
},
{
"ref":"hikari.events.guild_events.BanEvent.user",
"url":4,
"doc":"User that this ban event affects. Returns    - hikari.users.User The user that this event concerns."
},
{
"ref":"hikari.events.guild_events.BanEvent.fetch_user",
"url":4,
"doc":"Perform an API call to fetch the user this ban event affects. Returns    - hikari.users.User The user affected by this event.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.BanEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.events.guild_events.BanEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.BanEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.BanCreateEvent",
"url":4,
"doc":"Event that is fired when a user is banned from a guild. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_BANS Method generated by attrs for class BanCreateEvent."
},
{
"ref":"hikari.events.guild_events.BanCreateEvent.fetch_ban",
"url":4,
"doc":"Perform an API call to fetch the details about this ban. This will include the optionally defined audit log reason for the ban. Returns    - hikari.guilds.GuildMemberBan The ban details.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanCreateEvent.app",
"url":4,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.BanCreateEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.BanCreateEvent.shard",
"url":4,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.BanCreateEvent.user",
"url":4,
"doc":"User that this ban event affects. Returns    - hikari.users.User The user that this event concerns."
},
{
"ref":"hikari.events.guild_events.BanCreateEvent.fetch_user",
"url":4,
"doc":"Perform an API call to fetch the user this ban event affects. Returns    - hikari.users.User The user affected by this event.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanCreateEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.events.guild_events.BanCreateEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanCreateEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanDeleteEvent",
"url":4,
"doc":"Event that is fired when a user is unbanned from a guild. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_BANS Method generated by attrs for class BanDeleteEvent."
},
{
"ref":"hikari.events.guild_events.BanDeleteEvent.app",
"url":4,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.BanDeleteEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.BanDeleteEvent.shard",
"url":4,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.BanDeleteEvent.user",
"url":4,
"doc":"User that this ban event affects. Returns    - hikari.users.User The user that this event concerns."
},
{
"ref":"hikari.events.guild_events.BanDeleteEvent.fetch_user",
"url":4,
"doc":"Perform an API call to fetch the user this ban event affects. Returns    - hikari.users.User The user affected by this event.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanDeleteEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.events.guild_events.BanDeleteEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.BanDeleteEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.EmojisUpdateEvent",
"url":4,
"doc":"Event that is fired when the emojis in a guild are updated. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_EMOJIS Method generated by attrs for class EmojisUpdateEvent."
},
{
"ref":"hikari.events.guild_events.EmojisUpdateEvent.fetch_emojis",
"url":4,
"doc":"Perform an API call to retrieve an up-to-date view of the emojis. Returns    - typing.Sequence[emojis_.KnownCustomEmoji] All emojis in the guild.",
"func":1
},
{
"ref":"hikari.events.guild_events.EmojisUpdateEvent.app",
"url":4,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.EmojisUpdateEvent.emojis",
"url":4,
"doc":"Sequence of all emojis in this guild. Returns    - typing.Sequence[emojis_.KnownCustomEmoji] All emojis in the guild."
},
{
"ref":"hikari.events.guild_events.EmojisUpdateEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.EmojisUpdateEvent.shard",
"url":4,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.EmojisUpdateEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.events.guild_events.EmojisUpdateEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.EmojisUpdateEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.IntegrationsUpdateEvent",
"url":4,
"doc":"Event that is fired when the integrations in a guild are changed. This may occur when integrations are created, updated, or deleted.  ! note This event is similar to  hikari.events.channel_events.WebhookUpdateEvent in that Discord does not provide any information on what was actually changed, nor how it was changed. The only way you will be able to determine this is to keep a cache of this information manually up to date by fetching it using REST API calls. This is a limitation of Discord's design. We agree that it is not overly helpful to you. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_EMOJIS Method generated by attrs for class IntegrationsUpdateEvent."
},
{
"ref":"hikari.events.guild_events.IntegrationsUpdateEvent.fetch_integrations",
"url":4,
"doc":"Perform an API call to fetch some number of guild integrations.  ! warning The results of this are not clearly defined by Discord. The current behaviour appears to be that only the first 50 integrations actually get returned. Discord have made it clear that they are not willing to fix this in https: github.com/discord/discord-api-docs/issues/1990. Returns    - typing.Sequence[hikari.guilds.Integration] Some possibly random subset of the integrations in a guild, probably.",
"func":1
},
{
"ref":"hikari.events.guild_events.IntegrationsUpdateEvent.app",
"url":4,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.IntegrationsUpdateEvent.guild_id",
"url":4,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.guild_events.IntegrationsUpdateEvent.shard",
"url":4,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.IntegrationsUpdateEvent.guild",
"url":4,
"doc":"Get the cached guild that this event relates to, if known. If not known, this will return  builtins.None instead. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild this event relates to, or  builtins.None if not known."
},
{
"ref":"hikari.events.guild_events.IntegrationsUpdateEvent.fetch_guild",
"url":4,
"doc":"Perform an API call to get the guild that this event relates to. Returns    - hikari.guilds.RESTGuild The guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.IntegrationsUpdateEvent.fetch_guild_preview",
"url":4,
"doc":"Perform an API call to get the preview of the event's guild. Returns    - hikari.guilds.GuildPreview The preview of the guild this event occurred in.",
"func":1
},
{
"ref":"hikari.events.guild_events.PresenceUpdateEvent",
"url":4,
"doc":"Event fired when a user in a guild updates their presence in a guild. Sent when a guild member changes their presence in a specific guild. If the user is changed (e.g. new username), then this may fire many times (once for every guild the bot is part of). This is a limitation of how Discord implements their event system, unfortunately. Furthermore, if the target user is a bot and the bot only updates their presence on specific shards, this will only fire for the corresponding shards that saw the presence update. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_PRESENCES Method generated by attrs for class PresenceUpdateEvent."
},
{
"ref":"hikari.events.guild_events.PresenceUpdateEvent.user_id",
"url":4,
"doc":"User ID of the user that updated their presence. Returns    - hikari.snowflakes.Snowflake ID of the user the event concerns."
},
{
"ref":"hikari.events.guild_events.PresenceUpdateEvent.guild_id",
"url":4,
"doc":"Guild ID that the presence was updated in. Returns    - hikari.snowflakes.Snowflake ID of the guild the event occurred in."
},
{
"ref":"hikari.events.guild_events.PresenceUpdateEvent.get_cached_user",
"url":4,
"doc":"Get the full cached user, if it is available. Returns    - typing.Optional[hikari.users.User] The full cached user, or  builtins.None if not cached.",
"func":1
},
{
"ref":"hikari.events.guild_events.PresenceUpdateEvent.fetch_user",
"url":4,
"doc":"Perform an API call to fetch the user this event concerns. Returns    - hikari.users.User The user affected by this event.",
"func":1
},
{
"ref":"hikari.events.guild_events.PresenceUpdateEvent.app",
"url":4,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.guild_events.PresenceUpdateEvent.presence",
"url":4,
"doc":"Member presence. Returns    - hikari.presences.MemberPresence Presence for the user in this guild."
},
{
"ref":"hikari.events.guild_events.PresenceUpdateEvent.shard",
"url":4,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.guild_events.PresenceUpdateEvent.user",
"url":4,
"doc":"User that was updated. This is a partial user object that only contains the fields that were updated on the user profile. Will be  builtins.None if the user itself did not change. This is always the case if the user only updated their member representation and did not change their user profile directly. Returns    - typing.Optional[hikari.users.PartialUser] The partial user containing the updated fields."
},
{
"ref":"hikari.events.base_events",
"url":6,
"doc":"Base types and functions for events in Hikari."
},
{
"ref":"hikari.events.base_events.Event",
"url":6,
"doc":"Base event type that all Hikari events should subclass. Method generated by attrs for class Event."
},
{
"ref":"hikari.events.base_events.Event.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.base_events.ExceptionEvent",
"url":6,
"doc":"Event that is raised when another event handler raises an  Exception .  ! note Only exceptions that derive from  builtins.Exception will be caught. Other exceptions outside this range will propagate past this callback. This prevents event handlers interfering with critical exceptions such as  KeyboardError which would have potentially undesired side-effects on the application runtime. ! warning Any exceptions raised by handlers for this event will be dumped to the application logger and silently discarded, preventing recursive loops produced by faulty exception event handling. Thus, it is imperative that you ensure any exceptions are explicitly caught within handlers for this event if they may occur. Method generated by attrs for class ExceptionEvent."
},
{
"ref":"hikari.events.base_events.ExceptionEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.base_events.ExceptionEvent.shard",
"url":6,
"doc":"Shard that received the event, if there was one associated. Returns    - typing.Optional[hikari.api.shard.GatewayShard] Shard that raised this exception. This may be  builtins.None if no specific shard was the cause of this exception (e.g. when starting up or shutting down)."
},
{
"ref":"hikari.events.base_events.ExceptionEvent.failed_callback",
"url":6,
"doc":"Event callback that threw an exception. Returns    - callback Event callback that failed execution."
},
{
"ref":"hikari.events.base_events.ExceptionEvent.exc_info",
"url":6,
"doc":"Exception triplet that follows the same format as  sys.exc_info . Returns    - builtins.tuple[typing.Type[Exception], Exception, typing.Optional[types.TracebackType The  sys.exc_info -compatible tuple of the exception type, the exception instance, and the traceback of the exception."
},
{
"ref":"hikari.events.base_events.ExceptionEvent.retry",
"url":6,
"doc":"Invoke the failed event again. If an exception is thrown this time, it will need to be manually caught in-code, or will be discarded.",
"func":1
},
{
"ref":"hikari.events.base_events.ExceptionEvent.exception",
"url":6,
"doc":"Exception that was raised. Returns    - builtins.Exception Exception that was raised in the event handler."
},
{
"ref":"hikari.events.base_events.ExceptionEvent.failed_event",
"url":6,
"doc":"Event instance that caused the exception. Returns    - hikari.events.base_events.Event Event that was being processed when the exception occurred."
},
{
"ref":"hikari.events.base_events.is_no_recursive_throw_event",
"url":6,
"doc":"Return True if this event is marked as  ___norecursivethrow___ .",
"func":1
},
{
"ref":"hikari.events.base_events.no_recursive_throw",
"url":6,
"doc":"Decorate an event type to indicate errors should not be handled. This is useful for exception event types that you do not want to have invoked recursively.",
"func":1
},
{
"ref":"hikari.events.base_events.get_required_intents_for",
"url":6,
"doc":"Retrieve the intents that are required to listen to an event type. Parameters      event_type : typing.Type[Event] The event type to get required intents for. Returns    - typing.Collection[hikari.intents.Intents] Collection of acceptable subset combinations of intent needed to be able to receive the given event type.",
"func":1
},
{
"ref":"hikari.events.base_events.requires_intents",
"url":6,
"doc":"Decorate an event type to define what intents it requires. Parameters      first : hikari.intents.Intents First combination of intents that are acceptable in order to receive the decorated event type.  rest : hikari.intents.Intents Zero or more additional combinations of intents to require for this event to be subscribed to.",
"func":1
},
{
"ref":"hikari.events.member_events",
"url":18,
"doc":"Events concerning manipulation of members within guilds."
},
{
"ref":"hikari.events.member_events.MemberEvent",
"url":18,
"doc":"Event base for any events that concern guild members. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MEMBERS Method generated by attrs for class MemberEvent."
},
{
"ref":"hikari.events.member_events.MemberEvent.guild_id",
"url":18,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.member_events.MemberEvent.user",
"url":18,
"doc":"User object for the member this event concerns. Returns    - hikari.users.User User object for the member this event concerns."
},
{
"ref":"hikari.events.member_events.MemberEvent.user_id",
"url":18,
"doc":"ID of the user that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the user that this event relates to."
},
{
"ref":"hikari.events.member_events.MemberEvent.guild",
"url":18,
"doc":"Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else  builtins.None ."
},
{
"ref":"hikari.events.member_events.MemberEvent.shard",
"url":5,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.member_events.MemberEvent.app",
"url":6,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.member_events.MemberCreateEvent",
"url":18,
"doc":"Event that is fired when a member joins a guild. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MEMBERS Method generated by attrs for class MemberCreateEvent."
},
{
"ref":"hikari.events.member_events.MemberCreateEvent.guild_id",
"url":18,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.member_events.MemberCreateEvent.user",
"url":18,
"doc":"User object for the member this event concerns. Returns    - hikari.users.User User object for the member this event concerns."
},
{
"ref":"hikari.events.member_events.MemberCreateEvent.app",
"url":18,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.member_events.MemberCreateEvent.member",
"url":18,
"doc":"Member object for the member that joined the guild. Returns    - hikari.guilds.Member The member object for the member who just joined."
},
{
"ref":"hikari.events.member_events.MemberCreateEvent.shard",
"url":18,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.member_events.MemberCreateEvent.user_id",
"url":18,
"doc":"ID of the user that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the user that this event relates to."
},
{
"ref":"hikari.events.member_events.MemberCreateEvent.guild",
"url":18,
"doc":"Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else  builtins.None ."
},
{
"ref":"hikari.events.member_events.MemberUpdateEvent",
"url":18,
"doc":"Event that is fired when a member is updated in a guild. This may occur if roles are amended, or if the nickname is changed. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MEMBERS Method generated by attrs for class MemberUpdateEvent."
},
{
"ref":"hikari.events.member_events.MemberUpdateEvent.guild_id",
"url":18,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.member_events.MemberUpdateEvent.user",
"url":18,
"doc":"User object for the member this event concerns. Returns    - hikari.users.User User object for the member this event concerns."
},
{
"ref":"hikari.events.member_events.MemberUpdateEvent.app",
"url":18,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.member_events.MemberUpdateEvent.member",
"url":18,
"doc":"Member object for the member that was updated. Returns    - hikari.guilds.Member The member object for the member that was updated."
},
{
"ref":"hikari.events.member_events.MemberUpdateEvent.shard",
"url":18,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.member_events.MemberUpdateEvent.user_id",
"url":18,
"doc":"ID of the user that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the user that this event relates to."
},
{
"ref":"hikari.events.member_events.MemberUpdateEvent.guild",
"url":18,
"doc":"Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else  builtins.None ."
},
{
"ref":"hikari.events.member_events.MemberDeleteEvent",
"url":18,
"doc":"Event fired when a member is kicked from or leaves a guild. This requires one of the following combinations of intents in order to be dispatched: -  hikari.intents.Intents.GUILD_MEMBERS Method generated by attrs for class MemberDeleteEvent."
},
{
"ref":"hikari.events.member_events.MemberDeleteEvent.app",
"url":18,
"doc":"App instance for this application. Returns    - hikari.traits.RESTAware The REST-aware app trait."
},
{
"ref":"hikari.events.member_events.MemberDeleteEvent.guild_id",
"url":18,
"doc":"ID of the guild that this event relates to. Returns    - hikari.snowflakes.Snowflake The ID of the guild that relates to this event."
},
{
"ref":"hikari.events.member_events.MemberDeleteEvent.shard",
"url":18,
"doc":"Shard that received this event. Returns    - hikari.api.shard.GatewayShard The shard that triggered the event."
},
{
"ref":"hikari.events.member_events.MemberDeleteEvent.user",
"url":18,
"doc":"User object for the member this event concerns. Returns    - hikari.users.User User object for the member this event concerns."
},
{
"ref":"hikari.events.member_events.MemberDeleteEvent.user_id",
"url":18,
"doc":"ID of the user that this event concerns. Returns    - hikari.snowflakes.Snowflake The ID of the user that this event relates to."
},
{
"ref":"hikari.events.member_events.MemberDeleteEvent.guild",
"url":18,
"doc":"Get the cached view of the guild this member event occurred in. If the guild itself is not cached, this will return  builtins.None . Returns    - typing.Optional[hikari.guilds.GatewayGuild] The guild that this event occurred in, if known, else  builtins.None ."
},
{
"ref":"hikari.urls",
"url":30,
"doc":"API-wide URLs."
},
{
"ref":"hikari.embeds",
"url":14,
"doc":"Application and entities that are used to describe message embeds on Discord."
},
{
"ref":"hikari.embeds.Embed",
"url":14,
"doc":"Represents an embed."
},
{
"ref":"hikari.embeds.Embed.from_received_embed",
"url":14,
"doc":"Generate an embed from the given attributes. You should never call this.",
"func":1
},
{
"ref":"hikari.embeds.Embed.title",
"url":14,
"doc":"Return the title of the embed. This will be  builtins.None if not set. Returns    - typing.Optional[builtins.str] The title of the embed."
},
{
"ref":"hikari.embeds.Embed.description",
"url":14,
"doc":"Return the description of the embed. This will be  builtins.None if not set. Returns    - typing.Optional[builtins.str] The description of the embed."
},
{
"ref":"hikari.embeds.Embed.url",
"url":14,
"doc":"Return the URL of the embed title. This will be  builtins.None if not set. Returns    - typing.Optional[builtins.str] The URL of the embed title"
},
{
"ref":"hikari.embeds.Embed.color",
"url":14,
"doc":"Return the colour of the embed. This will be  builtins.None if not set. Returns    - typing.Optional[hikari.colors.Color] The colour that is set."
},
{
"ref":"hikari.embeds.Embed.colour",
"url":14,
"doc":"Return the colour of the embed. This will be  builtins.None if not set. Returns    - typing.Optional[hikari.colors.Color] The colour that is set."
},
{
"ref":"hikari.embeds.Embed.timestamp",
"url":14,
"doc":"Return the timestamp of the embed. This will be  builtins.None if not set. Returns    - typing.Optional[datetime.datetime] The timestamp set on the embed.  ! warning Setting a non-timezone-aware datetime will result in a warning being raised. This is done due to potential confusion caused by Discord requiring a UTC timestamp for this field. Any non-timezone aware timestamp is interpreted as using the system's current timezone instead. Thus, using  datetime.datetime.utcnow will result in a potentially incorrect timezone being set. To generate a timezone aware timestamp, use one of the following snippets:  Use UTC. >>> datetime.datetime.now(tz=datetime.timezone.utc) datetime.datetime(2020, 6, 5, 18, 29, 56, 424744, tzinfo=datetime.timezone.utc)  Use your current timezone. >>> datetime.datetime.now().astimezone() datetime.datetime(2020, 7, 7, 8, 57, 9, 775328, tzinfo= ., 'BST' By specifying a timezone, Hikari can automatically adjust the given time to UTC without you needing to think about it. You can generate a timezone-aware timestamp instead of a timezone-naive one by specifying a timezone. Hikari will detect any difference in timezone if the timestamp is non timezone-naive and fix it for you.  I am British, and it is June, so we are in daylight saving  (UTC+1 or GMT+1, specifically). >>> import datetime  This is timezone naive, notice no timezone in the repr that  gets printed. This is no good to us, as Discord will interpret it  as being in the future! >>> datetime.datetime.now() datetime.datetime(2020, 6, 5, 19, 29, 48, 281716)  Instead, this is a timezone-aware timestamp, and we can use this  correctly. This will always return the current time in UTC. >>> datetime.datetime.now(tz=datetime.timezone.utc) datetime.datetime(2020, 6, 5, 18, 29, 56, 424744, tzinfo=datetime.timezone.utc)  We could instead use a custom timezone. Since the timezone is  explicitly specified, Hikari will convert it to UTC for you when  you send the embed. >>>  . A library on PyPI called [tzlocal]( .) also exists that may be useful to you if you need to get your local timezone for any reason. >>> import datetime >>> import tzlocal  Naive datetime that will show the wrong time on Discord. >>> datetime.datetime.now() datetime.datetime(2020, 6, 5, 19, 33, 21, 329950)  Timezone-aware datetime that uses my local timezone correctly. >>> datetime.datetime.now(tz=tzlocal.get_localzone( datetime.datetime(2020, 6, 5, 19, 33, 40, 967939, tzinfo= )  Changing timezones. >>> dt = datetime.datetime.now(tz=datetime.timezone.utc) >>> print(dt) datetime.datetime(2020, 6, 5, 18, 38, 27, 863990, tzinfo=datetime.timezone.utc) >>> dt.astimezone(tzlocal.get_localzone( datetime.datetime(2020, 6, 5, 19, 38, 27, 863990, tzinfo= )  .this is not required, but you may find it more useful if using the timestamps in debug logs, for example."
},
{
"ref":"hikari.embeds.Embed.footer",
"url":14,
"doc":"Return the footer of the embed. Will be  builtins.None if not set. typing.Optional[EmbedFooter] The footer of the embed."
},
{
"ref":"hikari.embeds.Embed.image",
"url":14,
"doc":"Return the image set in the embed. Will be  builtins.None if not set. typing.Optional[EmbedImage] The image of the embed.  ! note Use  set_image to update this value."
},
{
"ref":"hikari.embeds.Embed.thumbnail",
"url":14,
"doc":"Return the thumbnail set in the embed. Will be  builtins.None if not set. typing.Optional[EmbedImage] The thumbnail of the embed.  ! note Use  set_thumbnail to update this value."
},
{
"ref":"hikari.embeds.Embed.video",
"url":14,
"doc":"Return the video to show in the embed. Will be  builtins.None if not set. Returns    - typing.Optional[EmbedVideo] The video of the embed.  ! note This object cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event with a video attached."
},
{
"ref":"hikari.embeds.Embed.provider",
"url":14,
"doc":"Return the provider to show in the embed. Will be  builtins.None if not set. Returns    - typing.Optional[EmbedProvider] The provider of the embed.  ! note This object cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event with a custom provider set."
},
{
"ref":"hikari.embeds.Embed.author",
"url":14,
"doc":"Return the author to show in the embed. Will be  builtins.None if not set. Returns    - typing.Optional[EmbedAuthor] The author of the embed.  ! note Use  set_author to update this value."
},
{
"ref":"hikari.embeds.Embed.fields",
"url":14,
"doc":"Return the sequence of fields in the embed.  ! note Use  add_field to add a new field,  edit_field to edit an existing field, or  remove_field to remove a field."
},
{
"ref":"hikari.embeds.Embed.set_author",
"url":14,
"doc":"Set the author of this embed. Parameters      name : typing.Optional[builtins.str] The optional name of the author. url : typing.Optional[builtins.str] The optional URL of the author. icon : typing.Optional[hikari.files.Resourceish] The optional image to show next to the embed author. This can be many different things, to aid in convenience. - If  builtins.None , nothing is set. - If a  pathlib.PurePath or  builtins.str to a valid URL, the URL is linked to directly. - Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will have their URL linked to directly. this field. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded as an attachment and linked into the embed. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and linked into the embed. Returns    - Embed This embed. Allows for call chaining.",
"func":1
},
{
"ref":"hikari.embeds.Embed.set_footer",
"url":14,
"doc":"Set the footer of this embed. Parameters      text : typing.Optional[str] The mandatory text string to set in the footer. If  builtins.None , the footer is removed. icon : typing.Optional[hikari.files.Resourceish] The optional image to show next to the embed footer. This can be many different things, to aid in convenience. - If  builtins.None , nothing is set. - If a  pathlib.PurePath or  builtins.str to a valid URL, the URL is linked to directly. - Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will have their URL linked to directly. this field. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded as an attachment and linked into the embed. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and linked into the embed. Returns    - Embed This embed. Allows for call chaining.",
"func":1
},
{
"ref":"hikari.embeds.Embed.set_image",
"url":14,
"doc":"Set the image on this embed. Parameters      image : typing.Optional[hikari.files.Resourceish] The optional resource to show for the embed image. This can be many different things, to aid in convenience. - If  builtins.None , nothing is set. - If a  pathlib.PurePath or  builtins.str to a valid URL, the URL is linked to directly. - Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will have their URL linked to directly. this field. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded as an attachment and linked into the embed. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and linked into the embed. Returns    - Embed This embed. Allows for call chaining.",
"func":1
},
{
"ref":"hikari.embeds.Embed.set_thumbnail",
"url":14,
"doc":"Set the image on this embed. Parameters      image : typing.Optional[hikari.files.Resourceish] The optional resource to show for the embed thumbnail. This can be many different things, to aid in convenience. - If  builtins.None , nothing is set. - If a  pathlib.PurePath or  builtins.str to a valid URL, the URL is linked to directly. - Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will have their URL linked to directly. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded as an attachment and linked into the embed. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and linked into the embed. Returns    - Embed This embed. Allows for call chaining.",
"func":1
},
{
"ref":"hikari.embeds.Embed.add_field",
"url":14,
"doc":"Add a new field to this embed. Parameters      name : str The mandatory non-empty field name. This must contain at least one non-whitespace character to be valid. value : str The mandatory non-empty field value. This must contain at least one non-whitespace character to be valid. Other Parameters         inline : bool If  builtins.True , the embed field may be shown \"inline\" on some Discord clients with other fields. If  builtins.False , it is always placed on a separate line. This will default to  builtins.False . Returns    - Embed This embed. Allows for call chaining.",
"func":1
},
{
"ref":"hikari.embeds.Embed.edit_field",
"url":14,
"doc":"Edit an existing field on this embed. Parameters      index : int The index of the field to edit. Other Parameters         name : hikari.undefined.UndefinedOr[str] The new field name to use. If left to the default ( undefined ), then it will not be changed. value : hikari.undefined.UndefinedOr[str] The new field value to use. If left to the default ( undefined ), then it will not be changed. inline : hikari.undefined.UndefinedOr[builtins.bool]  builtins.True to inline the field, or  builtins.False to force it to be on a separate line. If left to the default ( undefined ), then it will not be changed. Returns    - Embed This embed. Allows for call chaining. Raises    builtins.IndexError Raised if the index is greater than  len(embed.fields) - 1 or less than  -len(embed.fields) ",
"func":1
},
{
"ref":"hikari.embeds.Embed.remove_field",
"url":14,
"doc":"Remove an existing field from this embed. Parameters      index : int The index of the embed field to remove. Returns    - Embed This embed. Allows for call chaining. Raises    builtins.IndexError Raised if the index is greater than  len(embed.fields) - 1 or less than  -len(embed.fields) ",
"func":1
},
{
"ref":"hikari.embeds.EmbedResource",
"url":14,
"doc":"A base type for any resource provided in an embed. Resources can be downloaded and uploaded. Method generated by attrs for class EmbedResource."
},
{
"ref":"hikari.embeds.EmbedResource.url",
"url":14,
"doc":"URL of the resource."
},
{
"ref":"hikari.embeds.EmbedResource.filename",
"url":14,
"doc":"Filename of the resource."
},
{
"ref":"hikari.embeds.EmbedResource.stream",
"url":14,
"doc":"Produce a stream of data for the resource. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.",
"func":1
},
{
"ref":"hikari.embeds.EmbedResource.resource",
"url":14,
"doc":"The resource this object wraps around."
},
{
"ref":"hikari.embeds.EmbedResource.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.embeds.EmbedResource.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.embeds.EmbedResourceWithProxy",
"url":14,
"doc":"Resource with a corresponding proxied element. Method generated by attrs for class EmbedResourceWithProxy."
},
{
"ref":"hikari.embeds.EmbedResourceWithProxy.proxy_resource",
"url":14,
"doc":"The proxied version of the resource, or  builtins.None if not present.  ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."
},
{
"ref":"hikari.embeds.EmbedResourceWithProxy.url",
"url":14,
"doc":"URL of the resource."
},
{
"ref":"hikari.embeds.EmbedResourceWithProxy.filename",
"url":14,
"doc":"Filename of the resource."
},
{
"ref":"hikari.embeds.EmbedResourceWithProxy.stream",
"url":14,
"doc":"Produce a stream of data for the resource. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.",
"func":1
},
{
"ref":"hikari.embeds.EmbedResourceWithProxy.resource",
"url":14,
"doc":"The resource this object wraps around."
},
{
"ref":"hikari.embeds.EmbedResourceWithProxy.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.embeds.EmbedResourceWithProxy.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.embeds.EmbedVideo",
"url":14,
"doc":"Represents an embed video.  ! note This object cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event with a video attached.  Therefore, you should never need to initialize an instance of this class yourself. Method generated by attrs for class EmbedVideo."
},
{
"ref":"hikari.embeds.EmbedVideo.height",
"url":14,
"doc":"The height of the video."
},
{
"ref":"hikari.embeds.EmbedVideo.width",
"url":14,
"doc":"The width of the video."
},
{
"ref":"hikari.embeds.EmbedVideo.url",
"url":14,
"doc":"URL of the resource."
},
{
"ref":"hikari.embeds.EmbedVideo.filename",
"url":14,
"doc":"Filename of the resource."
},
{
"ref":"hikari.embeds.EmbedVideo.stream",
"url":14,
"doc":"Produce a stream of data for the resource. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.",
"func":1
},
{
"ref":"hikari.embeds.EmbedVideo.resource",
"url":14,
"doc":"The resource this object wraps around."
},
{
"ref":"hikari.embeds.EmbedVideo.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.embeds.EmbedVideo.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.embeds.EmbedImage",
"url":14,
"doc":"Represents an embed image. Method generated by attrs for class EmbedImage."
},
{
"ref":"hikari.embeds.EmbedImage.height",
"url":14,
"doc":"The height of the image, if present and known, otherwise  builtins.None .  ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."
},
{
"ref":"hikari.embeds.EmbedImage.width",
"url":14,
"doc":"The width of the image, if present and known, otherwise  builtins.None .  ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."
},
{
"ref":"hikari.embeds.EmbedImage.proxy_resource",
"url":14,
"doc":"The proxied version of the resource, or  builtins.None if not present.  ! note This field cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event."
},
{
"ref":"hikari.embeds.EmbedImage.url",
"url":14,
"doc":"URL of the resource."
},
{
"ref":"hikari.embeds.EmbedImage.filename",
"url":14,
"doc":"Filename of the resource."
},
{
"ref":"hikari.embeds.EmbedImage.stream",
"url":14,
"doc":"Produce a stream of data for the resource. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests.",
"func":1
},
{
"ref":"hikari.embeds.EmbedImage.resource",
"url":14,
"doc":"The resource this object wraps around."
},
{
"ref":"hikari.embeds.EmbedImage.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.embeds.EmbedImage.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.embeds.EmbedProvider",
"url":14,
"doc":"Represents an embed provider.  ! note This object cannot be set by bots or webhooks while sending an embed and will be ignored during serialization. Expect this to be populated on any received embed attached to a message event provided by an external source.  Therefore, you should never need to initialize an instance of this class yourself. Method generated by attrs for class EmbedProvider."
},
{
"ref":"hikari.embeds.EmbedProvider.name",
"url":14,
"doc":"The name of the provider."
},
{
"ref":"hikari.embeds.EmbedProvider.url",
"url":14,
"doc":"The URL of the provider."
},
{
"ref":"hikari.embeds.EmbedAuthor",
"url":14,
"doc":"Represents an author of an embed. Method generated by attrs for class EmbedAuthor."
},
{
"ref":"hikari.embeds.EmbedAuthor.icon",
"url":14,
"doc":"The author's icon, or  builtins.None if not present."
},
{
"ref":"hikari.embeds.EmbedAuthor.name",
"url":14,
"doc":"The name of the author, or  builtins.None if not specified."
},
{
"ref":"hikari.embeds.EmbedAuthor.url",
"url":14,
"doc":"The URL that the author's name should act as a hyperlink to. This may be  builtins.None if no hyperlink on the author's name is specified."
},
{
"ref":"hikari.embeds.EmbedFooter",
"url":14,
"doc":"Represents an embed footer. Method generated by attrs for class EmbedFooter."
},
{
"ref":"hikari.embeds.EmbedFooter.icon",
"url":14,
"doc":"The URL of the footer icon, or  builtins.None if not present."
},
{
"ref":"hikari.embeds.EmbedFooter.text",
"url":14,
"doc":"The footer text, or  builtins.None if not present."
},
{
"ref":"hikari.embeds.EmbedField",
"url":14,
"doc":"Represents a field in a embed. Method generated by attrs for class EmbedField."
},
{
"ref":"hikari.embeds.EmbedField.is_inline",
"url":14,
"doc":"Return  builtins.True if the field should display inline. Defaults to False."
},
{
"ref":"hikari.embeds.EmbedField.name",
"url":14,
"doc":"The name of the field."
},
{
"ref":"hikari.embeds.EmbedField.value",
"url":14,
"doc":"The value of the field."
},
{
"ref":"hikari.permissions",
"url":31,
"doc":"Bitfield of permissions."
},
{
"ref":"hikari.permissions.Permissions",
"url":31,
"doc":"Represents the permissions available in a given channel or guild. This enum is an  enum.IntFlag . This means that you can  combine multiple permissions together into one value using the bitwise-OR operator ( | ). my_perms = Permissions.MANAGE_CHANNELS | Permissions.MANAGE_GUILD your_perms = ( Permissions.CREATE_INSTANT_INVITE | Permissions.KICK_MEMBERS | Permissions.BAN_MEMBERS | Permissions.MANAGE_GUILD ) You can  check if a permission is present in a set of combined permissions by using the bitwise-AND operator ( & ). This will return the int-value of the permission if it is present, or  0 if not present. my_perms = Permissions.MANAGE_CHANNELS | Permissions.MANAGE_GUILD if my_perms & Permissions.MANAGE_CHANNELS: if my_perms & Permissions.MANAGE_GUILD: print(\"I have the permission to both manage the guild and the channels in it!\") else: print(\"I have the permission to manage channels!\") else: print(\"I don't have the permission to manage channels!\")  Or you could simplify it: if my_perms & (Permissions.MANAGE_CHANNELS | Permissions.MANAGE_GUILD): print(\"I have the permission to both manage the guild and the channels in it!\") elif my_perms & Permissions.MANAGE_CHANNELS: print(\"I have the permission to manage channels!\") else: print(\"I don't have the permission to manage channels!\") If you need to  check that a permission is not present , you can use the bitwise-XOR operator ( ^ ) to check. If the permission is not present, it will return a non-zero value, otherwise if it is present, it will return  0 . my_perms = Permissions.MANAGE_CHANNELS | Permissions.MANAGE_GUILD if my_perms ^ Permissions.MANAGE_CHANNELS: print(\"Please give me the MANAGE_CHANNELS permission!\") Lastly, if you need all the permissions set except the permission you want, you can use the inversion operator ( ~ ) to do that.  All permissions except ADMINISTRATOR. my_perms = ~Permissions.ADMINISTRATOR"
},
{
"ref":"hikari.permissions.Permissions.name",
"url":31,
"doc":"Return the name of the flag combination as a  builtins.str ."
},
{
"ref":"hikari.permissions.Permissions.value",
"url":31,
"doc":"Return the  builtins.int value of the flag."
},
{
"ref":"hikari.permissions.Permissions.all",
"url":31,
"doc":"Check if all of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.permissions.Permissions.any",
"url":31,
"doc":"Check if any of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.permissions.Permissions.difference",
"url":31,
"doc":"Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction  - operator.",
"func":1
},
{
"ref":"hikari.permissions.Permissions.intersection",
"url":31,
"doc":"Return a combination of flags that are set for both given values. Equivalent to using the \"AND\"  & operator.",
"func":1
},
{
"ref":"hikari.permissions.Permissions.invert",
"url":31,
"doc":"Return a set of all flags not in the current set.",
"func":1
},
{
"ref":"hikari.permissions.Permissions.is_disjoint",
"url":31,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.permissions.Permissions.is_subset",
"url":31,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.permissions.Permissions.is_superset",
"url":31,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.permissions.Permissions.none",
"url":31,
"doc":"Check if none of the given flags are part of this value.  ! note This is essentially the opposite of  Flag.any . Returns    - builtins.bool  builtins.True if none of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.permissions.Permissions.split",
"url":31,
"doc":"Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted  typing.Sequence of each membe",
"func":1
},
{
"ref":"hikari.permissions.Permissions.symmetric_difference",
"url":31,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.permissions.Permissions.union",
"url":31,
"doc":"Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\"  ~ operator.",
"func":1
},
{
"ref":"hikari.permissions.Permissions.isdisjoint",
"url":31,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.permissions.Permissions.issubset",
"url":31,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.permissions.Permissions.issuperset",
"url":31,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.permissions.Permissions.symmetricdifference",
"url":31,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.permissions.Permissions.NONE",
"url":31,
"doc":"Empty permission."
},
{
"ref":"hikari.permissions.Permissions.CREATE_INSTANT_INVITE",
"url":31,
"doc":"Allows creation of instant invites."
},
{
"ref":"hikari.permissions.Permissions.KICK_MEMBERS",
"url":31,
"doc":"Allows kicking members"
},
{
"ref":"hikari.permissions.Permissions.BAN_MEMBERS",
"url":31,
"doc":"Allows banning members."
},
{
"ref":"hikari.permissions.Permissions.ADMINISTRATOR",
"url":31,
"doc":"Allows all permissions and bypasses channel permission overwrites."
},
{
"ref":"hikari.permissions.Permissions.MANAGE_CHANNELS",
"url":31,
"doc":"Allows management and editing of channels."
},
{
"ref":"hikari.permissions.Permissions.MANAGE_GUILD",
"url":31,
"doc":"Allows management and editing of the guild."
},
{
"ref":"hikari.permissions.Permissions.ADD_REACTIONS",
"url":31,
"doc":"Allows for the addition of reactions to messages."
},
{
"ref":"hikari.permissions.Permissions.VIEW_AUDIT_LOG",
"url":31,
"doc":"Allows for viewing of audit logs."
},
{
"ref":"hikari.permissions.Permissions.PRIORITY_SPEAKER",
"url":31,
"doc":"Allows for using priority speaker in a voice channel."
},
{
"ref":"hikari.permissions.Permissions.STREAM",
"url":31,
"doc":"Allows the user to go live."
},
{
"ref":"hikari.permissions.Permissions.VIEW_CHANNEL",
"url":31,
"doc":"Allows guild members to view a channel, which includes reading messages in text channels."
},
{
"ref":"hikari.permissions.Permissions.SEND_MESSAGES",
"url":31,
"doc":"Allows for sending messages in a channel."
},
{
"ref":"hikari.permissions.Permissions.SEND_TTS_MESSAGES",
"url":31,
"doc":"Allows for sending of  /tts messages."
},
{
"ref":"hikari.permissions.Permissions.MANAGE_MESSAGES",
"url":31,
"doc":"Allows for deletion of other users messages."
},
{
"ref":"hikari.permissions.Permissions.EMBED_LINKS",
"url":31,
"doc":"Links sent by users with this permission will be auto-embedded."
},
{
"ref":"hikari.permissions.Permissions.ATTACH_FILES",
"url":31,
"doc":"Allows for uploading images and files."
},
{
"ref":"hikari.permissions.Permissions.READ_MESSAGE_HISTORY",
"url":31,
"doc":"Allows for reading of message history."
},
{
"ref":"hikari.permissions.Permissions.MENTION_ROLES",
"url":31,
"doc":"Allows for using the  @everyone tag to notify all users in a channel, and the  @here tag to notify all online users in a channel, and the  @role tag (even if the role is not mentionable) to notify all users with that role in a channel."
},
{
"ref":"hikari.permissions.Permissions.USE_EXTERNAL_EMOJIS",
"url":31,
"doc":"Allows the usage of custom emojis from other guilds."
},
{
"ref":"hikari.permissions.Permissions.VIEW_GUILD_INSIGHTS",
"url":31,
"doc":"Allows the user to view guild insights for eligible guilds."
},
{
"ref":"hikari.permissions.Permissions.CONNECT",
"url":31,
"doc":"Allows for joining of a voice channel."
},
{
"ref":"hikari.permissions.Permissions.SPEAK",
"url":31,
"doc":"Allows for speaking in a voice channel."
},
{
"ref":"hikari.permissions.Permissions.MUTE_MEMBERS",
"url":31,
"doc":"Allows for muting members in a voice channel."
},
{
"ref":"hikari.permissions.Permissions.DEAFEN_MEMBERS",
"url":31,
"doc":"Allows for deafening of members in a voice channel."
},
{
"ref":"hikari.permissions.Permissions.MOVE_MEMBERS",
"url":31,
"doc":"Allows for moving of members between voice channels."
},
{
"ref":"hikari.permissions.Permissions.USE_VOICE_ACTIVITY",
"url":31,
"doc":"Allows for using voice-activity-detection in a voice channel."
},
{
"ref":"hikari.permissions.Permissions.CHANGE_NICKNAME",
"url":31,
"doc":"Allows for modification of own nickname."
},
{
"ref":"hikari.permissions.Permissions.MANAGE_NICKNAMES",
"url":31,
"doc":"Allows for modification of other users nicknames."
},
{
"ref":"hikari.permissions.Permissions.MANAGE_ROLES",
"url":31,
"doc":"Allows management and editing of roles."
},
{
"ref":"hikari.permissions.Permissions.MANAGE_WEBHOOKS",
"url":31,
"doc":"Allows management and editing of webhooks."
},
{
"ref":"hikari.permissions.Permissions.MANAGE_EMOJIS",
"url":31,
"doc":"Allows management and editing of emojis."
},
{
"ref":"hikari.colors",
"url":32,
"doc":"Model that represents a common RGB color and provides simple conversions to other common color systems."
},
{
"ref":"hikari.colors.Color",
"url":32,
"doc":"Representation of a color. This value is immutable. This is a specialization of  builtins.int which provides alternative overrides for common methods and color system conversions. This currently supports:  RGB  RGB (float)  3-digit hex codes (e.g. 0xF1A  web safe)  6-digit hex codes (e.g. 0xFF11AA)  3-digit RGB strings (e.g.  1A2  web safe)  6-digit RGB hash strings (e.g.  1A2B3C) Examples     Examples of conversions to given formats include:   >>> c = Color(0xFF051A) Color(r=0xff, g=0x5, b=0x1a) >>> hex(c) 0xff051a >>> c.hex_code  FF051A >>> str(c)  FF051A >>> int(c) 16712986 >>> c.rgb (255, 5, 26) >>> c.rgb_float (1.0, 0.0196078431372549, 0.10196078431372549)   Alternatively, if you have an arbitrary input in one of the above formats that you wish to become a color, you can use  Color.of on the class itself to automatically attempt to resolve the color:   >>> Color.of(0xFF051A) Color(r=0xff, g=0x5, b=0x1a) >>> Color.of(16712986) Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of 255, 5, 26 Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of(255, 5, 26) Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of([0xFF, 0x5, 0x1a]) Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of(\" 1a2b3c\") Color(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.of(\" 1AB\") Color(r=0x11, g=0xaa, b=0xbb) >>> c = Color.of 1.0, 0.0196078431372549, 0.10196078431372549 Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of([1.0, 0.0196078431372549, 0.10196078431372549]) Color(r=0xff, g=0x5, b=0x1a)   Examples of initialization of Color objects from given formats include:   >>> c = Color(16712986) Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.from_rgb(255, 5, 26) Color(r=0xff, g=0x5, b=1xa) >>> c = Color.from_hex_code(\" 1a2b3c\") Color(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.from_hex_code(\" 1AB\") Color(r=0x11, g=0xaa, b=0xbb) >>> c = Color.from_rgb_float(1.0, 0.0196078431372549, 0.10196078431372549) Color(r=0xff, g=0x5, b=0x1a)  "
},
{
"ref":"hikari.colors.Color.rgb",
"url":32,
"doc":"The RGB representation of this Color. Represented as a tuple of R, G, B. Each value is in the range [0, 0xFF]. Example    -  (123, 234, 47) "
},
{
"ref":"hikari.colors.Color.rgb_float",
"url":32,
"doc":"Return the floating-point RGB representation of this Color. Represented as a tuple of R, G, B. Each value is in the range [0, 1]. Example    -  (0.1, 0.2, 0.76) "
},
{
"ref":"hikari.colors.Color.hex_code",
"url":32,
"doc":"Six-digit hexadecimal color code for this Color. This is prepended with a  symbol, and will be in upper case. Example    -  1A2B3C "
},
{
"ref":"hikari.colors.Color.raw_hex_code",
"url":32,
"doc":"Raw hex code. Example    -  1A2B3C "
},
{
"ref":"hikari.colors.Color.is_web_safe",
"url":32,
"doc":" builtins.True if the color is web safe,  builtins.False otherwise."
},
{
"ref":"hikari.colors.Color.from_rgb",
"url":32,
"doc":"Convert the given RGB to a  Color object. Each channel must be withing the range [0, 255] (0x0, 0xFF). Parameters      red : builtins.int Red channel. green : builtins.int Green channel. blue : builtins.int Blue channel. Returns    - Color A Color object. Raises    builtins.ValueError If red, green, or blue are outside the range [0x0, 0xFF].",
"func":1
},
{
"ref":"hikari.colors.Color.from_rgb_float",
"url":32,
"doc":"Convert the given RGB to a  Color object. The color-space represented values have to be within the range [0, 1]. Parameters      red : builtins.float Red channel. green : builtins.float Green channel. blue : builtins.float Blue channel. Returns    - Color A Color object. Raises    builtins.ValueError If red, green or blue are outside the range [0, 1].",
"func":1
},
{
"ref":"hikari.colors.Color.from_hex_code",
"url":32,
"doc":"Convert the given hexadecimal color code to a  Color . The inputs may be of the following format (case insensitive):  1a2 ,  1a2 ,  0x1a2 (for web-safe colors), or  1a2b3c ,  1a2b3c ,  0x1a2b3c (for regular 3-byte color-codes). Parameters      hex_code : builtins.str A hexadecimal color code to parse. This may optionally start with a case insensitive  0x or  . Returns    - Color A corresponding Color object. Raises    builtins.ValueError If  hex_code is not a hexadecimal or is a invalid length.",
"func":1
},
{
"ref":"hikari.colors.Color.from_int",
"url":32,
"doc":"Convert the given  typing.SupportsInt to a  Color . Parameters      integer : typing.SupportsInt The raw color integer. Returns    - Color The Color object.",
"func":1
},
{
"ref":"hikari.colors.Color.from_tuple_string",
"url":32,
"doc":"Convert a string in a tuple-like format to a  Color . This allows formats that are optionally enclosed by  () ,  {} , or  [] , and contain three floats or ints, either space separated or comma separated. If comma separated, trailing and leading whitespace around each member is truncated. This is provided to allow command frontends to directly pass user input for representing a given colour into this class safely. Examples        Floats \"1.0 1.0 1.0\" \"(1.0 1.0 1.0)\" \"[1.0 1.0 1.0]\" \"{1.0 1.0 1.0}\" \"1.0, 1.0, 1.0\" \"(1.0, 1.0, 1.0)\" \"[1.0, 1.0, 1.0]\" \"{1.0, 1.0, 1.0}\"  Ints \"252 252 252\" \"(252 252 252)\" \"[252 252 252]\" \"{252 252 252}\" \"252, 252, 252\" \"(252, 252, 252)\" \"[252, 252, 252]\" \"{252, 252, 252}\"   Parameters      tuple_str : builtins.str The string to parse. Returns    - Color The parsed colour object. Raises    ValueError If an invalid format is given, or if any values exceed 1.0 for floats or 255 for ints.",
"func":1
},
{
"ref":"hikari.colors.Color.from_bytes",
"url":32,
"doc":"Convert the bytes to a  Color . Parameters      bytes_ : typing.Iterable[builtins.int] A iterable of int byte values. byteorder : builtins.str The endianess of the value represented by the bytes. Can be  \"big\" endian or  \"little\" endian. signed : builtins.bool Whether the value is signed or unsigned. Returns    - Color The Color object.",
"func":1
},
{
"ref":"hikari.colors.Color.of",
"url":32,
"doc":"Convert the value to a  Color . This attempts to determine the correct data format based on the information provided. Parameters      value : Colorish A color compatible values. Examples       >>> Color.of(0xFF051A) Color(r=0xff, g=0x5, b=0x1a) >>> Color.of(16712986) Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of 255, 5, 26 Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of([0xFF, 0x5, 0x1a]) Color(r=0xff, g=0x5, b=1xa) >>> c = Color.of(\" 1a2b3c\") Color(r=0x1a, g=0x2b, b=0x3c) >>> c = Color.of(\" 1AB\") Color(r=0x11, g=0xaa, b=0xbb) >>> c = Color.of 1.0, 0.0196078431372549, 0.10196078431372549 Color(r=0xff, g=0x5, b=0x1a) >>> c = Color.of([1.0, 0.0196078431372549, 0.10196078431372549]) Color(r=0xff, g=0x5, b=0x1a)  Commas and brackets are optional, whitespace is ignored, and these  are compatible with all-ints between 0-255 or all-floats between  0.0 and 1.0 only. >>> c = Color.of(\"5, 22, 33\") Color(r=0x5, g=0x16, b=0x21) >>> c = Color.of(\"(5, 22, 33)\") Color(r=0x5, g=0x16, b=0x21) >>> c = Color.of(\"[5, 22, 33]\") Color(r=0x5, g=0x16, b=0x21) >>> c = Color.of(\"{5, 22, 33}\") Color(r=0x5, g=0x16, b=0x21)   Returns    - Color The Color object.",
"func":1
},
{
"ref":"hikari.colors.Color.to_bytes",
"url":32,
"doc":"Convert the color code to bytes. Parameters      length : builtins.int The number of bytes to produce. Should be around  3 , but not less. byteorder : builtins.str The endianess of the value represented by the bytes. Can be  \"big\" endian or  \"little\" endian. signed : builtins.bool Whether the value is signed or unsigned. Returns    - builtins.bytes The bytes representation of the Color.",
"func":1
},
{
"ref":"hikari.colors.Colorish",
"url":32,
"doc":"Type hint representing types of value compatible with a colour type. This may be: 1.  hikari.colors.Color 2.  hikari.colours.Colour (an alias for  hikari.colors.Color ). 3. A value that can be cast to an  builtins.int (RGB hex-code). 4. a 3- builtins.tuple of  builtins.int (RGB integers in range 0 through 255). 5. a 3- builtins.tuple of  builtins.int (RGB floats in range 0 through 1). 6. a list of  builtins.int . 7. a list of  builtins.float . 8. a  builtins.str hex colour code. A hex colour code is expected to be in one of the following formats. Each of the following examples means the same thing semantically. 1. (web-safe)  \"12F\" (equivalent to  \"1122FF\" ) 2. (web-safe)  \"0x12F\" (equivalent to  \"0x1122FF\" ) 3. (web-safe)  \"0X12F\" (equivalent to  \"0X1122FF\" ) 4. (web-safe)  \" 12F\" (equivalent to  \" 1122FF\" ) 5.  \"1122FF\" 6.  \"0x1122FF\" 7.  \"0X1122FF\" 8.  \" 1122FF\" Web-safe colours are three hex-digits wide,  XYZ becomes  XXYYZZ in full-form."
},
{
"ref":"hikari.channels",
"url":10,
"doc":"Application and entities that are used to describe both DMs and guild channels on Discord."
},
{
"ref":"hikari.channels.ChannelType",
"url":10,
"doc":"The known channel types that are exposed to us by the API."
},
{
"ref":"hikari.channels.ChannelType.name",
"url":10,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.channels.ChannelType.value",
"url":10,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.channels.ChannelType.GUILD_TEXT",
"url":10,
"doc":"A text channel in a guild."
},
{
"ref":"hikari.channels.ChannelType.DM",
"url":10,
"doc":"A direct channel between two users."
},
{
"ref":"hikari.channels.ChannelType.GUILD_VOICE",
"url":10,
"doc":"A voice channel in a guild."
},
{
"ref":"hikari.channels.ChannelType.GROUP_DM",
"url":10,
"doc":"A direct channel between multiple users."
},
{
"ref":"hikari.channels.ChannelType.GUILD_CATEGORY",
"url":10,
"doc":"An category used for organizing channels in a guild."
},
{
"ref":"hikari.channels.ChannelType.GUILD_NEWS",
"url":10,
"doc":"A channel that can be followed and can crosspost."
},
{
"ref":"hikari.channels.ChannelType.GUILD_STORE",
"url":10,
"doc":"A channel that show's a game's store page."
},
{
"ref":"hikari.channels.ChannelFollow",
"url":10,
"doc":"Relationship between a news channel and a subscriber channel. The subscriber channel will receive crosspost messages that correspond to any \"broadcast\" announcements that the news channel creates. Method generated by attrs for class ChannelFollow."
},
{
"ref":"hikari.channels.ChannelFollow.fetch_channel",
"url":10,
"doc":"Fetch the object of the guild channel being followed. Returns    - typing.Union[hikari.channels.GuildNewsChannel, hikari.channels.GuildTextChannel] The channel being followed. While this will usually be  GuildNewsChannel , if the channel's news status has been removed then this will be a  GuildTextChannel Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  READ_MESSAGES permission in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.channels.ChannelFollow.fetch_webhook",
"url":10,
"doc":"Fetch the webhook attached to this follow. Returns    - hikari.webhooks.Webhook The webhook attached to this follow. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission in the guild or channel this follow is targeting. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the webhook is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.channels.ChannelFollow.channel",
"url":10,
"doc":"Get the channel being followed from the cache.  ! warning This will always be  builtins.None if you are not in the guild that this channel exists in. Returns    - typing.Optional[hikari.channels.GuildNewsChannel, hikari.channels.GuildTextChannel] The object of the guild channel that was found in the cache or  builtins.None . While this will usually be  GuildNewsChannel or  builtins.None , if the channel referenced has since lost it's news status then this will return a  GuildTextChannel ."
},
{
"ref":"hikari.channels.ChannelFollow.app",
"url":10,
"doc":"Return the client application that models may use for procedures. Returns    - hikari.traits.RESTAware The REST-aware application object."
},
{
"ref":"hikari.channels.ChannelFollow.channel_id",
"url":10,
"doc":"Return the channel ID of the channel being followed. Returns    - hikari.snowflakes.Snowflake The channel ID for the channel being followed."
},
{
"ref":"hikari.channels.ChannelFollow.webhook_id",
"url":10,
"doc":"Return the ID of the webhook for this follow. Returns    - hikari.snowflakes.Snowflake The ID of the webhook that was created for this follow."
},
{
"ref":"hikari.channels.PermissionOverwrite",
"url":10,
"doc":"Represents permission overwrites for a channel or role in a channel. You may sometimes need to make instances of this object to add/edit permission overwrites on channels. Example    - Creating a permission overwrite.   overwrite = PermissionOverwrite( type=PermissionOverwriteType.MEMBER, allow=( Permissions.VIEW_CHANNEL | Permissions.READ_MESSAGE_HISTORY | Permissions.SEND_MESSAGES ), deny=( Permissions.MANAGE_MESSAGES | Permissions.SPEAK ), )   Method generated by attrs for class PermissionOverwrite."
},
{
"ref":"hikari.channels.PermissionOverwrite.unset",
"url":10,
"doc":"Bitfield of all permissions not explicitly allowed or denied by this overwrite."
},
{
"ref":"hikari.channels.PermissionOverwrite.allow",
"url":10,
"doc":"The permissions this overwrite allows."
},
{
"ref":"hikari.channels.PermissionOverwrite.deny",
"url":10,
"doc":"The permissions this overwrite denies."
},
{
"ref":"hikari.channels.PermissionOverwrite.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.PermissionOverwrite.type",
"url":10,
"doc":"The type of entity this overwrite targets."
},
{
"ref":"hikari.channels.PermissionOverwrite.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.PermissionOverwriteType",
"url":10,
"doc":"The type of entity a Permission Overwrite targets."
},
{
"ref":"hikari.channels.PermissionOverwriteType.name",
"url":10,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.channels.PermissionOverwriteType.value",
"url":10,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.channels.PermissionOverwriteType.ROLE",
"url":10,
"doc":"A permission overwrite that targets all the members with a specific role."
},
{
"ref":"hikari.channels.PermissionOverwriteType.MEMBER",
"url":10,
"doc":"A permission overwrite that targets a specific guild member."
},
{
"ref":"hikari.channels.PartialChannel",
"url":10,
"doc":"Channel representation for cases where further detail is not provided. This is commonly received in HTTP API responses where full information is not available from Discord. Method generated by attrs for class PartialChannel."
},
{
"ref":"hikari.channels.PartialChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.PartialChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.PartialChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.PartialChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.PartialChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.TextChannel",
"url":10,
"doc":"A channel that can have text messages in it. Method generated by attrs for class PartialChannel."
},
{
"ref":"hikari.channels.TextChannel.history",
"url":10,
"doc":"Browse the message history for a given text channel. Other Parameters         before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises    builtins.TypeError If you specify more than one of  before ,  after ,  about . hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to read message history in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint (other than  builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than  builtins.TypeError ).",
"func":1
},
{
"ref":"hikari.channels.TextChannel.send",
"url":10,
"doc":"Create a message in the channel this message belongs to. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.channels.TextChannel.trigger_typing",
"url":10,
"doc":"Trigger typing in a given channel. This returns an object that can either be  await ed to trigger typing once, or used as an async context manager to keep typing until the block completes.   await channel.trigger_typing()  type for 10s async with channel.trigger_typing(): await asyncio.sleep(35)  keep typing until this finishes    ! note Sending a message to this channel will stop the typing indicator. If using an  async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns    - hikari.api.special_endpoints.TypingIndicator The typing indicator object.",
"func":1
},
{
"ref":"hikari.channels.TextChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.TextChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.TextChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.TextChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.TextChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.PrivateChannel",
"url":10,
"doc":"The base for anything that is a private (non-guild bound) channel. Method generated by attrs for class PrivateChannel."
},
{
"ref":"hikari.channels.PrivateChannel.last_message_id",
"url":10,
"doc":"The ID of the last message sent in this channel.  ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."
},
{
"ref":"hikari.channels.PrivateChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.PrivateChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.PrivateChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.PrivateChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.PrivateChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.DMChannel",
"url":10,
"doc":"Represents a direct message text channel that is between you and another user. Method generated by attrs for class DMChannel."
},
{
"ref":"hikari.channels.DMChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard."
},
{
"ref":"hikari.channels.DMChannel.recipient",
"url":10,
"doc":"The user recipient of this DM."
},
{
"ref":"hikari.channels.DMChannel.last_message_id",
"url":10,
"doc":"The ID of the last message sent in this channel.  ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."
},
{
"ref":"hikari.channels.DMChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.DMChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.DMChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.DMChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.DMChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.DMChannel.history",
"url":10,
"doc":"Browse the message history for a given text channel. Other Parameters         before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises    builtins.TypeError If you specify more than one of  before ,  after ,  about . hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to read message history in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint (other than  builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than  builtins.TypeError ).",
"func":1
},
{
"ref":"hikari.channels.DMChannel.send",
"url":10,
"doc":"Create a message in the channel this message belongs to. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.channels.DMChannel.trigger_typing",
"url":10,
"doc":"Trigger typing in a given channel. This returns an object that can either be  await ed to trigger typing once, or used as an async context manager to keep typing until the block completes.   await channel.trigger_typing()  type for 10s async with channel.trigger_typing(): await asyncio.sleep(35)  keep typing until this finishes    ! note Sending a message to this channel will stop the typing indicator. If using an  async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns    - hikari.api.special_endpoints.TypingIndicator The typing indicator object.",
"func":1
},
{
"ref":"hikari.channels.GroupDMChannel",
"url":10,
"doc":"Represents a group direct message channel.  ! note This doesn't have the methods found on  TextChannel as bots cannot interact with a group DM that they own by sending or seeing messages in it. Method generated by attrs for class GroupDMChannel."
},
{
"ref":"hikari.channels.GroupDMChannel.icon_url",
"url":10,
"doc":"Icon for this groupd DM, if set."
},
{
"ref":"hikari.channels.GroupDMChannel.format_icon",
"url":10,
"doc":"Generate the icon for this group, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL, or  builtins.None if no icon is present. Raises    builtins.ValueError If  size is not a power of two between 16 and 4096 (inclusive).",
"func":1
},
{
"ref":"hikari.channels.GroupDMChannel.application_id",
"url":10,
"doc":"The ID of the application that created the group DM. If the group DM was not created by a bot, this will be  builtins.None ."
},
{
"ref":"hikari.channels.GroupDMChannel.icon_hash",
"url":10,
"doc":"The CDN hash of the icon of the group, if an icon is set."
},
{
"ref":"hikari.channels.GroupDMChannel.nicknames",
"url":10,
"doc":"A mapping of set nicknames within this group DMs to user IDs."
},
{
"ref":"hikari.channels.GroupDMChannel.owner_id",
"url":10,
"doc":"The ID of the owner of the group."
},
{
"ref":"hikari.channels.GroupDMChannel.recipients",
"url":10,
"doc":"The recipients of the group DM."
},
{
"ref":"hikari.channels.GroupDMChannel.last_message_id",
"url":10,
"doc":"The ID of the last message sent in this channel.  ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."
},
{
"ref":"hikari.channels.GroupDMChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.GroupDMChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.GroupDMChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.GroupDMChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.GroupDMChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.GuildCategory",
"url":10,
"doc":"Represents a guild category channel. These can contain other channels inside, and act as a method for organisation. Method generated by attrs for class GuildCategory."
},
{
"ref":"hikari.channels.GuildCategory.guild_id",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildCategory.position",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildCategory.permission_overwrites",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildCategory.is_nsfw",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildCategory.parent_id",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildCategory.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.channels.GuildCategory.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.GuildCategory.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.GuildCategory.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.GuildCategory.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.GuildCategory.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.GuildChannel",
"url":10,
"doc":"The base for anything that is a guild channel. Method generated by attrs for class GuildChannel."
},
{
"ref":"hikari.channels.GuildChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.channels.GuildChannel.guild_id",
"url":10,
"doc":"The ID of the guild the channel belongs to."
},
{
"ref":"hikari.channels.GuildChannel.is_nsfw",
"url":10,
"doc":"Whether the channel is marked as NSFW.  ! warning This will be  builtins.None when received over the gateway in certain events (e.g Guild Create)."
},
{
"ref":"hikari.channels.GuildChannel.parent_id",
"url":10,
"doc":"The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be  builtins.None ."
},
{
"ref":"hikari.channels.GuildChannel.permission_overwrites",
"url":10,
"doc":"The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."
},
{
"ref":"hikari.channels.GuildChannel.position",
"url":10,
"doc":"The sorting position of the channel. Higher numbers appear further down the channel list."
},
{
"ref":"hikari.channels.GuildChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.GuildChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.GuildChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.GuildChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.GuildChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.GuildTextChannel",
"url":10,
"doc":"Represents a guild text channel. Method generated by attrs for class GuildTextChannel."
},
{
"ref":"hikari.channels.GuildTextChannel.last_message_id",
"url":10,
"doc":"The ID of the last message sent in this channel.  ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."
},
{
"ref":"hikari.channels.GuildTextChannel.last_pin_timestamp",
"url":10,
"doc":"The timestamp of the last-pinned message.  ! note This may be  builtins.None in several cases; Discord does not document what these cases are. Trust no one!"
},
{
"ref":"hikari.channels.GuildTextChannel.rate_limit_per_user",
"url":10,
"doc":"The delay (in seconds) between a user can send a message to this channel. If there is no rate limit, this will be 0 seconds.  ! note Any user that has permissions allowing  MANAGE_MESSAGES ,  MANAGE_CHANNEL ,  ADMINISTRATOR will not be limited. Likewise, bots will not be affected by this rate limit."
},
{
"ref":"hikari.channels.GuildTextChannel.topic",
"url":10,
"doc":"The topic of the channel."
},
{
"ref":"hikari.channels.GuildTextChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.channels.GuildTextChannel.guild_id",
"url":10,
"doc":"The ID of the guild the channel belongs to."
},
{
"ref":"hikari.channels.GuildTextChannel.is_nsfw",
"url":10,
"doc":"Whether the channel is marked as NSFW.  ! warning This will be  builtins.None when received over the gateway in certain events (e.g Guild Create)."
},
{
"ref":"hikari.channels.GuildTextChannel.parent_id",
"url":10,
"doc":"The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be  builtins.None ."
},
{
"ref":"hikari.channels.GuildTextChannel.permission_overwrites",
"url":10,
"doc":"The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."
},
{
"ref":"hikari.channels.GuildTextChannel.position",
"url":10,
"doc":"The sorting position of the channel. Higher numbers appear further down the channel list."
},
{
"ref":"hikari.channels.GuildTextChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.GuildTextChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.GuildTextChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.GuildTextChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.GuildTextChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.GuildTextChannel.history",
"url":10,
"doc":"Browse the message history for a given text channel. Other Parameters         before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises    builtins.TypeError If you specify more than one of  before ,  after ,  about . hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to read message history in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint (other than  builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than  builtins.TypeError ).",
"func":1
},
{
"ref":"hikari.channels.GuildTextChannel.send",
"url":10,
"doc":"Create a message in the channel this message belongs to. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.channels.GuildTextChannel.trigger_typing",
"url":10,
"doc":"Trigger typing in a given channel. This returns an object that can either be  await ed to trigger typing once, or used as an async context manager to keep typing until the block completes.   await channel.trigger_typing()  type for 10s async with channel.trigger_typing(): await asyncio.sleep(35)  keep typing until this finishes    ! note Sending a message to this channel will stop the typing indicator. If using an  async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns    - hikari.api.special_endpoints.TypingIndicator The typing indicator object.",
"func":1
},
{
"ref":"hikari.channels.GuildNewsChannel",
"url":10,
"doc":"Represents an news channel. Method generated by attrs for class GuildNewsChannel."
},
{
"ref":"hikari.channels.GuildNewsChannel.last_message_id",
"url":10,
"doc":"The ID of the last message sent in this channel.  ! warning This might point to an invalid or deleted message. Do not assume that this will always be valid."
},
{
"ref":"hikari.channels.GuildNewsChannel.last_pin_timestamp",
"url":10,
"doc":"The timestamp of the last-pinned message.  ! note This may be  builtins.None in several cases; Discord does not document what these cases are. Trust no one!"
},
{
"ref":"hikari.channels.GuildNewsChannel.topic",
"url":10,
"doc":"The topic of the channel."
},
{
"ref":"hikari.channels.GuildNewsChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.channels.GuildNewsChannel.guild_id",
"url":10,
"doc":"The ID of the guild the channel belongs to."
},
{
"ref":"hikari.channels.GuildNewsChannel.is_nsfw",
"url":10,
"doc":"Whether the channel is marked as NSFW.  ! warning This will be  builtins.None when received over the gateway in certain events (e.g Guild Create)."
},
{
"ref":"hikari.channels.GuildNewsChannel.parent_id",
"url":10,
"doc":"The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be  builtins.None ."
},
{
"ref":"hikari.channels.GuildNewsChannel.permission_overwrites",
"url":10,
"doc":"The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."
},
{
"ref":"hikari.channels.GuildNewsChannel.position",
"url":10,
"doc":"The sorting position of the channel. Higher numbers appear further down the channel list."
},
{
"ref":"hikari.channels.GuildNewsChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.GuildNewsChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.GuildNewsChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.GuildNewsChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.GuildNewsChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.GuildNewsChannel.history",
"url":10,
"doc":"Browse the message history for a given text channel. Other Parameters         before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflakes. If you provide a datetime object, it will be transformed into a snowflakes. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.messages.Message] A iterator to fetch the messages. Raises    builtins.TypeError If you specify more than one of  before ,  after ,  about . hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to read message history in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint (other than  builtins.TypeError ) will only be raised once the result is awaited or interacted with. Invoking this function itself will not raise anything (other than  builtins.TypeError ).",
"func":1
},
{
"ref":"hikari.channels.GuildNewsChannel.send",
"url":10,
"doc":"Create a message in the channel this message belongs to. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.channels.GuildNewsChannel.trigger_typing",
"url":10,
"doc":"Trigger typing in a given channel. This returns an object that can either be  await ed to trigger typing once, or used as an async context manager to keep typing until the block completes.   await channel.trigger_typing()  type for 10s async with channel.trigger_typing(): await asyncio.sleep(35)  keep typing until this finishes    ! note Sending a message to this channel will stop the typing indicator. If using an  async with , it will start up again after a few seconds. This is a limitation of Discord's API. Returns    - hikari.api.special_endpoints.TypingIndicator The typing indicator object.",
"func":1
},
{
"ref":"hikari.channels.GuildStoreChannel",
"url":10,
"doc":"Represents a store channel. These were originally used to sell games when Discord had a game store. This was scrapped at the end of 2019, so these may disappear from the platform eventually. Method generated by attrs for class GuildStoreChannel."
},
{
"ref":"hikari.channels.GuildStoreChannel.guild_id",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildStoreChannel.position",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildStoreChannel.permission_overwrites",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildStoreChannel.is_nsfw",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildStoreChannel.parent_id",
"url":10,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.channels.GuildStoreChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.channels.GuildStoreChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.GuildStoreChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.GuildStoreChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.GuildStoreChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.GuildStoreChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.channels.GuildVoiceChannel",
"url":10,
"doc":"Represents an voice channel. Method generated by attrs for class GuildVoiceChannel."
},
{
"ref":"hikari.channels.GuildVoiceChannel.bitrate",
"url":10,
"doc":"The bitrate for the voice channel (in bits per second)."
},
{
"ref":"hikari.channels.GuildVoiceChannel.user_limit",
"url":10,
"doc":"The user limit for the voice channel. If this is  0 , then assume no limit."
},
{
"ref":"hikari.channels.GuildVoiceChannel.shard_id",
"url":10,
"doc":"Return the shard ID for the shard. This may be  builtins.None if the shard count is not known."
},
{
"ref":"hikari.channels.GuildVoiceChannel.guild_id",
"url":10,
"doc":"The ID of the guild the channel belongs to."
},
{
"ref":"hikari.channels.GuildVoiceChannel.is_nsfw",
"url":10,
"doc":"Whether the channel is marked as NSFW.  ! warning This will be  builtins.None when received over the gateway in certain events (e.g Guild Create)."
},
{
"ref":"hikari.channels.GuildVoiceChannel.parent_id",
"url":10,
"doc":"The ID of the parent category the channel belongs to. If no parent category is set for the channel, this will be  builtins.None ."
},
{
"ref":"hikari.channels.GuildVoiceChannel.permission_overwrites",
"url":10,
"doc":"The permission overwrites for the channel. This maps the ID of the entity in the overwrite to the overwrite data."
},
{
"ref":"hikari.channels.GuildVoiceChannel.position",
"url":10,
"doc":"The sorting position of the channel. Higher numbers appear further down the channel list."
},
{
"ref":"hikari.channels.GuildVoiceChannel.app",
"url":10,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.channels.GuildVoiceChannel.id",
"url":10,
"doc":"The ID of this entity."
},
{
"ref":"hikari.channels.GuildVoiceChannel.name",
"url":10,
"doc":"The channel's name. This will be missing for DM channels."
},
{
"ref":"hikari.channels.GuildVoiceChannel.type",
"url":10,
"doc":"The channel's type."
},
{
"ref":"hikari.channels.GuildVoiceChannel.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.messages",
"url":20,
"doc":"Application and entities that are used to describe messages on Discord."
},
{
"ref":"hikari.messages.MessageType",
"url":20,
"doc":"The type of a message."
},
{
"ref":"hikari.messages.MessageType.name",
"url":20,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.messages.MessageType.value",
"url":20,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.messages.MessageType.DEFAULT",
"url":20,
"doc":"A normal message."
},
{
"ref":"hikari.messages.MessageType.RECIPIENT_ADD",
"url":20,
"doc":"A message to denote a new recipient in a group."
},
{
"ref":"hikari.messages.MessageType.RECIPIENT_REMOVE",
"url":20,
"doc":"A message to denote that a recipient left the group."
},
{
"ref":"hikari.messages.MessageType.CALL",
"url":20,
"doc":"A message to denote a VoIP call."
},
{
"ref":"hikari.messages.MessageType.CHANNEL_NAME_CHANGE",
"url":20,
"doc":"A message to denote that the name of a channel changed."
},
{
"ref":"hikari.messages.MessageType.CHANNEL_ICON_CHANGE",
"url":20,
"doc":"A message to denote that the icon of a channel changed."
},
{
"ref":"hikari.messages.MessageType.CHANNEL_PINNED_MESSAGE",
"url":20,
"doc":"A message to denote that a message was pinned."
},
{
"ref":"hikari.messages.MessageType.GUILD_MEMBER_JOIN",
"url":20,
"doc":"A message to denote that a member joined the guild."
},
{
"ref":"hikari.messages.MessageType.USER_PREMIUM_GUILD_SUBSCRIPTION",
"url":20,
"doc":"A message to denote a Nitro subscription."
},
{
"ref":"hikari.messages.MessageType.USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_1",
"url":20,
"doc":"A message to denote a tier 1 Nitro subscription."
},
{
"ref":"hikari.messages.MessageType.USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_2",
"url":20,
"doc":"A message to denote a tier 2 Nitro subscription."
},
{
"ref":"hikari.messages.MessageType.USER_PREMIUM_GUILD_SUBSCRIPTION_TIER_3",
"url":20,
"doc":"A message to denote a tier 3 Nitro subscription."
},
{
"ref":"hikari.messages.MessageType.CHANNEL_FOLLOW_ADD",
"url":20,
"doc":"Channel follow add."
},
{
"ref":"hikari.messages.MessageFlag",
"url":20,
"doc":"Additional flags for message options."
},
{
"ref":"hikari.messages.MessageFlag.name",
"url":20,
"doc":"Return the name of the flag combination as a  builtins.str ."
},
{
"ref":"hikari.messages.MessageFlag.value",
"url":20,
"doc":"Return the  builtins.int value of the flag."
},
{
"ref":"hikari.messages.MessageFlag.all",
"url":20,
"doc":"Check if all of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.any",
"url":20,
"doc":"Check if any of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.difference",
"url":20,
"doc":"Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction  - operator.",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.intersection",
"url":20,
"doc":"Return a combination of flags that are set for both given values. Equivalent to using the \"AND\"  & operator.",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.invert",
"url":20,
"doc":"Return a set of all flags not in the current set.",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.is_disjoint",
"url":20,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.is_subset",
"url":20,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.is_superset",
"url":20,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.none",
"url":20,
"doc":"Check if none of the given flags are part of this value.  ! note This is essentially the opposite of  Flag.any . Returns    - builtins.bool  builtins.True if none of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.split",
"url":20,
"doc":"Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted  typing.Sequence of each membe",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.symmetric_difference",
"url":20,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.union",
"url":20,
"doc":"Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\"  ~ operator.",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.isdisjoint",
"url":20,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.issubset",
"url":20,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.issuperset",
"url":20,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.symmetricdifference",
"url":20,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.messages.MessageFlag.NONE",
"url":20,
"doc":"None"
},
{
"ref":"hikari.messages.MessageFlag.CROSSPOSTED",
"url":20,
"doc":"This message has been published to subscribed channels via channel following."
},
{
"ref":"hikari.messages.MessageFlag.IS_CROSSPOST",
"url":20,
"doc":"This message originated from a message in another channel via channel following."
},
{
"ref":"hikari.messages.MessageFlag.SUPPRESS_EMBEDS",
"url":20,
"doc":"Any embeds on this message should be omitted when serializing the message."
},
{
"ref":"hikari.messages.MessageFlag.SOURCE_MESSAGE_DELETED",
"url":20,
"doc":"The message this crosspost originated from was deleted via channel following."
},
{
"ref":"hikari.messages.MessageFlag.URGENT",
"url":20,
"doc":"This message came from the urgent message system."
},
{
"ref":"hikari.messages.MessageActivityType",
"url":20,
"doc":"The type of a rich presence message activity."
},
{
"ref":"hikari.messages.MessageActivityType.name",
"url":20,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.messages.MessageActivityType.value",
"url":20,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.messages.MessageActivityType.NONE",
"url":20,
"doc":"No activity."
},
{
"ref":"hikari.messages.MessageActivityType.JOIN",
"url":20,
"doc":"Join an activity."
},
{
"ref":"hikari.messages.MessageActivityType.SPECTATE",
"url":20,
"doc":"Spectating something."
},
{
"ref":"hikari.messages.MessageActivityType.LISTEN",
"url":20,
"doc":"Listening to something."
},
{
"ref":"hikari.messages.MessageActivityType.JOIN_REQUEST",
"url":20,
"doc":"Request to join an activity."
},
{
"ref":"hikari.messages.Attachment",
"url":20,
"doc":"Represents a file attached to a message. You can use this object in the same way as a  hikari.files.WebResource , by passing it as an attached file when creating a message, etc. Method generated by attrs for class Attachment."
},
{
"ref":"hikari.messages.Attachment.filename",
"url":20,
"doc":"The name of the file."
},
{
"ref":"hikari.messages.Attachment.height",
"url":20,
"doc":"The height of the image (if the file is an image)."
},
{
"ref":"hikari.messages.Attachment.id",
"url":20,
"doc":"The ID of this entity."
},
{
"ref":"hikari.messages.Attachment.proxy_url",
"url":20,
"doc":"The proxied URL of file."
},
{
"ref":"hikari.messages.Attachment.size",
"url":20,
"doc":"The size of the file in bytes."
},
{
"ref":"hikari.messages.Attachment.url",
"url":20,
"doc":"The source URL of file."
},
{
"ref":"hikari.messages.Attachment.width",
"url":20,
"doc":"The width of the image (if the file is an image)."
},
{
"ref":"hikari.messages.Attachment.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.messages.Attachment.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.messages.Attachment.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.messages.Attachment.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.messages.Reaction",
"url":20,
"doc":"Represents a reaction in a message. Method generated by attrs for class Reaction."
},
{
"ref":"hikari.messages.Reaction.count",
"url":20,
"doc":"The number of times the emoji has been used to react."
},
{
"ref":"hikari.messages.Reaction.emoji",
"url":20,
"doc":"The emoji used to react."
},
{
"ref":"hikari.messages.Reaction.is_me",
"url":20,
"doc":"Whether the current user reacted using this emoji."
},
{
"ref":"hikari.messages.MessageActivity",
"url":20,
"doc":"Represents the activity of a rich presence-enabled message. Method generated by attrs for class MessageActivity."
},
{
"ref":"hikari.messages.MessageActivity.party_id",
"url":20,
"doc":"The party ID of the message activity."
},
{
"ref":"hikari.messages.MessageActivity.type",
"url":20,
"doc":"The type of message activity."
},
{
"ref":"hikari.messages.MessageCrosspost",
"url":20,
"doc":"Represents information about a cross-posted message. This is a message that is sent in one channel/guild and may be \"published\" to another. Method generated by attrs for class MessageCrosspost."
},
{
"ref":"hikari.messages.MessageCrosspost.app",
"url":20,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.messages.MessageCrosspost.channel_id",
"url":20,
"doc":"The ID of the channel that the message originated from."
},
{
"ref":"hikari.messages.MessageCrosspost.guild_id",
"url":20,
"doc":"The ID of the guild that the message originated from.  ! warning This may be  builtins.None in some cases according to the Discord API documentation, but the situations that cause this to occur are not currently documented."
},
{
"ref":"hikari.messages.MessageCrosspost.id",
"url":20,
"doc":"The ID of the message.  ! warning This may be  builtins.None in some cases according to the Discord API documentation, but the situations that cause this to occur are not currently documented."
},
{
"ref":"hikari.messages.PartialMessage",
"url":20,
"doc":"A message representation containing partially populated information. This contains arbitrary fields that may be updated in a  MessageUpdateEvent , but for all other purposes should be treated as being optionally specified.  ! warn All fields on this model except  channel and  id may be set to  hikari.undefined.UNDEFINED (a singleton) if we have not received information about their state from Discord alongside field nullability. Method generated by attrs for class PartialMessage."
},
{
"ref":"hikari.messages.PartialMessage.link",
"url":20,
"doc":"Jump link to the message. Returns    - builtins.str The jump link to the message."
},
{
"ref":"hikari.messages.PartialMessage.fetch_channel",
"url":20,
"doc":"Fetch the channel this message was created in. Returns    - hikari.channels.PartialChannel The object of the channel this message belongs to. Raises    hikari.errors.BadRequestError If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. hikari.errors.ForbiddenError If you don't have access to the channel this message belongs to. hikari.errors.NotFoundError If the channel this message was created in does not exist.",
"func":1
},
{
"ref":"hikari.messages.PartialMessage.edit",
"url":20,
"doc":"Edit an existing message in a given channel. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] The message content to update with. If  hikari.undefined.UNDEFINED , then the content will not be changed. If  builtins.None , then the content will be removed. Any other value will be cast to a  builtins.str before sending. If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Other Parameters         embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] The embed to set on the message. If  hikari.undefined.UNDEFINED , the previous embed if present is not changed. If this is  builtins.None , then the embed is removed if present. Otherwise, the new embed value that was provided will be used as the replacement. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] Sanitation for  @everyone mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , then  @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool Sanitation for user mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid user mentions will behave as mentions. If  builtins.False , all valid user mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake user IDs, or  hikari.users.PartialUser -derived objects. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool Sanitation for role mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid role mentions will behave as mentions. If  builtins.False , all valid role mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake role IDs, or  hikari.guilds.PartialRole -derived objects. flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag] Optional flags to set on the message. If  hikari.undefined.UNDEFINED , then nothing is changed. Note that some flags may not be able to be set. Currently the only flags that can be set are  NONE and  SUPPRESS_EMBEDS . If you have  MANAGE_MESSAGES permissions, you can use this call to suppress embeds on another user's message.  ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however.  ! note There is currently no documented way to clear attachments or edit attachments from a previously sent message on Discord's API. To do this,  delete the message and re-send it.  ! warning If the message was not sent by your user, the only parameter you may provide to this call is the  flags parameter. Anything else will result in a  hikari.errors.ForbiddenError being raised. Returns    - hikari.messages.Message The edited message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the permissions to manage messages. hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.messages.PartialMessage.reply",
"url":20,
"doc":"Create a message in the given channel. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.messages.PartialMessage.delete",
"url":20,
"doc":"Delete this message. Raises    hikari.errors.NotFoundError If the channel this message was created in is not found, or if the message has already been deleted. hikari.errors.ForbiddenError If you lack the permissions to delete the message.",
"func":1
},
{
"ref":"hikari.messages.PartialMessage.add_reaction",
"url":20,
"doc":"Add a reaction to this message. Parameters      emoji : hikari.emojis.Emojiish The emoji to add. This may be a unicode emoji string, the  name:id of a custom emoji, or a subclass of  hikari.emojis.Emoji . Note that if the emoji is an  hikari.emojis.CustomEmoji and is not from a guild the bot user is in, then this will fail. Examples        Using a unicode emoji. await message.add_reaction(\"\ud83d\udc4c\")  Using a unicode emoji name. await message.add_reaction(\"\\N{OK HAND SIGN}\")  Using the  name:id format. await message.add_reaction(\"rooAYAYA:705837374319493284\")  Using a raw custom emoji mention (unanimated and animated) await message.add_reaction(\" \") await message.add_reaction(\" \")  Using an Emoji-derived object. await message.add_reaction(some_emoji_object)   Raises    hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. hikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the  ADD_REACTIONS permission. If you lack  READ_MESSAGE_HISTORY , this may also raise this error. hikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found. This will also occur if you try to add an emoji from a guild you are not part of if no one else has previously reacted with the same emoji.",
"func":1
},
{
"ref":"hikari.messages.PartialMessage.remove_reaction",
"url":20,
"doc":"Remove a reaction from this message. Parameters      emoji : hikari.emojis.Emojiish The emoji to remove. Other Parameters         user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser The user of the reaction to remove. If unspecified, then the bot's reaction is removed instead. Examples      Using a unicode emoji and removing the bot's reaction from this  reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\")  Using a unicode emoji and removing a specific user from this  reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\", some_user)  Using a raw custom emoji mention (unanimated and animated) await message.remove_reaction(\" \", some_user) await message.remove_reaction(\" \", some_user)  Using an Emoji object and removing a specific user from this  reaction. await message.remove_reaction(some_emoji_object, some_user) Raises    hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. hikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the  ADD_REACTIONS permission. If you lack  READ_MESSAGE_HISTORY , this may also raise this error. If you remove the reaction of another user without  MANAGE_MESSAGES , this will be raised. hikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found.",
"func":1
},
{
"ref":"hikari.messages.PartialMessage.remove_all_reactions",
"url":20,
"doc":"Remove all users' reactions for a specific emoji from the message. Other Parameters         emoji : hikari.undefined.UndefinedOr[hikari.emojis.Emojiish] The emoji to remove all reactions for. If not specified, then all emojis are removed. Example      Using a unicode emoji and removing all \ud83d\udc4c reacts from the message.  reaction. await message.remove_all_reactions(\"\\N{OK HAND SIGN}\")  Using a raw custom emoji mention (unanimated and animated) await message.remove_all_reactions(\" \") await message.remove_all_reactions(\" \")  Removing all reactions entirely. await message.remove_all_reactions() Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission, or the permission to view the channel hikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found. hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.",
"func":1
},
{
"ref":"hikari.messages.PartialMessage.activity",
"url":20,
"doc":"The message's activity."
},
{
"ref":"hikari.messages.PartialMessage.app",
"url":20,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.messages.PartialMessage.application",
"url":20,
"doc":"The message's application."
},
{
"ref":"hikari.messages.PartialMessage.attachments",
"url":20,
"doc":"The message attachments."
},
{
"ref":"hikari.messages.PartialMessage.author",
"url":20,
"doc":"The author of this message. This will be  builtins.None in some cases such as when Discord updates a message with an embed URL preview."
},
{
"ref":"hikari.messages.PartialMessage.channel_id",
"url":20,
"doc":"The ID of the channel that the message was sent in."
},
{
"ref":"hikari.messages.PartialMessage.channel_mentions",
"url":20,
"doc":"The channels the message mentions."
},
{
"ref":"hikari.messages.PartialMessage.content",
"url":20,
"doc":"The content of the message."
},
{
"ref":"hikari.messages.PartialMessage.edited_timestamp",
"url":20,
"doc":"The timestamp that the message was last edited at. Will be  builtins.None if the message wasn't ever edited, or  undefined if the info is not available."
},
{
"ref":"hikari.messages.PartialMessage.embeds",
"url":20,
"doc":"The message's embeds."
},
{
"ref":"hikari.messages.PartialMessage.flags",
"url":20,
"doc":"The message's flags."
},
{
"ref":"hikari.messages.PartialMessage.guild_id",
"url":20,
"doc":"The ID of the guild that the message was sent in."
},
{
"ref":"hikari.messages.PartialMessage.id",
"url":20,
"doc":"The ID of this entity."
},
{
"ref":"hikari.messages.PartialMessage.is_mentioning_everyone",
"url":20,
"doc":"Whether the message mentions  @everyone or  @here ."
},
{
"ref":"hikari.messages.PartialMessage.is_pinned",
"url":20,
"doc":"Whether the message is pinned."
},
{
"ref":"hikari.messages.PartialMessage.is_tts",
"url":20,
"doc":"Whether the message is a TTS message."
},
{
"ref":"hikari.messages.PartialMessage.member",
"url":20,
"doc":"The member for the author who created the message. If the message is not in a guild, this will be  builtins.None . This will also be  builtins.None in some cases such as when Discord updates a message with an embed URL preview."
},
{
"ref":"hikari.messages.PartialMessage.message_reference",
"url":20,
"doc":"The message's cross-posted reference data."
},
{
"ref":"hikari.messages.PartialMessage.nonce",
"url":20,
"doc":"The message nonce. This is a string used for validating a message was sent."
},
{
"ref":"hikari.messages.PartialMessage.reactions",
"url":20,
"doc":"The message's reactions."
},
{
"ref":"hikari.messages.PartialMessage.role_mentions",
"url":20,
"doc":"The roles the message mentions."
},
{
"ref":"hikari.messages.PartialMessage.timestamp",
"url":20,
"doc":"The timestamp that the message was sent at."
},
{
"ref":"hikari.messages.PartialMessage.type",
"url":20,
"doc":"The message's type."
},
{
"ref":"hikari.messages.PartialMessage.user_mentions",
"url":20,
"doc":"The users the message mentions."
},
{
"ref":"hikari.messages.PartialMessage.webhook_id",
"url":20,
"doc":"If the message was generated by a webhook, the webhook's ID."
},
{
"ref":"hikari.messages.PartialMessage.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.messages.Message",
"url":20,
"doc":"Represents a message with all known details. Method generated by attrs for class Message."
},
{
"ref":"hikari.messages.Message.guild_id",
"url":20,
"doc":"The ID of the guild that the message was sent in."
},
{
"ref":"hikari.messages.Message.author",
"url":20,
"doc":"The author of this message."
},
{
"ref":"hikari.messages.Message.member",
"url":20,
"doc":"The member properties for the message's author."
},
{
"ref":"hikari.messages.Message.content",
"url":20,
"doc":"The content of the message."
},
{
"ref":"hikari.messages.Message.timestamp",
"url":20,
"doc":"The timestamp that the message was sent at."
},
{
"ref":"hikari.messages.Message.edited_timestamp",
"url":20,
"doc":"The timestamp that the message was last edited at. Will be  builtins.None if it wasn't ever edited."
},
{
"ref":"hikari.messages.Message.is_tts",
"url":20,
"doc":"Whether the message is a TTS message."
},
{
"ref":"hikari.messages.Message.is_mentioning_everyone",
"url":20,
"doc":"Whether the message mentions  @everyone or  @here ."
},
{
"ref":"hikari.messages.Message.user_mentions",
"url":20,
"doc":"The users the message mentions."
},
{
"ref":"hikari.messages.Message.role_mentions",
"url":20,
"doc":"The roles the message mentions."
},
{
"ref":"hikari.messages.Message.channel_mentions",
"url":20,
"doc":"The channels the message mentions."
},
{
"ref":"hikari.messages.Message.attachments",
"url":20,
"doc":"The message attachments."
},
{
"ref":"hikari.messages.Message.embeds",
"url":20,
"doc":"The message embeds."
},
{
"ref":"hikari.messages.Message.reactions",
"url":20,
"doc":"The message reactions."
},
{
"ref":"hikari.messages.Message.is_pinned",
"url":20,
"doc":"Whether the message is pinned."
},
{
"ref":"hikari.messages.Message.webhook_id",
"url":20,
"doc":"If the message was generated by a webhook, the webhook's id."
},
{
"ref":"hikari.messages.Message.type",
"url":20,
"doc":"The message type."
},
{
"ref":"hikari.messages.Message.activity",
"url":20,
"doc":"The message activity."
},
{
"ref":"hikari.messages.Message.application",
"url":20,
"doc":"The message application."
},
{
"ref":"hikari.messages.Message.message_reference",
"url":20,
"doc":"The message crossposted reference data."
},
{
"ref":"hikari.messages.Message.flags",
"url":20,
"doc":"The message flags."
},
{
"ref":"hikari.messages.Message.nonce",
"url":20,
"doc":"The message nonce. This is a string used for validating a message was sent."
},
{
"ref":"hikari.messages.Message.link",
"url":20,
"doc":"Jump link to the message. Returns    - builtins.str The jump link to the message."
},
{
"ref":"hikari.messages.Message.fetch_channel",
"url":20,
"doc":"Fetch the channel this message was created in. Returns    - hikari.channels.PartialChannel The object of the channel this message belongs to. Raises    hikari.errors.BadRequestError If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. hikari.errors.ForbiddenError If you don't have access to the channel this message belongs to. hikari.errors.NotFoundError If the channel this message was created in does not exist.",
"func":1
},
{
"ref":"hikari.messages.Message.edit",
"url":20,
"doc":"Edit an existing message in a given channel. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] The message content to update with. If  hikari.undefined.UNDEFINED , then the content will not be changed. If  builtins.None , then the content will be removed. Any other value will be cast to a  builtins.str before sending. If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Other Parameters         embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] The embed to set on the message. If  hikari.undefined.UNDEFINED , the previous embed if present is not changed. If this is  builtins.None , then the embed is removed if present. Otherwise, the new embed value that was provided will be used as the replacement. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] Sanitation for  @everyone mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , then  @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool Sanitation for user mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid user mentions will behave as mentions. If  builtins.False , all valid user mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake user IDs, or  hikari.users.PartialUser -derived objects. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool Sanitation for role mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid role mentions will behave as mentions. If  builtins.False , all valid role mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake role IDs, or  hikari.guilds.PartialRole -derived objects. flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag] Optional flags to set on the message. If  hikari.undefined.UNDEFINED , then nothing is changed. Note that some flags may not be able to be set. Currently the only flags that can be set are  NONE and  SUPPRESS_EMBEDS . If you have  MANAGE_MESSAGES permissions, you can use this call to suppress embeds on another user's message.  ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however.  ! note There is currently no documented way to clear attachments or edit attachments from a previously sent message on Discord's API. To do this,  delete the message and re-send it.  ! warning If the message was not sent by your user, the only parameter you may provide to this call is the  flags parameter. Anything else will result in a  hikari.errors.ForbiddenError being raised. Returns    - hikari.messages.Message The edited message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the permissions to manage messages. hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.messages.Message.reply",
"url":20,
"doc":"Create a message in the given channel. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be TTS (Text To Speech). nonce : hikari.undefined.UndefinedOr[builtins.str] If provided, a nonce that can be used for optimistic message sending. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you lack permissions to send messages in the given channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request. builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.messages.Message.delete",
"url":20,
"doc":"Delete this message. Raises    hikari.errors.NotFoundError If the channel this message was created in is not found, or if the message has already been deleted. hikari.errors.ForbiddenError If you lack the permissions to delete the message.",
"func":1
},
{
"ref":"hikari.messages.Message.add_reaction",
"url":20,
"doc":"Add a reaction to this message. Parameters      emoji : hikari.emojis.Emojiish The emoji to add. This may be a unicode emoji string, the  name:id of a custom emoji, or a subclass of  hikari.emojis.Emoji . Note that if the emoji is an  hikari.emojis.CustomEmoji and is not from a guild the bot user is in, then this will fail. Examples        Using a unicode emoji. await message.add_reaction(\"\ud83d\udc4c\")  Using a unicode emoji name. await message.add_reaction(\"\\N{OK HAND SIGN}\")  Using the  name:id format. await message.add_reaction(\"rooAYAYA:705837374319493284\")  Using a raw custom emoji mention (unanimated and animated) await message.add_reaction(\" \") await message.add_reaction(\" \")  Using an Emoji-derived object. await message.add_reaction(some_emoji_object)   Raises    hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. hikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the  ADD_REACTIONS permission. If you lack  READ_MESSAGE_HISTORY , this may also raise this error. hikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found. This will also occur if you try to add an emoji from a guild you are not part of if no one else has previously reacted with the same emoji.",
"func":1
},
{
"ref":"hikari.messages.Message.remove_reaction",
"url":20,
"doc":"Remove a reaction from this message. Parameters      emoji : hikari.emojis.Emojiish The emoji to remove. Other Parameters         user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser The user of the reaction to remove. If unspecified, then the bot's reaction is removed instead. Examples      Using a unicode emoji and removing the bot's reaction from this  reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\")  Using a unicode emoji and removing a specific user from this  reaction. await message.remove_reaction(\"\\N{OK HAND SIGN}\", some_user)  Using a raw custom emoji mention (unanimated and animated) await message.remove_reaction(\" \", some_user) await message.remove_reaction(\" \", some_user)  Using an Emoji object and removing a specific user from this  reaction. await message.remove_reaction(some_emoji_object, some_user) Raises    hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. hikari.errors.ForbiddenError If this is the first reaction using this specific emoji on this message and you lack the  ADD_REACTIONS permission. If you lack  READ_MESSAGE_HISTORY , this may also raise this error. If you remove the reaction of another user without  MANAGE_MESSAGES , this will be raised. hikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found.",
"func":1
},
{
"ref":"hikari.messages.Message.remove_all_reactions",
"url":20,
"doc":"Remove all users' reactions for a specific emoji from the message. Other Parameters         emoji : hikari.undefined.UndefinedOr[hikari.emojis.Emojiish] The emoji to remove all reactions for. If not specified, then all emojis are removed. Example      Using a unicode emoji and removing all \ud83d\udc4c reacts from the message.  reaction. await message.remove_all_reactions(\"\\N{OK HAND SIGN}\")  Using a raw custom emoji mention (unanimated and animated) await message.remove_all_reactions(\" \") await message.remove_all_reactions(\" \")  Removing all reactions entirely. await message.remove_all_reactions() Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission, or the permission to view the channel hikari.errors.NotFoundError If the channel or message is not found, or if the emoji is not found. hikari.errors.BadRequestError If the emoji is invalid, unknown, or formatted incorrectly. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer.",
"func":1
},
{
"ref":"hikari.messages.Message.app",
"url":20,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.messages.Message.channel_id",
"url":20,
"doc":"The ID of the channel that the message was sent in."
},
{
"ref":"hikari.messages.Message.id",
"url":20,
"doc":"The ID of this entity."
},
{
"ref":"hikari.messages.Message.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.cli",
"url":33,
"doc":"Provides the  python -m hikari and  hikari commands to the shell."
},
{
"ref":"hikari.cli.main",
"url":33,
"doc":"Print package info and exit.",
"func":1
},
{
"ref":"hikari.internal",
"url":34,
"doc":"Package containing internal utilities used within this API."
},
{
"ref":"hikari.internal.cache",
"url":35,
"doc":"Various utilities that may be used in a cache-impl."
},
{
"ref":"hikari.internal.cache.StatefulCacheMappingView",
"url":35,
"doc":"A cache mapping view implementation used for representing cached data. Parameters      items : typing.Mapping[KeyT, typing.Union[ValueT, DataT, GenericRefWrapper[ValueT ] A mapping of keys to the values in their raw forms, wrapped by a ref wrapper or in a data form. builder : typing.Optional[typing.Callable DataT], ValueT The callable used to build entities before they're returned by the mapping. This is used to cover the case when items stores  DataT objects. unpack : bool Whether to unpack items from their ref wrappers or not before returning them. This accounts for when  items is  GenericRefWrapper[ValueT] . predicate : typing.Optional[typing.Callable typing.Any], bool A callable to use to determine whether entries should be returned or hidden, this should take in whatever raw type was passed for the value in  items . This may be  builtins.None if all entries should be exposed."
},
{
"ref":"hikari.internal.cache.StatefulCacheMappingView.get_item_at",
"url":35,
"doc":"Get an entry in the view at position  index .",
"func":1
},
{
"ref":"hikari.internal.cache.StatefulCacheMappingView.iterator",
"url":35,
"doc":"Get a lazy iterator of the entities in the view.",
"func":1
},
{
"ref":"hikari.internal.cache.EmptyCacheView",
"url":35,
"doc":"An empty cache view implementation."
},
{
"ref":"hikari.internal.cache.EmptyCacheView.get_item_at",
"url":35,
"doc":"Get an entry in the view at position  index .",
"func":1
},
{
"ref":"hikari.internal.cache.EmptyCacheView.iterator",
"url":35,
"doc":"Get a lazy iterator of the entities in the view.",
"func":1
},
{
"ref":"hikari.internal.cache.GuildRecord",
"url":35,
"doc":"An object used for storing guild specific cached information in-memory. This includes references to the cached entities that \"belong\" to the guild by ID if it's globally unique or by object if it's only unique within the guild. Method generated by attrs for class GuildRecord."
},
{
"ref":"hikari.internal.cache.GuildRecord.channels",
"url":35,
"doc":"A set of the IDs of the guild channels cached for this guild. This will be  builtins.None if no channels are cached for this guild else  typing.MutableSet[hikari.snowflakes.Snowflake] of channel IDs."
},
{
"ref":"hikari.internal.cache.GuildRecord.emojis",
"url":35,
"doc":"A set of the IDs of the emojis cached for this guild. This will be  builtins.None if no emojis are cached for this guild else  typing.MutableSet[hikari.snowflakes.Snowflake] of emoji IDs."
},
{
"ref":"hikari.internal.cache.GuildRecord.guild",
"url":35,
"doc":"A cached guild object. This will be  hikari.guilds.GatewayGuild or  builtins.None if not cached."
},
{
"ref":"hikari.internal.cache.GuildRecord.invites",
"url":35,
"doc":"A set of the  builtins.str codes of the invites cached for this guild. This will be  builtins.None if no invites are cached for this guild else  typing.MutableSequence[str] of invite codes."
},
{
"ref":"hikari.internal.cache.GuildRecord.is_available",
"url":35,
"doc":"Whether the chached guild is available or not. This will be  builtins.None when no  GuildRecord.guild is also  builtins.None else  builtins.bool ."
},
{
"ref":"hikari.internal.cache.GuildRecord.members",
"url":35,
"doc":"A mapping of user IDs to the objects of members cached for this guild. This will be  builtins.None if no members are cached for this guild else  hikari.internal.collections.ExtendedMutableMapping[hikari.snowflakes.Snowflake, MemberData] ."
},
{
"ref":"hikari.internal.cache.GuildRecord.presences",
"url":35,
"doc":"A mapping of user IDs to objects of the presences cached for this guild. This will be  builtins.None if no presences are cached for this guild else  hikari.internal.collections.ExtendedMutableMapping[hikari.snowflakes.Snowflake, MemberPresenceData] ."
},
{
"ref":"hikari.internal.cache.GuildRecord.roles",
"url":35,
"doc":"A set of the IDs of the roles cached for this guild. This will be  builtins.None if no roles are cached for this guild else  typing.MutableSet[hikari.snowflakes.Snowflake] of role IDs."
},
{
"ref":"hikari.internal.cache.GuildRecord.voice_states",
"url":35,
"doc":"A mapping of user IDs to objects of the voice states cached for this guild. This will be  builtins.None if no voice states are cached for this guild else  hikari.internal.collections.ExtendedMutableMapping[hikari.snowflakes.Snowflake, VoiceStateData] ."
},
{
"ref":"hikari.internal.cache.BaseData",
"url":35,
"doc":"A data class used for in-memory storage of entities in a more primitive form.  ! note This base implementation assumes that all the fields it'll handle will be immutable and to handle mutable fields you'll have to override build_entity and build_from_entity to explicitly copy them. Method generated by attrs for class BaseData."
},
{
"ref":"hikari.internal.cache.BaseData.build_entity",
"url":35,
"doc":"Build an entity object from this data object. Parameters      target The class of the entity object to build. kwargs Extra fields to pass on to the entity's initialiser. These will take priority over fields on the builder. Returns    - The initialised entity object.",
"func":1
},
{
"ref":"hikari.internal.cache.BaseData.build_from_entity",
"url":35,
"doc":"Build a data object from an initialised entity. Parameters      entity The entity object to build a data class from. Returns    - The built data class.",
"func":1
},
{
"ref":"hikari.internal.cache.BaseData.replace",
"url":35,
"doc":"",
"func":1
},
{
"ref":"hikari.internal.cache.InviteData",
"url":35,
"doc":"A data model for storing invite data in an in-memory cache. Method generated by attrs for class InviteData."
},
{
"ref":"hikari.internal.cache.InviteData.build_entity",
"url":35,
"doc":"Build an entity object from this data object. Parameters      target The class of the entity object to build. kwargs Extra fields to pass on to the entity's initialiser. These will take priority over fields on the builder. Returns    - The initialised entity object.",
"func":1
},
{
"ref":"hikari.internal.cache.InviteData.build_from_entity",
"url":35,
"doc":"Build a data object from an initialised entity. Parameters      entity The entity object to build a data class from. Returns    - The built data class.",
"func":1
},
{
"ref":"hikari.internal.cache.InviteData.channel_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.code",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.created_at",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.guild_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.inviter_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.is_temporary",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.max_age",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.max_uses",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.target_user_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.target_user_type",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.InviteData.uses",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData",
"url":35,
"doc":"A data model for storing member data in an in-memory cache. Method generated by attrs for class MemberData."
},
{
"ref":"hikari.internal.cache.MemberData.build_from_entity",
"url":35,
"doc":"Build a data object from an initialised entity. Parameters      entity The entity object to build a data class from. Returns    - The built data class.",
"func":1
},
{
"ref":"hikari.internal.cache.MemberData.build_entity",
"url":35,
"doc":"Build an entity object from this data object. Parameters      target The class of the entity object to build. kwargs Extra fields to pass on to the entity's initialiser. These will take priority over fields on the builder. Returns    - The initialised entity object.",
"func":1
},
{
"ref":"hikari.internal.cache.MemberData.guild_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData.has_been_deleted",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData.id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData.is_deaf",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData.is_mute",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData.joined_at",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData.nickname",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData.premium_since",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData.ref_count",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberData.role_ids",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData",
"url":35,
"doc":"A data model for storing known custom emoji data in an in-memory cache. Method generated by attrs for class KnownCustomEmojiData."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.build_from_entity",
"url":35,
"doc":"Build a data object from an initialised entity. Parameters      entity The entity object to build a data class from. Returns    - The built data class.",
"func":1
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.build_entity",
"url":35,
"doc":"Build an entity object from this data object. Parameters      target The class of the entity object to build. kwargs Extra fields to pass on to the entity's initialiser. These will take priority over fields on the builder. Returns    - The initialised entity object.",
"func":1
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.guild_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.has_been_deleted",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.is_animated",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.is_available",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.is_colons_required",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.is_managed",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.name",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.ref_count",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.role_ids",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.KnownCustomEmojiData.user_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData",
"url":35,
"doc":"A data model for storing rich activity data in an in-memory cache. Method generated by attrs for class RichActivityData."
},
{
"ref":"hikari.internal.cache.RichActivityData.build_from_entity",
"url":35,
"doc":"Build a data object from an initialised entity. Parameters      entity The entity object to build a data class from. Returns    - The built data class.",
"func":1
},
{
"ref":"hikari.internal.cache.RichActivityData.build_entity",
"url":35,
"doc":"Build an entity object from this data object. Parameters      target The class of the entity object to build. kwargs Extra fields to pass on to the entity's initialiser. These will take priority over fields on the builder. Returns    - The initialised entity object.",
"func":1
},
{
"ref":"hikari.internal.cache.RichActivityData.application_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.assets",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.created_at",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.details",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.emoji_id_or_name",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.flags",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.is_instance",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.name",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.party",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.secrets",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.state",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.timestamps",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.type",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.RichActivityData.url",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberPresenceData",
"url":35,
"doc":"A data model for storing presence data in an in-memory cache. Method generated by attrs for class MemberPresenceData."
},
{
"ref":"hikari.internal.cache.MemberPresenceData.build_from_entity",
"url":35,
"doc":"Build a data object from an initialised entity. Parameters      entity The entity object to build a data class from. Returns    - The built data class.",
"func":1
},
{
"ref":"hikari.internal.cache.MemberPresenceData.build_entity",
"url":35,
"doc":"Build an entity object from this data object. Parameters      target The class of the entity object to build. kwargs Extra fields to pass on to the entity's initialiser. These will take priority over fields on the builder. Returns    - The initialised entity object.",
"func":1
},
{
"ref":"hikari.internal.cache.MemberPresenceData.activities",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberPresenceData.client_status",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberPresenceData.guild_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberPresenceData.user_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.MemberPresenceData.visible_status",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData",
"url":35,
"doc":"A data model for storing voice state data in an in-memory cache. Method generated by attrs for class VoiceStateData."
},
{
"ref":"hikari.internal.cache.VoiceStateData.build_entity",
"url":35,
"doc":"Build an entity object from this data object. Parameters      target The class of the entity object to build. kwargs Extra fields to pass on to the entity's initialiser. These will take priority over fields on the builder. Returns    - The initialised entity object.",
"func":1
},
{
"ref":"hikari.internal.cache.VoiceStateData.build_from_entity",
"url":35,
"doc":"Build a data object from an initialised entity. Parameters      entity The entity object to build a data class from. Returns    - The built data class.",
"func":1
},
{
"ref":"hikari.internal.cache.VoiceStateData.channel_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.guild_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.is_guild_deafened",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.is_guild_muted",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.is_self_deafened",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.is_self_muted",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.is_streaming",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.is_suppressed",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.is_video_enabled",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.session_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.VoiceStateData.user_id",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.GenericRefWrapper",
"url":35,
"doc":"An object used for wrapping entities in an in-memory cache. This is intended to enable reference counting for entities that are only kept alive by reference (e.g. the unknown emoji objects attached to presence activities and user objects) without the use of a \"Data\" object which lowers the time spent building these entities for the objects that reference them. Method generated by attrs for class GenericRefWrapper."
},
{
"ref":"hikari.internal.cache.GenericRefWrapper.object",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.GenericRefWrapper.ref_count",
"url":35,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.cache.copy_guild_channel",
"url":35,
"doc":"Logic for handling the copying of guild channel objects. This exists account for the permission overwrite objects attached to guild channel objects which need to be copied themselves.",
"func":1
},
{
"ref":"hikari.internal.cache.GuildChannelCacheMappingView",
"url":35,
"doc":"A special case of the mapping view implements copy logic that targets guild channels specifically."
},
{
"ref":"hikari.internal.cache.GuildChannelCacheMappingView.get_item_at",
"url":35,
"doc":"Get an entry in the view at position  index .",
"func":1
},
{
"ref":"hikari.internal.cache.GuildChannelCacheMappingView.iterator",
"url":35,
"doc":"Get a lazy iterator of the entities in the view.",
"func":1
},
{
"ref":"hikari.internal.cache.Cache3DMappingView",
"url":35,
"doc":"A special case of the Mapping View which avoids copying the already immutable views contained within it."
},
{
"ref":"hikari.internal.cache.Cache3DMappingView.get_item_at",
"url":35,
"doc":"Get an entry in the view at position  index .",
"func":1
},
{
"ref":"hikari.internal.cache.Cache3DMappingView.iterator",
"url":35,
"doc":"Get a lazy iterator of the entities in the view.",
"func":1
},
{
"ref":"hikari.internal.cache.DataT",
"url":35,
"doc":"Type-hint for \"data\" objects used for storing and building entities."
},
{
"ref":"hikari.internal.cache.KeyT",
"url":35,
"doc":"Type-hint for mapping keys."
},
{
"ref":"hikari.internal.cache.ValueT",
"url":35,
"doc":"Type-hint for mapping values."
},
{
"ref":"hikari.internal.spel",
"url":36,
"doc":"HikariSPEL (Hikari SimPle Expression Language). HikariSPEL (Hikari SimPle Expression Language) is a super-simple expression language used in this module for quickly mapping values to other values and producing streams of changes. This somewhat mirrors other programming languages like Java which have a proper Stream API. The concept of HikariSPEL is that you are trying to look at the attribute of something. So, running  \"bar.baz.bork\" against an object  foo would be equivalent to  foo.bar.baz.bork in pure Python. The reason for doing this is Python lambdas are clunky, and using a nested function is nasty boilerplate. For applying  \"bar.baz\" to  foo , we assume  bar is an attribute or property of  foo , and  baz is an attribute or property of  foo.bar . We may instead want to invoke a method that takes no parameters (looking at  str.islower , as an example. To do this, we append  () onto the attribute name. For example, applying  author.username.islower() to a  hikari.messages.Message object. All expressions may start with a  . . You can negate the whole expression by instead starting them with  !. . You may also want to negate a condition. To do this, prepend  ! to the attribute name. For example, to check if a message was not made by a bot, you could run  author.!is_bot on a  Message object. Likewise, to check if the input was not a number, you could run  content.!isdigit() . This expression language is highly experimental and may change without prior notice for the time being while I play with getting something usable and nice to work with."
},
{
"ref":"hikari.internal.spel.AttrGetter",
"url":36,
"doc":"An attribute getter that can resolve nested attributes and methods. This follows the SPEL definition for how to define expressions. Expressions may be preceeded with an optional  . to aid in readability."
},
{
"ref":"hikari.internal.spel.AttrGetter.invert_all",
"url":36,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.spel.AttrGetter.pipeline",
"url":36,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.data_binding",
"url":37,
"doc":"Data binding utilities."
},
{
"ref":"hikari.internal.data_binding.Headers",
"url":37,
"doc":"Type hint for HTTP headers."
},
{
"ref":"hikari.internal.data_binding.Query",
"url":37,
"doc":"Type hint for HTTP query string."
},
{
"ref":"hikari.internal.data_binding.JSONObject",
"url":37,
"doc":"Type hint for a JSON-decoded object representation as a mapping."
},
{
"ref":"hikari.internal.data_binding.JSONArray",
"url":37,
"doc":"Type hint for a JSON-decoded array representation as a sequence."
},
{
"ref":"hikari.internal.data_binding.JSONish",
"url":37,
"doc":"Type hint for any valid JSON-decoded type."
},
{
"ref":"hikari.internal.data_binding.FormData",
"url":37,
"doc":"Helper class for multipart/form-data and application/x-www-form-urlencoded body generation."
},
{
"ref":"hikari.internal.data_binding.FormData.is_multipart",
"url":37,
"doc":""
},
{
"ref":"hikari.internal.data_binding.FormData.add_field",
"url":37,
"doc":"",
"func":1
},
{
"ref":"hikari.internal.data_binding.FormData.add_fields",
"url":37,
"doc":"",
"func":1
},
{
"ref":"hikari.internal.data_binding.FormData",
"url":37,
"doc":"Helper class for multipart/form-data and application/x-www-form-urlencoded body generation."
},
{
"ref":"hikari.internal.data_binding.FormData.is_multipart",
"url":37,
"doc":""
},
{
"ref":"hikari.internal.data_binding.FormData.add_field",
"url":37,
"doc":"",
"func":1
},
{
"ref":"hikari.internal.data_binding.FormData.add_fields",
"url":37,
"doc":"",
"func":1
},
{
"ref":"hikari.internal.data_binding.ContentDisposition",
"url":37,
"doc":"Method generated by attrs for class ContentDisposition."
},
{
"ref":"hikari.internal.data_binding.ContentDisposition.filename",
"url":37,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.data_binding.ContentDisposition.parameters",
"url":37,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.data_binding.ContentDisposition.type",
"url":37,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.internal.data_binding.dump_json",
"url":37,
"doc":"Serialize  obj to a JSON formatted  str . If  skipkeys is true then  dict keys that are not basic types ( str ,  int ,  float ,  bool ,  None ) will be skipped instead of raising a  TypeError . If  ensure_ascii is false, then the return value can contain non-ASCII characters if they appear in strings contained in  obj . Otherwise, all such characters are escaped in JSON strings. If  check_circular is false, then the circular reference check for container types will be skipped and a circular reference will result in an  OverflowError (or worse). If  allow_nan is false, then it will be a  ValueError to serialize out of range  float values ( nan ,  inf ,  -inf ) in strict compliance of the JSON specification, instead of using the JavaScript equivalents ( NaN ,  Infinity ,  -Infinity ). If  indent is a non-negative integer, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0 will only insert newlines.  None is the most compact representation. If specified,  separators should be an  (item_separator, key_separator) tuple. The default is  (', ', ': ') if  indent is  None and  (',', ': ') otherwise. To get the most compact JSON representation, you should specify  (',', ':') to eliminate whitespace.  default(obj) is a function that should return a serializable version of obj or raise TypeError. The default simply raises TypeError. If  sort_keys is true (default:  False ), then the output of dictionaries will be sorted by key. To use a custom  JSONEncoder subclass (e.g. one that overrides the  .default() method to serialize additional types), specify it with the  cls kwarg; otherwise  JSONEncoder is used.",
"func":1
},
{
"ref":"hikari.internal.data_binding.load_json",
"url":37,
"doc":"Deserialize  s (a  str ,  bytes or  bytearray instance containing a JSON document) to a Python object.  object_hook is an optional function that will be called with the result of any object literal decode (a  dict ). The return value of  object_hook will be used instead of the  dict . This feature can be used to implement custom decoders (e.g. JSON-RPC class hinting).  object_pairs_hook is an optional function that will be called with the result of any object literal decoded with an ordered list of pairs. The return value of  object_pairs_hook will be used instead of the  dict . This feature can be used to implement custom decoders. If  object_hook is also defined, the  object_pairs_hook takes priority.  parse_float , if specified, will be called with the string of every JSON float to be decoded. By default this is equivalent to float(num_str). This can be used to use another datatype or parser for JSON floats (e.g. decimal.Decimal).  parse_int , if specified, will be called with the string of every JSON int to be decoded. By default this is equivalent to int(num_str). This can be used to use another datatype or parser for JSON integers (e.g. float).  parse_constant , if specified, will be called with one of the following strings: -Infinity, Infinity, NaN. This can be used to raise an exception if invalid JSON numbers are encountered. To use a custom  JSONDecoder subclass, specify it with the  cls kwarg; otherwise  JSONDecoder is used. The  encoding argument is ignored and deprecated since Python 3.1.",
"func":1
},
{
"ref":"hikari.internal.data_binding.JSONObjectBuilder",
"url":37,
"doc":"Helper class used to quickly build JSON objects from various values. If provided with any values that are  hikari.undefined.UndefinedType , then these values will be ignored. This speeds up generation of JSON payloads for low level HTTP and websocket API interaction.  ! warn Because this subclasses  builtins.dict , you should not use the index operator to set items on this object. Doing so will skip any form of validation on the type. Use the  put methods instead."
},
{
"ref":"hikari.internal.data_binding.JSONObjectBuilder.put",
"url":37,
"doc":"Put a JSON value. If the value is  hikari.undefined.UNDEFINED it will not be stored. Parameters      key : builtins.str The key to give the element. value : hikari.undefined.UndefinedOr[typing.Any] The JSON type to put. This may be a non-JSON type if a conversion is also specified. This may alternatively be undefined. In the latter case, nothing is performed. Other Parameters         conversion : typing.Optional[typing.Callable typing.Any], JSONish The optional conversion to apply.",
"func":1
},
{
"ref":"hikari.internal.data_binding.JSONObjectBuilder.put_array",
"url":37,
"doc":"Put a JSON array. If the value is  hikari.undefined.UNDEFINED it will not be stored. If provided, a conversion will be applied to each item. Parameters      key : builtins.str The key to give the element. values : hikari.undefined.UndefinedOr[typing.Iterable[T The JSON types to put. This may be an iterable of non-JSON types if a conversion is also specified. This may alternatively be undefined. In the latter case, nothing is performed. Other Parameters         conversion : typing.Optional[typing.Callable typing.Any], JSONType The optional conversion to apply.",
"func":1
},
{
"ref":"hikari.internal.data_binding.JSONObjectBuilder.put_snowflake",
"url":37,
"doc":"Put a key with a snowflake value into the builder. If the value is  hikari.undefined.UNDEFINED it will not be stored. Parameters      key : builtins.str The key to give the element. value : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique The JSON type to put. This may alternatively be undefined, in this case, nothing is performed. This may also be  builtins.None , in this case the value isn't cast.",
"func":1
},
{
"ref":"hikari.internal.data_binding.JSONObjectBuilder.put_snowflake_array",
"url":37,
"doc":"Put an array of snowflakes with the given key into this builder. If the value is  hikari.undefined.UNDEFINED it will not be stored. Each snowflake should be castable to an  builtins.int . Parameters      key : builtins.str The key to give the element. values : hikari.undefined.UndefinedOr[typing.Iterable[hikari.snowflakes.SnowflakeishOr[hikari.snowflakes.Unique ] The JSON snowflakes to put. This may alternatively be undefined. In the latter case, nothing is performed.",
"func":1
},
{
"ref":"hikari.internal.data_binding.cast_json_array",
"url":37,
"doc":"Cast a JSON array to a given generic collection type. This will perform casts on each internal item individually. Note that >>> cast_json_array(raw_list, foo, bar=\"OK\")  .is equivalent to doing  >>> [foo(item, bar=\"OK\") for item in raw_list] Parameters      array : JSONArray The raw JSON-decoded array. cast : typing.Callable JSONish], T] The cast to apply to each item in the array. This should consume any valid JSON-decoded type and return the type corresponding to the generic type of the provided collection.  kwargs : typing.Any Extra keyword arguments to be passed during every call to cast. Returns    - typing.List[T] The generated list. Example    -   >>> arr = [123, 456, 789, 123] >>> cast_json_array(arr, str) [\"123\", \"456\", \"789\", \"123\"]  ",
"func":1
},
{
"ref":"hikari.internal.net",
"url":38,
"doc":"General bits and pieces that are reused between components."
},
{
"ref":"hikari.internal.net.generate_error_response",
"url":38,
"doc":"Given an erroneous HTTP response, return a corresponding exception.",
"func":1
},
{
"ref":"hikari.internal.net.create_client_session",
"url":38,
"doc":"Generate a client session using the given settings.  ! warning You must invoke this from within a running event loop.  ! note If you pass an explicit connector, then the connection that is created will not own the connector. You will be expected to manually close it __after__ the returned client session is closed to prevent leaking resources. Parameters      connector : aiohttp.BaseConnector The connector to use. connector_owner : builtins.bool If  builtins.True , then the client session will close the connector on shutdown. Otherwise, you must do it manually. http_settings : hikari.config.HTTPSettings HTTP settings to use. raise_for_status : builtins.bool  builtins.True to default to throwing exceptions if a request fails, or  builtins.False to default to not. trust_env : builtins.bool  builtins.True to trust anything in environment variables and the  netrc file,  builtins.False to ignore it. ws_response_cls : typing.Type[aiohttp.ClientWebSocketResponse]  builtins.True to default to throwing exceptions if a request fails, or  builtins.False to default to not. Returns    - aiohttp.ClientSession The client session to use.",
"func":1
},
{
"ref":"hikari.internal.routes",
"url":39,
"doc":"Provides the valid routes that can be used on the API and the CDN."
},
{
"ref":"hikari.internal.routes.CompiledRoute",
"url":39,
"doc":"A compiled representation of a route to a specific resource. This is a similar representation to what  Route provides, except  Route is treated as a template, this is treated as an instance. Method generated by attrs for class CompiledRoute."
},
{
"ref":"hikari.internal.routes.CompiledRoute.method",
"url":39,
"doc":"Return the HTTP method of this compiled route."
},
{
"ref":"hikari.internal.routes.CompiledRoute.create_url",
"url":39,
"doc":"Create the full URL with which you can make a request. Parameters      base_url : builtins.str The base of the URL to prepend to the compiled path. Returns    - builtins.str The full URL for the route.",
"func":1
},
{
"ref":"hikari.internal.routes.CompiledRoute.create_real_bucket_hash",
"url":39,
"doc":"Create a full bucket hash from a given initial hash. The result of this hash will be decided by the value of the major parameters passed to the route during the compilation phase. Parameters      initial_bucket_hash : builtins.str The initial bucket hash provided by Discord in the HTTP headers for a given response. Returns    - builtins.str The input hash amalgamated with a hash code produced by the major parameters in this compiled route instance.",
"func":1
},
{
"ref":"hikari.internal.routes.CompiledRoute.compiled_path",
"url":39,
"doc":"The compiled route path to use."
},
{
"ref":"hikari.internal.routes.CompiledRoute.major_param_hash",
"url":39,
"doc":"The major parameters in a bucket hash-compatible representation."
},
{
"ref":"hikari.internal.routes.CompiledRoute.route",
"url":39,
"doc":"The route this compiled route was created from."
},
{
"ref":"hikari.internal.routes.Route",
"url":39,
"doc":"A template used to create compiled routes for specific parameters. These compiled routes are used to identify rate limit buckets. Compiled routes may have a single major parameter. Parameters      method : builtins.str The HTTP method path_template : builtins.str The template string for the path to use."
},
{
"ref":"hikari.internal.routes.Route.compile",
"url":39,
"doc":"Generate a formatted  CompiledRoute for this route. This takes into account any URL parameters that have been passed. Parameters       kwargs : typing.Any Any parameters to interpolate into the route path. Returns    - CompiledRoute The compiled route.",
"func":1
},
{
"ref":"hikari.internal.routes.Route.major_param",
"url":39,
"doc":"The optional major parameter name."
},
{
"ref":"hikari.internal.routes.Route.method",
"url":39,
"doc":"The HTTP method."
},
{
"ref":"hikari.internal.routes.Route.path_template",
"url":39,
"doc":"The template string used for the path."
},
{
"ref":"hikari.internal.routes.CDNRoute",
"url":39,
"doc":"Route implementation for a CDN resource. Method generated by attrs for class CDNRoute."
},
{
"ref":"hikari.internal.routes.CDNRoute.compile",
"url":39,
"doc":"Generate a full CDN url from this endpoint. Parameters      base_url : builtins.str The base URL for the CDN. The generated route is concatenated onto this. file_format : builtins.str The file format to use for the asset. size : typing.Optional[builtins.int] The custom size query parameter to set. If  builtins.None , it is not passed.  kwargs : typing.Any Parameters to interpolate into the path template. Returns    - builtins.str The full asset URL. Raises    builtins.TypeError If a GIF is requested, but the asset is not animated; if an invalid file format for the endpoint is passed; or if a  size is passed but the route is not  sizable . builtins.ValueError If  size is specified, but is not an integer power of  2 between  16 and  4096 inclusive or is negative.",
"func":1
},
{
"ref":"hikari.internal.routes.CDNRoute.compile_to_file",
"url":39,
"doc":"Perform the same as  compile , but return the URL as a  files.URL .",
"func":1
},
{
"ref":"hikari.internal.routes.CDNRoute.path_template",
"url":39,
"doc":"Template string for this endpoint."
},
{
"ref":"hikari.internal.routes.CDNRoute.sizable",
"url":39,
"doc":" builtins.True if a  size param can be specified, or  builtins.False otherwise."
},
{
"ref":"hikari.internal.routes.CDNRoute.valid_formats",
"url":39,
"doc":"Valid file formats for this endpoint."
},
{
"ref":"hikari.internal.time",
"url":40,
"doc":"Utility methods used for parsing timestamps and datetimes from Discord."
},
{
"ref":"hikari.internal.time.DISCORD_EPOCH",
"url":40,
"doc":"Discord epoch used within snowflake identifiers. This is defined as the number of seconds between  1/1/1970 00:00:00 UTC and  1/1/2015 00:00:00 UTC . References       [Discord API documentation - Snowflakes](https: discord.com/developers/docs/reference snowflakes)"
},
{
"ref":"hikari.internal.time.rfc7231_datetime_string_to_datetime",
"url":40,
"doc":"Return the HTTP date as a datetime object. Parameters      date_str : builtins.str The RFC-2822 (section 3.3) compliant date string to parse. Returns    - datetime.datetime The HTTP date as a datetime object. References       [RFC-2822](https: www.ietf.org/rfc/rfc2822.txt)  [Mozilla documentation for  Date HTTP header](https: developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date)",
"func":1
},
{
"ref":"hikari.internal.time.datetime_to_discord_epoch",
"url":40,
"doc":"Parse a  datetime.datetime object into an  builtins.int  DISCORD_EPOCH offset. Parameters      timestamp : datetime.datetime Number of seconds since  1/1/1970 00:00:00 UTC . Returns    - builtins.int Number of milliseconds since  1/1/2015 00:00:00 UTC .",
"func":1
},
{
"ref":"hikari.internal.time.discord_epoch_to_datetime",
"url":40,
"doc":"Parse a Discord epoch into a  datetime.datetime object. Parameters      epoch : builtins.int Number of milliseconds since  1/1/2015 00:00:00 UTC . Returns    - datetime.datetime Number of seconds since  1/1/1970 00:00:00 UTC .",
"func":1
},
{
"ref":"hikari.internal.time.unix_epoch_to_datetime",
"url":40,
"doc":"Parse a UNIX epoch to a  datetime.datetime object.  ! note If an epoch that's outside the range of what this system can handle, this will return  datetime.datetime.max if the timestamp is positive, or  datetime.datetime.min otherwise. Parameters      epoch : typing.Union[builtins.int, builtins.float] Number of seconds/milliseconds since  1/1/1970 00:00:00 UTC . is_millis : builtins.bool  builtins.True by default, indicates the input timestamp is measured in milliseconds rather than seconds Returns    - datetime.datetime Number of seconds since  1/1/1970 00:00:00 UTC .",
"func":1
},
{
"ref":"hikari.internal.time.Intervalish",
"url":40,
"doc":"Type hint representing a naive time period or time span. This is a type that is like an interval of some sort. This is an alias for  typing.Union[int, float, datetime.datetime] , where  builtins.int and  builtins.float types are interpreted as a number of seconds."
},
{
"ref":"hikari.internal.time.timespan_to_int",
"url":40,
"doc":"Cast the given timespan in seconds to an integer value. Parameters      value : Intervalish The number of seconds. Returns    - builtins.int The integer number of seconds. Fractions are discarded. Negative values are removed.",
"func":1
},
{
"ref":"hikari.internal.time.local_datetime",
"url":40,
"doc":"Return the current date/time for the system's time zone.",
"func":1
},
{
"ref":"hikari.internal.time.utc_datetime",
"url":40,
"doc":"Return the current date/time for UTC (GMT+0).",
"func":1
},
{
"ref":"hikari.internal.time.monotonic",
"url":40,
"doc":"Performance counter for benchmarking.",
"func":1
},
{
"ref":"hikari.internal.time.monotonic_ns",
"url":40,
"doc":"Performance counter for benchmarking as nanoseconds.",
"func":1
},
{
"ref":"hikari.internal.time.uuid",
"url":40,
"doc":"Generate a unique UUID (1ns precision).",
"func":1
},
{
"ref":"hikari.internal.aio",
"url":41,
"doc":"Asyncio extensions and utilities."
},
{
"ref":"hikari.internal.aio.completed_future",
"url":41,
"doc":"Create a future on the current running loop that is completed, then return it. Parameters      result : T The value to set for the result of the future.  T is a generic type placeholder for the type that the future will have set as the result.  T may be  builtins.None , in which case, this will return  asyncio.Future[builtins.None] . Returns    - asyncio.Future[T] The completed future.",
"func":1
},
{
"ref":"hikari.internal.aio.is_async_iterator",
"url":41,
"doc":"Determine if the object is an async iterator or not.",
"func":1
},
{
"ref":"hikari.internal.aio.is_async_iterable",
"url":41,
"doc":"Determine if the object is an async iterable or not.",
"func":1
},
{
"ref":"hikari.internal.aio.first_completed",
"url":41,
"doc":"Wait for the first awaitable to complete. The awaitables that don't complete first will be cancelled. Completion is defined as having a result or an exception set. Thus, cancelling any of the awaitables will also result in the others being cancelled. If the first awaitable raises an exception, then that exception will be propagated. Parameters       aws : typing.Awaitable[typing.Any] Awaitables to wait for. timeout : typing.Optional[float] Optional timeout to wait for, or  builtins.None to not use one. If the timeout is reached, all awaitables are cancelled immediately.  ! note If more than one awaitable is completed before entering this call, then the first future is always returned.",
"func":1
},
{
"ref":"hikari.internal.aio.all_of",
"url":41,
"doc":"Await the completion of all the given awaitable items. If any fail or time out, then they are all cancelled. Parameters       aws : typing.Awaitable[T_co] Awaitables to wait for. timeout : typing.Optional[float] Optional timeout to wait for, or  builtins.None to not use one. If the timeout is reached, all awaitables are cancelled immediately. Returns    - typing.Sequence[T_co] The results of each awaitable in the order they were provided invoked in.",
"func":1
},
{
"ref":"hikari.internal.ux",
"url":42,
"doc":"User-experience extensions and utilities."
},
{
"ref":"hikari.internal.ux.init_logging",
"url":42,
"doc":"Attempt to initialize logging for the user. If any handlers already exist, this is ignored entirely. This ensures the user can use any existing logging configuration without us interfering. You can manually disable this by passing  None as the  flavor parameter. Parameters      flavor : typing.Optional[builtins.None, builtins.str, typing.Dict[builtins.str, typing.Any The hint for configuring logging. This can be  builtins.None to not enable logging automatically. If you pass a  builtins.str or a  builtins.int , it is interpreted as the global logging level to use, and should match one of  \"DEBUG\" ,  \"INFO\" ,  \"WARNING\" ,  \"ERROR\" or  \"CRITICAL\" , if  builtins.str . The configuration will be set up to use a  colorlog coloured logger, and to use a sane logging format strategy. The output will be written to  sys.stderr using this configuration. If you pass a  builtins.dict , it is treated as the mapping to pass to  logging.config.dictConfig . allow_color : builtins.bool If  builtins.False , no colour is allowed. If  builtins.True , the output device must be supported for this to return  builtins.True . force_color : builtins.bool If  builtins.True , return  builtins.True always, otherwise only return  builtins.True if the device supports colour output and the  allow_color flag is not  builtins.False .",
"func":1
},
{
"ref":"hikari.internal.ux.print_banner",
"url":42,
"doc":"Print a banner of choice to  sys.stdout . Inspired by Spring Boot, we display an ASCII logo on startup. This is styled to grab the user's attention, and contains info such as the library version, the Python interpreter, the OS, and links to our Discord server and documentation. Users can override this by placing a  banner.txt' in some package and referencing it in this call. Parameters      package : typing.Optional[builtins.str] The package to find the  banner.txt in, or  builtins.None if no banner should be shown.  ! note The  banner.txt must be in the root folder of the package. allow_color : builtins.bool If  builtins.False , no colour is allowed. If  builtins.True , the output device must be supported for this to return  builtins.True . force_color : builtins.bool If  builtins.True , return  builtins.True always, otherwise only return  builtins.True if the device supports colour output and the  allow_color flag is not  builtins.False .",
"func":1
},
{
"ref":"hikari.internal.ux.supports_color",
"url":42,
"doc":"Return  builtins.True if the terminal device supports color output. Parameters      allow_color : builtins.bool If  builtins.False , no color is allowed. If  builtins.True , the output device must be supported for this to return  builtins.True . force_color : builtins.bool If  builtins.True , return  builtins.True always, otherwise only return  builtins.True if the device supports color output and the  allow_color flag is not  builtins.False . Returns    - builtins.bool  builtins.True if color is allowed on the output terminal, or  builtins.False otherwise.",
"func":1
},
{
"ref":"hikari.internal.ux.HikariVersion",
"url":42,
"doc":"Hikari-compatible strict version."
},
{
"ref":"hikari.internal.ux.HikariVersion.version_re",
"url":42,
"doc":""
},
{
"ref":"hikari.internal.ux.HikariVersion.parse",
"url":42,
"doc":"",
"func":1
},
{
"ref":"hikari.internal.ux.check_for_updates",
"url":42,
"doc":"Perform a check for newer versions of the library, logging any found.",
"func":1
},
{
"ref":"hikari.internal.collections",
"url":43,
"doc":"Custom data structures used within Hikari's core implementation."
},
{
"ref":"hikari.internal.collections.MapT",
"url":43,
"doc":"Type-hint A type hint used for mapped collection objects."
},
{
"ref":"hikari.internal.collections.KeyT",
"url":43,
"doc":"Type-hint A type hint used for the type of a mapping's key."
},
{
"ref":"hikari.internal.collections.ValueT",
"url":43,
"doc":"Type-hint A type hint used for the type of a mapping's value."
},
{
"ref":"hikari.internal.collections.SnowflakeSet",
"url":43,
"doc":"Set of  hikari.snowflakes.Snowflake objects. This internally uses a sorted bisect-array of 64 bit integers to represent the information. This reduces the space needed to store these objects significantly down to the size of 8 bytes per item. In contrast, a regular list would take generally 8 bytes per item just to store the memory address, and then a further 28 bytes or more to physically store the integral value if it does not get interned by the Python implementation you are using. A regular set would consume even more space, being a hashtable internally. The detail of this implementation has the side effect that searches will take  \\mathcal{O} \\left( \\log n \\right)  operations in the worst case, and  \\Omega \\left (k \\right)  in the best case. Average case will be  \\mathcal{O} \\left( \\log n \\right)  Insertions and removals will take  \\mathcal{O} \\left( \\log n \\right)  operations in the worst case, due to  bisect using a binary insertion sort algorithm internally. Average case will be  \\mathcal{O} \\left( \\log n \\right)  and best case will be  \\Omega \\left\\( k \\right)   ! warning This is not thread-safe and must not be iterated across whilst being concurrently modified. Other Parameters          ids : builtins.int The IDs to fill this table with."
},
{
"ref":"hikari.internal.collections.SnowflakeSet.add",
"url":43,
"doc":"Add a snowflake to this set.",
"func":1
},
{
"ref":"hikari.internal.collections.SnowflakeSet.add_all",
"url":43,
"doc":"Add a collection of snowflakes to this set.",
"func":1
},
{
"ref":"hikari.internal.collections.SnowflakeSet.clear",
"url":43,
"doc":"Clear all items from this collection.",
"func":1
},
{
"ref":"hikari.internal.collections.SnowflakeSet.discard",
"url":43,
"doc":"Remove a snowflake from this set if it's present.",
"func":1
},
{
"ref":"hikari.internal.collections.ExtendedMutableMapping",
"url":43,
"doc":"The abstract class of mutable mappings used within Hikari. These are mutable mappings that have a couple of extra methods to allow for further optimised copy operations, as well as the ability to freeze the implementation of a mapping to make it read-only."
},
{
"ref":"hikari.internal.collections.ExtendedMutableMapping.copy",
"url":43,
"doc":"Return a copy of this mapped collection. Unlike simply doing  dict(mapping) , this may rely on internal detail around how the data is being stored to allow for a more efficient copy. This may look like calling  dict.copy and wrapping the result in a mapped collection.  ! note Any removal policy on this mapped collection will be copied over. Returns    - MapT[KeyT, ValueT] A copy of this mapped collection.",
"func":1
},
{
"ref":"hikari.internal.collections.ExtendedMutableMapping.freeze",
"url":43,
"doc":"Return a frozen mapping view of the items in this mapped collection. Unlike simply doing  dict(mapping) , this may rely on internal detail around how the data is being stored to allow for a more efficient copy. This may look like calling  dict.copy .  ! note Unlike  ExtendedMutableMapping.copy , this should return a pure mapping with no removal policy at all. Returns    - typing.MutableMapping[KeyT, ValueT] A frozen mapping view of the items in this mapped collection.",
"func":1
},
{
"ref":"hikari.internal.collections.FreezableDict",
"url":43,
"doc":"A mapping that wraps a dict, but can also be frozen."
},
{
"ref":"hikari.internal.collections.FreezableDict.copy",
"url":43,
"doc":"Return a copy of this mapped collection. Unlike simply doing  dict(mapping) , this may rely on internal detail around how the data is being stored to allow for a more efficient copy. This may look like calling  dict.copy and wrapping the result in a mapped collection.  ! note Any removal policy on this mapped collection will be copied over. Returns    - MapT[KeyT, ValueT] A copy of this mapped collection.",
"func":1
},
{
"ref":"hikari.internal.collections.FreezableDict.freeze",
"url":43,
"doc":"Return a frozen mapping view of the items in this mapped collection. Unlike simply doing  dict(mapping) , this may rely on internal detail around how the data is being stored to allow for a more efficient copy. This may look like calling  dict.copy .  ! note Unlike  ExtendedMutableMapping.copy , this should return a pure mapping with no removal policy at all. Returns    - typing.MutableMapping[KeyT, ValueT] A frozen mapping view of the items in this mapped collection.",
"func":1
},
{
"ref":"hikari.internal.collections.TimedCacheMap",
"url":43,
"doc":"A most-recently-inserted limited mutable mapping implementation. This will remove entries on modification as as they pass the expiry limit. Parameters      expiry : datetime.timedelta The timedelta of how long entries should be stored for before removal. source : typing.Optional[typing.Dict[KeyT, typing.Tuple[builtins.float, ValueT A source dictionary of keys to tuples of float timestamps and values to create this from."
},
{
"ref":"hikari.internal.collections.TimedCacheMap.copy",
"url":43,
"doc":"Return a copy of this mapped collection. Unlike simply doing  dict(mapping) , this may rely on internal detail around how the data is being stored to allow for a more efficient copy. This may look like calling  dict.copy and wrapping the result in a mapped collection.  ! note Any removal policy on this mapped collection will be copied over. Returns    - MapT[KeyT, ValueT] A copy of this mapped collection.",
"func":1
},
{
"ref":"hikari.internal.collections.TimedCacheMap.freeze",
"url":43,
"doc":"Return a frozen mapping view of the items in this mapped collection. Unlike simply doing  dict(mapping) , this may rely on internal detail around how the data is being stored to allow for a more efficient copy. This may look like calling  dict.copy .  ! note Unlike  ExtendedMutableMapping.copy , this should return a pure mapping with no removal policy at all. Returns    - typing.MutableMapping[KeyT, ValueT] A frozen mapping view of the items in this mapped collection.",
"func":1
},
{
"ref":"hikari.internal.collections.LimitedCapacityCacheMap",
"url":43,
"doc":"Implementation of a capacity-limited most-recently-inserted mapping. This will start removing the oldest entries after it's maximum capacity is reached as new entries are added. Parameters      limit : int The limit for how many objects should be stored by this mapping before it starts removing the oldest entries. source : typing.Optional[typing.Dict[KeyT, ValueT A source dictionary of keys to values to create this from."
},
{
"ref":"hikari.internal.collections.LimitedCapacityCacheMap.copy",
"url":43,
"doc":"Return a copy of this mapped collection. Unlike simply doing  dict(mapping) , this may rely on internal detail around how the data is being stored to allow for a more efficient copy. This may look like calling  dict.copy and wrapping the result in a mapped collection.  ! note Any removal policy on this mapped collection will be copied over. Returns    - MapT[KeyT, ValueT] A copy of this mapped collection.",
"func":1
},
{
"ref":"hikari.internal.collections.LimitedCapacityCacheMap.freeze",
"url":43,
"doc":"Return a frozen mapping view of the items in this mapped collection. Unlike simply doing  dict(mapping) , this may rely on internal detail around how the data is being stored to allow for a more efficient copy. This may look like calling  dict.copy .  ! note Unlike  ExtendedMutableMapping.copy , this should return a pure mapping with no removal policy at all. Returns    - typing.MutableMapping[KeyT, ValueT] A frozen mapping view of the items in this mapped collection.",
"func":1
},
{
"ref":"hikari.internal.collections.get_index_or_slice",
"url":43,
"doc":"Get a mapping's entry at a given index as if it's a sequence of it's values. Parameters      mapping : typing.Mapping[KeyT, ValueT] The mapping of entries to treat as a sequence. index_or_slice : typing.Sequence[KeyT, ValueT] The index to get an entry to get or slice of multiple entries to get. Returns    - ValueT or typing.Sequence[ValueT] The value found at the given integer index or a sequence of the values found based on the given slice's rules. Raises    TypeError If  index_or_slice isn't a  builtins.slice or  builtins.int . IndexError If  index_or_slice is an int and is outside the range of the mapping's contents.",
"func":1
},
{
"ref":"hikari.internal.collections.copy_mapping",
"url":43,
"doc":"Logic for copying mappings that targets implementation specific copy impls (e.g. dict.copy).  ! warning For general use,  MappedCollection should be preferred over this.",
"func":1
},
{
"ref":"hikari.internal.attr_extensions",
"url":44,
"doc":"Utility for extending and optimising the usage of attr models."
},
{
"ref":"hikari.internal.attr_extensions.with_copy",
"url":44,
"doc":"Add a custom implementation for copying attrs models to a class.  ! note This will only work if the class has an attrs generated init.",
"func":1
},
{
"ref":"hikari.internal.attr_extensions.copy_attrs",
"url":44,
"doc":"Shallow copy an attrs model with  init enabled. Parameters      model : ModelT The attrs model to shallow copy. Returns    - ModelT The new shallow copied attrs model.",
"func":1
},
{
"ref":"hikari.internal.attr_extensions.deep_copy_attrs",
"url":44,
"doc":"Deep copy an attrs model with  init enabled. Parameters      model : ModelT The attrs model to deep copy. memo : typing.Optional[typing.MutableMapping[builtins.int, typing.Any A memo dictionary of objects already copied during the current copying pass, see https: docs.python.org/3/library/copy.html for more details.  ! note This won't deep copy attributes where \"skip_deep_copy\" is set to  builtins.True in their metadata. Returns    - ModelT The new deep copied attrs model.",
"func":1
},
{
"ref":"hikari.internal.attr_extensions.invalidate_deep_copy_cache",
"url":44,
"doc":"Remove all the globally cached generated deep copy functions.",
"func":1
},
{
"ref":"hikari.internal.attr_extensions.invalidate_shallow_copy_cache",
"url":44,
"doc":"Remove all the globally cached copy functions.",
"func":1
},
{
"ref":"hikari.internal.enums",
"url":45,
"doc":"Implementation of parts of Python's  enum protocol to be more performant."
},
{
"ref":"hikari.internal.enums.Enum",
"url":45,
"doc":"Clone of Python's  enum.Enum implementation. This is designed to be faster and more efficient than Python's implementation, while retaining the majority of the external interface that Python's  enum.Enum provides. An  Enum is a simple class containing a discrete set of constant values that can be used in place of this type. This acts as a type-safe way of representing a set number of \"things\".  ! warning Some semantics such as subtype checking and instance checking may differ. It is recommended to compare these values using the    operator rather than the  is operator for safety reasons. Special Members on the class                 __enumtype__ : Always  Enum .   __members__ : An immutable  typing.Mapping that maps each member name to the member value.   __objtype__ : Always the first type that the enum is derived from. For example:   >>> class UserType(str, Enum):  . USER = \"user\"  . PARTIAL = \"partial\"  . MEMBER = \"member\" >>> print(UserType.__objtype__)    Operators on the class              EnumType[\"FOO\"] : Return the member that has the name  FOO , raising a  builtins.KeyError if it is not present.   EnumType.FOO : Return the member that has the name  FOO , raising a  builtins.AttributeError if it is not present.   EnumType(x) : Attempt to cast  x to the enum type by finding an existing member that has the same __value__. If this fails, you should expect a  builtins.ValueError to be raised. Operators on each enum member               -   e1  e2 :  builtins.bool Compare equality.   e1 != e2 :  builtins.bool Compare inequality.   builtins.repr(e) :  builtins.str Get the machine readable representation of the enum member  e .   builtins.str(e) :  builtins.str Get the  builtins.str name of the enum member  e . Special properties on each enum member                      name :  builtins.str The name of the member.   value : The value of the member. The type depends on the implementation type of the enum you are using. All other methods and operators on enum members are inherited from the member's __value__. For example, an enum extending  builtins.int would be able to be used as an  int type outside these overridden definitions."
},
{
"ref":"hikari.internal.enums.Enum.name",
"url":45,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.internal.enums.Enum.value",
"url":45,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.internal.enums.Flag",
"url":45,
"doc":"Clone of Python's  enum.Flag implementation. This is designed to be faster and more efficient than Python's implementation, while retaining the majority of the external interface that Python's  enum.Flag provides. In simple terms, an  Flag is a set of wrapped constant  builtins.int values that can be combined in any combination to make a special value. This is a more efficient way of combining things like permissions together into a single integral value, and works by setting individual  1 s and  0 s on the binary representation of the integer. This implementation has extra features, in that it will actively behave like a  builtins.set as well.  ! warning Despite wrapping  builtins.int values, conceptually this does not behave as if it were a subclass of  int .  ! danger Some semantics such as subtype checking and instance checking may differ. It is recommended to compare these values using the    operator rather than the  is operator for safety reasons. Especially where pseudo-members created from combinations are cached, results of using of  is may not be deterministic. This is a side effect of some internal performance improvements. Failing to observe this __will__ result in unexpected behaviour occurring in your application! Special Members on the class                 __enumtype__ : Always  Flag .   __everything__ : A special member with all documented bits set.   __members__ : An immutable  typing.Mapping that maps each member name to the member value.   __objtype__ : Always  builtins.int . Operators on the class              FlagType[\"FOO\"] : Return the member that has the name  FOO , raising a  builtins.KeyError if it is not present.   FlagType.FOO : Return the member that has the name  FOO , raising a  builtins.AttributeError if it is not present.   FlagType(x) : Attempt to cast  x to the enum type by finding an existing member that has the same __value__. If this fails, then a special __composite__ instance of the type is made. The name of this type is a combination of all members that combine to make the bitwise value. Operators on each flag member               -   e1 & e2 : Bitwise  AND operation. Will return a member that contains all flags that are common between both oprands on the values. This also works with one of the oprands being an  builtins.int eger. You may instead use the  intersection method.   e1 | e2 : Bitwise  OR operation. Will return a member that contains all flags that appear on at least one of the oprands. This also works with one of the oprands being an  builtins.int eger. You may instead use the  union method.   e1 ^ e2 : Bitwise  XOR operation. Will return a member that contains all flags that only appear on at least one and at most one of the oprands. This also works with one of the oprands being an  builtins.int eger. You may instead use the  symmetric_difference method.   ~e : Return the inverse of this value. This is equivalent to disabling all flags that are set on this value and enabling all flags that are not set on this value. Note that this will behave slightly differently to inverting a pure int value. You may instead use the  invert method.   e1 - e2 : Bitwise set difference operation. Returns all flags set on  e1 that are not set on  e2 as well. You may instead use the  difference method.   bool(e) :  builtins.bool Return  builtins.True if  e has a non-zero value, otherwise  builtins.False .   E.A in e :  builtins.bool  builtins.True if  E.A is in  e . This is functionally equivalent to  E.A & e  E.A .   iter(e) : Explode the value into a iterator of each __documented__ flag that can be combined to make up the value  e . Returns an iterator across all well-defined flags that make up this value. This will only include the flags explicitly defined on this  Flag type and that are individual powers of two (this means if converted to twos-compliment binary, exactly one bit must be a  1 ). In simple terms, this means that you should not expect combination flags to be returned.   e1  e2 :  builtins.bool Compare equality.   e1 != e2 :  builtins.bool Compare inequality.   e1 < e2 :  builtins.bool Compare by ordering.   builtins.int(e) :  builtins.int Get the integer value of this flag   builtins.repr(e) :  builtins.str Get the machine readable representation of the flag member  e .   builtins.str(e) :  builtins.str Get the  builtins.str name of the flag member  e . Special properties on each flag member                      e.name :  builtins.str The name of the member. For composite members, this will be generated.   e.value :  builtins.int The value of the member. Special members on each flag member                  -   e.all(E.A, E.B, E.C,  .) :  builtins.bool Returns  builtins.True if __all__ of  E.A ,  E.B ,  E.C , et cetera make up the value of  e .   e.any(E.A, E.B, E.C,  .) :  builtins.bool Returns  builtins.True if __any__ of  E.A ,  E.B ,  E.C , et cetera make up the value of  e .   e.none(E.A, E.B, E.C,  .) :  builtins.bool Returns  builtins.True if __none__ of  E.A ,  E.B ,  E.C , et cetera make up the value of  e .   e.split() :  typing.Sequence Explode the value into a sequence of each __documented__ flag that can be combined to make up the value  e . Returns a sorted sequence of each power-of-two flag that makes up the value  e . This is equivalent to  list(iter(e  . All other methods and operators on  Flag members are inherited from the member's __value__.  ! note Due to limitations around how this is re-implemented, this class is not considered a subclass of  Enum at runtime, even if MyPy believes this is possible"
},
{
"ref":"hikari.internal.enums.Flag.name",
"url":45,
"doc":"Return the name of the flag combination as a  builtins.str ."
},
{
"ref":"hikari.internal.enums.Flag.value",
"url":45,
"doc":"Return the  builtins.int value of the flag."
},
{
"ref":"hikari.internal.enums.Flag.all",
"url":45,
"doc":"Check if all of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.any",
"url":45,
"doc":"Check if any of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.difference",
"url":45,
"doc":"Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction  - operator.",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.intersection",
"url":45,
"doc":"Return a combination of flags that are set for both given values. Equivalent to using the \"AND\"  & operator.",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.invert",
"url":45,
"doc":"Return a set of all flags not in the current set.",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.is_disjoint",
"url":45,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.is_subset",
"url":45,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.is_superset",
"url":45,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.none",
"url":45,
"doc":"Check if none of the given flags are part of this value.  ! note This is essentially the opposite of  Flag.any . Returns    - builtins.bool  builtins.True if none of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.split",
"url":45,
"doc":"Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted  typing.Sequence of each membe",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.symmetric_difference",
"url":45,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.union",
"url":45,
"doc":"Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\"  ~ operator.",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.isdisjoint",
"url":45,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.issubset",
"url":45,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.issuperset",
"url":45,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.internal.enums.Flag.symmetricdifference",
"url":45,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.internal.reflect",
"url":46,
"doc":"Reflection utilities."
},
{
"ref":"hikari.internal.reflect.resolve_signature",
"url":46,
"doc":"Get the  inspect.Signature of  func with resolved forward annotations. Parameters      func : typing.Callable  .],  .] The function to get the resolved annotations from.  ! warning This will use  builtins.eval to resolve string type-hints and forward references. This has a slight performance overhead, so attempt to cache this info as much as possible. Returns    - inspect.Signature A  inspect.Signature object with all forward reference annotations resolved.",
"func":1
},
{
"ref":"hikari.guilds",
"url":15,
"doc":"Application and entities that are used to describe guilds on Discord."
},
{
"ref":"hikari.guilds.Guild",
"url":15,
"doc":"A representation of a guild on Discord. Method generated by attrs for class Guild."
},
{
"ref":"hikari.guilds.Guild.banner_url",
"url":15,
"doc":"Banner for the guild, if set."
},
{
"ref":"hikari.guilds.Guild.discovery_splash_url",
"url":15,
"doc":"Discovery splash for the guild, if set."
},
{
"ref":"hikari.guilds.Guild.emojis",
"url":15,
"doc":"Return the emojis in this guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A mapping of emoji IDs to the objects of emojis in this guild."
},
{
"ref":"hikari.guilds.Guild.roles",
"url":15,
"doc":"Return the roles in this guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, Role] A mapping of role IDs to the objects of roles in this guild."
},
{
"ref":"hikari.guilds.Guild.splash_url",
"url":15,
"doc":"Splash for the guild, if set."
},
{
"ref":"hikari.guilds.Guild.format_banner",
"url":15,
"doc":"Generate the guild's banner image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL of the banner, or  builtins.None if no banner is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.Guild.format_discovery_splash",
"url":15,
"doc":"Generate the guild's discovery splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The string URL. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.Guild.format_splash",
"url":15,
"doc":"Generate the guild's splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the splash, or  builtins.None if not set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.Guild.get_emoji",
"url":15,
"doc":"Get an emoji from the cache by it's ID.",
"func":1
},
{
"ref":"hikari.guilds.Guild.get_role",
"url":15,
"doc":"Get a role from the cache by it's ID.",
"func":1
},
{
"ref":"hikari.guilds.Guild.afk_channel_id",
"url":15,
"doc":"The ID for the channel that AFK voice users get sent to. If  builtins.None , then no AFK channel is set up for this guild."
},
{
"ref":"hikari.guilds.Guild.afk_timeout",
"url":15,
"doc":"Timeout for activity before a member is classed as AFK. How long a voice user has to be AFK for before they are classed as being AFK and are moved to the AFK channel ( Guild.afk_channel_id )."
},
{
"ref":"hikari.guilds.Guild.application_id",
"url":15,
"doc":"The ID of the application that created this guild. This will always be  builtins.None for guilds that weren't created by a bot."
},
{
"ref":"hikari.guilds.Guild.banner_hash",
"url":15,
"doc":"The hash for the guild's banner. This is only present if the guild has  GuildFeature.BANNER in  Guild.features for this guild. For all other purposes, it is  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.default_message_notifications",
"url":15,
"doc":"The default setting for message notifications in this guild."
},
{
"ref":"hikari.guilds.Guild.description",
"url":15,
"doc":"The guild's description. This is only present if certain  GuildFeature 's are set in  Guild.features for this guild. Otherwise, this will always be  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.discovery_splash_hash",
"url":15,
"doc":"The hash of the discovery splash for the guild, if there is one."
},
{
"ref":"hikari.guilds.Guild.explicit_content_filter",
"url":15,
"doc":"The setting for the explicit content filter in this guild."
},
{
"ref":"hikari.guilds.Guild.is_widget_enabled",
"url":15,
"doc":"Describes whether the guild widget is enabled or not. If this information is not present, this will be  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.max_video_channel_users",
"url":15,
"doc":"The maximum number of users allowed in a video channel together. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.mfa_level",
"url":15,
"doc":"The required MFA level for users wishing to participate in this guild."
},
{
"ref":"hikari.guilds.Guild.owner_id",
"url":15,
"doc":"The ID of the owner of this guild."
},
{
"ref":"hikari.guilds.Guild.preferred_locale",
"url":15,
"doc":"The preferred locale to use for this guild. This can only be change if  GuildFeature.PUBLIC is in  Guild.features for this guild and will otherwise default to  en-US ."
},
{
"ref":"hikari.guilds.Guild.premium_subscription_count",
"url":15,
"doc":"The number of nitro boosts that the server currently has. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.premium_tier",
"url":15,
"doc":"The premium tier for this guild."
},
{
"ref":"hikari.guilds.Guild.public_updates_channel_id",
"url":15,
"doc":"The channel ID of the channel where admins and moderators receive notices from Discord. This is only present if  GuildFeature.PUBLIC is in  Guild.features for this guild. For all other purposes, it should be considered to be  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.region",
"url":15,
"doc":"The voice region for the guild."
},
{
"ref":"hikari.guilds.Guild.rules_channel_id",
"url":15,
"doc":"The ID of the channel where guilds with the  GuildFeature.PUBLIC  features display rules and guidelines. If the  GuildFeature.PUBLIC feature is not defined, then this is  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.splash_hash",
"url":15,
"doc":"The hash of the splash for the guild, if there is one."
},
{
"ref":"hikari.guilds.Guild.system_channel_flags",
"url":15,
"doc":"Return flags for the guild system channel. These are used to describe which notifications are suppressed. Returns    - GuildSystemChannelFlag The system channel flags for this channel."
},
{
"ref":"hikari.guilds.Guild.system_channel_id",
"url":15,
"doc":"The ID of the system channel or  builtins.None if it is not enabled. Welcome messages and Nitro boost messages may be sent to this channel."
},
{
"ref":"hikari.guilds.Guild.vanity_url_code",
"url":15,
"doc":"The vanity URL code for the guild's vanity URL. This is only present if  GuildFeature.VANITY_URL is in  Guild.features for this guild. If not, this will always be  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.verification_level",
"url":15,
"doc":"The verification level needed for a user to participate in this guild."
},
{
"ref":"hikari.guilds.Guild.widget_channel_id",
"url":15,
"doc":"The channel ID that the widget's generated invite will send the user to. If this information is unavailable or this is not enabled for the guild then this will be  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.guilds.Guild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.guilds.Guild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.Guild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.guilds.Guild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.guilds.Guild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.guilds.Guild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.guilds.Guild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.guilds.Guild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.guilds.RESTGuild",
"url":15,
"doc":"Guild specialization that is sent via the REST API only. Method generated by attrs for class RESTGuild."
},
{
"ref":"hikari.guilds.RESTGuild.emojis",
"url":15,
"doc":"Return the emojis in this guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A mapping of emoji IDs to the objects of emojis in this guild."
},
{
"ref":"hikari.guilds.RESTGuild.roles",
"url":15,
"doc":"Return the roles in this guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, Role] A mapping of role IDs to the objects of roles in this guild."
},
{
"ref":"hikari.guilds.RESTGuild.get_emoji",
"url":15,
"doc":"Get an emoji from the cache by it's ID.",
"func":1
},
{
"ref":"hikari.guilds.RESTGuild.get_role",
"url":15,
"doc":"Get a role from the cache by it's ID.",
"func":1
},
{
"ref":"hikari.guilds.RESTGuild.approximate_active_member_count",
"url":15,
"doc":"The approximate number of members in the guild that are not offline."
},
{
"ref":"hikari.guilds.RESTGuild.approximate_member_count",
"url":15,
"doc":"The approximate number of members in the guild."
},
{
"ref":"hikari.guilds.RESTGuild.max_members",
"url":15,
"doc":"The maximum number of members allowed in this guild."
},
{
"ref":"hikari.guilds.RESTGuild.max_presences",
"url":15,
"doc":"The maximum number of presences for the guild."
},
{
"ref":"hikari.guilds.RESTGuild.banner_url",
"url":15,
"doc":"Banner for the guild, if set."
},
{
"ref":"hikari.guilds.RESTGuild.discovery_splash_url",
"url":15,
"doc":"Discovery splash for the guild, if set."
},
{
"ref":"hikari.guilds.RESTGuild.splash_url",
"url":15,
"doc":"Splash for the guild, if set."
},
{
"ref":"hikari.guilds.RESTGuild.format_banner",
"url":15,
"doc":"Generate the guild's banner image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL of the banner, or  builtins.None if no banner is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.RESTGuild.format_discovery_splash",
"url":15,
"doc":"Generate the guild's discovery splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The string URL. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.RESTGuild.format_splash",
"url":15,
"doc":"Generate the guild's splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the splash, or  builtins.None if not set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.RESTGuild.afk_channel_id",
"url":15,
"doc":"The ID for the channel that AFK voice users get sent to. If  builtins.None , then no AFK channel is set up for this guild."
},
{
"ref":"hikari.guilds.RESTGuild.afk_timeout",
"url":15,
"doc":"Timeout for activity before a member is classed as AFK. How long a voice user has to be AFK for before they are classed as being AFK and are moved to the AFK channel ( Guild.afk_channel_id )."
},
{
"ref":"hikari.guilds.RESTGuild.application_id",
"url":15,
"doc":"The ID of the application that created this guild. This will always be  builtins.None for guilds that weren't created by a bot."
},
{
"ref":"hikari.guilds.RESTGuild.banner_hash",
"url":15,
"doc":"The hash for the guild's banner. This is only present if the guild has  GuildFeature.BANNER in  Guild.features for this guild. For all other purposes, it is  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.default_message_notifications",
"url":15,
"doc":"The default setting for message notifications in this guild."
},
{
"ref":"hikari.guilds.RESTGuild.description",
"url":15,
"doc":"The guild's description. This is only present if certain  GuildFeature 's are set in  Guild.features for this guild. Otherwise, this will always be  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.discovery_splash_hash",
"url":15,
"doc":"The hash of the discovery splash for the guild, if there is one."
},
{
"ref":"hikari.guilds.RESTGuild.explicit_content_filter",
"url":15,
"doc":"The setting for the explicit content filter in this guild."
},
{
"ref":"hikari.guilds.RESTGuild.is_widget_enabled",
"url":15,
"doc":"Describes whether the guild widget is enabled or not. If this information is not present, this will be  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.max_video_channel_users",
"url":15,
"doc":"The maximum number of users allowed in a video channel together. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.mfa_level",
"url":15,
"doc":"The required MFA level for users wishing to participate in this guild."
},
{
"ref":"hikari.guilds.RESTGuild.owner_id",
"url":15,
"doc":"The ID of the owner of this guild."
},
{
"ref":"hikari.guilds.RESTGuild.preferred_locale",
"url":15,
"doc":"The preferred locale to use for this guild. This can only be change if  GuildFeature.PUBLIC is in  Guild.features for this guild and will otherwise default to  en-US ."
},
{
"ref":"hikari.guilds.RESTGuild.premium_subscription_count",
"url":15,
"doc":"The number of nitro boosts that the server currently has. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.premium_tier",
"url":15,
"doc":"The premium tier for this guild."
},
{
"ref":"hikari.guilds.RESTGuild.public_updates_channel_id",
"url":15,
"doc":"The channel ID of the channel where admins and moderators receive notices from Discord. This is only present if  GuildFeature.PUBLIC is in  Guild.features for this guild. For all other purposes, it should be considered to be  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.region",
"url":15,
"doc":"The voice region for the guild."
},
{
"ref":"hikari.guilds.RESTGuild.rules_channel_id",
"url":15,
"doc":"The ID of the channel where guilds with the  GuildFeature.PUBLIC  features display rules and guidelines. If the  GuildFeature.PUBLIC feature is not defined, then this is  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.splash_hash",
"url":15,
"doc":"The hash of the splash for the guild, if there is one."
},
{
"ref":"hikari.guilds.RESTGuild.system_channel_flags",
"url":15,
"doc":"Return flags for the guild system channel. These are used to describe which notifications are suppressed. Returns    - GuildSystemChannelFlag The system channel flags for this channel."
},
{
"ref":"hikari.guilds.RESTGuild.system_channel_id",
"url":15,
"doc":"The ID of the system channel or  builtins.None if it is not enabled. Welcome messages and Nitro boost messages may be sent to this channel."
},
{
"ref":"hikari.guilds.RESTGuild.vanity_url_code",
"url":15,
"doc":"The vanity URL code for the guild's vanity URL. This is only present if  GuildFeature.VANITY_URL is in  Guild.features for this guild. If not, this will always be  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.verification_level",
"url":15,
"doc":"The verification level needed for a user to participate in this guild."
},
{
"ref":"hikari.guilds.RESTGuild.widget_channel_id",
"url":15,
"doc":"The channel ID that the widget's generated invite will send the user to. If this information is unavailable or this is not enabled for the guild then this will be  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.guilds.RESTGuild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.guilds.RESTGuild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.RESTGuild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.guilds.RESTGuild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.guilds.RESTGuild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.guilds.RESTGuild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.guilds.RESTGuild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.guilds.RESTGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.guilds.GatewayGuild",
"url":15,
"doc":"Guild specialization that is sent via the gateway only. Method generated by attrs for class GatewayGuild."
},
{
"ref":"hikari.guilds.GatewayGuild.channels",
"url":15,
"doc":"Get the channels cached for the guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A mapping of channel IDs to objects of the channels cached for the guild."
},
{
"ref":"hikari.guilds.GatewayGuild.emojis",
"url":15,
"doc":"Return the emojis in this guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A mapping of emoji IDs to the objects of emojis in this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.members",
"url":15,
"doc":"Get the members cached for the guild. typing.Mapping[hikari.snowflakes.Snowflake, Member] A mapping of user IDs to objects of the members cached for the guild."
},
{
"ref":"hikari.guilds.GatewayGuild.presences",
"url":15,
"doc":"Get the presences cached for the guild. typing.Mapping[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A mapping of user IDs to objects of the presences cached for the guild."
},
{
"ref":"hikari.guilds.GatewayGuild.roles",
"url":15,
"doc":"Return the roles in this guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, Role] A mapping of role IDs to the objects of roles in this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.voice_states",
"url":15,
"doc":"Get the voice states cached for the guild. Returns    - typing.Mapping[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A mapping of user IDs to objects of the voice states cached for the guild."
},
{
"ref":"hikari.guilds.GatewayGuild.get_channel",
"url":15,
"doc":"Get a cached channel that belongs to the guild by it's ID or object. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The object or ID of the guild channel to get from the cache. Returns    - typing.Optional[hikari.channels.GuildChannel] The object of the guild channel found in cache or  builtins.None.",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.get_emoji",
"url":15,
"doc":"Get a cached role that belongs to the guild by it's ID or object. Parameters      emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The object or ID of the emoji to get from the cache. Returns    - typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the custom emoji if found in cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.get_member",
"url":15,
"doc":"Get a cached member that belongs to the guild by it's user ID or object. Parameters      user : hikari.snowflakes.SnowflakeishOr[hikari.users.User] The object or ID of the user to get the cached member for. Returns    - typing.Optional[Member] The cached member object if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.get_my_member",
"url":15,
"doc":"Return the cached member for the bot user in this guild, if known. Returns    - typing.Optional[Member] The cached member for this guild, or  builtins.None if not known. This will be sent on each  hikari.events.guild_events.GuildAvailableEvent , as well as any presence updates if you have opted into them.",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.get_presence",
"url":15,
"doc":"Get a cached presence that belongs to the guild by it's user ID or object. Parameters      user : hikari.snowflakes.SnowflakeishOr[hikari.users.User] The object or ID of the user to get the cached presence for. Returns    - typing.Optional[hikari.presences.MemberPresence] The cached presence object if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.get_role",
"url":15,
"doc":"Get a cached role that belongs to the guild by it's ID or object. Parameters      role : hikari.snowflakes.SnowflakeishOr[Role] The object or ID of the role to get for this guild from the cache. Returns    - typing.Optional[Role] The object of the role found in cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.get_voice_state",
"url":15,
"doc":"Get a cached voice state that belongs to the guild by it's user. Parameters      user : hikari.snowflakes.SnowflakeishOr[hikari.users.User] The object or ID of the user to get the cached voice state for. Returns    - typing.Optional[hikari.voices.VoiceState] The cached voice state object if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.is_large",
"url":15,
"doc":"Whether the guild is considered to be large or not. This information is only available if the guild was sent via a  GUILD_CREATE event. If the guild is received from any other place, this will always be  builtins.None . The implications of a large guild are that presence information will not be sent about members who are offline or invisible."
},
{
"ref":"hikari.guilds.GatewayGuild.joined_at",
"url":15,
"doc":"The date and time that the bot user joined this guild. This information is only available if the guild was sent via a  GUILD_CREATE event. If the guild is received from any other place, this will always be  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.member_count",
"url":15,
"doc":"The number of members in this guild. This information is only available if the guild was sent via a  GUILD_CREATE event. If the guild is received from any other place, this will always be  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.banner_url",
"url":15,
"doc":"Banner for the guild, if set."
},
{
"ref":"hikari.guilds.GatewayGuild.discovery_splash_url",
"url":15,
"doc":"Discovery splash for the guild, if set."
},
{
"ref":"hikari.guilds.GatewayGuild.splash_url",
"url":15,
"doc":"Splash for the guild, if set."
},
{
"ref":"hikari.guilds.GatewayGuild.format_banner",
"url":15,
"doc":"Generate the guild's banner image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL of the banner, or  builtins.None if no banner is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.format_discovery_splash",
"url":15,
"doc":"Generate the guild's discovery splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The string URL. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.format_splash",
"url":15,
"doc":"Generate the guild's splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the splash, or  builtins.None if not set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.afk_channel_id",
"url":15,
"doc":"The ID for the channel that AFK voice users get sent to. If  builtins.None , then no AFK channel is set up for this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.afk_timeout",
"url":15,
"doc":"Timeout for activity before a member is classed as AFK. How long a voice user has to be AFK for before they are classed as being AFK and are moved to the AFK channel ( Guild.afk_channel_id )."
},
{
"ref":"hikari.guilds.GatewayGuild.application_id",
"url":15,
"doc":"The ID of the application that created this guild. This will always be  builtins.None for guilds that weren't created by a bot."
},
{
"ref":"hikari.guilds.GatewayGuild.banner_hash",
"url":15,
"doc":"The hash for the guild's banner. This is only present if the guild has  GuildFeature.BANNER in  Guild.features for this guild. For all other purposes, it is  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.default_message_notifications",
"url":15,
"doc":"The default setting for message notifications in this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.description",
"url":15,
"doc":"The guild's description. This is only present if certain  GuildFeature 's are set in  Guild.features for this guild. Otherwise, this will always be  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.discovery_splash_hash",
"url":15,
"doc":"The hash of the discovery splash for the guild, if there is one."
},
{
"ref":"hikari.guilds.GatewayGuild.explicit_content_filter",
"url":15,
"doc":"The setting for the explicit content filter in this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.is_widget_enabled",
"url":15,
"doc":"Describes whether the guild widget is enabled or not. If this information is not present, this will be  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.max_video_channel_users",
"url":15,
"doc":"The maximum number of users allowed in a video channel together. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.mfa_level",
"url":15,
"doc":"The required MFA level for users wishing to participate in this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.owner_id",
"url":15,
"doc":"The ID of the owner of this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.preferred_locale",
"url":15,
"doc":"The preferred locale to use for this guild. This can only be change if  GuildFeature.PUBLIC is in  Guild.features for this guild and will otherwise default to  en-US ."
},
{
"ref":"hikari.guilds.GatewayGuild.premium_subscription_count",
"url":15,
"doc":"The number of nitro boosts that the server currently has. This information may not be present, in which case, it will be  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.premium_tier",
"url":15,
"doc":"The premium tier for this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.public_updates_channel_id",
"url":15,
"doc":"The channel ID of the channel where admins and moderators receive notices from Discord. This is only present if  GuildFeature.PUBLIC is in  Guild.features for this guild. For all other purposes, it should be considered to be  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.region",
"url":15,
"doc":"The voice region for the guild."
},
{
"ref":"hikari.guilds.GatewayGuild.rules_channel_id",
"url":15,
"doc":"The ID of the channel where guilds with the  GuildFeature.PUBLIC  features display rules and guidelines. If the  GuildFeature.PUBLIC feature is not defined, then this is  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.splash_hash",
"url":15,
"doc":"The hash of the splash for the guild, if there is one."
},
{
"ref":"hikari.guilds.GatewayGuild.system_channel_flags",
"url":15,
"doc":"Return flags for the guild system channel. These are used to describe which notifications are suppressed. Returns    - GuildSystemChannelFlag The system channel flags for this channel."
},
{
"ref":"hikari.guilds.GatewayGuild.system_channel_id",
"url":15,
"doc":"The ID of the system channel or  builtins.None if it is not enabled. Welcome messages and Nitro boost messages may be sent to this channel."
},
{
"ref":"hikari.guilds.GatewayGuild.vanity_url_code",
"url":15,
"doc":"The vanity URL code for the guild's vanity URL. This is only present if  GuildFeature.VANITY_URL is in  Guild.features for this guild. If not, this will always be  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.verification_level",
"url":15,
"doc":"The verification level needed for a user to participate in this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.widget_channel_id",
"url":15,
"doc":"The channel ID that the widget's generated invite will send the user to. If this information is unavailable or this is not enabled for the guild then this will be  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.guilds.GatewayGuild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.guilds.GatewayGuild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.GatewayGuild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.guilds.GatewayGuild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.guilds.GatewayGuild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.guilds.GatewayGuild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.guilds.GatewayGuild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.guilds.GatewayGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.guilds.GuildWidget",
"url":15,
"doc":"Represents a guild widget. Method generated by attrs for class GuildWidget."
},
{
"ref":"hikari.guilds.GuildWidget.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.guilds.GuildWidget.channel_id",
"url":15,
"doc":"The ID of the channel the invite for this embed targets, if enabled."
},
{
"ref":"hikari.guilds.GuildWidget.is_enabled",
"url":15,
"doc":"Whether this embed is enabled."
},
{
"ref":"hikari.guilds.Role",
"url":15,
"doc":"Represents a guild bound Role object. Method generated by attrs for class Role."
},
{
"ref":"hikari.guilds.Role.colour",
"url":15,
"doc":"Alias for the  color field."
},
{
"ref":"hikari.guilds.Role.color",
"url":15,
"doc":"The colour of this role. This will be applied to a member's name in chat if it's their top coloured role."
},
{
"ref":"hikari.guilds.Role.guild_id",
"url":15,
"doc":"The ID of the guild this role belongs to"
},
{
"ref":"hikari.guilds.Role.is_hoisted",
"url":15,
"doc":"Whether this role is hoisting the members it's attached to in the member list. members will be hoisted under their highest role where this is set to  builtins.True ."
},
{
"ref":"hikari.guilds.Role.is_managed",
"url":15,
"doc":"Whether this role is managed by an integration."
},
{
"ref":"hikari.guilds.Role.is_mentionable",
"url":15,
"doc":"Whether this role can be mentioned by all regardless of permissions."
},
{
"ref":"hikari.guilds.Role.permissions",
"url":15,
"doc":"The guild wide permissions this role gives to the members it's attached to, This may be overridden by channel overwrites."
},
{
"ref":"hikari.guilds.Role.position",
"url":15,
"doc":"The position of this role in the role hierarchy. This will start at  0 for the lowest role (@everyone) and increase as you go up the hierarchy."
},
{
"ref":"hikari.guilds.Role.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.guilds.Role.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.guilds.Role.name",
"url":15,
"doc":"The role's name."
},
{
"ref":"hikari.guilds.Role.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.guilds.GuildFeature",
"url":15,
"doc":"Features that a guild can provide."
},
{
"ref":"hikari.guilds.GuildFeature.name",
"url":15,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.guilds.GuildFeature.value",
"url":15,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.guilds.GuildFeature.ANIMATED_ICON",
"url":15,
"doc":"Guild has access to set an animated guild icon."
},
{
"ref":"hikari.guilds.GuildFeature.BANNER",
"url":15,
"doc":"Guild has access to set a guild banner image."
},
{
"ref":"hikari.guilds.GuildFeature.COMMERCE",
"url":15,
"doc":"Guild has access to use commerce features (i.e. create store channels)."
},
{
"ref":"hikari.guilds.GuildFeature.COMMUNITY",
"url":15,
"doc":"Guild has community features enabled."
},
{
"ref":"hikari.guilds.GuildFeature.DISCOVERABLE",
"url":15,
"doc":"Guild is able to be discovered in the directory. This also implies the guild can be viewed without joining."
},
{
"ref":"hikari.guilds.GuildFeature.FEATURABLE",
"url":15,
"doc":"Guild is able to be featured in the directory."
},
{
"ref":"hikari.guilds.GuildFeature.INVITE_SPLASH",
"url":15,
"doc":"Guild has access to set an invite splash background."
},
{
"ref":"hikari.guilds.GuildFeature.MORE_EMOJI",
"url":15,
"doc":"More emojis can be hosted in this guild than normal."
},
{
"ref":"hikari.guilds.GuildFeature.NEWS",
"url":15,
"doc":"Guild has access to create news channels."
},
{
"ref":"hikari.guilds.GuildFeature.PARTNERED",
"url":15,
"doc":"Guild is partnered."
},
{
"ref":"hikari.guilds.GuildFeature.PUBLIC",
"url":15,
"doc":"Guild is public, go figure."
},
{
"ref":"hikari.guilds.GuildFeature.PUBLIC_DISABLED",
"url":15,
"doc":"Guild cannot be public."
},
{
"ref":"hikari.guilds.GuildFeature.RELAY_ENABLED",
"url":15,
"doc":"Guild is using relays. Relays are new infrastructure designed to handle large guilds more efficiently server-side."
},
{
"ref":"hikari.guilds.GuildFeature.VANITY_URL",
"url":15,
"doc":"Guild has access to set a vanity URL."
},
{
"ref":"hikari.guilds.GuildFeature.VERIFIED",
"url":15,
"doc":"Guild is verified."
},
{
"ref":"hikari.guilds.GuildFeature.VIP_REGIONS",
"url":15,
"doc":"Guild has access to set 384kbps bitrate in voice. Previously gave access to VIP voice servers."
},
{
"ref":"hikari.guilds.GuildFeature.WELCOME_SCREEN_ENABLED",
"url":15,
"doc":"Guild has enabled the welcome screen."
},
{
"ref":"hikari.guilds.GuildFeatureish",
"url":15,
"doc":"Type hint for possible guild features. Generally these will be of type  GuildFeature , but undocumented or new fields may just be  builtins.str until they are documented and amended to the library."
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag",
"url":15,
"doc":"Defines which features are suppressed in the system channel."
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.name",
"url":15,
"doc":"Return the name of the flag combination as a  builtins.str ."
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.value",
"url":15,
"doc":"Return the  builtins.int value of the flag."
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.all",
"url":15,
"doc":"Check if all of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.any",
"url":15,
"doc":"Check if any of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.difference",
"url":15,
"doc":"Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction  - operator.",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.intersection",
"url":15,
"doc":"Return a combination of flags that are set for both given values. Equivalent to using the \"AND\"  & operator.",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.invert",
"url":15,
"doc":"Return a set of all flags not in the current set.",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.is_disjoint",
"url":15,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.is_subset",
"url":15,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.is_superset",
"url":15,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.none",
"url":15,
"doc":"Check if none of the given flags are part of this value.  ! note This is essentially the opposite of  Flag.any . Returns    - builtins.bool  builtins.True if none of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.split",
"url":15,
"doc":"Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted  typing.Sequence of each membe",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.symmetric_difference",
"url":15,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.union",
"url":15,
"doc":"Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\"  ~ operator.",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.isdisjoint",
"url":15,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.issubset",
"url":15,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.issuperset",
"url":15,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.symmetricdifference",
"url":15,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.NONE",
"url":15,
"doc":"Nothing is suppressed."
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.SUPPRESS_USER_JOIN",
"url":15,
"doc":"Display a message about new users joining."
},
{
"ref":"hikari.guilds.GuildSystemChannelFlag.SUPPRESS_PREMIUM_SUBSCRIPTION",
"url":15,
"doc":"Display a message when the guild is Nitro boosted."
},
{
"ref":"hikari.guilds.GuildMessageNotificationsLevel",
"url":15,
"doc":"Represents the default notification level for new messages in a guild."
},
{
"ref":"hikari.guilds.GuildMessageNotificationsLevel.name",
"url":15,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.guilds.GuildMessageNotificationsLevel.value",
"url":15,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.guilds.GuildMessageNotificationsLevel.ALL_MESSAGES",
"url":15,
"doc":"Notify users when any message is sent."
},
{
"ref":"hikari.guilds.GuildMessageNotificationsLevel.ONLY_MENTIONS",
"url":15,
"doc":"Only notify users when they are @mentioned."
},
{
"ref":"hikari.guilds.GuildExplicitContentFilterLevel",
"url":15,
"doc":"Represents the explicit content filter setting for a guild."
},
{
"ref":"hikari.guilds.GuildExplicitContentFilterLevel.name",
"url":15,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.guilds.GuildExplicitContentFilterLevel.value",
"url":15,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.guilds.GuildExplicitContentFilterLevel.DISABLED",
"url":15,
"doc":"No explicit content filter."
},
{
"ref":"hikari.guilds.GuildExplicitContentFilterLevel.MEMBERS_WITHOUT_ROLES",
"url":15,
"doc":"Filter posts from anyone without a role."
},
{
"ref":"hikari.guilds.GuildExplicitContentFilterLevel.ALL_MEMBERS",
"url":15,
"doc":"Filter all posts."
},
{
"ref":"hikari.guilds.GuildMFALevel",
"url":15,
"doc":"Represents the multi-factor authorization requirement for a guild."
},
{
"ref":"hikari.guilds.GuildMFALevel.name",
"url":15,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.guilds.GuildMFALevel.value",
"url":15,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.guilds.GuildMFALevel.NONE",
"url":15,
"doc":"No MFA requirement."
},
{
"ref":"hikari.guilds.GuildMFALevel.ELEVATED",
"url":15,
"doc":"MFA requirement."
},
{
"ref":"hikari.guilds.GuildVerificationLevel",
"url":15,
"doc":"Represents the level of verification of a guild."
},
{
"ref":"hikari.guilds.GuildVerificationLevel.name",
"url":15,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.guilds.GuildVerificationLevel.value",
"url":15,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.guilds.GuildVerificationLevel.NONE",
"url":15,
"doc":"Unrestricted."
},
{
"ref":"hikari.guilds.GuildVerificationLevel.LOW",
"url":15,
"doc":"Must have a verified email on their account."
},
{
"ref":"hikari.guilds.GuildVerificationLevel.MEDIUM",
"url":15,
"doc":"Must have been registered on Discord for more than 5 minutes."
},
{
"ref":"hikari.guilds.GuildVerificationLevel.HIGH",
"url":15,
"doc":"Must also be a member of the guild for longer than 10 minutes."
},
{
"ref":"hikari.guilds.GuildVerificationLevel.VERY_HIGH",
"url":15,
"doc":"Must have a verified phone number."
},
{
"ref":"hikari.guilds.GuildPremiumTier",
"url":15,
"doc":"Tier for Discord Nitro boosting in a guild."
},
{
"ref":"hikari.guilds.GuildPremiumTier.name",
"url":15,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.guilds.GuildPremiumTier.value",
"url":15,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.guilds.GuildPremiumTier.NONE",
"url":15,
"doc":"No Nitro boost level."
},
{
"ref":"hikari.guilds.GuildPremiumTier.TIER_1",
"url":15,
"doc":"Level 1 Nitro boost."
},
{
"ref":"hikari.guilds.GuildPremiumTier.TIER_2",
"url":15,
"doc":"Level 2 Nitro boost."
},
{
"ref":"hikari.guilds.GuildPremiumTier.TIER_3",
"url":15,
"doc":"Level 3 Nitro boost."
},
{
"ref":"hikari.guilds.GuildPreview",
"url":15,
"doc":"A preview of a guild with the  GuildFeature.PUBLIC feature. Method generated by attrs for class GuildPreview."
},
{
"ref":"hikari.guilds.GuildPreview.discovery_splash_url",
"url":15,
"doc":"Discovery splash for the guild, if set."
},
{
"ref":"hikari.guilds.GuildPreview.splash_url",
"url":15,
"doc":"Splash for the guild, if set."
},
{
"ref":"hikari.guilds.GuildPreview.format_discovery_splash",
"url":15,
"doc":"Generate the guild's discovery splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The string URL. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.GuildPreview.format_splash",
"url":15,
"doc":"Generate the guild's splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the splash, or  builtins.None if not set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.GuildPreview.approximate_active_member_count",
"url":15,
"doc":"The approximate amount of presences in this guild."
},
{
"ref":"hikari.guilds.GuildPreview.approximate_member_count",
"url":15,
"doc":"The approximate amount of members in this guild."
},
{
"ref":"hikari.guilds.GuildPreview.description",
"url":15,
"doc":"The guild's description, if set."
},
{
"ref":"hikari.guilds.GuildPreview.discovery_splash_hash",
"url":15,
"doc":"The hash of the discovery splash for the guild, if there is one."
},
{
"ref":"hikari.guilds.GuildPreview.emojis",
"url":15,
"doc":"The mapping of IDs to the emojis this guild provides."
},
{
"ref":"hikari.guilds.GuildPreview.splash_hash",
"url":15,
"doc":"The hash of the splash for the guild, if there is one."
},
{
"ref":"hikari.guilds.GuildPreview.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.guilds.GuildPreview.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.guilds.GuildPreview.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.GuildPreview.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.guilds.GuildPreview.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.guilds.GuildPreview.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.guilds.GuildPreview.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.guilds.GuildPreview.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.guilds.GuildPreview.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.guilds.Member",
"url":15,
"doc":"Used to represent a guild bound member. Method generated by attrs for class Member."
},
{
"ref":"hikari.guilds.Member.app",
"url":15,
"doc":"Return the app that is bound to the user object."
},
{
"ref":"hikari.guilds.Member.avatar_hash",
"url":15,
"doc":"Avatar hash for the user, if they have one, otherwise  builtins.None ."
},
{
"ref":"hikari.guilds.Member.avatar_url",
"url":15,
"doc":"Avatar URL for the user, if they have one set. May be  builtins.None if no custom avatar is set. In this case, you should use  default_avatar_url instead."
},
{
"ref":"hikari.guilds.Member.default_avatar_url",
"url":15,
"doc":"Default avatar for this user."
},
{
"ref":"hikari.guilds.Member.discriminator",
"url":15,
"doc":"Discriminator for the user."
},
{
"ref":"hikari.guilds.Member.display_name",
"url":15,
"doc":"Return the member's display name. If the member has a nickname, this will return that nickname. Otherwise, it will return the username instead. Returns    - builtins.str The member display name. See Also     Nickname:  Member.nickname Username:  Member.username "
},
{
"ref":"hikari.guilds.Member.flags",
"url":15,
"doc":"Flag bits that are set for the user."
},
{
"ref":"hikari.guilds.Member.id",
"url":15,
"doc":"Return the ID of this entity. Returns    - Snowflake The snowflake ID of this object."
},
{
"ref":"hikari.guilds.Member.is_bot",
"url":15,
"doc":" builtins.True if this user is a bot account,  builtins.False otherwise."
},
{
"ref":"hikari.guilds.Member.is_system",
"url":15,
"doc":" builtins.True if this user is a system account,  builtins.False otherwise."
},
{
"ref":"hikari.guilds.Member.mention",
"url":15,
"doc":"Return a raw mention string for the given member. If the member has a known nickname, we always return a bang (\" ! \") before the ID part of the mention string. This mimics the behaviour Discord clients tend to provide. Example    -   >>> some_member_without_nickname.mention ' ' >>> some_member_with_nickname.mention ' '   Returns    - builtins.str The mention string to use."
},
{
"ref":"hikari.guilds.Member.presence",
"url":15,
"doc":"Get the cached presence for this member, if known. Presence info includes user status and activities. This requires the  GUILD_PRESENCES intent to be enabled. Returns    - typing.Optional[hikari.presences.MemberPresence] The member presence, or  builtins.None if not known."
},
{
"ref":"hikari.guilds.Member.top_role",
"url":15,
"doc":"Return the highest role the member has. Returns    - typing.Optional[hikari.guilds.Role]  builtins.None if the cache is missing the roles information or the highest role the user has."
},
{
"ref":"hikari.guilds.Member.username",
"url":15,
"doc":"Username for the user."
},
{
"ref":"hikari.guilds.Member.format_avatar",
"url":15,
"doc":"Generate the avatar for this user, if set. If no custom avatar is set, this returns  builtins.None . You can then use the  default_avatar_url attribute instead to fetch the displayed URL. Parameters      ext : typing.Optional[builtins.str] The ext to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). Will be ignored for default avatars which can only be  png . If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns    - typing.Optional[hikari.files.URL] The URL to the avatar, or  builtins.None if not present. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.Member.fetch_self",
"url":15,
"doc":"Fetch an up-to-date view of this member from the API. Returns    - hikari.guilds.Member An up-to-date view of this member.",
"func":1
},
{
"ref":"hikari.guilds.Member.guild_id",
"url":15,
"doc":"The ID of the guild this member belongs to."
},
{
"ref":"hikari.guilds.Member.is_deaf",
"url":15,
"doc":" builtins.True if this member is deafened in the current voice channel. This will be  hikari.undefined.UndefinedType if it's state is unknown."
},
{
"ref":"hikari.guilds.Member.is_mute",
"url":15,
"doc":" builtins.True if this member is muted in the current voice channel. This will be  hikari.undefined.UndefinedType if it's state is unknown."
},
{
"ref":"hikari.guilds.Member.joined_at",
"url":15,
"doc":"The datetime of when this member joined the guild they belong to."
},
{
"ref":"hikari.guilds.Member.nickname",
"url":15,
"doc":"This member's nickname. This will be  builtins.None if not set. On member update events, this may not be included at all. In this case, this will be undefined."
},
{
"ref":"hikari.guilds.Member.premium_since",
"url":15,
"doc":"The datetime of when this member started \"boosting\" this guild. Will be  builtins.None if the member is not a premium user."
},
{
"ref":"hikari.guilds.Member.role_ids",
"url":15,
"doc":"A sequence of the IDs of the member's current roles."
},
{
"ref":"hikari.guilds.Member.user",
"url":15,
"doc":"This member's corresponding user object."
},
{
"ref":"hikari.guilds.Member.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.guilds.Integration",
"url":15,
"doc":"Represents a guild integration object. Method generated by attrs for class Integration."
},
{
"ref":"hikari.guilds.Integration.expire_behavior",
"url":15,
"doc":"How members should be treated after their connected subscription expires. This will not be enacted until after  GuildIntegration.expire_grace_period passes."
},
{
"ref":"hikari.guilds.Integration.expire_grace_period",
"url":15,
"doc":"How many days users with expired subscriptions are given until  GuildIntegration.expire_behavior is enacted out on them"
},
{
"ref":"hikari.guilds.Integration.is_emojis_enabled",
"url":15,
"doc":"Whether users under this integration are allowed to use it's custom emojis."
},
{
"ref":"hikari.guilds.Integration.is_enabled",
"url":15,
"doc":"Whether this integration is enabled."
},
{
"ref":"hikari.guilds.Integration.is_syncing",
"url":15,
"doc":"Whether this integration is syncing subscribers/emojis."
},
{
"ref":"hikari.guilds.Integration.last_synced_at",
"url":15,
"doc":"The datetime of when this integration's subscribers were last synced."
},
{
"ref":"hikari.guilds.Integration.role_id",
"url":15,
"doc":"The ID of the managed role used for this integration's subscribers."
},
{
"ref":"hikari.guilds.Integration.user",
"url":15,
"doc":"The user this integration belongs to."
},
{
"ref":"hikari.guilds.Integration.account",
"url":15,
"doc":"The account connected to this integration."
},
{
"ref":"hikari.guilds.Integration.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.guilds.Integration.name",
"url":15,
"doc":"The name of this integration."
},
{
"ref":"hikari.guilds.Integration.type",
"url":15,
"doc":"The type of this integration."
},
{
"ref":"hikari.guilds.Integration.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.guilds.GuildMemberBan",
"url":15,
"doc":"Used to represent guild bans. Method generated by attrs for class GuildMemberBan."
},
{
"ref":"hikari.guilds.GuildMemberBan.reason",
"url":15,
"doc":"The reason for this ban, will be  builtins.None if no reason was given."
},
{
"ref":"hikari.guilds.GuildMemberBan.user",
"url":15,
"doc":"The object of the user this ban targets."
},
{
"ref":"hikari.guilds.IntegrationAccount",
"url":15,
"doc":"An account that's linked to an integration. Method generated by attrs for class IntegrationAccount."
},
{
"ref":"hikari.guilds.IntegrationAccount.id",
"url":15,
"doc":"The string ID of this (likely) third party account."
},
{
"ref":"hikari.guilds.IntegrationAccount.name",
"url":15,
"doc":"The name of this account."
},
{
"ref":"hikari.guilds.IntegrationExpireBehaviour",
"url":15,
"doc":"Behavior for expiring integration subscribers."
},
{
"ref":"hikari.guilds.IntegrationExpireBehaviour.name",
"url":15,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.guilds.IntegrationExpireBehaviour.value",
"url":15,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.guilds.IntegrationExpireBehaviour.REMOVE_ROLE",
"url":15,
"doc":"Remove the role."
},
{
"ref":"hikari.guilds.IntegrationExpireBehaviour.KICK",
"url":15,
"doc":"Kick the subscriber."
},
{
"ref":"hikari.guilds.PartialGuild",
"url":15,
"doc":"Base object for any partial guild objects. Method generated by attrs for class PartialGuild."
},
{
"ref":"hikari.guilds.PartialGuild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.guilds.PartialGuild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.guilds.PartialGuild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.guilds.PartialGuild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.guilds.PartialGuild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.guilds.PartialGuild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.guilds.PartialGuild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.guilds.PartialGuild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.guilds.PartialGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.guilds.PartialIntegration",
"url":15,
"doc":"A partial representation of an integration, found in audit logs. Method generated by attrs for class PartialIntegration."
},
{
"ref":"hikari.guilds.PartialIntegration.account",
"url":15,
"doc":"The account connected to this integration."
},
{
"ref":"hikari.guilds.PartialIntegration.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.guilds.PartialIntegration.name",
"url":15,
"doc":"The name of this integration."
},
{
"ref":"hikari.guilds.PartialIntegration.type",
"url":15,
"doc":"The type of this integration."
},
{
"ref":"hikari.guilds.PartialIntegration.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.guilds.PartialRole",
"url":15,
"doc":"Represents a partial guild bound Role object. Method generated by attrs for class PartialRole."
},
{
"ref":"hikari.guilds.PartialRole.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.guilds.PartialRole.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.guilds.PartialRole.name",
"url":15,
"doc":"The role's name."
},
{
"ref":"hikari.guilds.PartialRole.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.intents",
"url":47,
"doc":"Shard intents for controlling which events the application receives."
},
{
"ref":"hikari.intents.Intents",
"url":47,
"doc":"Represents an intent on the gateway. This is a bitfield representation of all the categories of event that you wish to receive. Any events not in an intent category will be fired regardless of what intents you provide.  ! info Discord now places limits on certain events you can receive without whitelisting your bot first. On the  Bot tab in the developer's portal for your bot, you should now have the option to enable functionality for receiving these events. If you attempt to request an intent type that you have not whitelisted your bot for, you will be disconnected on startup with a  4014 closure code.  ! warning If you are using the V7 Gateway, you will be REQUIRED to provide some form of intent value when you connect. Failure to do so may result in immediate termination of the session server-side. This enum is an  enum.IntFlag , which means that you can use bitwise operators to join and splice multiple intents into one value. For example, if we wish to only refer to the  GUILDS intent, then it is simply a case of accessing it normally.   my_intents = Intents.GUILDS   If we wanted to have several intents grouped together, we would use the bitwise-or operator to combine them ( | ). This can be done in-place with the  |= operator if needed.    One or two values that fit on one line. my_intents = Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES  Several intents together. You may find it useful to format these like  so to keep your code readable. my_intents = ( Intents.GUILDS | Intents.GUILD_BANS | Intents.GUILD_EMOJIS | Intents.GUILD_INTEGRATIONS | Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES )   To check if an intent  is present in a given intents bitfield, you can use the bitwise-and operator ( & ) to check. This returns the \"intersection\" or \"crossover\" between the left and right-hand side of the  & . You can then use the    operator to check that specific values are present. You can check in-place with the  &= operator if needed.    Check if an intent is set: if (my_intents & Intents.GUILD_MESSAGES)  Intents.GUILD_MESSAGES: print(\"Guild messages are enabled\")  Checking if ALL in a combination are set: expected_intents = (Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES) if (my_intents & expected_intents)  expected_intents: print(\"Messages are enabled in guilds and private messages.\")  Checking if AT LEAST ONE in a combination is set: expected_intents = (Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES) if my_intents & expected_intents: print(\"Messages are enabled in guilds or private messages.\")   Removing one or more intents from a combination can be done with the bitwise-xor ( ^ ) operator. The  ^= operator can do this in-place.    Remove GUILD_MESSAGES my_intents = my_intents ^ Intents.GUILD_MESSAGES  or, simplifying: my_intents ^= Intents.GUILD_MESSAGES  Remove all messages events. my_intents = my_intents ^ (Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES)  or, simplifying my_intents ^= (Intents.GUILD_MESSAGES | Intents.PRIVATE_MESSAGES)   What is and is not covered by intents?                    The following unprivileged events require intents to be dispatched: -  GUILD_CREATE -  GUILD_UPDATE -  GUILD_DELETE -  GUILD_ROLE_CREATE -  GUILD_ROLE_UPDATE -  GUILD_ROLE_DELETE -  GUILD_BAN_ADD -  GUILD_BAN_REMOVE -  GUILD_EMOJIS_UPDATE -  GUILD_INTEGRATIONS_UPDATE -  INVITE_CREATE -  INVITE_DELETE -  CHANNEL_CREATE -  CHANNEL_UPDATE -  CHANNEL_DELETE -  CHANNEL_PINS_UPDATE (guilds only) -  MESSAGE_CREATE -  MESSAGE_UPDATE -  MESSAGE_DELETE -  MESSAGE_BULK_DELETE -  MESSAGE_REACTION_ADD -  MESSAGE_REACTION_REMOVE -  MESSAGE_REACTION_REMOVE_ALL -  MESSAGE_REACTION_REMOVE_EMOJI -  TYPING_START -  VOICE_STATE_UPDATE -  WEBHOOKS_UPDATE The following privileged events require intents to be dispatched: -  GUILD_MEMBER_ADD -  GUILD_MEMBER_UPDATE -  GUILD_MEMBER_REMOVE -  PRESENCE_UPDATE All events not listed above will be dispatched regardless of whether intents are used or not."
},
{
"ref":"hikari.intents.Intents.is_privileged",
"url":47,
"doc":"Determine whether the intent requires elevated privileges. If this is  builtins.True , you will be required to opt-in to using this intent on the Discord Developer Portal before you can utilise it in your application."
},
{
"ref":"hikari.intents.Intents.name",
"url":47,
"doc":"Return the name of the flag combination as a  builtins.str ."
},
{
"ref":"hikari.intents.Intents.value",
"url":47,
"doc":"Return the  builtins.int value of the flag."
},
{
"ref":"hikari.intents.Intents.all",
"url":47,
"doc":"Check if all of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.intents.Intents.any",
"url":47,
"doc":"Check if any of the given flags are part of this value. Returns    - builtins.bool  builtins.True if any of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.intents.Intents.difference",
"url":47,
"doc":"Perform a set difference with the other set. This will return all flags in this set that are not in the other value. Equivalent to using the subtraction  - operator.",
"func":1
},
{
"ref":"hikari.intents.Intents.intersection",
"url":47,
"doc":"Return a combination of flags that are set for both given values. Equivalent to using the \"AND\"  & operator.",
"func":1
},
{
"ref":"hikari.intents.Intents.invert",
"url":47,
"doc":"Return a set of all flags not in the current set.",
"func":1
},
{
"ref":"hikari.intents.Intents.is_disjoint",
"url":47,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.intents.Intents.is_subset",
"url":47,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.intents.Intents.is_superset",
"url":47,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.intents.Intents.none",
"url":47,
"doc":"Check if none of the given flags are part of this value.  ! note This is essentially the opposite of  Flag.any . Returns    - builtins.bool  builtins.True if none of the given flags are part of this value. Otherwise, return  builtins.False .",
"func":1
},
{
"ref":"hikari.intents.Intents.split",
"url":47,
"doc":"Return a list of all defined atomic values for this flag. Any unrecognised bits will be omitted for brevity. The result will be a name-sorted  typing.Sequence of each membe",
"func":1
},
{
"ref":"hikari.intents.Intents.symmetric_difference",
"url":47,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.intents.Intents.union",
"url":47,
"doc":"Return a combination of all flags in this set and the other set. Equivalent to using the \"OR\"  ~ operator.",
"func":1
},
{
"ref":"hikari.intents.Intents.isdisjoint",
"url":47,
"doc":"Return whether two sets have a intersection or not. If the two sets have an intersection, then this returns  builtins.False . If no common flag values exist between them, then this returns  builtins.True .",
"func":1
},
{
"ref":"hikari.intents.Intents.issubset",
"url":47,
"doc":"Return whether another set contains this set or not. Equivalent to using the \"in\" operator.",
"func":1
},
{
"ref":"hikari.intents.Intents.issuperset",
"url":47,
"doc":"Return whether this set contains another set or not.",
"func":1
},
{
"ref":"hikari.intents.Intents.symmetricdifference",
"url":47,
"doc":"Return a set with the symmetric differences of two flag sets. Equivalent to using the \"XOR\"  ^ operator. For  a ^ b , this can be considered the same as  (a - b) | (b - a) .",
"func":1
},
{
"ref":"hikari.intents.Intents.NONE",
"url":47,
"doc":"Represents no intents."
},
{
"ref":"hikari.intents.Intents.GUILDS",
"url":47,
"doc":"Subscribes to the following events:   GUILD_CREATE   GUILD_UPDATE   GUILD_DELETE   GUILD_ROLE_CREATE   GUILD_ROLE_UPDATE   GUILD_ROLE_DELETE   CHANNEL_CREATE   CHANNEL_UPDATE   CHANNEL_DELETE   CHANNEL_PINS_UPDATE "
},
{
"ref":"hikari.intents.Intents.GUILD_MEMBERS",
"url":47,
"doc":"Subscribes to the following events:   GUILD_MEMBER_ADD   GUILD_MEMBER_UPDATE   GUILD_MEMBER_REMOVE  ! warning This intent is privileged, and requires enabling/whitelisting to use."
},
{
"ref":"hikari.intents.Intents.GUILD_BANS",
"url":47,
"doc":"Subscribes to the following events:   GUILD_BAN_ADD   GUILD_BAN_REMOVE "
},
{
"ref":"hikari.intents.Intents.GUILD_EMOJIS",
"url":47,
"doc":"Subscribes to the following events:   GUILD_EMOJIS_UPDATE "
},
{
"ref":"hikari.intents.Intents.GUILD_INTEGRATIONS",
"url":47,
"doc":"Subscribes to the following events:   GUILD_INTEGRATIONS_UPDATE "
},
{
"ref":"hikari.intents.Intents.GUILD_WEBHOOKS",
"url":47,
"doc":"Subscribes to the following events:   WEBHOOKS_UPDATE "
},
{
"ref":"hikari.intents.Intents.GUILD_INVITES",
"url":47,
"doc":"Subscribes to the following events:   INVITE_CREATE   INVITE_DELETE "
},
{
"ref":"hikari.intents.Intents.GUILD_VOICE_STATES",
"url":47,
"doc":"Subscribes to the following events:   VOICE_STATE_UPDATE "
},
{
"ref":"hikari.intents.Intents.GUILD_PRESENCES",
"url":47,
"doc":"Subscribes to the following events:   PRESENCE_UPDATE  ! warning This intent is privileged, and requires enabling/whitelisting to use."
},
{
"ref":"hikari.intents.Intents.GUILD_MESSAGES",
"url":47,
"doc":"Subscribes to the following events:   MESSAGE_CREATE (in guilds only)   MESSAGE_UPDATE (in guilds only)   MESSAGE_DELETE (in guilds only)   MESSAGE_BULK_DELETE (in guilds only)"
},
{
"ref":"hikari.intents.Intents.GUILD_MESSAGE_REACTIONS",
"url":47,
"doc":"Subscribes to the following events:   MESSAGE_REACTION_ADD (in guilds only)   MESSAGE_REACTION_REMOVE (in guilds only)   MESSAGE_REACTION_REMOVE_ALL (in guilds only)   MESSAGE_REACTION_REMOVE_EMOJI (in guilds only)"
},
{
"ref":"hikari.intents.Intents.GUILD_MESSAGE_TYPING",
"url":47,
"doc":"Subscribes to the following events:   TYPING_START (in guilds only)"
},
{
"ref":"hikari.intents.Intents.DM_MESSAGES",
"url":47,
"doc":"Subscribes to the following events:   MESSAGE_CREATE (in private message channels (non-guild bound) only)   MESSAGE_UPDATE (in private message channels (non-guild bound) only)   MESSAGE_DELETE (in private message channels (non-guild bound) only)"
},
{
"ref":"hikari.intents.Intents.DM_MESSAGE_REACTIONS",
"url":47,
"doc":"Subscribes to the following events:   MESSAGE_REACTION_ADD (in private message channels (non-guild bound) only)   MESSAGE_REACTION_REMOVE (in private message channels (non-guild bound) only)   MESSAGE_REACTION_REMOVE_ALL (in private message channels (non-guild bound) only)   MESSAGE_REACTION_REMOVE_EMOJI (in private message channels (non-guild bound) only)"
},
{
"ref":"hikari.intents.Intents.DM_MESSAGE_TYPING",
"url":47,
"doc":"Subscribes to the following events   TYPING_START (in private message channels (non-guild bound) only)"
},
{
"ref":"hikari.intents.Intents.ALL_GUILDS_UNPRIVILEGED",
"url":47,
"doc":"All unprivileged guild-related intents."
},
{
"ref":"hikari.intents.Intents.ALL_GUILDS_PRIVILEGED",
"url":47,
"doc":"All privileged guild intents.  ! warning This set of intent is privileged, and requires enabling/whitelisting to use."
},
{
"ref":"hikari.intents.Intents.ALL_GUILDS",
"url":47,
"doc":"All unprivileged guild intents and all privileged guild intents. This combines  Intents.ALL_GUILDS_UNPRIVILEGED and  Intents.ALL_GUILDS_PRIVILEGED .  ! warning This set of intent is privileged, and requires enabling/whitelisting to use."
},
{
"ref":"hikari.intents.Intents.ALL_DMS",
"url":47,
"doc":"All private message channel (non-guild bound) intents."
},
{
"ref":"hikari.intents.Intents.ALL_MESSAGES",
"url":47,
"doc":"All message intents."
},
{
"ref":"hikari.intents.Intents.ALL_MESSAGE_REACTIONS",
"url":47,
"doc":"All message reaction intents."
},
{
"ref":"hikari.intents.Intents.ALL_MESSAGE_TYPING",
"url":47,
"doc":"All typing indicator intents."
},
{
"ref":"hikari.intents.Intents.ALL_UNPRIVILEGED",
"url":47,
"doc":"All unprivileged intents."
},
{
"ref":"hikari.intents.Intents.ALL_PRIVILEGED",
"url":47,
"doc":"All privileged intents.  ! warning This set of intent is privileged, and requires enabling/whitelisting to use."
},
{
"ref":"hikari.intents.Intents.ALL",
"url":47,
"doc":"All unprivileged and privileged intents.  ! warning This set of intent is privileged, and requires enabling/whitelisting to use."
},
{
"ref":"hikari.api",
"url":48,
"doc":"Interfaces for components that make up Hikari applications. These are provided to uncouple specific implementation details from each implementation, thus allowing custom solutions to be engineered such as bots relying on a distributed event bus or cache."
},
{
"ref":"hikari.api.voice",
"url":49,
"doc":"Interfaces used to describe voice client implementations."
},
{
"ref":"hikari.api.voice.VoiceComponent",
"url":49,
"doc":"Interface for a voice system implementation."
},
{
"ref":"hikari.api.voice.VoiceComponent.connections",
"url":49,
"doc":"Return a mapping of guild-id to active voice connection."
},
{
"ref":"hikari.api.voice.VoiceComponent.close",
"url":49,
"doc":"Shut down all connections, waiting for them to terminate. Once this is done, unsubscribe from any events. If you simply wish to disconnect every connection, use  disconnect instead.",
"func":1
},
{
"ref":"hikari.api.voice.VoiceComponent.disconnect",
"url":49,
"doc":"Shut down all connections, waiting for them to terminate. This will not close the voice component.",
"func":1
},
{
"ref":"hikari.api.voice.VoiceComponent.connect_to",
"url":49,
"doc":"Connect to a given voice channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel] The channel or channel ID to connect to. guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.Guild] The guild to connect to. deaf : builtins.bool Defaulting to  builtins.False , if  builtins.True , the client will enter the voice channel deafened (thus unable to hear other users). mute : builtins.bool Defaulting to  builtins.False , if  builtins.True , the client will enter the voice channel muted (thus unable to send audio). voice_connection_type : typing.Type[VoiceConnection] The type of voice connection to use. This should be initialized internally using the  IVoiceConnection.initialize  builtins.classmethod .  kwargs : typing.Any Any arguments to provide to the  IVoiceConnection.initialize method. Returns    - VoiceConnection A voice connection implementation of some sort.",
"func":1
},
{
"ref":"hikari.api.voice.VoiceConnection",
"url":49,
"doc":"An abstract interface for defining how bots can interact with voice. Since voice will generally be run in a subprocess to prevent interfering with the bot when performing CPU-bound encoding/encryption, any implementation of this is expected to implement the appropriate mechanisms for communicating with a voice subprocess and controlling it, however, this is left to the discretion of each implementation. Control is left to the implementation to define how to perform it. The idea is to allow various decoders to be implemented to allow this to direct interface with other types of system outside this library, such as LavaLink, for example."
},
{
"ref":"hikari.api.voice.VoiceConnection.initialize",
"url":49,
"doc":"Initialize and connect the voice connection. Parameters      channel_id : hikari.snowflakes.Snowflake The channel ID that the voice connection is actively connected to. debug : builtins.bool  builtins.True if debugging mode should be enabled. This is up to each implementation to decide how to provide this, if at all. endpoint : str The voice websocket endpoint to connect to. Will contain the protocol at the start (i.e.  wss:  ), and end with the  correct port (the port and protocol are sanitized since Discord still provide the wrong information four years later). guild_id : hikari.snowflakes.Snowflake The guild ID that the websocket should connect to. on_close : typing.Callable T], typing.Awaitable[None A shutdown hook to invoke when closing a connection to ensure the connection is unregistered from the voice component safely. owner : VoiceComponent The component that made this connection object. session_id : builtins.str The voice session ID to use. shard_id : builtins.int The associated shard ID that the voice connection was generated from. token : builtins.str The voice token to use. user_id : hikari.snowflakes.Snowflake The user ID of the account that just joined the voice channel.  kwargs : typing.Any Any implementation-specific arguments to provide to the voice connection that is being initialized. Returns    - T The type of this connection object.",
"func":1
},
{
"ref":"hikari.api.voice.VoiceConnection.channel_id",
"url":49,
"doc":"Return the ID of the voice channel this voice connection is in."
},
{
"ref":"hikari.api.voice.VoiceConnection.guild_id",
"url":49,
"doc":"Return the ID of the guild this voice connection is in."
},
{
"ref":"hikari.api.voice.VoiceConnection.is_alive",
"url":49,
"doc":"Return  builtins.True if the connection is alive."
},
{
"ref":"hikari.api.voice.VoiceConnection.shard_id",
"url":49,
"doc":"Return the ID of the shard that requested the connection."
},
{
"ref":"hikari.api.voice.VoiceConnection.owner",
"url":49,
"doc":"Return the component that is managing this connection."
},
{
"ref":"hikari.api.voice.VoiceConnection.disconnect",
"url":49,
"doc":"Signal the process to shut down.",
"func":1
},
{
"ref":"hikari.api.voice.VoiceConnection.join",
"url":49,
"doc":"Wait for the process to halt before continuing.",
"func":1
},
{
"ref":"hikari.api.voice.VoiceConnection.notify",
"url":49,
"doc":"Submit an event to the voice connection to be processed.",
"func":1
},
{
"ref":"hikari.api.cache",
"url":50,
"doc":"Core interface for a cache implementation."
},
{
"ref":"hikari.api.cache.CacheView",
"url":50,
"doc":"Interface describing an immutable snapshot view of part of a cache."
},
{
"ref":"hikari.api.cache.CacheView.get_item_at",
"url":50,
"doc":"Get an entry in the view at position  index .",
"func":1
},
{
"ref":"hikari.api.cache.CacheView.iterator",
"url":50,
"doc":"Get a lazy iterator of the entities in the view.",
"func":1
},
{
"ref":"hikari.api.cache.Cache",
"url":50,
"doc":"Interface describing the operations a cache component should provide. This will be used by the gateway and HTTP API to cache specific types of objects that the application should attempt to remember for later, depending on how this is implemented. The requirement for this stems from the assumption by Discord that bot applications will maintain some form of \"memory\" of the events that occur. The implementation may choose to use a simple in-memory collection of objects, or may decide to use a distributed system such as a Redis cache for cross-process bots.  ! note For a stateless implementation of this cache getting methods will always return empty resources (e.g  builtins.None and empty cache views)."
},
{
"ref":"hikari.api.cache.Cache.get_emoji",
"url":50,
"doc":"Get a known custom emoji from the cache. Parameters      emoji_id : hikari.snowflakes.Snowflake The ID of the emoji to get from the cache. Returns    - typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_emojis_view",
"url":50,
"doc":"Get a view of the known custom emoji objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the known custom emojis found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_emojis_view_for_guild",
"url":50,
"doc":"Get a view of the known custom emojis cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached emoji objects for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of emojis found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_guild",
"url":50,
"doc":"Get a guild from the cache.  ! warning This will return a guild regardless of whether it is available or not. To only query available guilds, use  get_available_guild instead. Likewise, to only query unavailable guilds, use  get_unavailable_guild . Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_available_guild",
"url":50,
"doc":"Get the object of an available guild from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_unavailable_guild",
"url":50,
"doc":"Get the object of a unavailable guild from the cache.  ! note Unlike  Cache.get_available_guild , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_available_guilds_view",
"url":50,
"doc":"Get a view of the available guild objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_unavailable_guilds_view",
"url":50,
"doc":"Get a view of the unavailable guild objects in the cache.  ! note Unlike  Cache.get_available_guilds_view , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_guild_channel",
"url":50,
"doc":"Get a guild channel from the cache. Parameters      channel_id : hikari.snowflakes.Snowflake The ID of the guild channel to get from the cache. Returns    - typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_guild_channels_view",
"url":50,
"doc":"Get a view of the guild channels in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_guild_channels_view_for_guild",
"url":50,
"doc":"Get a view of the guild channels in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_invite",
"url":50,
"doc":"Get an invite object from the cache. Parameters      code : str The string code of the invite to get from the cache. Returns    - typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_invites_view",
"url":50,
"doc":"Get a view of the invite objects in the cache. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string codes to objects of the invites that were found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_invites_view_for_guild",
"url":50,
"doc":"Get a view of the invite objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string code to objects of the invites that were found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_invites_view_for_channel",
"url":50,
"doc":"Get a view of the invite objects in the cache for a specified channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get invite objects for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to get invite objects for. Returns    - CacheView[str, invites.InviteWithMetadata] A view of string codes to objects of the invites there were found in the cache for the specified channel.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_me",
"url":50,
"doc":"Get the own user object from the cache. Returns    - typing.Optional[hikari.users.OwnUser] The own user object that was found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_member",
"url":50,
"doc":"Get a member object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake user_id : hikari.snowflakes.Snowflake Returns    - typing.Optional[hikari.guilds.Member] The object of the member found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_members_view",
"url":50,
"doc":"Get a view of all the members objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were found from the cache.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_members_view_for_guild",
"url":50,
"doc":"Get a view of the members cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached member view for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the members cached for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_presence",
"url":50,
"doc":"Get a presence object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get a presence for. user_id : hikari.snowflakes.Snowflake The ID of the user to get a presence for. Returns    - typing.Optional[hikari.presences.MemberPresence] The object of the presence that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_presences_view",
"url":50,
"doc":"Get a view of all the presence objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake A view of guild IDs to views of user IDs to objects of the presences found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_presences_view_for_guild",
"url":50,
"doc":"Get a view of the presence objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached presence objects for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presence found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_role",
"url":50,
"doc":"Get a role object from the cache. Parameters      role_id : hikari.snowflakes.Snowflake The ID of the role to get from the cache. Returns    - typing.Optional[hikari.guilds.Role] The object of the role found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_roles_view",
"url":50,
"doc":"Get a view of all the role objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_roles_view_for_guild",
"url":50,
"doc":"Get a view of the roles in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached roles for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_user",
"url":50,
"doc":"Get a user object from the cache. Parameters      user_id : hikari.snowflakes.Snowflake The ID of the user to get from the cache. Returns    - typing.Optional[hikari.users.User] The object of the user that was found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_users_view",
"url":50,
"doc":"Get a view of the user objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the users found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_voice_state",
"url":50,
"doc":"Get a voice state object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get a voice state for. user_id :hikari.snowflakes.Snowflake The ID of the user to get a voice state for. Returns    - typing.Optional[hikari.voices.VoiceState] The object of the voice state that was found in the cache, or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_voice_states_view",
"url":50,
"doc":"Get a view of all the voice state objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were found in the cache,",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_voice_states_view_for_channel",
"url":50,
"doc":"Get a view of the voice states cached for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached voice states for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to get the cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified channel.",
"func":1
},
{
"ref":"hikari.api.cache.Cache.get_voice_states_view_for_guild",
"url":50,
"doc":"Get a view of the voice states cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache",
"url":50,
"doc":"Cache that exposes read-only operations as well as mutation operations. This is only exposed to internal components. There is no guarantee the user-facing cache will provide these methods or not.  ! note For a \"stateless\" implementation of this getting methods will always return empty resources (e.g  builtins.None and empty cache views) while modifying methods will always raise  builtins.NotImplementedError when they are called."
},
{
"ref":"hikari.api.cache.MutableCache.clear_emojis",
"url":50,
"doc":"Remove all the known custom emoji objects from the cache.  ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A cache view of emoji IDs to objects of the emojis that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_emojis_for_guild",
"url":50,
"doc":"Remove the known custom emoji objects cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove the cached emoji objects for.  ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the emojis that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_emoji",
"url":50,
"doc":"Remove a known custom emoji from the cache. Parameters      emoji_id : hikari.snowflakes.Snowflake The ID of the emoji to remove from the cache.  ! note This will not delete emojis that are being kept alive by a reference on a presence entry. Returns    - typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was removed from the cache or  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_emoji",
"url":50,
"doc":"Add a known custom emoji to the cache. Parameters      emoji : hikari.emojis.KnownCustomEmoji The object of the known custom emoji to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_emoji",
"url":50,
"doc":"Update an emoji object in the cache. Parameters      emoji : hikari.emojis.KnownCustomEmoji The object of the emoji to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.emojis.KnownCustomEmoji], typing.Optional[hikari.emojis.KnownCustomEmoji A tuple of the old cached emoji object if found (else  builtins.None ) and the new cached emoji object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_guilds",
"url":50,
"doc":"Remove all the guild objects from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] The cache view of guild IDs to guild objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_guild",
"url":50,
"doc":"Remove a guild object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild that was removed from the cache, will be  builtins.None if not found. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_guild",
"url":50,
"doc":"Add a guild object to the cache. Parameters      guild : hikari.guilds.GatewayGuild The object of the guild to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_guild_availability",
"url":50,
"doc":"Set whether a cached guild is available or not. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to set the availability for. is_available : builtins.bool The availability to set for the guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_guild",
"url":50,
"doc":"Update a guild in the cache. Parameters      guild : hikari.guilds.GatewayGuild The object of the guild to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.guilds.GatewayGuild], typing.Optional[hikari.guilds.GatewayGuild A tuple of the old cached guild object if found (else  builtins.None ) and the object of the guild that was added to the cache if it could be added (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_guild_channels",
"url":50,
"doc":"Remove all guild channels from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_guild_channels_for_guild",
"url":50,
"doc":"Remove guild channels from the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove cached channels for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_guild_channel",
"url":50,
"doc":"Remove a guild channel from the cache. Parameters      channel_id : hikari.snowflakes.Snowflake The ID of the guild channel to remove from the cache. Returns    - typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_guild_channel",
"url":50,
"doc":"Add a guild channel to the cache. Parameters      channel : hikari.channels.GuildChannel The guild channel based object to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_guild_channel",
"url":50,
"doc":"Update a guild channel in the cache, Parameters      channel : hikari.channels.GuildChannel The object of the channel to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.channels.GuildChannel], typing.Optional[hikari.channels.GuildChannel A tuple of the old cached guild channel if found (else  builtins.None ) and the new cached guild channel if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_invites",
"url":50,
"doc":"Remove all the invite objects from the cache. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_invites_for_guild",
"url":50,
"doc":"Remove the invite objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_invites_for_channel",
"url":50,
"doc":"Remove the invite objects in the cache for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove invite objects for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to remove invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified channel. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_invite",
"url":50,
"doc":"Remove an invite object from the cache. Parameters      code : str The string code of the invite to remove from the cache. Returns    - typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_invite",
"url":50,
"doc":"Add an invite object to the cache. Parameters      invite : hikari.invites.InviteWithMetadata The object of the invite to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_invite",
"url":50,
"doc":"Update an invite in the cache. Parameters      invite : hikari.invites.InviteWithMetadata The object of the invite to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.invites.InviteWithMetadata], typing.Optional[hikari.invites.InviteWithMetadata A tuple of the old cached invite object if found (else  builtins.None ) and the new cached invite object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_me",
"url":50,
"doc":"Remove the own user object from the cache. Returns    - typing.Optional[hikari.users.OwnUser] The own user object that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_me",
"url":50,
"doc":"Set the own user object in the cache. Parameters      user : hikari.users.OwnUser The own user object to set in the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_me",
"url":50,
"doc":"Update the own user entry in the cache. Parameters      user : hikari.users.OwnUser The own user object to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.users.OwnUser], typing.Optional[hikari.users.OwnUser A tuple of the old cached own user object if found (else  builtins.None ) and the new cached own user object if it could be cached, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_members",
"url":50,
"doc":"Remove all the guild members in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_members_for_guild",
"url":50,
"doc":"Remove the members for a specific guild from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove cached members for.  ! note This will skip members that are being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the member objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_member",
"url":50,
"doc":"Remove a member object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove a member from the cache for. user_id : hikari.snowflakes.Snowflake The ID of the user to remove a member from the cache for.  ! note You cannot delete a member entry that's being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns    - typing.Optional[hikari.guilds.Member] The object of the member that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_member",
"url":50,
"doc":"Add a member object to the cache. Parameters      member : hikari.guilds.Member The object of the member to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_member",
"url":50,
"doc":"Update a member in the cache. Parameters      member : hikari.guilds.Member The object of the member to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.guilds.Member], typing.Optional[hikari.guilds.Member A tuple of the old cached member object if found (else  builtins.None ) and the new cached member object if it could be cached (else  builtins.None ) Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_presences",
"url":50,
"doc":"Remove all the presences in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence A view of guild IDs to views of user IDs to objects of the presences that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_presences_for_guild",
"url":50,
"doc":"Remove the presences in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove presences for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presences that were removed from the cache for the specified guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_presence",
"url":50,
"doc":"Remove a presence from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove a presence for. user_id : hikari.snowflakes.Snowflake The ID of the user to remove a presence for. Returns    - typing.Optional[hikari.presences.MemberPresence] The object of the presence that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_presence",
"url":50,
"doc":"Add a presence object to the cache. Parameters      presence : hikari.presences.MemberPresence The object of the presence to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_presence",
"url":50,
"doc":"Update a presence object in the cache. Parameters      presence : hikari.presences.MemberPresence The object of the presence to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.presences.MemberPresence], typing.Optional[hikari.presences.MemberPresence A tuple of the old cached invite object if found (else  builtins.None and the new cached invite object if it could be cached ( else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_roles",
"url":50,
"doc":"Remove all role objects from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_roles_for_guild",
"url":50,
"doc":"Remove role objects from the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove roles for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache for the specific guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_role",
"url":50,
"doc":"Remove a role object form the cache. Parameters      role_id : hikari.snowflakes.Snowflake The ID of the role to remove from the cache. Returns    - typing.Optional[hikari.guilds.Role] The object of the role that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_role",
"url":50,
"doc":"Add a role object to the cache. Parameters      role : hikari.guilds.Role The object of the role to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_role",
"url":50,
"doc":"Update a role in the cache. Parameters      role : hikari.guilds.Role The object of the role to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.guilds.Role], typing.Optional[hikari.guilds.Role A tuple of the old cached role object if found (else  builtins.None and the new cached role object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_users",
"url":50,
"doc":"Clear the user objects from the cache.  ! note This will skip users that are being referenced by other entries within the cache; member entries and DM entries will keep a user alive within the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the user objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_user",
"url":50,
"doc":"Remove a user object from the cache. Parameters      user_id : hikari.snowflakes.Snowflake The ID of the user to remove from the cache.  ! note You cannot delete a user object while it's being referenced by other entries within the cache; member entries and DM entries will keep a user alive within the cache. Returns    - typing.Optional[hikari.users.User] The object of the user that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_user",
"url":50,
"doc":"Add a user object to the cache. Parameters      user : hikari.users.User The object of the user to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_user",
"url":50,
"doc":"Update a user object in the cache. Parameters      user : hikari.users.User The object of the user to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.users.User], typing.Optional[hikari.users.User A tuple of the old cached user if found (else  builtins.None ) and the newly cached user if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_voice_states",
"url":50,
"doc":"Remove all voice state objects from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were removed from the states. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_voice_states_for_guild",
"url":50,
"doc":"Clear the voice state objects cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to the voice state objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.clear_voice_states_for_channel",
"url":50,
"doc":"Remove the voice state objects cached for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove voice states for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to remove voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice state that were removed from the cache for the specified channel. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.delete_voice_state",
"url":50,
"doc":"Remove a voice state object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild the voice state to remove is related to. user_id : hikari.snowflakes.Snowflake The ID of the user who the voice state to remove belongs to. Returns    - typing.Optional[hikari.voices.VoiceState] The object of the voice state that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.set_voice_state",
"url":50,
"doc":"Add a voice state object to the cache. Parameters      voice_state : hikari.voices.VoiceState The object of the voice state to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.update_voice_state",
"url":50,
"doc":"Update a voice state object in the cache. Parameters      voice_state : hikari.voices.VoiceState The object of the voice state to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.voices.VoiceState], typing.Optional[hikari.voices.VoiceState A tuple of the old cached voice state if found (else  builtins.None ) and the new cached voice state object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_emoji",
"url":50,
"doc":"Get a known custom emoji from the cache. Parameters      emoji_id : hikari.snowflakes.Snowflake The ID of the emoji to get from the cache. Returns    - typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_emojis_view",
"url":50,
"doc":"Get a view of the known custom emoji objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the known custom emojis found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_emojis_view_for_guild",
"url":50,
"doc":"Get a view of the known custom emojis cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached emoji objects for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of emojis found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_guild",
"url":50,
"doc":"Get a guild from the cache.  ! warning This will return a guild regardless of whether it is available or not. To only query available guilds, use  get_available_guild instead. Likewise, to only query unavailable guilds, use  get_unavailable_guild . Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_available_guild",
"url":50,
"doc":"Get the object of an available guild from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_unavailable_guild",
"url":50,
"doc":"Get the object of a unavailable guild from the cache.  ! note Unlike  Cache.get_available_guild , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_available_guilds_view",
"url":50,
"doc":"Get a view of the available guild objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_unavailable_guilds_view",
"url":50,
"doc":"Get a view of the unavailable guild objects in the cache.  ! note Unlike  Cache.get_available_guilds_view , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_guild_channel",
"url":50,
"doc":"Get a guild channel from the cache. Parameters      channel_id : hikari.snowflakes.Snowflake The ID of the guild channel to get from the cache. Returns    - typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_guild_channels_view",
"url":50,
"doc":"Get a view of the guild channels in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_guild_channels_view_for_guild",
"url":50,
"doc":"Get a view of the guild channels in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_invite",
"url":50,
"doc":"Get an invite object from the cache. Parameters      code : str The string code of the invite to get from the cache. Returns    - typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_invites_view",
"url":50,
"doc":"Get a view of the invite objects in the cache. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string codes to objects of the invites that were found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_invites_view_for_guild",
"url":50,
"doc":"Get a view of the invite objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string code to objects of the invites that were found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_invites_view_for_channel",
"url":50,
"doc":"Get a view of the invite objects in the cache for a specified channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get invite objects for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to get invite objects for. Returns    - CacheView[str, invites.InviteWithMetadata] A view of string codes to objects of the invites there were found in the cache for the specified channel.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_me",
"url":50,
"doc":"Get the own user object from the cache. Returns    - typing.Optional[hikari.users.OwnUser] The own user object that was found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_member",
"url":50,
"doc":"Get a member object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake user_id : hikari.snowflakes.Snowflake Returns    - typing.Optional[hikari.guilds.Member] The object of the member found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_members_view",
"url":50,
"doc":"Get a view of all the members objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were found from the cache.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_members_view_for_guild",
"url":50,
"doc":"Get a view of the members cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached member view for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the members cached for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_presence",
"url":50,
"doc":"Get a presence object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get a presence for. user_id : hikari.snowflakes.Snowflake The ID of the user to get a presence for. Returns    - typing.Optional[hikari.presences.MemberPresence] The object of the presence that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_presences_view",
"url":50,
"doc":"Get a view of all the presence objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake A view of guild IDs to views of user IDs to objects of the presences found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_presences_view_for_guild",
"url":50,
"doc":"Get a view of the presence objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached presence objects for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presence found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_role",
"url":50,
"doc":"Get a role object from the cache. Parameters      role_id : hikari.snowflakes.Snowflake The ID of the role to get from the cache. Returns    - typing.Optional[hikari.guilds.Role] The object of the role found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_roles_view",
"url":50,
"doc":"Get a view of all the role objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_roles_view_for_guild",
"url":50,
"doc":"Get a view of the roles in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached roles for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_user",
"url":50,
"doc":"Get a user object from the cache. Parameters      user_id : hikari.snowflakes.Snowflake The ID of the user to get from the cache. Returns    - typing.Optional[hikari.users.User] The object of the user that was found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_users_view",
"url":50,
"doc":"Get a view of the user objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the users found in the cache.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_voice_state",
"url":50,
"doc":"Get a voice state object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get a voice state for. user_id :hikari.snowflakes.Snowflake The ID of the user to get a voice state for. Returns    - typing.Optional[hikari.voices.VoiceState] The object of the voice state that was found in the cache, or  builtins.None .",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_voice_states_view",
"url":50,
"doc":"Get a view of all the voice state objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were found in the cache,",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_voice_states_view_for_channel",
"url":50,
"doc":"Get a view of the voice states cached for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached voice states for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to get the cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified channel.",
"func":1
},
{
"ref":"hikari.api.cache.MutableCache.get_voice_states_view_for_guild",
"url":50,
"doc":"Get a view of the voice states cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified guild.",
"func":1
},
{
"ref":"hikari.api.rest",
"url":51,
"doc":"Provides an interface for REST API implementations to follow."
},
{
"ref":"hikari.api.rest.ConnectorFactory",
"url":51,
"doc":"Provider of a connector."
},
{
"ref":"hikari.api.rest.ConnectorFactory.close",
"url":51,
"doc":"Close any resources if they exist.",
"func":1
},
{
"ref":"hikari.api.rest.ConnectorFactory.acquire",
"url":51,
"doc":"Acquire the connector.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient",
"url":51,
"doc":"Interface for functionality that a REST API implementation provides."
},
{
"ref":"hikari.api.rest.RESTClient.close",
"url":51,
"doc":"Close the client session.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_channel",
"url":51,
"doc":"Fetch a channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The channel to fetch. This may be the object or the ID of an existing channel. Returns    - hikari.channels.PartialChannel The channel. This will be a _derivative_ of  hikari.channels.PartialChannel , depending on the type of channel you request for. This means that you may get one of  hikari.channels.DMChannel ,  hikari.channels.GroupDMChannel ,  hikari.channels.GuildTextChannel ,  hikari.channels.GuildVoiceChannel ,  hikari.channels.GuildStoreChannel ,  hikari.channels.GuildNewsChannel . Likewise, the  hikari.channels.GuildChannel can be used to determine if a channel is guild-bound, and  hikari.channels.TextChannel can be used to determine if the channel provides textual functionality to the application. You can check for these using the  builtins.isinstance builtin function. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  READ_MESSAGES permission in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_channel",
"url":51,
"doc":"Edit a channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to edit. This may be the object or the ID of an existing channel. Other Parameters         name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel. position : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel. topic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel. nsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not. bitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel. user_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel. rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel. parent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.PartialChannel The edited channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing permissions to edit the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.follow_channel",
"url":51,
"doc":"Follow a news channel to send messages to a target channel. Parameters      news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel] The object or ID of the news channel to follow. target_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The object or ID of the channel to target. Returns    - hikari.channels.ChannelFollow Information about the new relationship that was made. Raises    hikari.errors.BadRequestError If you try to follow a channel that's not a news channel or if the target channel has reached it's webhook limit, which is 10 at the time of writing. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission in the target channel or are missing the  VIEW_CHANNEL permission in the origin channel. hikari.errors.NotFoundError If the origin or target channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_channel",
"url":51,
"doc":"Delete a channel in a guild, or close a DM. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The channel to delete. This may be the object or the ID of an existing channel. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_permission_overwrites",
"url":51,
"doc":"Edit permissions for a specific entity in the given guild channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to edit a permission overwrite in. This may be the object, or the ID of an existing channel. target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters         target_type : hikari.undefined.UndefinedOr[hikari.channels.PermissionOverwriteType] If provided, the type of the target to update. If unset, will attempt to get the type from  target . allow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions. deny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    builtins.TypeError If  target_type is unset and we were unable to determine the type from  target . hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_PERMISSIONS permission in the channel. hikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_permission_overwrite",
"url":51,
"doc":"Delete a custom permission for an entity in a given guild channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to delete a permission overwrite in. This may be the object, or the ID of an existing channel. target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_PERMISSIONS permission in the channel. hikari.errors.NotFoundError If the channel is not found or the target is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_channel_invites",
"url":51,
"doc":"Fetch all invites pointing to the given guild channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to fetch the invites from. This may be a channel object, or the ID of an existing channel. Returns    - typing.Sequence[hikari.invites.InviteWithMetadata] The invites pointing to the given guild channel. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission in the channel. hikari.errors.NotFoundError If the channel is not found in any guilds you are a member of. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_invite",
"url":51,
"doc":"Create an invite to the given guild channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to create a invite for. This may be the object or the ID of an existing channel. Other Parameters         max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, builtins.float, builtins.int If provided, the duration of the invite before expiry. max_uses : hikari.undefined.UndefinedOr[builtins.int] If provided, the max uses the invite can have. temporary : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the invite only grants temporary membership. unique : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the invite should be unique. target_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser If provided, the target user id for this invite. This may be the object or the ID of an existing user. target_user_type : hikari.undefined.UndefinedOr[hikari.invites.TargetUserType] If provided, the type of target user for this invite. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.invites.InviteWithMetadata The invite to the given guild channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNELS permission. hikari.errors.NotFoundError If the channel is not found, or if the target user does not exist, if provided. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.trigger_typing",
"url":51,
"doc":"Trigger typing in a text channel. The result of this call can be awaited to trigger typing once, or can be used as an async context manager to continually type until the context manager is left. Examples        Trigger typing just once. await rest.trigger_typing(channel)  Trigger typing repeatedly for 1 minute. async with rest.trigger_typing(channel): await asyncio.sleep(60)    ! warning Sending a message to the channel will cause the typing indicator to disappear until it is re-triggered. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to trigger typing in. This may be the object or the ID of an existing channel. Returns    - hikari.api.special_endpoints.TypingIndicator A typing indicator to use. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  SEND_MESSAGES in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise any of the above types.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_pins",
"url":51,
"doc":"Fetch the pinned messages in this text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to fetch pins from. This may be the object or the ID of an existing channel. Returns    - typing.Sequence[hikari.messages.Message] The pinned messages in this text channel. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  READ_MESSAGES in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.pin_message",
"url":51,
"doc":"Pin an existing message in the given text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to pin a message in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to pin. This may be the object or the ID of an existing message. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES in the channel. hikari.errors.NotFoundError If the channel is not found, or if the message does not exist in the given channel. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.unpin_message",
"url":51,
"doc":"Unpin a given message from a given text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to unpin a message in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to unpin. This may be the object or the ID of an existing message. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission. hikari.errors.NotFoundError If the channel is not found or the message is not a pinned message in the given channel. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_messages",
"url":51,
"doc":"Browse the message history for a given text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to fetch messages in. This may be the object or the ID of an existing channel. Other Parameters         before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.messages.Message] An iterator to fetch the messages.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    builtins.TypeError If you specify more than one of  before ,  after ,  about . hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  READ_MESSAGE_HISTORY in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint (other than  builtins.TypeError ) will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything (other than  builtins.TypeError ).",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_message",
"url":51,
"doc":"Fetch a specific message in the given text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to fetch messages in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns    - hikari.messages.Message The requested message. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  READ_MESSAGE_HISTORY in the channel. hikari.errors.NotFoundError If the channel is not found or the message is not found in the given text channel. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_message",
"url":51,
"doc":"Create a message in the given channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to create the message in. content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. nonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all user mentions will be detected. If provided, and  builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all role mentions will be detected. If provided, and  builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified. hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_crossposts",
"url":51,
"doc":"Broadcast an announcement message. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel] The object or ID of the news channel to crosspost a message in. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The object or ID of the message to crosspost. Returns    - hikari.messages.Message The message object that was crossposted. Raises    hikari.errors.BadRequestError If you tried to crosspost a message that has already been broadcast. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you try to crosspost a message by the current user without the  SEND_MESSAGES permission for the target news channel or try to crosspost a message by another user without both the  SEND_MESSAGES and  MANAGE_MESSAGES permissions for the target channel. hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_message",
"url":51,
"doc":"Edit an existing message in a given channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to create the message in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to edit. This may be the object or the ID of an existing message. content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If  hikari.undefined.UNDEFINED , then the content will not be changed. If  builtins.None , then the content will be removed. Any other value will be cast to a  builtins.str before sending. If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Other Parameters         embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If  hikari.undefined.UNDEFINED , the previous embed if present is not changed. If this is  builtins.None , then the embed is removed if present. Otherwise, the new embed value that was provided will be used as the replacement. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for  @everyone mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , then  @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, sanitation for user mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid user mentions will behave as mentions. If  builtins.False , all valid user mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake user IDs, or  hikari.users.PartialUser -derived objects. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, sanitation for role mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid role mentions will behave as mentions. If  builtins.False , all valid role mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake role IDs, or  hikari.guilds.PartialRole -derived objects. flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag] If provided, optional flags to set on the message. If  hikari.undefined.UNDEFINED , then nothing is changed. Note that some flags may not be able to be set. Currently the only flags that can be set are  NONE and  SUPPRESS_EMBEDS . If you have  MANAGE_MESSAGES permissions, you can use this call to suppress embeds on another user's message.  ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however.  ! note There is currently no documented way to clear attachments or edit attachments from a previously sent message on Discord's API. To do this,  delete the message and re-send it. This also applies to embed attachments.  ! warning If you specify one of  mentions_everyone ,  user_mentions , or  role_mentions , then all others will default to  builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time.  ! warning If the message was not sent by your user, the only parameter you may provide to this call is the  flags parameter. Anything else will result in a  hikari.errors.ForbiddenError being raised. Returns    - hikari.messages.Message The edited message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  SEND_MESSAGES in the channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the  MANAGE_MESSAGES permission. hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_message",
"url":51,
"doc":"Delete a given message in a given channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to delete the message in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES , and the message is not sent by you. hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_messages",
"url":51,
"doc":"Bulk-delete messages from the channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to bulk delete the messages in. This may be the object or the ID of an existing channel.  messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The messages to delete. This may be one or more objects or IDs of existing messages.  ! note This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket. If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to  delete_message . The implication of this is that the  delete_message endpoint is ratelimited by a different bucket with different usage rates.  ! warning This endpoint is not atomic. If an error occurs midway through a bulk delete, you will  not be able to revert any changes made up to this point.  ! warning Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion. Raises    hikari.errors.BulkDeleteError An error containing the messages successfully deleted, and the messages that were not removed. The  builtins.BaseException.__cause__ of the exception will be the original error that terminated this process.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.add_reaction",
"url":51,
"doc":"Add a reaction emoji to a message in a given channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to add the reaction to is. This may be a  hikari.channels.TextChannel or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to add a reaction to. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to react to the message with. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  ADD_REACTIONS (this is only necessary if you are the first person to add the reaction). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_my_reaction",
"url":51,
"doc":"Delete a reaction that your application user created. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reaction from. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to remove your reaction from. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_all_reactions_for_emoji",
"url":51,
"doc":"Delete all reactions for a single emoji on a given message. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete the reactions from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reactions from. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to delete all reactions from. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_reaction",
"url":51,
"doc":"Delete a reaction from a message. If you are looking to delete your own applications reaction, use  delete_my_reaction . Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reaction from. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to delete all reactions from. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_all_reactions",
"url":51,
"doc":"Delete all reactions from a message. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete all reaction from. This may be the object or the ID of an existing message. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_reactions_for_emoji",
"url":51,
"doc":"Fetch reactions for an emoji from a message. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete all reaction from. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to filter reactions by. Returns    - hikari.iterators.LazyIterator[hikari.users.User] An iterator to fetch the users.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_webhook",
"url":51,
"doc":"Create webhook in a channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the webhook will be created. This may be the object or the ID of an existing channel. name : str The name for the webhook. This cannnot be  clyde . Other Parameters         avatar : typing.Optional[hikari.files.Resourceish] If provided, the avatar for the webhook. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.webhooks.Webhook The created webhook. Raises    hikari.errors.BadRequestError If  name doesnt follow the restrictions enforced by discord. hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_webhook",
"url":51,
"doc":"Fetch an existing webhook. Parameters      webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook] The webhook to fetch. This may be the object or the ID of an existing webhook. Other Parameters         token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to fetch the webhook instead of the token the client was initialized with. Returns    - hikari.webhooks.Webhook The requested webhook. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission when not using a token. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the webhook is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_channel_webhooks",
"url":51,
"doc":"Fetch all channel webhooks. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to fetch the webhooks for. This may be a  hikari.channels.TextChannel or the ID of an existing channel. Returns    - typing.Sequence[hikari.webhooks.Webhook] The fetched webhooks. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_guild_webhooks",
"url":51,
"doc":"Fetch all guild webhooks. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the webhooks for. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.webhooks.Webhook] The fetched webhooks. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_webhook",
"url":51,
"doc":"Edit a webhook. Parameters      webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook] The webhook to edit. This may be the object or the ID of an existing webhook. Other Parameters         token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to edit the webhook instead of the token the client was initialized with. name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new webhook name. avatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new webhook avatar. If  builtins.None , will remove the webhook avatar. channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel If provided, the text channel to move the webhook to. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.webhooks.Webhook The edited webhook. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission when not using a token. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the webhook is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_webhook",
"url":51,
"doc":"Delete a webhook. Parameters      webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook] The webhook to delete. This may be the object or the ID of an existing webhook. Other Parameters         token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to delete the webhook instead of the token the client was initialized with. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission when not using a token. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the webhoook is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.execute_webhook",
"url":51,
"doc":"Execute a webhook. Parameters      webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook] The webhook to execute. This may be the object or the ID of an existing webhook token: builtins.str The webhook token. content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed nor no  embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. embeds : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embeds. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. nonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all user mentions will be detected. If provided, and  builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all role mentions will be detected. If provided, and  builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified or if both  embed and  embeds are specified. hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_gateway_url",
"url":51,
"doc":"Fetch the gateway url.  ! note This endpoint does not require any valid authorization. Raises    hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_gateway_bot",
"url":51,
"doc":"Fetch the gateway gateway info for the bot. Returns    - hikari.sessions.GatewayBot The gateway bot. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_invite",
"url":51,
"doc":"Fetch an existing invite. Parameters      invite : hikari.invites.Inviteish The invite to fetch. This may be an invite object or the code of an existing invite. Returns    - hikari.invites.Invite The requested invite. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the invite is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_invite",
"url":51,
"doc":"Delete an existing invite. Parameters      invite : hikari.invites.Inviteish The invite to delete. This may be an invite object or the code of an existing invite. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission in the guild the invite is from or if you are missing the  MANAGE_CHANNELS permission in the channel the invite is from. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the invite is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_my_user",
"url":51,
"doc":"Fetch the token's associated user. Returns    - hikari.users.OwnUser The token's associated user. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_my_user",
"url":51,
"doc":"Edit the token's associated user. Other Parameters         username : undefined.UndefinedOr[builtins.str] If provided, the new username. avatar : undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new avatar. If  builtins.None , the avatar will be removed. Returns    - hikari.users.OwnUser The edited token's associated user. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Discord also returns this on a ratelimit: https: github.com/discord/discord-api-docs/issues/1462 hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_my_connections",
"url":51,
"doc":"Fetch the token's associated connections. Returns    - hikari.applications.OwnConnection The token's associated connections. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_my_guilds",
"url":51,
"doc":"Fetch the token's associated guilds. Other Parameters         newest_first : builtins.bool Whether to fetch the newest first or the olders first. Defaults to  builtins.False . start_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild If provided, will start at this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may also be a guild object. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.applications.OwnGuild] The token's associated guilds.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.leave_guild",
"url":51,
"doc":"Leave a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to leave. This may be the object or the ID of an existing guild. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found or you own the guild. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_dm_channel",
"url":51,
"doc":"Create a DM channel with a user. Parameters      user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to create the DM channel with. This may be the object or the ID of an existing user. Returns    - hikari.channels.DMChannel The created DM channel. Raises    hikari.errors.BadRequestError If the user is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_application",
"url":51,
"doc":"Fetch the token's associated application. Returns    - hikari.applications.Application The token's associated application. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.add_user_to_guild",
"url":51,
"doc":"Add a user to a guild.  ! note This requires the  access_token to have the  hikari.applications.OAuth2Scope.GUILDS_JOIN scope enabled. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to add the user to. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to add to the guild. This may be the object or the ID of an existing user. Other Parameters         nick : hikari.undefined.UndefinedOr[builtins.str] If provided, the nick to add to the user when he joins the guild. Requires the  MANAGE_NICKNAMES permission on the guild. roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the roles to add to the user when he joins the guild. This may be a collection objects or IDs of existing roles. Requires the  MANAGE_ROLES permission on the guild. mute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the mute state to add the user when he joins the guild. Requires the  MUTE_MEMBERS permission on the guild. deaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the deaf state to add the user when he joins the guild. Requires the  DEAFEN_MEMBERS permission on the guild. Returns    - typing.Optional[hikari.guilds.Member]  builtins.None if the user was already part of the guild, else  hikari.guilds.Member . Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are not part of the guild you want to add the user to, if you are missing permissions to do one of the things you specified, if you are using an access token for another user, if the token is bound to annother bot or if the access token doesnt have the  hikari.applications.OAuth2Scope.GUILDS_JOIN scope enabled. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If you own the guild or the user is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_voice_regions",
"url":51,
"doc":"Fetch available voice regions.  ! note This endpoint doesn't return VIP voice regions. Returns    - typing.Sequence[hikari.voices.VoiceRegion] The available voice regions. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_user",
"url":51,
"doc":"Fetch a user. Parameters      user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to fetch. This can be the object or the ID of an existing user. Returns    - hikari.users.User The requested user Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the user is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_audit_log",
"url":51,
"doc":"Fetch the guild's audit log. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the audit logs from. This can be a guild object or the ID of an existing guild. Other Parameters         before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, filter to only actions after this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser If provided, the user to filter for. event_type : hikari.undefined.UndefinedOr[hikari.audit_logs.AuditLogEventType] If provided, the event type to filter for. Returns    - hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog] The guild's audit log.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  VIEW_AUDIT_LOG permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_emoji",
"url":51,
"doc":"Fetch a guild emoji. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the emoji from. This can be a guild object or the ID of an existing guild. emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a  hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns    - hikari.emojis.KnownCustomEmoji The requested emoji. Raises    hikari.errors.NotFoundError If the guild or the emoji are not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_guild_emojis",
"url":51,
"doc":"Fetch the emojis of a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the emojis from. This can be a guild object or the ID of an existing guild. Returns    - typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises    hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_emoji",
"url":51,
"doc":"Create an emoji in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the emoji on. This can be a guild object or the ID of an existing guild. name : builtins.str The name for the emoji. image : hikari.files.Resourceish The 128x128 image for the emoji. Maximum upload size is 256kb. This can be a still or an animated image. Other Parameters         roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, a collection of the roles that will be able to use this emoji. This can be a  hikari.guilds.PartialRole or the ID of an existing role. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.emojis.KnownCustomEmoji The created emoji. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the type of emoji in the guild. hikari.errors.ForbiddenError If you are missing  MANAGE_EMOJIS in the server. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_emoji",
"url":51,
"doc":"Edit an emoji in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the emoji on. This can be a guild object or the ID of an existing guild. emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to edit. This can be a  hikari.emojis.CustomEmoji or the ID of an existing emoji. Other Parameters         name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the emoji. roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the new collection of roles that will be able to use this emoji. This can be a  hikari.guilds.PartialRole or the ID of an existing role. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.emojis.KnownCustomEmoji The edited emoji. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing  MANAGE_EMOJIS in the server. hikari.errors.NotFoundError If the guild or the emoji are not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_emoji",
"url":51,
"doc":"Delete an emoji in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the emoji on. This can be a guild object or the ID of an existing guild. emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to delete. This can be a  hikari.emojis.CustomEmoji or the ID of an existing emoji. Raises    hikari.errors.ForbiddenError If you are missing  MANAGE_EMOJIS in the server. hikari.errors.NotFoundError If the guild or the emoji are not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.guild_builder",
"url":51,
"doc":"Make a guild builder to create a guild with. Parameters      name : builtins.str The new guilds name. Returns    - hikari.api.special_endpoints.GuildBuilder The guild builder to use. This will allow to create a guild later with  hikari.api.special_endpoints.GuildBuilder.create . Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once  hikari.api.special_endpoints.GuildBuilder.create is called. Invoking this function itself will not raise any of the above types. See Also     Guild builder:  hikari.api.special_endpoints.GuildBuilder ",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_guild",
"url":51,
"doc":"Fetch a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch. This can be the object or the ID of an existing guild. Returns    - hikari.guilds.RESTGuild The requested guild. Raises    hikari.errors.ForbiddenError If you are not part of the guild. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_guild_preview",
"url":51,
"doc":"Fetch a guild preview. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the preview of. This can be a guild object or the ID of an existing guild. Returns    - hikari.guilds.GuildPreview The requested guild preview.  ! note This will only work for guilds you are a part of or are public. Raises    hikari.errors.NotFoundError If the guild is not found or you are not part of the guild. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_guild",
"url":51,
"doc":"Edit a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. Other Parameters         name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild. region : hikari.undefined.UndefinedOr[hikari.voices.VoiceRegionish] If provided, the new voice region for the guild. verification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level. default_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level. explicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level. afk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires  afk_timeout to be set to work. afk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout. icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the  ANIMATED_ICON feature. owner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner.  ! warn You need to be the owner of the server to use this. splash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the  INVITE_SPLASH feature. banner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the  BANNER feature. system_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel. rules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel. public_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel. preferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.guilds.RESTGuild The edited guild. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission or if you tried to pass ownership without being the server owner. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_guild",
"url":51,
"doc":"Delete a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete. This may be the object or the ID of an existing guild. Raises    hikari.errors.ForbiddenError If you are not the owner of the guild. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If you own the guild or if you are not in it. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_guild_channels",
"url":51,
"doc":"Fetch the channels in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the channels from. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.channels.GuildChannel] The requested channels. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_guild_text_channel",
"url":51,
"doc":"Create a text channel in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild. name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). topic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters. nsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW. rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the ammount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.GuildTextChannel The created channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_guild_news_channel",
"url":51,
"doc":"Create a news channel in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild. name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). topic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters. nsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW. rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the ammount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.GuildNewsChannel The created channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_guild_voice_channel",
"url":51,
"doc":"Create a voice channel in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild. name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). user_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit. bitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.GuildVoiceChannel The created channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_guild_category",
"url":51,
"doc":"Create a category in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild. name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.GuildCategory The created category. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.reposition_channels",
"url":51,
"doc":"Reposition the channels in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to reposition the channels in. This may be the object or the ID of an existing guild. positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel A mapping of of the object or the ID of an existing channel to the new position, relative to their parent category, if any. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_member",
"url":51,
"doc":"Fetch a guild member. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to get the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to get the member for. This may be the object or the ID of an existing user. Returns    - hikari.guilds.Member The requested member. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or the user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_members",
"url":51,
"doc":"Fetch the members from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the members of. This may be the object or the ID of an existing guild. Returns    - hikari.iterators.LazyIterator[hikari.guilds.Member] An iterator to fetch the members.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_member",
"url":51,
"doc":"Edit a guild member. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. Other Parameters         nick : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new nick for the member. If  builtins.None , will remove the members nick. Requires the  MANAGE_NICKNAMES permission. roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the new roles for the member. Requires the  MANAGE_ROLES permission. mute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server mute state for the member. Requires the  MUTE_MEMBERS permission. deaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server deaf state for the member. Requires the  DEAFEN_MEMBERS permission. voice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel ] If provided,  builtins.None or the object or the ID of an existing voice channel to move the member to. If  builtins.None , will disconnect the member from voice. Requires the  MOVE_MEMBERS permission and the  CONNECT permission in the original voice channel and the target voice channel.  ! note If the member is not in a voice channel, this will take no effect. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing a permission to do an action. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or the user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_my_nick",
"url":51,
"doc":"Edit the associated token's member nick. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. nick : typing.Optional[builtins.str] The new nick. If  builtins.None , will remove the nick. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  CHANGE_NICKNAME permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.add_role_to_member",
"url":51,
"doc":"Add a role to a member. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild where the member is in. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to add the role to. This may be the object or the ID of an existing user. role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to add. This may be the object or the ID of an existing role. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild, user or role are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.remove_role_from_member",
"url":51,
"doc":"Remove a role from a member. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild where the member is in. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to remove the role from. This may be the object or the ID of an existing user. role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to remove. This may be the object or the ID of an existing role. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild, user or role are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.kick_user",
"url":51,
"doc":"Kick a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to kick the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  KICK_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.kick_member",
"url":51,
"doc":"Kick a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to kick the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  KICK_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.ban_user",
"url":51,
"doc":"Ban a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to ban the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters         delete_message_days : hikari.undefined.UndefinedNoneOr[int] If provided, the number of days to delete messages for. This must be between 0 and 7. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.ban_member",
"url":51,
"doc":"Ban a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to ban the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters         delete_message_days : hikari.undefined.UndefinedNoneOr[int] If provided, the number of days to delete messages for. This must be between 0 and 7. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.unban_user",
"url":51,
"doc":"Unban a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to unban the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to unban. This may be the object or the ID of an existing user. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.unban_member",
"url":51,
"doc":"Unban a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to unban the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to unban. This may be the object or the ID of an existing user. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_ban",
"url":51,
"doc":"Fetch the guild's ban info for a user. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the ban from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to fetch the ban of. This may be the object or the ID of an existing user. Returns    - hikari.guilds.GuildMemberBan The requested ban info. Raises    hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found or if the user is not banned. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_bans",
"url":51,
"doc":"Fetch the bans of a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the bans from. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.guilds.GuildMemberBan] The requested bans. Raises    hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_roles",
"url":51,
"doc":"Fetch the roles of a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the roles from. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.guilds.Role] The requested roles. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.create_role",
"url":51,
"doc":"Create a role. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the role in. This may be the object or the ID of an existing guild. Other Parameters         name : hikari.undefined.UndefinedOr[builtins.str] If provided, the name for the role. permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] The permissions to give the role. This will default to setting NO roles if left to the default value. This is in contrast to default behaviour on Discord where some random permissions will be set by default. color : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the role's color. colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for  color . hoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role. mentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.guilds.Role The created role. Raises    builtins.TypeError If both  color and  colour are specified. hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.reposition_roles",
"url":51,
"doc":"Reposition the roles in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to reposition the roles in. This may be the object or the ID of an existing guild. positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole A mapping of the position to the role. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_role",
"url":51,
"doc":"Edit a role. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the role in. This may be the object or the ID of an existing guild. role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to edit. This may be the object or the ID of an existing role. Other Parameters         name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the role. permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new permissions for the role. color : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the new color for the role. colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for  color . hoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role. mentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.guilds.Role The edited role. Raises    builtins.TypeError If both  color and  colour are specified. hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or role are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.delete_role",
"url":51,
"doc":"Delete a role. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the role in. This may be the object or the ID of an existing guild. role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to delete. This may be the object or the ID of an existing role. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or role are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.estimate_guild_prune_count",
"url":51,
"doc":"Estimate the guild prune count. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to estimate the guild prune count for. This may be the object or the ID of an existing guild. Other Parameters         days : hikari.undefined.UndefinedOr[builtins.int] If provided, number of days to count prune for. include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count. Returns    - builtins.int The estimated guild prune count. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  KICK_MEMBERS permission. hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.begin_guild_prune",
"url":51,
"doc":"Begin the guild prune. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to begin the guild prune in. This may be the object or the ID of an existing guild. Other Parameters         days : hikari.undefined.UndefinedOr[builtins.int] If provided, number of days to count prune for. compute_prune_count: hikari.snowflakes.SnowflakeishOr[builtins.bool] If provided, whether to return the prune count. This is discouraged for large guilds. include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - typing.Optional[builtins.int] If  compute_prune_count is not provided or  builtins.True , the number of members pruned. Else  builtins.None . Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  KICK_MEMBERS permission. hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_guild_voice_regions",
"url":51,
"doc":"Fetch the available voice regions for a guild.  ! note Unlike  RESTClient.fetch_voice_regions , this will return the VIP regions if the guild has access to them. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the voice regions for. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.voices.VoiceRegion] The available voice regions for the guild. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_guild_invites",
"url":51,
"doc":"Fetch the guild's invites. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the invites for. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.invites.InviteWithMetadata] The invites for the guild. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_integrations",
"url":51,
"doc":"Fetch the guild's integrations. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the integrations for. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.guilds.Integration] The integrations for the guild. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_widget",
"url":51,
"doc":"Fetch a guilds's widget. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the widget from. This can be the object or the ID of an existing guild. Returns    - hikari.guilds.GuildWidget The requested guild widget. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.edit_widget",
"url":51,
"doc":"Fetch a guilds's widget. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the widget in. This can be the object or the ID of an existing guild. Other Parameters         channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel If provided, the channel to set the widget to. If  builtins.None , will not set to any. enabled : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to enable the widget. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.guilds.GuildWidget The edited guild widget. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.fetch_vanity_url",
"url":51,
"doc":"Fetch a guild's vanity url. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the vanity url from. This can be the object or the ID of an existing guild. Returns    - hikari.invites.VanityURL The requested invite. Raises    hikari.errors.ForbiddenError If you are not part of the guild. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.rest.RESTClient.http_settings",
"url":7,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.api.rest.RESTClient.proxy_settings",
"url":7,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.api.chunker",
"url":52,
"doc":"Component that provides the ability manage guild chunking."
},
{
"ref":"hikari.api.chunker.GuildChunker",
"url":52,
"doc":"Component specialization that is used to manage guild chunking."
},
{
"ref":"hikari.api.chunker.GuildChunker.fetch_members_for_guild",
"url":52,
"doc":"Request for a guild chunk. Parameters      guild : hikari.guilds.Guild The guild to request chunk for. Other Parameters         timeout : typing.Union[builtins.int, builtins.float, builtins.None] The maximum amount of time the returned stream should spend waiting for the next chunk event to be received before ending the iteration. If  builtins.None then this will never timeout between events. limit : typing.Optional[builtins.int] The limit for how many events the streamer should queue before dropping extra received events. Leave as  builtins.None for this to be unlimited. include_presences : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences. query : builtins.str If not    , request the members which username starts with the string. query_limit : builtins.int Maximum number of members to send matching the query. users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User ] If provided, the users to request for.  ! note To request the full list of members, set  query to    (empty string) and  limit to  0 .  ! note The chunk request will not be sent off until the returned stream is opened.  ! warning Validation errors like  builtins.ValueError and  hikari.errors.MissingIntentError will be delayed until you open the returned stream. Returns    - hikari.event_stream.Streamer[hikari.events.shard_events.MemberChunkEvent] A stream of chunk events for the generated request.",
"func":1
},
{
"ref":"hikari.api.chunker.GuildChunker.get_request_status",
"url":52,
"doc":"Return the status of a request. Parameters      nonce : str The unique identifier for the tracked request to get. Returns    - typing.Optional[RequestInformation] Information about the request if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.api.chunker.GuildChunker.list_requests_for_shard",
"url":52,
"doc":"List the statuses of requests made for a specific shard. Parameters      shard : typing.Union[hikari.api.shard.GatewayShard, builtins.int] The object or ID of the shard to get the tracked requests for. Returns    - typing.Sequence[RequestInformation] A sequence of data objects of information about the tracked requests for the given shard.",
"func":1
},
{
"ref":"hikari.api.chunker.GuildChunker.list_requests_for_guild",
"url":52,
"doc":"List the statuses of requests made for a specific guild. Parameters      guild: hikari.snowflakes.SnowflakeishOr[hikari.guilds.GatewayGuild] The object or ID of the guild to get the tracked requests for. Returns    - typing.Sequence[RequestInformation] A sequence of data objects of information about the tracked requests for the given guild.",
"func":1
},
{
"ref":"hikari.api.chunker.GuildChunker.consume_chunk_event",
"url":52,
"doc":"Listen to chunk events. Parameters      event : hikari.events.shard_events.MemberChunkEvent The object of the chunk event that's being consumed.",
"func":1
},
{
"ref":"hikari.api.chunker.GuildChunker.request_guild_members",
"url":52,
"doc":"Request for a guild chunk.  ! note For the chunker to track a request the request may need to be made using this method rather than using  hikari.api.shard.GatewayShard.request_guild_members . Parameters      guild : hikari.guilds.Guild The guild to request chunk for. Other Parameters         include_presences : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences. query : builtins.str If not    , request the members which username starts with the string. limit : builtins.int Maximum number of members to send matching the query. users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User ] If provided, the users to request for.  ! note To request the full list of members, set  query to    (empty string) and  limit to  0 . Returns    - builtins.str The generated unique nonce used for tracking this request. Raises    ValueError When trying to specify  users with  query / limit , if  limit is not between 0 and 100, both inclusive or if  users length is over 100. hikari.errors.MissingIntentError When trying to request presences without the  GUILD_MEMBERS or when trying to request the full list of members without  GUILD_PRESENCES .",
"func":1
},
{
"ref":"hikari.api.chunker.GuildChunker.close",
"url":52,
"doc":"Close the guild chunker.",
"func":1
},
{
"ref":"hikari.api.chunker.RequestInformation",
"url":52,
"doc":"Information about a member request that's being tracked. This protocol defines the fields that should be exported by a  GuildChunker implementation when getting the tracked information about a request."
},
{
"ref":"hikari.api.chunker.RequestInformation.average_chunk_size",
"url":52,
"doc":"Average amount of members that are being received per chunk. Returns    - typing.Optional[builtins.int] The  builtins.int average size of each chunk for this request or  builtins.None if we haven't received a response to pull information from yet."
},
{
"ref":"hikari.api.chunker.RequestInformation.chunk_count",
"url":52,
"doc":"Amount of chunks that are expected for this request. Returns    - typing.Optional[builtins.int] The  builtins.int count of how many chunk events should be received for this request or  builtins.None if we haven't received a response to pull information from yet."
},
{
"ref":"hikari.api.chunker.RequestInformation.guild_id",
"url":52,
"doc":"Snowflake ID of the guild this chunk request is for. Returns    - hikari.snowflakes.Snowflake The ID of the guild this request is for."
},
{
"ref":"hikari.api.chunker.RequestInformation.is_complete",
"url":52,
"doc":"Whether this chunk request is finished or not. A chunk request may be considered finished after all chunks have been received or after it's timed out. Returns    - builtins.bool Whether this chunk request is considered to be finished or not yet."
},
{
"ref":"hikari.api.chunker.RequestInformation.last_received",
"url":52,
"doc":"Datetime of when we last received a chunk for this event. Returns    - typing.Optional[datetime.datetime] A datetime object of when we last received a chunk event for this request or  builtins.None if we haven't received any chunk events in response to this request yet."
},
{
"ref":"hikari.api.chunker.RequestInformation.missing_chunk_indexes",
"url":52,
"doc":"Sequence of the indexes of chunks we haven't received yet. Returns    - typing.Optional[typing.Sequence[builtins.int A sequence of  builtins.int indexes of the chunk events we haven't received for this request or  builtins.None if we haven't received a response to pull information from yet."
},
{
"ref":"hikari.api.chunker.RequestInformation.nonce",
"url":52,
"doc":"Automatically generated unique identifier of the this chunk's event. Returns    - builtins.str The unique nonce that was generated for this request."
},
{
"ref":"hikari.api.chunker.RequestInformation.not_found_ids",
"url":52,
"doc":"Sequence of the snowflakes that were requested but not found.  ! note If no IDs were requested then this will be empty. typing.Sequence[hikari.snowflakes.Snowflake] A sequence of the snowflake IDs that were explicitly requested but weren't found."
},
{
"ref":"hikari.api.chunker.RequestInformation.received_chunks",
"url":52,
"doc":"Count of how many chunks have been received so far. Returns    - builtins.int The  builtins.int count of how many chunks events we've received in response to this request so far."
},
{
"ref":"hikari.api.special_endpoints",
"url":53,
"doc":"Special additional endpoints used by the REST API."
},
{
"ref":"hikari.api.special_endpoints.TypingIndicator",
"url":53,
"doc":"Result type of  hikari.api.rest.RESTClient.trigger_typing . This is an object that can either be awaited like a coroutine to trigger the typing indicator once, or an async context manager to keep triggering the typing indicator repeatedly until the context finishes.  ! note This is a helper class that is used by  hikari.api.rest.RESTClient . You should only ever need to use instances of this class that are produced by that API."
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder",
"url":53,
"doc":"Result type of  hikari.api.rest.RESTClient.guild_builder . This is used to create a guild in a tidy way using the HTTP API, since the logic behind creating a guild on an API level is somewhat confusing and detailed.  ! note This is a helper class that is used by  hikari.api.rest.RESTClient . You should only ever need to use instances of this class that are produced by that API, thus, any details about the constructor are omitted from the following examples for brevity. Examples     Creating an empty guild.   guild = await rest.guild_builder(\"My Server!\").create()   Creating a guild with an icon   from hikari.files import WebResourceStream guild_builder = rest.guild_builder(\"My Server!\") guild_builder.icon = WebResourceStream(\"cat.png\", \"http:  .\") guild = await guild_builder.create()   Adding roles to your guild.   from hikari.permissions import Permissions guild_builder = rest.guild_builder(\"My Server!\") everyone_role_id = guild_builder.add_role(\"@everyone\") admin_role_id = guild_builder.add_role(\"Admins\", permissions=Permissions.ADMINISTRATOR) await guild_builder.create()    ! warning The first role must always be the  @everyone role.  ! note If you call  add_role , the default roles provided by discord will be created. This also applies to the  add_ functions for text channels/voice channels/categories.  ! note Functions that return a  hikari.snowflakes.Snowflake do  not provide the final ID that the object will have once the API call is made. The returned IDs are only able to be used to re-reference particular objects while building the guild format. This is provided to allow creation of channels within categories, and to provide permission overwrites. Adding a text channel to your guild.   guild_builder = rest.guild_builder(\"My Server!\") category_id = guild_builder.add_category(\"My safe place\") channel_id = guild_builder.add_text_channel(\"general\", parent_id=category_id) await guild_builder.create()   Method generated by attrs for class GuildBuilder."
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.name",
"url":53,
"doc":"Name of the guild to create. Returns    - builtins.str The guild name."
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.create",
"url":53,
"doc":"Send the request to Discord to create the guild. The application user will be added to this guild as soon as it is created. All IDs that were provided when building this guild will become invalid and will be replaced with real IDs. Returns    - hikari.guilds.RESTGuild The created guild. Raises    hikari.errors.BadRequestError If any values set in the guild builder are invalid. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are already in 10 guilds. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.add_role",
"url":53,
"doc":"Create a role.  ! warning The first role you create must always be the  @everyone role. Parameters      name : builtins.str The role's name. Other Parameters         permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the permissions for the role. color : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the role's color. colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for  color . hoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role. mentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.snowflakes.Snowflake The dummy ID for this role that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID. Raises    builtins.ValueError If you are defining the first role, but did not name it  @everyone . builtins.TypeError If you specify both  color and  colour together or if you try to specify  color ,  colour ,  hoisted ,  mentionable or  position for the  @everyone role.",
"func":1
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.add_category",
"url":53,
"doc":"Create a category channel. Parameters      name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category. Returns    - hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.",
"func":1
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.add_text_channel",
"url":53,
"doc":"Create a text channel. Parameters      name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). topic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters. nsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW. rate_limit_per_user : hikari.undefined.UndefinedOr[builtins.int] If provided, the ammount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns    - hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.",
"func":1
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.add_voice_channel",
"url":53,
"doc":"Create a voice channel. Parameters      name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). user_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit. bitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns    - hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.",
"func":1
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.default_message_notifications",
"url":53,
"doc":"Default message notification level that can be overwritten. If not overridden, this will use the Discord default level."
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.explicit_content_filter_level",
"url":53,
"doc":"Explicit content filter level that can be overwritten. If not overridden, this will use the Discord default level."
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.icon",
"url":53,
"doc":"Guild icon to use that can be overwritten. If not overridden, the guild will not have an icon."
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.region",
"url":53,
"doc":"Guild voice channel region to use that can be overwritten. If not overridden, the guild will use the default voice region for Discord."
},
{
"ref":"hikari.api.special_endpoints.GuildBuilder.verification_level",
"url":53,
"doc":"Verification level required to join the guild that can be overwritten. If not overridden, the guild will use the default verification level for Discord."
},
{
"ref":"hikari.api.event_factory",
"url":54,
"doc":"Component that provides the ability to generate event models."
},
{
"ref":"hikari.api.event_factory.EventFactory",
"url":54,
"doc":"Interface for components that deserialize JSON events."
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_channel_create_event",
"url":54,
"doc":"Parse a raw payload from Discord into a channel create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.ChannelCreateEvent The parsed channel create event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_channel_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a channel update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.ChannelUpdateEvent The parsed event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_channel_delete_event",
"url":54,
"doc":"Parse a raw payload from Discord into a channel delete event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.ChannelDeleteEvent The parsed channel delete event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_channel_pins_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a channel pins update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.PinsUpdateEvent The parsed channel pins update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_webhook_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a webhook update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.WebhookUpdateEvent The parsed webhook update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_typing_start_event",
"url":54,
"doc":"Parse a raw payload from Discord into a typing start event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.typing_events.TypingEvent The parsed typing start event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_invite_create_event",
"url":54,
"doc":"Parse a raw payload from Discord into an invite create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.InviteCreateEvent The parsed invite create event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_invite_delete_event",
"url":54,
"doc":"Parse a raw payload from Discord into an invite delete event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.InviteDeleteEvent The parsed invite delete event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_create_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.GuildAvailableEvent The parsed guild create event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.GuildUpdateEvent The parsed guild update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_leave_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild leave event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.GuildLeaveEvent The parsed guild leave event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_unavailable_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild unavailable event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.GuildUnavailableEvent The parsed guild unavailable event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_ban_add_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild ban add event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.BanCreateEvent The parsed guild ban add event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_ban_remove_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild ban remove event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.BanDeleteEvent The parsed guild ban remove event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_emojis_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild emojis update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.EmojisUpdateEvent The parsed guild emojis update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_integrations_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guilds integrations update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.IntegrationsUpdateEvent The parsed guilds integrations update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_member_add_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild member add event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.member_events.MemberCreateEvent The parsed guild member add event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_member_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild member update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.member_events.MemberUpdateEvent The parsed guild member update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_member_remove_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild member remove event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.member_events.MemberDeleteEvent The parsed guild member remove event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_role_create_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild role create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.role_events.RoleCreateEvent The parsed guild role create event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_role_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild role update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.role_events.RoleUpdateEvent The parsed guild role update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_role_delete_event",
"url":54,
"doc":"Parse a raw payload from Discord into a guild role delete event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.role_events.RoleDeleteEvent The parsed guild role delete event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_presence_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a presence update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.PresenceUpdateEvent The parsed presence update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_message_create_event",
"url":54,
"doc":"Parse a raw payload from Discord into a message create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.message_events.MessageCreateEvent The parsed message create event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_message_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a message update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.message_events.MessageUpdateEvent The parsed message update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_message_delete_event",
"url":54,
"doc":"Parse a raw payload from Discord into a message delete event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.message_events.MessageDeleteEvent The parsed message delete event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_message_delete_bulk_event",
"url":54,
"doc":"Parse a raw payload from Discord into a message delete bulk event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.message_events.MessageDeleteEvent The parsed message delete bulk event object. Raises    builtins.NotImplementedError If a bulk delete occurs in a DM channel.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_message_reaction_add_event",
"url":54,
"doc":"Parse a raw payload from Discord into a message reaction add event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.reaction_events.ReactionAddEvent The parsed message reaction add event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_message_reaction_remove_event",
"url":54,
"doc":"Parse a raw payload from Discord into a message reaction remove event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.reaction_events.ReactionDeleteEvent The parsed message reaction remove event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_message_reaction_remove_all_event",
"url":54,
"doc":"Parse a raw payload from Discord into a message reaction remove all event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.reaction_events.ReactionDeleteAllEvent The parsed message reaction remove all event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_message_reaction_remove_emoji_event",
"url":54,
"doc":"Parse a raw payload from Discord into a message reaction remove emoji event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.reaction_events.ReactionDeleteEmojiEvent The parsed message reaction remove emoji event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_ready_event",
"url":54,
"doc":"Parse a raw payload from Discord into a ready event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.shard_events.ShardReadyEvent The parsed ready event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_own_user_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a own user update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.user_events.OwnUserUpdateEvent The parsed own user update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_guild_member_chunk_event",
"url":54,
"doc":"Parse a raw payload from Discord into a member chunk event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.shard_events.MemberChunkEvent The parsed member chunk object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_voice_state_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a voice state update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.voice_events.VoiceStateUpdateEvent The parsed voice state update event object.",
"func":1
},
{
"ref":"hikari.api.event_factory.EventFactory.deserialize_voice_server_update_event",
"url":54,
"doc":"Parse a raw payload from Discord into a voice server update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.voice_events.VoiceServerUpdateEvent The parsed voice server update event object.",
"func":1
},
{
"ref":"hikari.api.entity_factory",
"url":55,
"doc":"Core interface for an object that serializes/deserializes API objects."
},
{
"ref":"hikari.api.entity_factory.EntityFactory",
"url":55,
"doc":"Interface for components that serialize and deserialize JSON payloads."
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_own_connection",
"url":55,
"doc":"Parse a raw payload from Discord into an own connection object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.applications.OwnConnection The deserialized \"own connection\" object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_own_guild",
"url":55,
"doc":"Parse a raw payload from Discord into an own guild object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.applications.OwnGuild The deserialized \"own guild\" object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_application",
"url":55,
"doc":"Parse a raw payload from Discord into an application object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.applications.Application The deserialized application object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_audit_log",
"url":55,
"doc":"Parse a raw payload from Discord into an audit log object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.audit_logs.AuditLog The deserialized audit log object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_channel_follow",
"url":55,
"doc":"Parse a raw payload from Discord into a channel follow object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.ChannelFollow The deserialized channel follow object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_permission_overwrite",
"url":55,
"doc":"Parse a raw payload from Discord into a permission overwrite object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.PermissionOverwrite The deserialized permission overwrite object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.serialize_permission_overwrite",
"url":55,
"doc":"Serialize a permission overwrite object to a json serializable dict. Parameters      overwrite : hikari.channels.PermissionOverwrite The permission overwrite object to serialize. Returns    - hikari.internal.data_binding.JSONObject The serialized representation of the permission overwrite.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_partial_channel",
"url":55,
"doc":"Parse a raw payload from Discord into a partial channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.PartialChannel The deserialized \"partial channel\" object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_dm",
"url":55,
"doc":"Parse a raw payload from Discord into a DM channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.DMChannel The deserialized DM channel object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_group_dm",
"url":55,
"doc":"Parse a raw payload from Discord into a group DM channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.GroupDMChannel The deserialized group DM object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_guild_category",
"url":55,
"doc":"Parse a raw payload from Discord into a guild category object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.GuildCategory The deserialized guild category object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_guild_text_channel",
"url":55,
"doc":"Parse a raw payload from Discord into a guild text channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.GuildTextChannel The deserialized guild text channel object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_guild_news_channel",
"url":55,
"doc":"Parse a raw payload from Discord into a guild news channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.GuildNewsChannel The deserialized guild news channel object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_guild_store_channel",
"url":55,
"doc":"Parse a raw payload from Discord into a guild store channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.GuildStoreChannel The deserialized guild store channel object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_guild_voice_channel",
"url":55,
"doc":"Parse a raw payload from Discord into a guild voice channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is npt included in the channel's payload. Returns    - hikari.channels.GuildVoiceChannel The deserialized guild voice channel object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_channel",
"url":55,
"doc":"Parse a raw payload from Discord into a channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. This will be ignored for DM and group DM channels and will be prioritised over  \"guild_id\" in the payload when passed.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.PartialChannel The deserialized partial channel-derived object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload of a guild channel.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_embed",
"url":55,
"doc":"Parse a raw payload from Discord into an embed object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.embeds.Embed The deserialized embed object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.serialize_embed",
"url":55,
"doc":"Serialize an embed object to a json serializable dict. Parameters      embed : hikari.embeds.Embed The embed object to serialize. Returns    - typing.Tuple[hikari.internal.data_binding.JSONObject, typing.List[hikari.files.Resource A tuple with two items in it. The first item will be the serialized embed representation. The second item will be a list of resources to upload with the embed.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_unicode_emoji",
"url":55,
"doc":"Parse a raw payload from Discord into a unicode emoji object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.emojis.UnicodeEmoji The deserialized unicode emoji object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_custom_emoji",
"url":55,
"doc":"Parse a raw payload from Discord into a custom emoji object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.emojis.CustomEmoji The deserialized custom emoji object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_known_custom_emoji",
"url":55,
"doc":"Parse a raw payload from Discord into a known custom emoji object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. guild_id : hikari.snowflakes.Snowflake The ID of the guild this emoji belongs to. This is used to ensure that the guild a known custom emoji belongs to is remembered by allowing for a context based artificial  guild_id attribute. Returns    - hikari.emojis.KnownCustomEmoji The deserialized \"known custom emoji\" object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_emoji",
"url":55,
"doc":"Parse a raw payload from Discord into an emoji object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.emojis.UnicodeEmoji or hikari.emojis.CustomEmoji The deserialized custom or unicode emoji object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_gateway_bot",
"url":55,
"doc":"Parse a raw payload from Discord into a gateway bot object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.sessions.GatewayBot The deserialized gateway bot object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_guild_widget",
"url":55,
"doc":"Parse a raw payload from Discord into a guild widget object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.GuildWidget The deserialized guild widget object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_member",
"url":55,
"doc":"Parse a raw payload from Discord into a member object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         user : hikari.undefined.UndefinedOr[hikari.users.User] The user to attach to this member, should only be passed in situations where \"user\" is not included in the payload. guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this member belongs to. If this is specified then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id covers cases such as the GUILD_CREATE gateway event and GET Guild Member where  \"guild_id\" is not included in the returned payload. Returns    - hikari.guilds.Member The deserialized member object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_role",
"url":55,
"doc":"Parse a raw payload from Discord into a role object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. guild_id : hikari.snowflakes.Snowflake The ID of the guild this role belongs to. This is used to ensure that the guild a role belongs to is remembered by allowing for a context based artificial  guild_id attribute. Returns    - hikari.guilds.Role The deserialized role object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_partial_integration",
"url":55,
"doc":"Parse a raw payload from Discord into a partial integration object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.PartialIntegration The deserialized partial integration object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_integration",
"url":55,
"doc":"Parse a raw payload from Discord into an integration object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.Integration The deserialized integration object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_guild_member_ban",
"url":55,
"doc":"Parse a raw payload from Discord into a guild member ban object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.GuildMemberBan The deserialized guild member ban object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_guild_preview",
"url":55,
"doc":"Parse a raw payload from Discord into a guild preview object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.GuildPreview The deserialized guild preview object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_rest_guild",
"url":55,
"doc":"Parse a raw payload from Discord into a guild object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.RESTGuild The deserialized guild object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_gateway_guild",
"url":55,
"doc":"Parse a raw payload from Discord into a guild object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - GatewayGuildDefinition The deserialized guild object and the internal collections as maps of  hikari.snowflakes.Snowflake mapping to  hikari.channels.GuildChannel ,  hikari.guilds.Member ,  hikari.presences.MemberPresence ,  hikari.guilds.Role , and  hikari.emojis.KnownCustomEmoji . This is provided in several components to allow separate caching and linking between entities in various relational cache implementations internally.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_vanity_url",
"url":55,
"doc":"Parse a raw payload from Discord into a vanity url object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.invites.VanityURL The deserialized vanity url object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_invite",
"url":55,
"doc":"Parse a raw payload from Discord into an invite object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.invites.Invite The deserialized invite object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_invite_with_metadata",
"url":55,
"doc":"Parse a raw payload from Discord into a invite with metadata object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.invites.InviteWithMetadata The deserialized invite with metadata object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_partial_message",
"url":55,
"doc":"Parse a raw payload from Discord into a partial message object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.messages.PartialMessage The deserialized partial message object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_message",
"url":55,
"doc":"Parse a raw payload from Discord into a message object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.messages.Message The deserialized message object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_member_presence",
"url":55,
"doc":"Parse a raw payload from Discord into a member presence object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild the presence belongs to. If this is specified then it is prioritised over  guild_id in the payload.  ! note At the time of writing, the only place where  guild_id will be mandatory is when parsing presences sent in a  GUILD_CREATE event from Discord, since the  guild_id attribute in the payload will have been omitted for redundancy. Returns    - hikari.presences.MemberPresence The deserialized member presence object. Raises    KeyError If  guild_id is not an attribute of the  payload dict, and no guild ID was passed for the  guild_id parameter. If this is raised, no guild ID info was provided anywhere.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_user",
"url":55,
"doc":"Parse a raw payload from Discord into a user object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.users.User The deserialized user object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_my_user",
"url":55,
"doc":"Parse a raw payload from Discord into a user object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.users.OwnUser The deserialized user object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_voice_state",
"url":55,
"doc":"Parse a raw payload from Discord into a voice state object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this voice state belongs to. If this is specified then this will be prioritised over  \"guild_id\" in the payload. member : hikari.undefined.UndefinedOr[hikari.guilds.Member] The object of the member this voice state belongs to. If this is specified then this will be prioritised over  \"member\" in the payload.  ! note At the time of writing,  GUILD_CREATE events are the only known place where neither  guild_id nor  member will be keys on the payload. In this case, you will need to provide the former parameters explicitly. Returns    - hikari.voices.VoiceState The deserialized voice state object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload for the payload of the voice state. This will also be raised if no  member data was passed in any acceptable place.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_voice_region",
"url":55,
"doc":"Parse a raw payload from Discord into a voice region object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.voices.VoiceRegion The deserialized voice region object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.EntityFactory.deserialize_webhook",
"url":55,
"doc":"Parse a raw payload from Discord into a webhook object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.webhooks.Webhook The deserialized webhook object.",
"func":1
},
{
"ref":"hikari.api.entity_factory.GatewayGuildDefinition",
"url":55,
"doc":"A structure for handling entities within guild create and update events. Method generated by attrs for class GatewayGuildDefinition."
},
{
"ref":"hikari.api.entity_factory.GatewayGuildDefinition.channels",
"url":55,
"doc":"Mapping of channel IDs to the channels that belong to the guild. Will be  builtins.None when returned by guild update gateway events rather than create."
},
{
"ref":"hikari.api.entity_factory.GatewayGuildDefinition.emojis",
"url":55,
"doc":"Mapping of emoji IDs to the emojis that belong to the guild."
},
{
"ref":"hikari.api.entity_factory.GatewayGuildDefinition.guild",
"url":55,
"doc":"Object of the guild the definition is for."
},
{
"ref":"hikari.api.entity_factory.GatewayGuildDefinition.members",
"url":55,
"doc":"Mapping of user IDs to the members that belong to the guild. Will be  builtins.None when returned by guild update gateway events rather than create.  ! note This may be a partial mapping of members in the guild."
},
{
"ref":"hikari.api.entity_factory.GatewayGuildDefinition.presences",
"url":55,
"doc":"Mapping of user IDs to the presences that are active in the guild. Will be  builtins.None when returned by guild update gateway events rather than create.  ! note This may be a partial mapping of presences active in the guild."
},
{
"ref":"hikari.api.entity_factory.GatewayGuildDefinition.roles",
"url":55,
"doc":"Mapping of role IDs to the roles that belong to the guild."
},
{
"ref":"hikari.api.entity_factory.GatewayGuildDefinition.voice_states",
"url":55,
"doc":"Mapping of user IDs to the voice states that are active in the guild.  ! note This may be a partial mapping of voice states active in the guild."
},
{
"ref":"hikari.api.event_dispatcher",
"url":56,
"doc":"Core interface for components that dispatch events to the library."
},
{
"ref":"hikari.api.event_dispatcher.EventDispatcher",
"url":56,
"doc":"Base interface for event dispatcher implementations. This is a consumer of a  hikari.events.base_events.Event object, and is expected to invoke one or more corresponding event listeners where appropriate."
},
{
"ref":"hikari.api.event_dispatcher.EventDispatcher.dispatch",
"url":56,
"doc":"Dispatch an event. Parameters      event : hikari.events.base_events.Event The event to dispatch. Example    - We can dispatch custom events by first defining a class that derives from  hikari.events.base_events.Event .   import attr from hikari.traits import RESTAware from hikari.events.base_events import Event from hikari.users import User from hikari.snowflakes import Snowflake @attr.s() class EveryoneMentionedEvent(Event): app: RESTAware = attr.ib() author: User = attr.ib()  'The user who mentioned everyone. ' content: str = attr.ib()  'The message that was sent. ' message_id: Snowflake = attr.ib()  'The message ID. ' channel_id: Snowflake = attr.ib()  'The channel ID. '   We can then dispatch our event as we see fit.   from hikari.events.messages import MessageCreateEvent @bot.listen(MessageCreateEvent) async def on_message(event): if \"@everyone\" in event.content or \"@here\" in event.content: event = EveryoneMentionedEvent( author=event.author, content=event.content, message_id=event.id, channel_id=event.channel_id, ) bot.dispatch(event)   This event can be listened to elsewhere by subscribing to it with  EventDispatcher.subscribe .   @bot.listen(EveryoneMentionedEvent) async def on_everyone_mentioned(event): print(event.user, \"just pinged everyone in\", event.channel_id)   Returns    - asyncio.Future[typing.Any] A future that can be optionally awaited. If awaited, the future will complete once all corresponding event listeners have been invoked. If not awaited, this will schedule the dispatch of the events in the background for later. See Also     Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.api.event_dispatcher.EventDispatcher.subscribe",
"url":56,
"doc":"Subscribe a given callback to a given event type. Parameters      event_type : typing.Type[T] The event type to listen for. This will also listen for any subclasses of the given type.  T must be a subclass of  hikari.events.base_events.Event . callback Must be a coroutine function to invoke. This should consume an instance of the given event, or an instance of a valid subclass if one exists. Any result is discarded. Example    - The following demonstrates subscribing a callback to message creation events.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.subscribe(MessageCreateEvent, on_message)   Returns    - typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None] The event callback that was passed in. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.api.event_dispatcher.EventDispatcher.unsubscribe",
"url":56,
"doc":"Unsubscribe a given callback from a given event type, if present. Parameters      event_type : typing.Type[T] The event type to unsubscribe from. This must be the same exact type as was originally subscribed with to be removed correctly.  T must derive from  hikari.events.base_events.Event . callback The callback to unsubscribe. Example    - The following demonstrates unsubscribing a callback from a message creation event.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.unsubscribe(MessageCreateEvent, on_message)  ",
"func":1
},
{
"ref":"hikari.api.event_dispatcher.EventDispatcher.get_listeners",
"url":56,
"doc":"Get the listeners for a given event type, if there are any. Parameters      event_type : typing.Type[T] The event type to look for.  T must be a subclass of  hikari.events.base_events.Event . polymorphic : builtins.bool If  builtins.True , this will also return the listeners of the subclasses of the given event type. If  builtins.False , then only listeners for this class specifically are returned. The default is  builtins.True . Returns    - typing.Collection[typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None A copy of the collection of listeners for the event. Will return an empty collection if nothing is registered.  T must be a subclass of  hikari.events.base_events.Event . See Also     Has listener:  hikari.api.event_dispatcher.EventDispatcher.has_listener ",
"func":1
},
{
"ref":"hikari.api.event_dispatcher.EventDispatcher.listen",
"url":56,
"doc":"Generate a decorator to subscribe a callback to an event type. This is a second-order decorator. Parameters      event_type : typing.Optional[typing.Type[T The event type to subscribe to. The implementation may allow this to be undefined. If this is the case, the event type will be inferred instead from the type hints on the function signature.  T must be a subclass of  hikari.events.base_events.Event . Returns    - typing.Callable T], T] A decorator for a coroutine function that passes it to  EventDispatcher.subscribe before returning the function reference. See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.api.event_dispatcher.EventDispatcher.stream",
"url":56,
"doc":"Return a stream iterator for the given event and sub-events. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. timeout : typing.Optional[builtins.int, builtins.float] How long this streamer should wait for the next event before ending the iteration. If  builtins.None then this will continue until explicitly broken from. limit : typing.Optional[builtins.int] The limit for how many events this should queue at one time before dropping extra incoming events, leave this as  builtins.None for the cache size to be unlimited. Returns    - hikari.event_stream.Streamer[hikari.events.base_events.Event] The async iterator to handle streamed events. This must be started with  async with stream: or  await stream.open() before asynchronously iterating over it.  ! warning If you use  await stream.open() to start the stream then you must also close it with  await stream.close() otherwise it may queue events in memory indefinitely. Examples       async with bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id as stream: async for user_id in stream.map(\"user_id\").limit(50):  .   or using await  open() and await  close()   stream = bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id await stream.open() async for user_id in stream.map(\"user_id\").limit(50)  . await stream.close()   See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.api.event_dispatcher.EventDispatcher.wait_for",
"url":56,
"doc":"Wait for a given event to occur once, then return the event. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. predicate A function taking the event as the single parameter. This should return  builtins.True if the event is one you want to return, or  builtins.False if the event should not be returned. If left as  None (the default), then the first matching event type that the bot receives (or any subtype) will be the one returned.  ! warn ASYNC PREDICATES ARE NOT SUPPORTED. timeout : typing.Union[builtins.float, builtins.int, builtins.None] The amount of time to wait before raising an  asyncio.TimeoutError and giving up instead. This is measured in seconds. If  builtins.None , then no timeout will be waited for (no timeout can result in \"leaking\" of coroutines that never complete if called in an uncontrolled way, so is not recommended). Returns    - hikari.events.base_events.Event The event that was provided. Raises    asyncio.TimeoutError If the timeout is not  builtins.None and is reached before an event is received that the predicate returns  builtins.True for. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch ",
"func":1
},
{
"ref":"hikari.api.shard",
"url":57,
"doc":"Provides an interface for gateway shard implementations to conform to."
},
{
"ref":"hikari.api.shard.GatewayDataFormat",
"url":57,
"doc":"Format of inbound gateway payloads."
},
{
"ref":"hikari.api.shard.GatewayDataFormat.name",
"url":57,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.api.shard.GatewayDataFormat.value",
"url":57,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.api.shard.GatewayDataFormat.JSON",
"url":57,
"doc":"Javascript serialized object notation."
},
{
"ref":"hikari.api.shard.GatewayDataFormat.ETF",
"url":57,
"doc":"Erlang transmission format."
},
{
"ref":"hikari.api.shard.GatewayCompression",
"url":57,
"doc":"Types of gateway compression that may be supported."
},
{
"ref":"hikari.api.shard.GatewayCompression.name",
"url":57,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.api.shard.GatewayCompression.value",
"url":57,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.api.shard.GatewayCompression.TRANSPORT_ZLIB_STREAM",
"url":57,
"doc":"Transport compression using ZLIB."
},
{
"ref":"hikari.api.shard.GatewayCompression.PAYLOAD_ZLIB_STREAM",
"url":57,
"doc":"Payload compression using ZLIB."
},
{
"ref":"hikari.api.shard.GatewayShard",
"url":57,
"doc":"Interface for a definition of a V6/V7 compatible websocket gateway. Each instance should represent a single shard."
},
{
"ref":"hikari.api.shard.GatewayShard.heartbeat_latency",
"url":57,
"doc":"Return the shard's most recent heartbeat latency. Returns    - builtins.float Heartbeat latency measured in seconds. If the information is not yet available, then this will be  float('nan') instead."
},
{
"ref":"hikari.api.shard.GatewayShard.id",
"url":57,
"doc":"Return the shard ID for this shard. Returns    - builtins.int The integer 0-based shard ID."
},
{
"ref":"hikari.api.shard.GatewayShard.intents",
"url":57,
"doc":"Return the intents set on this shard. Returns    - hikari.intents.Intents The intents being used on this shard."
},
{
"ref":"hikari.api.shard.GatewayShard.is_alive",
"url":57,
"doc":"Return  builtins.True if the shard is alive and connected. Returns    - builtins.bool  builtins.True if connected, or  builtins.False if not."
},
{
"ref":"hikari.api.shard.GatewayShard.shard_count",
"url":57,
"doc":"Return the total number of shards expected in the entire application. Returns    - builtins.int A number of shards greater than or equal to 1."
},
{
"ref":"hikari.api.shard.GatewayShard.get_user_id",
"url":57,
"doc":"Return the user ID. If the shard has not connected fully yet, this should wait until the ID is set before returning. Returns    - hikari.snowflakes.Snowflake The user ID for the application user.",
"func":1
},
{
"ref":"hikari.api.shard.GatewayShard.close",
"url":57,
"doc":"Close the websocket if it is connected, otherwise do nothing.",
"func":1
},
{
"ref":"hikari.api.shard.GatewayShard.join",
"url":57,
"doc":"Wait indefinitely until the websocket closes permanently. This can be placed in a task and cancelled without affecting the websocket runtime itself.",
"func":1
},
{
"ref":"hikari.api.shard.GatewayShard.start",
"url":57,
"doc":"Start the shard, wait for it to become ready.",
"func":1
},
{
"ref":"hikari.api.shard.GatewayShard.update_presence",
"url":57,
"doc":"Update the presence of the shard user. If the shard is not alive, no physical data will be sent, however, the new presence settings will be remembered for when the shard does connect. Other Parameters         idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed. afk : hikari.undefined.UndefinedOr[builtins.bool] If  builtins.True , the user is marked as AFK. If  builtins.False , the user is marked as being active. If undefined, this will not be changed. activity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed. status : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed.",
"func":1
},
{
"ref":"hikari.api.shard.GatewayShard.update_voice_state",
"url":57,
"doc":"Update the voice state for this shard in a given guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild or guild ID to update the voice state for. channel : typing.Optional[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel The channel or channel ID to update the voice state for. If  builtins.None then the bot will leave the voice channel that it is in for the given guild. self_mute : builtins.bool If  builtins.True , the bot will mute itself in that voice channel. If  builtins.False , then it will unmute itself. self_deaf : builtins.bool If  builtins.True , the bot will deafen itself in that voice channel. If  builtins.False , then it will undeafen itself.",
"func":1
},
{
"ref":"hikari.api.shard.GatewayShard.request_guild_members",
"url":57,
"doc":"Request for a guild chunk. Parameters      guild: hikari.guilds.Guild The guild to request chunk for. Other Parameters         include_presences: hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences. query: builtins.str If not    , request the members which username starts with the string. limit: builtins.int Maximum number of members to send matching the query. users: hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User ] If provided, the users to request for. nonce: hikari.undefined.UndefinedOr[builtins.str] If provided, the nonce to be sent with guild chunks.  ! note To request the full list of members, set  query to    (empty string) and  limit to  0 . Raises    ValueError When trying to specify  users with  query / limit , if  limit is not between 0 and 100, both inclusive or if  users length is over 100. hikari.errors.MissingIntentError When trying to request presences without the  GUILD_MEMBERS or when trying to request the full list of members without  GUILD_PRESENCES .",
"func":1
},
{
"ref":"hikari.snowflakes",
"url":1,
"doc":"Implementation of a Snowflake type."
},
{
"ref":"hikari.snowflakes.Snowflake",
"url":1,
"doc":"A concrete representation of a unique ID for an entity on Discord. This object can be treated as a regular  builtins.int for most purposes."
},
{
"ref":"hikari.snowflakes.Snowflake.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.snowflakes.Snowflake.internal_worker_id",
"url":1,
"doc":"ID of the worker that created this snowflake on Discord's systems."
},
{
"ref":"hikari.snowflakes.Snowflake.internal_process_id",
"url":1,
"doc":"ID of the process that created this snowflake on Discord's systems."
},
{
"ref":"hikari.snowflakes.Snowflake.increment",
"url":1,
"doc":"Increment of Discord's system when this object was made."
},
{
"ref":"hikari.snowflakes.Snowflake.from_datetime",
"url":1,
"doc":"Get a snowflake object from a datetime object.",
"func":1
},
{
"ref":"hikari.snowflakes.Snowflake.min",
"url":1,
"doc":"Minimum value for a snowflakes.",
"func":1
},
{
"ref":"hikari.snowflakes.Snowflake.max",
"url":1,
"doc":"Maximum value for a snowflakes.",
"func":1
},
{
"ref":"hikari.snowflakes.Snowflake.from_data",
"url":1,
"doc":"Convert the pieces of info that comprise an ID into a Snowflake.",
"func":1
},
{
"ref":"hikari.snowflakes.Unique",
"url":1,
"doc":"Mixin for a class that enforces uniqueness by a snowflake ID."
},
{
"ref":"hikari.snowflakes.Unique.id",
"url":1,
"doc":"Return the ID of this entity. Returns    - Snowflake The snowflake ID of this object."
},
{
"ref":"hikari.snowflakes.Unique.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.snowflakes.calculate_shard_id",
"url":1,
"doc":"Calculate the shard ID for a guild based on it's shard aware app or shard count. Parameters      app_or_count : typing.Union[hikari.traits.ShardAware, builtins.int] The shard aware app of the current application or the integer count of the current app's shards. guild : SnowflakeishOr[hikari.guilds.PartialGuild] The object or ID of the guild to get the shard ID of. Returns    - builtins.int The zero-indexed integer ID of the shard that should cover this guild.",
"func":1
},
{
"ref":"hikari.snowflakes.Snowflakeish",
"url":1,
"doc":"Type hint for a value that resembles a  Snowflake object functionally. This is a value that is  Snowflake -ish. A value is  Snowflake -ish if casting it to an  int allows it to be cast to a  Snowflake . The valid types for this type hint are: -  builtins.int -  Snowflake "
},
{
"ref":"hikari.snowflakes.SearchableSnowflakeish",
"url":1,
"doc":"Type hint for a snowflakeish that can be searched for in history. This is just a  Snowflakeish that can alternatively be some form of  datetime.datetime instance. The valid types for this type hint are: -  builtins.str containing digits. -  builtins.int -  Snowflake -  datetime.datetime "
},
{
"ref":"hikari.snowflakes.SnowflakeishOr",
"url":1,
"doc":"Type hint representing a unique object entity. This is a value that is  Snowflake -ish or a specific type covariant. If you see  SnowflakeishOr[Foo] anywhere as a type hint, it means the value may be a  Foo instance, a  Snowflake , a  builtins.int or a  builtins.str with numeric digits only. Essentially this represents any concrete object, or ID of that object. It is used across Hikari's API to allow use of functions when information is only partially available (due to Discord inconsistencies, edge case behaviour, or use of intents). The valid types for this type hint are: -  buitlins.int -  Snowflake "
},
{
"ref":"hikari.snowflakes.SearchableSnowflakeishOr",
"url":1,
"doc":"Type hint for a unique object entity that can be searched for. This is a variant of  SnowflakeishOr that also allows an alternative value of a  datetime.datetime to be specified. Essentially this represents any concrete object, or ID of that object. It is used across Hikari's API to allow use of functions when information is only partially available (due to Discord inconsistencies, edge case behaviour, or use of intents). The valid types for this type hint are: -  buitlins.int -  Snowflake -  datetime.datetime "
},
{
"ref":"hikari.config",
"url":58,
"doc":"Data class containing network-related configuration settings."
},
{
"ref":"hikari.config.BasicAuthHeader",
"url":58,
"doc":"An object that can be set as a producer for a basic auth header. Method generated by attrs for class BasicAuthHeader."
},
{
"ref":"hikari.config.BasicAuthHeader.header",
"url":58,
"doc":"Create the full  Authentication header value. Returns    - builtins.str A base64-encoded string containing  \"{username}:{password}\" ."
},
{
"ref":"hikari.config.BasicAuthHeader.charset",
"url":58,
"doc":"Encoding to use for the username and password. Default is  \"utf-8\" , but you may choose to use something else, including third-party encodings (e.g. IBM's EBCDIC codepages). Returns    - builtins.str The encoding to use."
},
{
"ref":"hikari.config.BasicAuthHeader.password",
"url":58,
"doc":"Password to use. Returns    - builtins.str The password to use."
},
{
"ref":"hikari.config.BasicAuthHeader.username",
"url":58,
"doc":"Username for the header. Returns    - builtins.str The username to use. This must not contain  \":\" ."
},
{
"ref":"hikari.config.ProxySettings",
"url":58,
"doc":"Settings for configuring an HTTP-based proxy. Method generated by attrs for class ProxySettings."
},
{
"ref":"hikari.config.ProxySettings.all_headers",
"url":58,
"doc":"Return all proxy headers. Returns    - typing.Optional[hikari.internal.data_binding.Headers] Any headers that are set, or  builtins.None if no headers are to be sent with any request."
},
{
"ref":"hikari.config.ProxySettings.auth",
"url":58,
"doc":"Authentication header value to use. When cast to a  builtins.str , this should provide the full value for the authentication header. If you are using basic auth, you should consider using the  BasicAuthHeader helper object here, as this will provide any transformations you may require into a base64 string. The default is to have this set to  builtins.None , which will result in no authentication being provided. Returns    - typing.Any The value for the  Authentication header, or  builtins.None to disable."
},
{
"ref":"hikari.config.ProxySettings.headers",
"url":58,
"doc":"Additional headers to use for requests via a proxy, if required."
},
{
"ref":"hikari.config.ProxySettings.trust_env",
"url":58,
"doc":"Toggle whether to look for a  netrc file or environment variables. If  builtins.True , and no  url is given on this object, then  HTTP_PROXY and  HTTPS_PROXY will be used from the environment variables, or a  netrc file may be read to determine credentials. If  builtins.False , then this information is instead ignored. Defaults to  builtins.False to prevent potentially unwanted behavior.  ! note For more details of using  netrc , visit: https: www.gnu.org/software/inetutils/manual/html_node/The-_002enetrc-file.html Returns    - builtins.bool  builtins.True if allowing the use of environment variables and/or  netrc to determine proxy settings;  builtins.False if this should be disabled explicitly."
},
{
"ref":"hikari.config.ProxySettings.url",
"url":58,
"doc":"Proxy URL to use. Defaults to  builtins.None which disables the use of an explicit proxy. Returns    - typing.Union[builtins.None, builtins.str, yarl.URL] The proxy URL to use, or  builtins.None to disable it."
},
{
"ref":"hikari.config.HTTPTimeoutSettings",
"url":58,
"doc":"Settings to control HTTP request timeouts. Method generated by attrs for class HTTPTimeoutSettings."
},
{
"ref":"hikari.config.HTTPTimeoutSettings.acquire_and_connect",
"url":58,
"doc":"Timeout for  request_socket_connect PLUS connection acquisition. By default, this has no timeout allocated. Returns    - typing.Optional[builtins.float] The timeout, or  builtins.None to disable it."
},
{
"ref":"hikari.config.HTTPTimeoutSettings.request_socket_connect",
"url":58,
"doc":"Timeout for connecting a socket. By default, this has no timeout allocated. Returns    - typing.Optional[builtins.float] The timeout, or  builtins.None to disable it."
},
{
"ref":"hikari.config.HTTPTimeoutSettings.request_socket_read",
"url":58,
"doc":"Timeout for reading a socket. By default, this has no timeout allocated. Returns    - typing.Optional[builtins.float] The timeout, or  builtins.None to disable it."
},
{
"ref":"hikari.config.HTTPTimeoutSettings.total",
"url":58,
"doc":"Total timeout for entire request. By default, this has a 30 second timeout allocated. Returns    - typing.Optional[builtins.float] The timeout, or  builtins.None to disable it."
},
{
"ref":"hikari.config.HTTPSettings",
"url":58,
"doc":"Settings to control HTTP clients. Method generated by attrs for class HTTPSettings."
},
{
"ref":"hikari.config.HTTPSettings.ssl",
"url":58,
"doc":""
},
{
"ref":"hikari.config.HTTPSettings.enable_cleanup_closed",
"url":58,
"doc":"Toggle whether to clean up closed transports. This defaults to  builtins.True to combat various protocol and asyncio issues present when using Microsoft Windows. If you are sure you know what you are doing, you may instead set this to  False to disable this behavior internally. Returns    - builtins.bool  builtins.True to enable this behavior,  builtins.False to disable it."
},
{
"ref":"hikari.config.HTTPSettings.force_close_transports",
"url":58,
"doc":"Toggle whether to force close transports on shutdown. This defaults to  builtins.True to combat various protocol and asyncio issues present when using Microsoft Windows. If you are sure you know what you are doing, you may instead set this to  False to disable this behavior internally. Returns    - builtins.bool  builtins.True to enable this behavior,  builtins.False to disable it."
},
{
"ref":"hikari.config.HTTPSettings.max_redirects",
"url":58,
"doc":"Behavior for handling redirect HTTP responses. If a  builtins.int , allow following redirects from  3xx HTTP responses for up to this many redirects. Exceeding this value will raise an exception. If  builtins.None , then disallow any redirects. The default is to disallow this behavior for security reasons. Generally, it is safer to keep this disabled. You may find a case in the future where you need to enable this if Discord change their URL without warning.  ! note This will only apply to the REST API. WebSockets remain unaffected by any value set here. Returns    - typing.Optional[builtins.int] The number of redirects to allow at a maximum per request.  builtins.None disables the handling of redirects and will result in exceptions being raised instead should one occur."
},
{
"ref":"hikari.config.HTTPSettings.timeouts",
"url":58,
"doc":"Settings to control HTTP request timeouts. The behaviour if this is not explicitly defined is to use sane defaults that are most efficient for optimal use of this library. Returns    - HTTPTimeoutSettings The HTTP timeout settings to use for connection timeouts."
},
{
"ref":"hikari.files",
"url":2,
"doc":"Utilities and classes for interacting with files and web resources."
},
{
"ref":"hikari.files.ensure_path",
"url":2,
"doc":"Convert a path-like object to a  pathlib.Path instance.",
"func":1
},
{
"ref":"hikari.files.ensure_resource",
"url":2,
"doc":"Given a resource or string, convert it to a valid resource as needed. Parameters      url_or_resource : Resourceish The item to convert. Ff a  Resource is passed, it is simply returned again. Anything else is converted to a  Resource first. Returns    - typing.Optional[Resource] The resource to use, or  builtins.None if  builtins.None was input.",
"func":1
},
{
"ref":"hikari.files.unwrap_bytes",
"url":2,
"doc":"Convert a byte-like object to bytes.",
"func":1
},
{
"ref":"hikari.files.Pathish",
"url":2,
"doc":"Type hint representing a literal file or path. This may be one of: -  builtins.str path. -  os.PathLike derivative, such as  pathlib.PurePath and  pathlib.Path ."
},
{
"ref":"hikari.files.Rawish",
"url":2,
"doc":"Type hint representing valid raw data types. This may be one of: -  bytes -  bytearray -  memoryview -  io.BytesIO -  io.StringIO (assuming UTF-8 encoding)."
},
{
"ref":"hikari.files.Resourceish",
"url":2,
"doc":"Type hint representing a file or path to a file/URL/data URI. This may be one of: -  Resource or a derivative. -  builtins.str path. -  os.PathLike derivative, such as  pathlib.PurePath and  pathlib.Path . -  bytes -  bytearray -  memoryview -  io.BytesIO -  io.StringIO (assuming UTF-8 encoding)."
},
{
"ref":"hikari.files.LazyByteIteratorish",
"url":2,
"doc":"Type hint representing an iterator/iterable of bytes. This may be one of: -  typing.AsyncIterator[bytes] -  typing.AsyncIterable[bytes] -  typing.Iterator[bytes] -  typing.Iterable[bytes] -  typing.AsyncIterator[str] (assuming UTF-8 encoding). -  typing.AsyncIterable[str] (assuming UTF-8 encoding). -  typing.Iterator[str] (assuming UTF-8 encoding). -  typing.Iterable[str] (assuming UTF-8 encoding). -  asyncio.StreamReader -  aiohttp.StreamReader "
},
{
"ref":"hikari.files.AsyncReader",
"url":2,
"doc":"Protocol for reading a resource asynchronously using bit inception. This supports being used as an async iterable, although the implementation detail is left to each implementation of this class to define. Method generated by attrs for class AsyncReader."
},
{
"ref":"hikari.files.AsyncReader.data_uri",
"url":2,
"doc":"Fetch the data URI. This reads the entire resource.",
"func":1
},
{
"ref":"hikari.files.AsyncReader.read",
"url":2,
"doc":"Read the rest of the resource and return it in a  builtins.bytes object.",
"func":1
},
{
"ref":"hikari.files.AsyncReader.filename",
"url":2,
"doc":"The filename of the resource."
},
{
"ref":"hikari.files.AsyncReader.mimetype",
"url":2,
"doc":"The mimetype of the resource. May be  builtins.None if not known."
},
{
"ref":"hikari.files.AsyncReaderContextManager",
"url":2,
"doc":"Context manager that returns a reader."
},
{
"ref":"hikari.files.Resource",
"url":2,
"doc":"Base for any uploadable or downloadable representation of information. These representations can be streamed using bit inception for performance, which may result in significant decrease in memory usage for larger resources."
},
{
"ref":"hikari.files.Resource.url",
"url":2,
"doc":"URL of the resource."
},
{
"ref":"hikari.files.Resource.filename",
"url":2,
"doc":"Filename of the resource."
},
{
"ref":"hikari.files.Resource.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.files.Resource.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.files.Resource.stream",
"url":2,
"doc":"Produce a stream of data for the resource. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. This will fetch the headers for the HTTP resource this object points to without downloading the entire content, which can be significantly faster if you are scanning file types in messages, for example. Returns    - AsyncReaderContextManager[AsyncReader] An async iterable of bytes to stream.",
"func":1
},
{
"ref":"hikari.files.File",
"url":2,
"doc":"A resource that exists on the local machine's storage to be uploaded. Parameters      path : typing.Union[builtins.str, os.PathLike, pathlib.Path] The path to use.  ! note If passing a  pathlib.Path , this must not be a  pathlib.PurePath directly, as it will be used to expand tokens such as  ~ that denote the home directory, and    for relative paths. This will all be performed as required in an executor to prevent blocking the event loop. filename : typing.Optional[builtins.str] The filename to use. If this is  builtins.None , the name of the file is taken from the path instead. spoiler : bool Whether to mark the file as a spoiler in Discord. Defaults to  builtins.False ."
},
{
"ref":"hikari.files.File.url",
"url":2,
"doc":"URL of the resource."
},
{
"ref":"hikari.files.File.filename",
"url":2,
"doc":"Filename of the resource."
},
{
"ref":"hikari.files.File.stream",
"url":2,
"doc":"Start streaming the resource using a thread pool executor. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run the blocking read operations in. If  builtins.None , the default executor for the running event loop will be used instead. head_only : builtins.bool Not used. Provided only to match the underlying interface. Returns    - AsyncReaderContextManager[FileReader] An async context manager that when entered, produces the data stream.",
"func":1
},
{
"ref":"hikari.files.File.is_spoiler",
"url":2,
"doc":"Whether the file will be marked as a spoiler."
},
{
"ref":"hikari.files.File.path",
"url":2,
"doc":"The path to the file."
},
{
"ref":"hikari.files.File.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.files.File.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.files.FileReader",
"url":2,
"doc":"Abstract base for a file reader object. Various implementations have to exist in order to cater for situations where we cannot pass IO objects around (e.g. ProcessPoolExecutors, since they pickle things). Method generated by attrs for class FileReader."
},
{
"ref":"hikari.files.FileReader.executor",
"url":2,
"doc":"The associated  concurrent.futures.Executor to use for blocking IO."
},
{
"ref":"hikari.files.FileReader.path",
"url":2,
"doc":"The path to the resource to read."
},
{
"ref":"hikari.files.FileReader.data_uri",
"url":2,
"doc":"Fetch the data URI. This reads the entire resource.",
"func":1
},
{
"ref":"hikari.files.FileReader.read",
"url":2,
"doc":"Read the rest of the resource and return it in a  builtins.bytes object.",
"func":1
},
{
"ref":"hikari.files.FileReader.filename",
"url":2,
"doc":"The filename of the resource."
},
{
"ref":"hikari.files.FileReader.mimetype",
"url":2,
"doc":"The mimetype of the resource. May be  builtins.None if not known."
},
{
"ref":"hikari.files.WebResource",
"url":2,
"doc":"Base class for a resource that resides on the internet. The logic for identifying this resource is left to each implementation to define.  ! info For a usable concrete implementation, use  URL instead.  ! note Some components may choose to not upload this resource directly and instead simply refer to the URL as needed. The main place this will occur is within embeds. If you need to re-upload the resource, you should download it into a  builtins.bytes and pass that instead in these cases."
},
{
"ref":"hikari.files.WebResource.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.files.WebResource.url",
"url":2,
"doc":"URL of the resource."
},
{
"ref":"hikari.files.WebResource.filename",
"url":2,
"doc":"Filename of the resource."
},
{
"ref":"hikari.files.WebResource.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.files.WebResource.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.files.URL",
"url":2,
"doc":"A URL that represents a web resource. Parameters      url : builtins.str The URL of the resource.  ! note Some components may choose to not upload this resource directly and instead simply refer to the URL as needed. The main place this will occur is within embeds. If you need to re-upload the resource, you should download it into a  builtins.bytes and pass that instead in these cases."
},
{
"ref":"hikari.files.URL.url",
"url":2,
"doc":"URL of the resource."
},
{
"ref":"hikari.files.URL.filename",
"url":2,
"doc":"Filename of the resource."
},
{
"ref":"hikari.files.URL.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.files.URL.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.files.URL.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.files.WebReader",
"url":2,
"doc":"Asynchronous reader to use to read data from a web resource. Method generated by attrs for class WebReader."
},
{
"ref":"hikari.files.WebReader.read",
"url":2,
"doc":"Read the rest of the resource and return it in a  builtins.bytes object.",
"func":1
},
{
"ref":"hikari.files.WebReader.charset",
"url":2,
"doc":"Optional character set information, if known."
},
{
"ref":"hikari.files.WebReader.head_only",
"url":2,
"doc":"If  builtins.True , then only the HEAD was requested. In this case, neither  __aiter__ nor  read would return anything other than an empty byte string."
},
{
"ref":"hikari.files.WebReader.reason",
"url":2,
"doc":"The HTTP response status reason."
},
{
"ref":"hikari.files.WebReader.size",
"url":2,
"doc":"The size of the resource, if known."
},
{
"ref":"hikari.files.WebReader.status",
"url":2,
"doc":"The initial HTTP response status."
},
{
"ref":"hikari.files.WebReader.stream",
"url":2,
"doc":"The  aiohttp.StreamReader to read the content from."
},
{
"ref":"hikari.files.WebReader.url",
"url":2,
"doc":"The URL being read from."
},
{
"ref":"hikari.files.WebReader.data_uri",
"url":2,
"doc":"Fetch the data URI. This reads the entire resource.",
"func":1
},
{
"ref":"hikari.files.WebReader.filename",
"url":2,
"doc":"The filename of the resource."
},
{
"ref":"hikari.files.WebReader.mimetype",
"url":2,
"doc":"The mimetype of the resource. May be  builtins.None if not known."
},
{
"ref":"hikari.files.Bytes",
"url":2,
"doc":"Representation of in-memory data to upload. Parameters      data : typing.Union[Rawish, LazyByteIteratorish] The raw data. filename : builtins.str The filename to use. mimetype : typing.Optional[builtins.str] The mimetype, or  builtins.None if you do not wish to specify this. If not provided, then this will be generated from the file extension of the filename instead. spoiler : bool Whether to mark the file as a spoiler in Discord. Defaults to  builtins.False ."
},
{
"ref":"hikari.files.Bytes.url",
"url":2,
"doc":"URL of the resource."
},
{
"ref":"hikari.files.Bytes.filename",
"url":2,
"doc":"Filename of the resource."
},
{
"ref":"hikari.files.Bytes.stream",
"url":2,
"doc":"Start streaming the content in chunks. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Not used. Provided only to match the underlying interface. Returns    - AsyncReaderContextManager[IteratorReader] An async context manager that when entered, produces the data stream.",
"func":1
},
{
"ref":"hikari.files.Bytes.from_data_uri",
"url":2,
"doc":"Parse a given data URI. Parameters      data_uri : builtins.str The data URI to parse. filename : typing.Optional[builtins.str] Filename to use. If this is not provided, then this is generated instead. Returns    - Bytes The parsed data URI as a  Bytes object. Raises    builtins.ValueError If the parsed argument is not a data URI.",
"func":1
},
{
"ref":"hikari.files.Bytes.data",
"url":2,
"doc":"The raw data/provider of raw data to upload."
},
{
"ref":"hikari.files.Bytes.is_spoiler",
"url":2,
"doc":"Whether the file will be marked as a spoiler."
},
{
"ref":"hikari.files.Bytes.mimetype",
"url":2,
"doc":"The provided mimetype, if provided. Otherwise  builtins.None ."
},
{
"ref":"hikari.files.Bytes.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.files.Bytes.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.files.IteratorReader",
"url":2,
"doc":"Asynchronous file reader that operates on in-memory data. Method generated by attrs for class IteratorReader."
},
{
"ref":"hikari.files.IteratorReader.data",
"url":2,
"doc":"The data that will be yielded in chunks."
},
{
"ref":"hikari.files.IteratorReader.data_uri",
"url":2,
"doc":"Fetch the data URI. This reads the entire resource.",
"func":1
},
{
"ref":"hikari.files.IteratorReader.read",
"url":2,
"doc":"Read the rest of the resource and return it in a  builtins.bytes object.",
"func":1
},
{
"ref":"hikari.files.IteratorReader.filename",
"url":2,
"doc":"The filename of the resource."
},
{
"ref":"hikari.files.IteratorReader.mimetype",
"url":2,
"doc":"The mimetype of the resource. May be  builtins.None if not known."
},
{
"ref":"hikari.sessions",
"url":59,
"doc":"Entities directly related to creating and managing gateway shard sessions."
},
{
"ref":"hikari.sessions.GatewayBot",
"url":59,
"doc":"Used to represent gateway information for the connected bot. Method generated by attrs for class GatewayBot."
},
{
"ref":"hikari.sessions.GatewayBot.session_start_limit",
"url":59,
"doc":"Information about the bot's current session start limit."
},
{
"ref":"hikari.sessions.GatewayBot.shard_count",
"url":59,
"doc":"The recommended number of shards to use when connecting to the gateway."
},
{
"ref":"hikari.sessions.GatewayBot.url",
"url":59,
"doc":"The WSS URL that can be used for connecting to the gateway."
},
{
"ref":"hikari.sessions.SessionStartLimit",
"url":59,
"doc":"Used to represent information about the current session start limits. Method generated by attrs for class SessionStartLimit."
},
{
"ref":"hikari.sessions.SessionStartLimit.used",
"url":59,
"doc":"Return how many times you have sent an IDENTIFY in the window."
},
{
"ref":"hikari.sessions.SessionStartLimit.reset_at",
"url":59,
"doc":"Return the approximate time that the IDENTIFY limit resets at."
},
{
"ref":"hikari.sessions.SessionStartLimit.max_concurrency",
"url":59,
"doc":"Maximum connection concurrency. This defines how many shards can be started at once within a 5 second window. For most bots, this will always be  1 , but for very large bots, this may be increased to reduce startup times. Contact Discord for more information."
},
{
"ref":"hikari.sessions.SessionStartLimit.remaining",
"url":59,
"doc":"The remaining number of session starts this bot has."
},
{
"ref":"hikari.sessions.SessionStartLimit.reset_after",
"url":59,
"doc":"When  SessionStartLimit.remaining will reset for the current bot. After it resets it will be set to  SessionStartLimit.total ."
},
{
"ref":"hikari.sessions.SessionStartLimit.total",
"url":59,
"doc":"The total number of session starts the current bot is allowed."
},
{
"ref":"hikari.undefined",
"url":60,
"doc":"Singleton used throughout the library to denote values that are not present."
},
{
"ref":"hikari.undefined.UNDEFINED",
"url":60,
"doc":"A sentinel singleton that denotes a missing or omitted value."
},
{
"ref":"hikari.undefined.UndefinedNoneOr",
"url":60,
"doc":"Type hint for a value that may be  undefined.UNDEFINED , or  builtins.None .  UndefinedNoneOr[T] is simply an alias for  UndefinedOr[typing.Optional[T  , which would expand to  typing.Union[UndefinedType, T, None] ."
},
{
"ref":"hikari.undefined.UndefinedOr",
"url":60,
"doc":"Type hint to mark a type as being semantically optional.  NOTE THAT THIS IS NOT THE SAME AS  typing.Optional BY DEFINITION . If you see a type with this marker, it may be  UNDEFINED or the value it wraps. For example,  UndefinedOr[float] would mean the value could be a  builtins.float , or the literal  UNDEFINED value. On the other hand,  typing.Optional[float] would mean the value could be a  builtins.float , or the literal  builtins.None value. The reason for using this is in some places, there is a semantic difference between specifying something as being  builtins.None , i.e. \"no value\", and having a default to specify that the value has just not been mentioned. The main example of this is in  edit endpoints where the contents will only be changed if they are explicitly mentioned in the call. Editing a message content and setting it to  builtins.None would be expected to clear the content, whereas setting it to  UNDEFINED would be expected to leave the value as it is without changing it. Consider  UndefinedOr[T] semantically equivalent to  undefined versus  null in JavaScript, or  Optional  versus  null in Java and C . If in doubt, remember: -  UNDEFINED means there is no value present, or that it has been left to the default value. -  builtins.None means the value is present and explicitly empty/null/void, where this has a deterministic documented behaviour and no differentiation is made between a  builtins.None value, and one that has been omitted."
},
{
"ref":"hikari.undefined.UndefinedType",
"url":60,
"doc":"The type of the  UNDEFINED singleton sentinel value."
},
{
"ref":"hikari.undefined.count",
"url":60,
"doc":"Count the number of items that are provided that are  UNDEFINED .",
"func":1
},
{
"ref":"hikari.impl",
"url":61,
"doc":"Basic implementations of application components. These components implement the interfaces in  hikari.api to provide the baseline functionality. For most applications that do not have bespoke performance or structural requirements, you will want to use these implementations."
},
{
"ref":"hikari.impl.voice",
"url":62,
"doc":"Implementation of a simple voice management system."
},
{
"ref":"hikari.impl.voice.VoiceComponentImpl",
"url":62,
"doc":"A standard voice component management implementation. This is the regular implementation you will generally use to connect to voice channels with."
},
{
"ref":"hikari.impl.voice.VoiceComponentImpl.app",
"url":62,
"doc":""
},
{
"ref":"hikari.impl.voice.VoiceComponentImpl.connections",
"url":62,
"doc":"Return a mapping of guild-id to active voice connection."
},
{
"ref":"hikari.impl.voice.VoiceComponentImpl.disconnect",
"url":62,
"doc":"Shut down all connections, waiting for them to terminate. This will not close the voice component.",
"func":1
},
{
"ref":"hikari.impl.voice.VoiceComponentImpl.close",
"url":62,
"doc":"Shut down all connections, waiting for them to terminate. Once this is done, unsubscribe from any events. If you simply wish to disconnect every connection, use  disconnect instead.",
"func":1
},
{
"ref":"hikari.impl.voice.VoiceComponentImpl.connect_to",
"url":62,
"doc":"Connect to a given voice channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel] The channel or channel ID to connect to. guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.Guild] The guild to connect to. deaf : builtins.bool Defaulting to  builtins.False , if  builtins.True , the client will enter the voice channel deafened (thus unable to hear other users). mute : builtins.bool Defaulting to  builtins.False , if  builtins.True , the client will enter the voice channel muted (thus unable to send audio). voice_connection_type : typing.Type[VoiceConnection] The type of voice connection to use. This should be initialized internally using the  IVoiceConnection.initialize  builtins.classmethod .  kwargs : typing.Any Any arguments to provide to the  IVoiceConnection.initialize method. Returns    - VoiceConnection A voice connection implementation of some sort.",
"func":1
},
{
"ref":"hikari.impl.bot",
"url":63,
"doc":"Basic implementation the components for a single-process bot."
},
{
"ref":"hikari.impl.bot.BotApp",
"url":63,
"doc":"Basic auto-sharding bot implementation. This is the class you will want to use to start, control, and build a bot with. Parameters      token : builtins.str The bot token to sign in with. Other Parameters         allow_color : builtins.bool Defaulting to  builtins.True , this will enable coloured console logs on any platform that is a TTY. Setting a  \"CLICOLOR\" environment variable to any  non  0 value will override this setting. Users should consider this an advice to the application on whether it is safe to show colours if possible or not. Since some terminals can be awkward or not support features in a standard way, the option to explicitly disable this is provided. See  force_color for an alternative. banner : typing.Optional[builtins.str] The package to search for a  banner.txt in. Defaults to  \"hikari\" for the  \"hikari/banner.txt\" banner. Setting this to  builtins.None will disable the banner being shown. chunking_limit : typing.Optional[builtins.int] Defaults to  200 . The maximum amount of requests that this chunker should store information about for each shard. enable_cache : builtins.bool Defaults to  builtins.True . If  builtins.False , the application is configured to be mostly stateless. This means almost all cache calls will yield an empty or  builtins.None value, and you will be left to rely on the  REST API only. This can be a viable alternative if you are providing a custom cache implementation, or simply do not want the overhead of maintaining a state in your application. executor : typing.Optional[concurrent.futures.Executor] Defaults to  builtins.None . If non- builtins.None , then this executor is used instead of the  concurrent.futures.ThreadPoolExecutor attached to the  asyncio.AbstractEventLoop that the bot will run on. This executor is used primarily for file-IO. While mainly supporting the  concurrent.futures.ThreadPoolExecutor implementation in the standard lib, Hikari's file handling systems should also work with  concurrent.futures.ProcessPoolExecutor , which relies on all objects used in IPC to be  pickle able. Many third-party libraries will not support this fully though, so your mileage may vary on using ProcessPoolExecutor implementations with this parameter. force_color : builtins.bool Defaults to  builtins.False . If  builtins.True , then this application will __force__ colour to be used in console-based output. Specifying a  \"CLICOLOR_FORCE\" environment variable with a non- \"0\" value will override this setting. http_settings : typing.Optional[hikari.config.HTTPSettings] Optional custom HTTP configuration settings to use. Allows you to customise functionality such as whether SSL-verification is enabled, what timeouts  aiohttp should expect to use for requests, and behavior regarding HTTP-redirects. intents : hikari.intents.Intents Defaults to  hikari.intents.Intents.ALL_UNPRIVILEGED . This allows you to change which intents your application will use on the gateway. This can be used to control and change the types of events you will receive. logs : typing.Union[builtins.None, LoggerLevel, typing.Dict[str, typing.Any Defaults to  \"INFO\" . If  builtins.None , then the Python logging system is left uninitialized on startup, and you will need to configure it manually to view most logs that are output by components of this library. If one of the valid values in a  LoggerLevel , then this will match a call to  colorlog.basicConfig (a facade for  logging.basicConfig with additional conduit for enabling coloured logging levels) with the  level kwarg matching this value. If a  typing.Dict[str, typing.Any] equivalent, then this value is passed to  logging.config.dictConfig to allow the user to provide a specialized logging configuration of their choice. As a side note, you can always opt to leave this on the default value and then use an incremental  logging.config.dictConfig that applies any additional changes on top of the base configuration, if you prefer. An example of can be found in the  Example section. Note that  \"TRACE_HIKARI\" is a library-specific logging level which is expected to be more verbose than  \"DEBUG\" . max_rate_limit : builtins.float The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. This defaults to five minutes if left to the default value. This is to stop potentially indefinitely waiting on an endpoint, which is almost never what you want to do if giving a response to a user. You can set this to  float(\"inf\") to disable this check entirely. Note that this only applies to the REST API component that communicates with Discord, and will not affect sharding or third party HTTP endpoints that may be in use. proxy_settings : typing.Optional[config.ProxySettings] Custom proxy settings to use with network-layer logic in your application to get through an HTTP-proxy. rest_url : typing.Optional[builtins.str] Defaults to the Discord REST API URL if  builtins.None . Can be overridden if you are attempting to point to an unofficial endpoint, or if you are attempting to mock/stub the Discord API for any reason. Generally you do not want to change this.  ! note  force_color will always take precedence over  allow_color .  ! note Settings that control the gateway session are provided to the  BotApp.run and  BotApp.start functions in this class. This is done to allow you to contextually customise details such as sharding configuration without having to re-initialize the entire application each time. Example    - Setting up logging using a dictionary configuration:   import os from logging.config import dictConfig from hikari import Bot, Intents bot = Bot(token=os.environ[\"BOT_TOKEN\"], intents=Intents.ALL, logs=\"INFO\")  We want to make gateway logs output as DEBUG, and TRACE for all ratelimit content. dictConfig({ \"version\": 1, \"incremental\": True, \"loggers\": { \"hikari.gateway\": { \"level\": \"DEBUG\" }, \"hikari.ratelimits\": { \"level\": \"TRACE_HIKARI\" }, }, })  "
},
{
"ref":"hikari.impl.bot.BotApp.cache",
"url":63,
"doc":"Return the immutable cache implementation for this object. Returns    - hikari.api.cache.Cache The cache component for this object."
},
{
"ref":"hikari.impl.bot.BotApp.chunker",
"url":63,
"doc":"Return the guild chunker component. Returns    - hikari.api.chunker.GuildChunker The guild chunker component."
},
{
"ref":"hikari.impl.bot.BotApp.dispatcher",
"url":63,
"doc":"Return the event dispatcher for this object. Returns    - hikari.api.event_dispatcher.EventDispatcher The event dispatcher component."
},
{
"ref":"hikari.impl.bot.BotApp.entity_factory",
"url":63,
"doc":"Return the entity factory implementation for this object. Returns    - hikari.api.entity_factory.EntityFactory The entity factory component."
},
{
"ref":"hikari.impl.bot.BotApp.event_factory",
"url":63,
"doc":"Return the event factory component. Returns    - hikari.api.event_factory.EventFactory The event factory component."
},
{
"ref":"hikari.impl.bot.BotApp.executor",
"url":63,
"doc":"Return the executor to use for blocking operations. This may return  builtins.None if the default  asyncio thread pool should be used instead. Returns    - typing.Optional[concurrent.futures.Executor] The executor to use, or  builtins.None to use the  asyncio default instead."
},
{
"ref":"hikari.impl.bot.BotApp.heartbeat_latencies",
"url":63,
"doc":"Return a mapping of shard ID to heartbeat latency. Any shards that are not yet started will be  float('nan') . Returns    - typing.Mapping[builtins.int, builtins.float] Each shard ID mapped to the corresponding heartbeat latency. Each latency is measured in seconds."
},
{
"ref":"hikari.impl.bot.BotApp.heartbeat_latency",
"url":63,
"doc":"Return the average heartbeat latency of all started shards. If no shards are started, this will return  float('nan') . Returns    - builtins.float The average heartbeat latency of all started shards, or  float('nan') if no shards are started. This is measured in seconds."
},
{
"ref":"hikari.impl.bot.BotApp.http_settings",
"url":63,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.impl.bot.BotApp.intents",
"url":63,
"doc":"Return the intents registered for the application. Returns    - hikari.intents.Intents The intents registered on this application."
},
{
"ref":"hikari.impl.bot.BotApp.me",
"url":63,
"doc":"Return the bot user, if known. This should be available as soon as the bot has fired the  hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be  builtins.None . Returns    - typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise  builtins.None ."
},
{
"ref":"hikari.impl.bot.BotApp.proxy_settings",
"url":63,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.impl.bot.BotApp.shard_count",
"url":63,
"doc":"Return the number of shards in the total application. This may not be the same as the size of  shards . If the application is auto-sharded, this may be  0 until the shards are started. Returns    - builtins.int The number of shards in the total application."
},
{
"ref":"hikari.impl.bot.BotApp.voice",
"url":63,
"doc":"Return the voice connection manager component for this application. Returns    - hikari.api.voice.VoiceComponent The voice component for the application."
},
{
"ref":"hikari.impl.bot.BotApp.rest",
"url":63,
"doc":"Return the REST client to use for HTTP requests. Returns    - hikari.api.rest.RESTClient The REST client to use."
},
{
"ref":"hikari.impl.bot.BotApp.close",
"url":63,
"doc":"Kill the application by shutting all components down.",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.dispatch",
"url":63,
"doc":"Dispatch an event. Parameters      event : hikari.events.base_events.Event The event to dispatch. Example    - We can dispatch custom events by first defining a class that derives from  hikari.events.base_events.Event .   import attr from hikari.traits import RESTAware from hikari.events.base_events import Event from hikari.users import User from hikari.snowflakes import Snowflake @attr.s() class EveryoneMentionedEvent(Event): app: RESTAware = attr.ib() author: User = attr.ib()  'The user who mentioned everyone. ' content: str = attr.ib()  'The message that was sent. ' message_id: Snowflake = attr.ib()  'The message ID. ' channel_id: Snowflake = attr.ib()  'The channel ID. '   We can then dispatch our event as we see fit.   from hikari.events.messages import MessageCreateEvent @bot.listen(MessageCreateEvent) async def on_message(event): if \"@everyone\" in event.content or \"@here\" in event.content: event = EveryoneMentionedEvent( author=event.author, content=event.content, message_id=event.id, channel_id=event.channel_id, ) bot.dispatch(event)   This event can be listened to elsewhere by subscribing to it with  EventDispatcher.subscribe .   @bot.listen(EveryoneMentionedEvent) async def on_everyone_mentioned(event): print(event.user, \"just pinged everyone in\", event.channel_id)   Returns    - asyncio.Future[typing.Any] A future that can be optionally awaited. If awaited, the future will complete once all corresponding event listeners have been invoked. If not awaited, this will schedule the dispatch of the events in the background for later. See Also     Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.get_listeners",
"url":63,
"doc":"Get the listeners for a given event type, if there are any. Parameters      event_type : typing.Type[T] The event type to look for.  T must be a subclass of  hikari.events.base_events.Event . polymorphic : builtins.bool If  builtins.True , this will also return the listeners of the subclasses of the given event type. If  builtins.False , then only listeners for this class specifically are returned. The default is  builtins.True . Returns    - typing.Collection[typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None A copy of the collection of listeners for the event. Will return an empty collection if nothing is registered.  T must be a subclass of  hikari.events.base_events.Event . See Also     Has listener:  hikari.api.event_dispatcher.EventDispatcher.has_listener ",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.join",
"url":63,
"doc":"Wait indefinitely until the application closes. This can be placed in a task and cancelled without affecting the application runtime itself. Any exceptions raised by shards will be propagated to here. Other Parameters         until_close : builtins.bool Defaults to  builtins.True . If set, the waiter will stop as soon as a request for shut down is processed. This can allow you to break and begin closing your own resources. If  builtins.False , then this will wait until all shards' tasks have died.",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.listen",
"url":63,
"doc":"Generate a decorator to subscribe a callback to an event type. This is a second-order decorator. Parameters      event_type : typing.Optional[typing.Type[T The event type to subscribe to. The implementation may allow this to be undefined. If this is the case, the event type will be inferred instead from the type hints on the function signature.  T must be a subclass of  hikari.events.base_events.Event . Returns    - typing.Callable T], T] A decorator for a coroutine function that passes it to  EventDispatcher.subscribe before returning the function reference. See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.print_banner",
"url":63,
"doc":"Print the banner. This allows library vendors to override this behaviour, or choose to inject their own \"branding\" on top of what hikari provides by default. Normal users should not need to invoke this function, and can simply change the  banner argument passed to the constructor to manipulate what is displayed. Parameters      banner : typing.Optional[builtins.str] The package to find a  banner.txt in. allow_color : builtins.bool A flag that allows advising whether to allow color if supported or not. Can be overridden by setting a  \"CLICOLOR\" environment variable to a non- \"0\" string. force_color : builtins.bool A flag that allows forcing color to always be output, even if the terminal device may not support it. Setting the  \"CLICOLOR_FORCE\" environment variable to a non- \"0\" string will override this.  ! note  force_color will always take precedence over  allow_color .",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.run",
"url":63,
"doc":"Start the bot, wait for all shards to become ready, and then return. Other Parameters         activity : typing.Optional[hikari.presences.Activity] The initial activity to display in the bot user presence, or  builtins.None (default) to not show any. afk : builtins.bool The initial AFK state to display in the bot user presence, or  builtins.False (default) to not show any. asyncio_debug : builtins.bool Defaults to  builtins.False . If  builtins.True , then debugging is enabled for the asyncio event loop in use. check_for_updates : builtins.bool Defaults to  builtins.True . If  builtins.True , will check for newer versions of  hikari on PyPI and notify if available. close_passed_executor : builtins.bool Defaults to  builtins.False . If  builtins.True , any custom  concurrent.futures.Executor passed to the constructor will be shut down when the application terminates. This does not affect the default executor associated with the event loop, and will not do anything if you do not provide a custom executor to the constructor. close_loop : builtins.bool Defaults to  builtins.True . If  builtins.True , then once the bot enters a state where all components have shut down permanently during application shutdown, then all asyngens and background tasks will be destroyed, and the event loop will be shut down. This will wait until all  hikari -owned  aiohttp connectors have had time to attempt to shut down correctly (around 250ms), and on Python 3.9 and newer, will also shut down the default event loop executor too. coroutine_tracking_depth : typing.Optional[builtins.int] Defaults to  builtins.None . If an integer value and supported by the interpreter, then this many nested coroutine calls will be tracked with their call origin state. This allows you to determine where non-awaited coroutines may originate from, but generally you do not want to leave this enabled for performance reasons. enable_signal_handlers : builtins.bool Defaults to  builtins.True . If on a __non-Windows__ OS with builtin support for kernel-level POSIX signals, then setting this to  builtins.True will allow treating keyboard interrupts and other OS signals to safely shut down the application as calls to shut down the application properly rather than just killing the process in a dirty state immediately. You should leave this disabled unless you plan to implement your own signal handling yourself. idle_since : typing.Optional[datetime.datetime] The  datetime.datetime the user should be marked as being idle since, or  builtins.None (default) to not show this. ignore_session_start_limit : builtins.bool Defaults to  builtins.False . If  builtins.False , then attempting to start more sessions than you are allowed in a 24 hour window will throw a  hikari.errors.GatewayError rather than going ahead and hitting the IDENTIFY limit, which may result in your token being reset. Setting to  builtins.True disables this behavior. large_threshold : builtins.int Threshold for members in a guild before it is treated as being \"large\" and no longer sending member details in the  GUILD CREATE event. Defaults to  250 . propagate_interrupts : builtins.bool Defaults to  builtins.False . If set to  builtins.True , then any internal  hikari.errors.HikariInterrupt that is raises as a result of catching an OS level signal will result in the exception being rethrown once the application has closed. This can allow you to use hikari signal handlers and still be able to determine what kind of interrupt the application received after it closes. When  builtins.False , nothing is raised and the call will terminate cleanly and silently where possible instead. shard_ids : typing.Optional[typing.Set[builtins.int The shard IDs to create shards for. If not  builtins.None , then a non- None  shard_count must ALSO be provided. Defaults to  builtins.None , which means the Discord-recommended count is used for your application instead. shard_count : typing.Optional[builtins.int] The number of shards to use in the entire distributed application. Defaults to  builtins.None which results in the count being determined dynamically on startup. status : hikari.presences.Status The initial status to show for the user presence on startup. Defaults to  hikari.presences.Status.ONLINE .",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.start",
"url":63,
"doc":"Start the bot, wait for all shards to become ready, and then return. Other Parameters         activity : typing.Optional[hikari.presences.Activity] The initial activity to display in the bot user presence, or  builtins.None (default) to not show any. afk : builtins.bool The initial AFK state to display in the bot user presence, or  builtins.False (default) to not show any. check_for_updates : builtins.bool Defaults to  builtins.True . If  builtins.True , will check for newer versions of  hikari on PyPI and notify if available. idle_since : typing.Optional[datetime.datetime] The  datetime.datetime the user should be marked as being idle since, or  builtins.None (default) to not show this. ignore_session_start_limit : builtins.bool Defaults to  builtins.False . If  builtins.False , then attempting to start more sessions than you are allowed in a 24 hour window will throw a  hikari.errors.GatewayError rather than going ahead and hitting the IDENTIFY limit, which may result in your token being reset. Setting to  builtins.True disables this behavior. large_threshold : builtins.int Threshold for members in a guild before it is treated as being \"large\" and no longer sending member details in the  GUILD CREATE event. Defaults to  250 . shard_ids : typing.Optional[typing.Set[builtins.int The shard IDs to create shards for. If not  builtins.None , then a non- None  shard_count must ALSO be provided. Defaults to  builtins.None , which means the Discord-recommended count is used for your application instead. shard_count : typing.Optional[builtins.int] The number of shards to use in the entire distributed application. Defaults to  builtins.None which results in the count being determined dynamically on startup. status : hikari.presences.Status The initial status to show for the user presence on startup. Defaults to  hikari.presences.Status.ONLINE .",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.stream",
"url":63,
"doc":"Return a stream iterator for the given event and sub-events. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. timeout : typing.Optional[builtins.int, builtins.float] How long this streamer should wait for the next event before ending the iteration. If  builtins.None then this will continue until explicitly broken from. limit : typing.Optional[builtins.int] The limit for how many events this should queue at one time before dropping extra incoming events, leave this as  builtins.None for the cache size to be unlimited. Returns    - hikari.event_stream.Streamer[hikari.events.base_events.Event] The async iterator to handle streamed events. This must be started with  async with stream: or  await stream.open() before asynchronously iterating over it.  ! warning If you use  await stream.open() to start the stream then you must also close it with  await stream.close() otherwise it may queue events in memory indefinitely. Examples       async with bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id as stream: async for user_id in stream.map(\"user_id\").limit(50):  .   or using await  open() and await  close()   stream = bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id await stream.open() async for user_id in stream.map(\"user_id\").limit(50)  . await stream.close()   See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.subscribe",
"url":63,
"doc":"Subscribe a given callback to a given event type. Parameters      event_type : typing.Type[T] The event type to listen for. This will also listen for any subclasses of the given type.  T must be a subclass of  hikari.events.base_events.Event . callback Must be a coroutine function to invoke. This should consume an instance of the given event, or an instance of a valid subclass if one exists. Any result is discarded. Example    - The following demonstrates subscribing a callback to message creation events.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.subscribe(MessageCreateEvent, on_message)   Returns    - typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None] The event callback that was passed in. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.unsubscribe",
"url":63,
"doc":"Unsubscribe a given callback from a given event type, if present. Parameters      event_type : typing.Type[T] The event type to unsubscribe from. This must be the same exact type as was originally subscribed with to be removed correctly.  T must derive from  hikari.events.base_events.Event . callback The callback to unsubscribe. Example    - The following demonstrates unsubscribing a callback from a message creation event.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.unsubscribe(MessageCreateEvent, on_message)  ",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.wait_for",
"url":63,
"doc":"Wait for a given event to occur once, then return the event. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. predicate A function taking the event as the single parameter. This should return  builtins.True if the event is one you want to return, or  builtins.False if the event should not be returned. If left as  None (the default), then the first matching event type that the bot receives (or any subtype) will be the one returned.  ! warn ASYNC PREDICATES ARE NOT SUPPORTED. timeout : typing.Union[builtins.float, builtins.int, builtins.None] The amount of time to wait before raising an  asyncio.TimeoutError and giving up instead. This is measured in seconds. If  builtins.None , then no timeout will be waited for (no timeout can result in \"leaking\" of coroutines that never complete if called in an uncontrolled way, so is not recommended). Returns    - hikari.events.base_events.Event The event that was provided. Raises    asyncio.TimeoutError If the timeout is not  builtins.None and is reached before an event is received that the predicate returns  builtins.True for. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch ",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.update_presence",
"url":63,
"doc":"Update the presence on all shards. This call will patch the presence on each shard. This means that unless you explicitly specify a parameter, the previous value will be retained. This means you do not have to track the global presence in your code. Other Parameters         idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed. afk : hikari.undefined.UndefinedOr[builtins.bool] If  builtins.True , the user is marked as AFK. If  builtins.False , the user is marked as being active. If undefined, this will not be changed. activity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed. status : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed.  ! note This will only send the update payloads to shards that are alive. Any shards that are not alive will cache the new presence for when they do start.  ! note If you want to set presences per shard, access the shard you wish to update (e.g. by using  BotApp.shards ), and call  hikari.api.shard.GatewayShard.update_presence on that shard. This method is simply a facade to make performing this in bulk simpler.",
"func":1
},
{
"ref":"hikari.impl.bot.BotApp.shards",
"url":63,
"doc":"Return a mapping of shards in this application instance. Each shard ID is mapped to the corresponding shard instance. If the application has not started, it is acceptable to assume the result of this call will be an empty mapping. Returns    - typing.Mapping[int, hikari.api.shard.GatewayShard] The shard mapping."
},
{
"ref":"hikari.impl.bot.LoggerLevelT",
"url":63,
"doc":"Type-hint for a valid logging level. This may be an  int logging level (e.g.  logging.DEBUG ,  logging.CRITICAL ), or a capitalized string that matches one of  \"TRACE_HIKARI\" ,  \"DEBUG\" ,  \"INFO\" ,  \"WARNING\",  \"ERROR\" , or  \"CRITICAL\" ."
},
{
"ref":"hikari.impl.stateless_guild_chunker",
"url":64,
"doc":"Basic implementation of a guild chunker."
},
{
"ref":"hikari.impl.stateless_guild_chunker.StatelessGuildChunkerImpl",
"url":64,
"doc":"Stateless guild chunker. A stateless guild chunker implementation that implements dummy operations for each of the required attributes of a functional guild chunker implementation. Any methods will always raise  builtins.NotImplemented when being invoked."
},
{
"ref":"hikari.impl.stateless_guild_chunker.StatelessGuildChunkerImpl.fetch_members_for_guild",
"url":64,
"doc":"Request for a guild chunk. Parameters      guild : hikari.guilds.Guild The guild to request chunk for. Other Parameters         timeout : typing.Union[builtins.int, builtins.float, builtins.None] The maximum amount of time the returned stream should spend waiting for the next chunk event to be received before ending the iteration. If  builtins.None then this will never timeout between events. limit : typing.Optional[builtins.int] The limit for how many events the streamer should queue before dropping extra received events. Leave as  builtins.None for this to be unlimited. include_presences : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences. query : builtins.str If not    , request the members which username starts with the string. query_limit : builtins.int Maximum number of members to send matching the query. users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User ] If provided, the users to request for.  ! note To request the full list of members, set  query to    (empty string) and  limit to  0 .  ! note The chunk request will not be sent off until the returned stream is opened.  ! warning Validation errors like  builtins.ValueError and  hikari.errors.MissingIntentError will be delayed until you open the returned stream. Returns    - hikari.event_stream.Streamer[hikari.events.shard_events.MemberChunkEvent] A stream of chunk events for the generated request.",
"func":1
},
{
"ref":"hikari.impl.stateless_guild_chunker.StatelessGuildChunkerImpl.get_request_status",
"url":64,
"doc":"Return the status of a request. Parameters      nonce : str The unique identifier for the tracked request to get. Returns    - typing.Optional[RequestInformation] Information about the request if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_guild_chunker.StatelessGuildChunkerImpl.list_requests_for_shard",
"url":64,
"doc":"List the statuses of requests made for a specific shard. Parameters      shard : typing.Union[hikari.api.shard.GatewayShard, builtins.int] The object or ID of the shard to get the tracked requests for. Returns    - typing.Sequence[RequestInformation] A sequence of data objects of information about the tracked requests for the given shard.",
"func":1
},
{
"ref":"hikari.impl.stateless_guild_chunker.StatelessGuildChunkerImpl.list_requests_for_guild",
"url":64,
"doc":"List the statuses of requests made for a specific guild. Parameters      guild: hikari.snowflakes.SnowflakeishOr[hikari.guilds.GatewayGuild] The object or ID of the guild to get the tracked requests for. Returns    - typing.Sequence[RequestInformation] A sequence of data objects of information about the tracked requests for the given guild.",
"func":1
},
{
"ref":"hikari.impl.stateless_guild_chunker.StatelessGuildChunkerImpl.consume_chunk_event",
"url":64,
"doc":"Listen to chunk events. Parameters      event : hikari.events.shard_events.MemberChunkEvent The object of the chunk event that's being consumed.",
"func":1
},
{
"ref":"hikari.impl.stateless_guild_chunker.StatelessGuildChunkerImpl.request_guild_members",
"url":64,
"doc":"Request for a guild chunk.  ! note For the chunker to track a request the request may need to be made using this method rather than using  hikari.api.shard.GatewayShard.request_guild_members . Parameters      guild : hikari.guilds.Guild The guild to request chunk for. Other Parameters         include_presences : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences. query : builtins.str If not    , request the members which username starts with the string. limit : builtins.int Maximum number of members to send matching the query. users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User ] If provided, the users to request for.  ! note To request the full list of members, set  query to    (empty string) and  limit to  0 . Returns    - builtins.str The generated unique nonce used for tracking this request. Raises    ValueError When trying to specify  users with  query / limit , if  limit is not between 0 and 100, both inclusive or if  users length is over 100. hikari.errors.MissingIntentError When trying to request presences without the  GUILD_MEMBERS or when trying to request the full list of members without  GUILD_PRESENCES .",
"func":1
},
{
"ref":"hikari.impl.stateless_guild_chunker.StatelessGuildChunkerImpl.close",
"url":64,
"doc":"Close the guild chunker.",
"func":1
},
{
"ref":"hikari.impl.rest",
"url":65,
"doc":"Implementation of a V8 compatible REST API for Discord. This also includes implementations designed towards providing RESTful functionality."
},
{
"ref":"hikari.impl.rest.BasicLazyCachedTCPConnectorFactory",
"url":65,
"doc":"Lazy cached TCP connector factory."
},
{
"ref":"hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.close",
"url":65,
"doc":"Close any resources if they exist.",
"func":1
},
{
"ref":"hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.acquire",
"url":65,
"doc":"Acquire the connector.",
"func":1
},
{
"ref":"hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.connector",
"url":65,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.impl.rest.BasicLazyCachedTCPConnectorFactory.http_settings",
"url":65,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.impl.rest.RESTApp",
"url":65,
"doc":"The base for a HTTP-only Discord application. This comprises of a shared TCP connector connection pool, and can have  RESTClientImpl instances for specific credentials acquired from it. Parameters      connector_factory : typing.Optional[ConnectorFactory] A factory that produces an  aiohttp.BaseConnector when requested. Defaults to a connector for a shared  aiohttp.TCPConnector if  builtins.None . The connector factory is expected to handle providing locks around resources and caching any result as desired. connector_owner : builtins.bool If you created the connector yourself, set this to  builtins.True if you want this component to destroy the connector once closed. Otherwise,  builtins.False will prevent this and you will have to do this manually. The latter is useful if you wish to maintain a shared connection pool across your application with other non-Hikari components.  ! warning If you do not give a  connector_factory , this will be IGNORED and always be treated as  builtins.True internally. executor : typing.Optional[concurrent.futures.Executor] The executor to use for blocking file IO operations. If  builtins.None is passed, then the default  concurrent.futures.ThreadPoolExecutor for the  asyncio.AbstractEventLoop will be used instead. http_settings : typing.Optional[hikari.config.HTTPSettings] HTTP settings to use. Sane defaults are used if this is  builtins.None . max_rate_limit : builtins.float Maximum number of seconds to sleep for when rate limited. If a rate limit occurs that is longer than this value, then a  hikari.errors.RateLimitedError will be raised instead of waiting. This is provided since some endpoints may respond with non-sensible rate limits. Defaults to five minutes if unspecified. proxy_settings : typing.Optional[hikari.config.ProxySettings] Proxy settings to use. If  builtins.None then no proxy configuration will be used. url : typing.Optional[builtins.str] The base URL for the API. You can generally leave this as being  builtins.None and the correct default API base URL will be generated.  ! note This event loop will be bound to a connector when the first call to  acquire is made."
},
{
"ref":"hikari.impl.rest.RESTApp.executor",
"url":65,
"doc":"Return the executor to use for blocking operations. This may return  builtins.None if the default  asyncio thread pool should be used instead. Returns    - typing.Optional[concurrent.futures.Executor] The executor to use, or  builtins.None to use the  asyncio default instead."
},
{
"ref":"hikari.impl.rest.RESTApp.http_settings",
"url":65,
"doc":""
},
{
"ref":"hikari.impl.rest.RESTApp.proxy_settings",
"url":65,
"doc":""
},
{
"ref":"hikari.impl.rest.RESTApp.acquire",
"url":65,
"doc":"",
"func":1
},
{
"ref":"hikari.impl.rest.RESTApp.close",
"url":65,
"doc":"",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl",
"url":65,
"doc":"Implementation of the V6 and V7-compatible Discord HTTP API. This manages making HTTP/1.1 requests to the API and using the entity factory within the passed application instance to deserialize JSON responses to Pythonic data classes that are used throughout this library. Parameters      connector_factory : typing.Optional[ConnectorFactory] A factory that produces an  aiohttp.BaseConnector when requested. Defaults to a connector for a shared  aiohttp.TCPConnector if  builtins.None . The connector factory is expected to handle providing locks around resources and caching any result as desired. connector_owner : builtins.bool If you created the connector yourself, set this to  builtins.True if you want this component to destroy the connector once closed. Otherwise,  builtins.False will prevent this and you will have to do this manually. The latter is useful if you wish to maintain a shared connection pool across your application with other non-Hikari components. entity_factory : hikari.api.entity_factory.EntityFactory The entity factory to use. executor : typing.Optional[concurrent.futures.Executor] The executor to use for blocking IO. Defaults to the  asyncio thread pool if set to  builtins.None . max_rate_limit : builtins.float Maximum number of seconds to sleep for when rate limited. If a rate limit occurs that is longer than this value, then a  hikari.errors.RateLimitedError will be raised instead of waiting. This is provided since some endpoints may respond with non-sensible rate limits. token : hikari.undefined.UndefinedOr[builtins.str] The bot or bearer token. If no token is to be used, this can be undefined. token_type : hikari.undefined.UndefinedOr[builtins.str] The type of token in use. If no token is used, this can be ignored and left to the default value. This can be  \"Bot\" or  \"Bearer\" . rest_url : builtins.str The HTTP API base URL. This can contain format-string specifiers to interpolate information such as API version in use."
},
{
"ref":"hikari.impl.rest.RESTClientImpl.http_settings",
"url":65,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.impl.rest.RESTClientImpl.proxy_settings",
"url":65,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.impl.rest.RESTClientImpl.close",
"url":65,
"doc":"Close the HTTP client and any open HTTP connections.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_channel",
"url":65,
"doc":"Fetch a channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The channel to fetch. This may be the object or the ID of an existing channel. Returns    - hikari.channels.PartialChannel The channel. This will be a _derivative_ of  hikari.channels.PartialChannel , depending on the type of channel you request for. This means that you may get one of  hikari.channels.DMChannel ,  hikari.channels.GroupDMChannel ,  hikari.channels.GuildTextChannel ,  hikari.channels.GuildVoiceChannel ,  hikari.channels.GuildStoreChannel ,  hikari.channels.GuildNewsChannel . Likewise, the  hikari.channels.GuildChannel can be used to determine if a channel is guild-bound, and  hikari.channels.TextChannel can be used to determine if the channel provides textual functionality to the application. You can check for these using the  builtins.isinstance builtin function. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  READ_MESSAGES permission in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_channel",
"url":65,
"doc":"Edit a channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to edit. This may be the object or the ID of an existing channel. Other Parameters         name : hikari.undefined.UndefinedOr builtins.str] If provided, the new name for the channel. position : hikari.undefined.UndefinedOr builtins.int] If provided, the new position for the channel. topic : hikari.undefined.UndefinedOr[builtins.str] If provided, the new topic for the channel. nsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the channel should be marked as NSFW or not. bitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the new bitrate for the channel. user_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the new user limit in the channel. rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new rate limit per user in the channel. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the new permission overwrites for the channel. parent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory If provided, the new guild category for the channel. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.PartialChannel The edited channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing permissions to edit the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.follow_channel",
"url":65,
"doc":"Follow a news channel to send messages to a target channel. Parameters      news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel] The object or ID of the news channel to follow. target_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The object or ID of the channel to target. Returns    - hikari.channels.ChannelFollow Information about the new relationship that was made. Raises    hikari.errors.BadRequestError If you try to follow a channel that's not a news channel or if the target channel has reached it's webhook limit, which is 10 at the time of writing. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission in the target channel or are missing the  VIEW_CHANNEL permission in the origin channel. hikari.errors.NotFoundError If the origin or target channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_channel",
"url":65,
"doc":"Delete a channel in a guild, or close a DM. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel] The channel to delete. This may be the object or the ID of an existing channel. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_permission_overwrites",
"url":65,
"doc":"Edit permissions for a specific entity in the given guild channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to edit a permission overwrite in. This may be the object, or the ID of an existing channel. target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to edit. This may be the object or the ID of an existing overwrite. Other Parameters         target_type : hikari.undefined.UndefinedOr[hikari.channels.PermissionOverwriteType] If provided, the type of the target to update. If unset, will attempt to get the type from  target . allow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all allowed permissions. deny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new vale of all disallowed permissions. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    builtins.TypeError If  target_type is unset and we were unable to determine the type from  target . hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_PERMISSIONS permission in the channel. hikari.errors.NotFoundError If the channel is not found or the target is not found if it is a role. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_permission_overwrite",
"url":65,
"doc":"Delete a custom permission for an entity in a given guild channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to delete a permission overwrite in. This may be the object, or the ID of an existing channel. target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish] The channel overwrite to delete. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_PERMISSIONS permission in the channel. hikari.errors.NotFoundError If the channel is not found or the target is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_channel_invites",
"url":65,
"doc":"Fetch all invites pointing to the given guild channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to fetch the invites from. This may be a channel object, or the ID of an existing channel. Returns    - typing.Sequence[hikari.invites.InviteWithMetadata] The invites pointing to the given guild channel. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission in the channel. hikari.errors.NotFoundError If the channel is not found in any guilds you are a member of. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_invite",
"url":65,
"doc":"Create an invite to the given guild channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel] The channel to create a invite for. This may be the object or the ID of an existing channel. Other Parameters         max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, builtins.float, builtins.int If provided, the duration of the invite before expiry. max_uses : hikari.undefined.UndefinedOr[builtins.int] If provided, the max uses the invite can have. temporary : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the invite only grants temporary membership. unique : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the invite should be unique. target_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser If provided, the target user id for this invite. This may be the object or the ID of an existing user. target_user_type : hikari.undefined.UndefinedOr[hikari.invites.TargetUserType] If provided, the type of target user for this invite. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.invites.InviteWithMetadata The invite to the given guild channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNELS permission. hikari.errors.NotFoundError If the channel is not found, or if the target user does not exist, if provided. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.trigger_typing",
"url":65,
"doc":"Trigger typing in a text channel. The result of this call can be awaited to trigger typing once, or can be used as an async context manager to continually type until the context manager is left. Examples        Trigger typing just once. await rest.trigger_typing(channel)  Trigger typing repeatedly for 1 minute. async with rest.trigger_typing(channel): await asyncio.sleep(60)    ! warning Sending a message to the channel will cause the typing indicator to disappear until it is re-triggered. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to trigger typing in. This may be the object or the ID of an existing channel. Returns    - hikari.api.special_endpoints.TypingIndicator A typing indicator to use. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  SEND_MESSAGES in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise any of the above types.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_pins",
"url":65,
"doc":"Fetch the pinned messages in this text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to fetch pins from. This may be the object or the ID of an existing channel. Returns    - typing.Sequence[hikari.messages.Message] The pinned messages in this text channel. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  READ_MESSAGES in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.pin_message",
"url":65,
"doc":"Pin an existing message in the given text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to pin a message in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to pin. This may be the object or the ID of an existing message. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES in the channel. hikari.errors.NotFoundError If the channel is not found, or if the message does not exist in the given channel. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.unpin_message",
"url":65,
"doc":"Unpin a given message from a given text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to unpin a message in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to unpin. This may be the object or the ID of an existing message. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission. hikari.errors.NotFoundError If the channel is not found or the message is not a pinned message in the given channel. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_messages",
"url":65,
"doc":"Browse the message history for a given text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to fetch messages in. This may be the object or the ID of an existing channel. Other Parameters         before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages before this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages after this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, fetch messages around this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.messages.Message] An iterator to fetch the messages.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    builtins.TypeError If you specify more than one of  before ,  after ,  about . hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  READ_MESSAGE_HISTORY in the channel. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint (other than  builtins.TypeError ) will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything (other than  builtins.TypeError ).",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_message",
"url":65,
"doc":"Fetch a specific message in the given text channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to fetch messages in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to fetch. This may be the object or the ID of an existing channel. Returns    - hikari.messages.Message The requested message. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  READ_MESSAGE_HISTORY in the channel. hikari.errors.NotFoundError If the channel is not found or the message is not found in the given text channel. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_message",
"url":65,
"doc":"Create a message in the given channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to create the message in. content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. nonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all user mentions will be detected. If provided, and  builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all role mentions will be detected. If provided, and  builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified. hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  SEND_MESSAGES in the channel or the person you are trying to message has the DM's disabled. hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! warning You are expected to make a connection to the gateway and identify once before being able to use this endpoint for a bot.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_crossposts",
"url":65,
"doc":"Broadcast an announcement message. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel] The object or ID of the news channel to crosspost a message in. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The object or ID of the message to crosspost. Returns    - hikari.messages.Message The message object that was crossposted. Raises    hikari.errors.BadRequestError If you tried to crosspost a message that has already been broadcast. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you try to crosspost a message by the current user without the  SEND_MESSAGES permission for the target news channel or try to crosspost a message by another user without both the  SEND_MESSAGES and  MANAGE_MESSAGES permissions for the target channel. hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_message",
"url":65,
"doc":"Edit an existing message in a given channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to create the message in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to edit. This may be the object or the ID of an existing message. content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message content to update with. If  hikari.undefined.UNDEFINED , then the content will not be changed. If  builtins.None , then the content will be removed. Any other value will be cast to a  builtins.str before sending. If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Other Parameters         embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed] If provided, the embed to set on the message. If  hikari.undefined.UNDEFINED , the previous embed if present is not changed. If this is  builtins.None , then the embed is removed if present. Otherwise, the new embed value that was provided will be used as the replacement. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, sanitation for  @everyone mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , then  @everyone / @here mentions in the message content will show up as mentioning everyone that can view the chat. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, sanitation for user mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid user mentions will behave as mentions. If  builtins.False , all valid user mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake user IDs, or  hikari.users.PartialUser -derived objects. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, sanitation for role mentions. If  hikari.undefined.UNDEFINED , then the previous setting is not changed. If  builtins.True , all valid role mentions will behave as mentions. If  builtins.False , all valid role mentions will not behave as mentions. You may alternatively pass a collection of  hikari.snowflakes.Snowflake role IDs, or  hikari.guilds.PartialRole -derived objects. flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag] If provided, optional flags to set on the message. If  hikari.undefined.UNDEFINED , then nothing is changed. Note that some flags may not be able to be set. Currently the only flags that can be set are  NONE and  SUPPRESS_EMBEDS . If you have  MANAGE_MESSAGES permissions, you can use this call to suppress embeds on another user's message.  ! note Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however.  ! note There is currently no documented way to clear attachments or edit attachments from a previously sent message on Discord's API. To do this,  delete the message and re-send it. This also applies to embed attachments.  ! warning If you specify one of  mentions_everyone ,  user_mentions , or  role_mentions , then all others will default to  builtins.False , even if they were enabled previously. This is a limitation of Discord's design. If in doubt, specify all three of them each time.  ! warning If the message was not sent by your user, the only parameter you may provide to this call is the  flags parameter. Anything else will result in a  hikari.errors.ForbiddenError being raised. Returns    - hikari.messages.Message The edited message. Raises    hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  SEND_MESSAGES in the channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the  MANAGE_MESSAGES permission. hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_message",
"url":65,
"doc":"Delete a given message in a given channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to delete the message in. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete. This may be the object or the ID of an existing message. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES , and the message is not sent by you. hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_messages",
"url":65,
"doc":"Bulk-delete messages from the channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to bulk delete the messages in. This may be the object or the ID of an existing channel.  messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The messages to delete. This may be one or more objects or IDs of existing messages.  ! note This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket. If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to  delete_message . The implication of this is that the  delete_message endpoint is ratelimited by a different bucket with different usage rates.  ! warning This endpoint is not atomic. If an error occurs midway through a bulk delete, you will  not be able to revert any changes made up to this point.  ! warning Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion. Raises    hikari.errors.BulkDeleteError An error containing the messages successfully deleted, and the messages that were not removed. The  builtins.BaseException.__cause__ of the exception will be the original error that terminated this process.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.add_reaction",
"url":65,
"doc":"Add a reaction emoji to a message in a given channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to add the reaction to is. This may be a  hikari.channels.TextChannel or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to add a reaction to. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to react to the message with. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  ADD_REACTIONS (this is only necessary if you are the first person to add the reaction). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_my_reaction",
"url":65,
"doc":"Delete a reaction that your application user created. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reaction from. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to remove your reaction from. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_all_reactions_for_emoji",
"url":65,
"doc":"Delete all reactions for a single emoji on a given message. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete the reactions from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reactions from. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to delete all reactions from. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_reaction",
"url":65,
"doc":"Delete a reaction from a message. If you are looking to delete your own applications reaction, use  delete_my_reaction . Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete a reaction from. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to delete all reactions from. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_all_reactions",
"url":65,
"doc":"Delete all reactions from a message. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete all reaction from. This may be the object or the ID of an existing message. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.ForbiddenError If you are missing the  MANAGE_MESSAGES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_reactions_for_emoji",
"url":65,
"doc":"Fetch reactions for an emoji from a message. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel. message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage] The message to delete all reaction from. This may be the object or the ID of an existing message. emoji : hikari.emojis.Emojiish The emoji to filter reactions by. Returns    - hikari.iterators.LazyIterator[hikari.users.User] An iterator to fetch the users.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    hikari.errors.BadRequestError If an invalid unicode emoji is given, or if the given custom emoji does not exist. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel or message is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_webhook",
"url":65,
"doc":"Create webhook in a channel. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel where the webhook will be created. This may be the object or the ID of an existing channel. name : str The name for the webhook. This cannnot be  clyde . Other Parameters         avatar : typing.Optional[hikari.files.Resourceish] If provided, the avatar for the webhook. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.webhooks.Webhook The created webhook. Raises    hikari.errors.BadRequestError If  name doesnt follow the restrictions enforced by discord. hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_webhook",
"url":65,
"doc":"Fetch an existing webhook. Parameters      webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook] The webhook to fetch. This may be the object or the ID of an existing webhook. Other Parameters         token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to fetch the webhook instead of the token the client was initialized with. Returns    - hikari.webhooks.Webhook The requested webhook. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission when not using a token. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the webhook is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_channel_webhooks",
"url":65,
"doc":"Fetch all channel webhooks. Parameters      channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel] The channel to fetch the webhooks for. This may be a  hikari.channels.TextChannel or the ID of an existing channel. Returns    - typing.Sequence[hikari.webhooks.Webhook] The fetched webhooks. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_guild_webhooks",
"url":65,
"doc":"Fetch all guild webhooks. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the webhooks for. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.webhooks.Webhook] The fetched webhooks. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_webhook",
"url":65,
"doc":"Edit a webhook. Parameters      webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook] The webhook to edit. This may be the object or the ID of an existing webhook. Other Parameters         token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to edit the webhook instead of the token the client was initialized with. name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new webhook name. avatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new webhook avatar. If  builtins.None , will remove the webhook avatar. channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel If provided, the text channel to move the webhook to. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.webhooks.Webhook The edited webhook. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission when not using a token. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the webhook is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_webhook",
"url":65,
"doc":"Delete a webhook. Parameters      webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook] The webhook to delete. This may be the object or the ID of an existing webhook. Other Parameters         token : hikari.undefined.UndefinedOr[builtins.str] If provided, the webhoook token that will be used to delete the webhook instead of the token the client was initialized with. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_WEBHOOKS permission when not using a token. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the webhoook is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.execute_webhook",
"url":65,
"doc":"Execute a webhook. Parameters      webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.Webhook] The webhook to execute. This may be the object or the ID of an existing webhook token: builtins.str The webhook token. content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed nor no  embeds kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embed. embeds : hikari.undefined.UndefinedOr[hikari.embeds.Embed] If provided, the message embeds. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish], If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish , If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. tts : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system. nonce : hikari.undefined.UndefinedOr[builtins.str] An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all user mentions will be detected. If provided, and  builtins.False , all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all role mentions will be detected. If provided, and  builtins.False , all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles.  ! note Attachments can be passed as many different things, to aid in convenience. - If a  pathlib.PurePath or  builtins.str to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of  hikari.files.WebResource such as  hikari.files.URL ,  hikari.messages.Attachment ,  hikari.emojis.Emoji ,  EmbedResource , etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability. - If a  hikari.files.Bytes is passed, or a  builtins.str that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided. - If a  hikari.files.File ,  pathlib.PurePath or  builtins.str that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of  concurrent.futures.Executor that is being used for the application (default is a thread pool which supports this behaviour). Returns    - hikari.messages.Message The created message. Raises    builtins.ValueError If more than 100 unique objects/entities are passed for  role_mentions or  user_mentions . builtins.TypeError If both  attachment and  attachments are specified or if both  embed and  embeds are specified. hikari.errors.BadRequestError This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; users in  user_mentions not being mentioned in the message content; roles in  role_mentions not being mentioned in the message content. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the channel is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_gateway_url",
"url":65,
"doc":"Fetch the gateway url.  ! note This endpoint does not require any valid authorization. Raises    hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_gateway_bot",
"url":65,
"doc":"Fetch the gateway gateway info for the bot. Returns    - hikari.sessions.GatewayBot The gateway bot. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_invite",
"url":65,
"doc":"Fetch an existing invite. Parameters      invite : hikari.invites.Inviteish The invite to fetch. This may be an invite object or the code of an existing invite. Returns    - hikari.invites.Invite The requested invite. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the invite is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_invite",
"url":65,
"doc":"Delete an existing invite. Parameters      invite : hikari.invites.Inviteish The invite to delete. This may be an invite object or the code of an existing invite. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission in the guild the invite is from or if you are missing the  MANAGE_CHANNELS permission in the channel the invite is from. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the invite is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_my_user",
"url":65,
"doc":"Fetch the token's associated user. Returns    - hikari.users.OwnUser The token's associated user. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_my_user",
"url":65,
"doc":"Edit the token's associated user. Other Parameters         username : undefined.UndefinedOr[builtins.str] If provided, the new username. avatar : undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new avatar. If  builtins.None , the avatar will be removed. Returns    - hikari.users.OwnUser The edited token's associated user. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Discord also returns this on a ratelimit: https: github.com/discord/discord-api-docs/issues/1462 hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_my_connections",
"url":65,
"doc":"Fetch the token's associated connections. Returns    - hikari.applications.OwnConnection The token's associated connections. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_my_guilds",
"url":65,
"doc":"Fetch the token's associated guilds. Other Parameters         newest_first : builtins.bool Whether to fetch the newest first or the olders first. Defaults to  builtins.False . start_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild If provided, will start at this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may also be a guild object. In this case, the date the object was first created will be used. Returns    - hikari.iterators.LazyIterator[hikari.applications.OwnGuild] The token's associated guilds.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.leave_guild",
"url":65,
"doc":"Leave a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to leave. This may be the object or the ID of an existing guild. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found or you own the guild. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_dm_channel",
"url":65,
"doc":"Create a DM channel with a user. Parameters      user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to create the DM channel with. This may be the object or the ID of an existing user. Returns    - hikari.channels.DMChannel The created DM channel. Raises    hikari.errors.BadRequestError If the user is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_application",
"url":65,
"doc":"Fetch the token's associated application. Returns    - hikari.applications.Application The token's associated application. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.add_user_to_guild",
"url":65,
"doc":"Add a user to a guild.  ! note This requires the  access_token to have the  hikari.applications.OAuth2Scope.GUILDS_JOIN scope enabled. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to add the user to. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to add to the guild. This may be the object or the ID of an existing user. Other Parameters         nick : hikari.undefined.UndefinedOr[builtins.str] If provided, the nick to add to the user when he joins the guild. Requires the  MANAGE_NICKNAMES permission on the guild. roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the roles to add to the user when he joins the guild. This may be a collection objects or IDs of existing roles. Requires the  MANAGE_ROLES permission on the guild. mute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the mute state to add the user when he joins the guild. Requires the  MUTE_MEMBERS permission on the guild. deaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the deaf state to add the user when he joins the guild. Requires the  DEAFEN_MEMBERS permission on the guild. Returns    - typing.Optional[hikari.guilds.Member]  builtins.None if the user was already part of the guild, else  hikari.guilds.Member . Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are not part of the guild you want to add the user to, if you are missing permissions to do one of the things you specified, if you are using an access token for another user, if the token is bound to annother bot or if the access token doesnt have the  hikari.applications.OAuth2Scope.GUILDS_JOIN scope enabled. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If you own the guild or the user is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_voice_regions",
"url":65,
"doc":"Fetch available voice regions.  ! note This endpoint doesn't return VIP voice regions. Returns    - typing.Sequence[hikari.voices.VoiceRegion] The available voice regions. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_user",
"url":65,
"doc":"Fetch a user. Parameters      user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to fetch. This can be the object or the ID of an existing user. Returns    - hikari.users.User The requested user Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the user is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_audit_log",
"url":65,
"doc":"Fetch the guild's audit log. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the audit logs from. This can be a guild object or the ID of an existing guild. Other Parameters         before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique If provided, filter to only actions after this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used. user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser If provided, the user to filter for. event_type : hikari.undefined.UndefinedOr[hikari.audit_logs.AuditLogEventType] If provided, the event type to filter for. Returns    - hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog] The guild's audit log.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  VIEW_AUDIT_LOG permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_emoji",
"url":65,
"doc":"Fetch a guild emoji. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the emoji from. This can be a guild object or the ID of an existing guild. emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to fetch. This can be a  hikari.emojis.CustomEmoji or the ID of an existing emoji. Returns    - hikari.emojis.KnownCustomEmoji The requested emoji. Raises    hikari.errors.NotFoundError If the guild or the emoji are not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_guild_emojis",
"url":65,
"doc":"Fetch the emojis of a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the emojis from. This can be a guild object or the ID of an existing guild. Returns    - typing.Sequence[hikari.emojis.KnownCustomEmoji] The requested emojis. Raises    hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_emoji",
"url":65,
"doc":"Create an emoji in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the emoji on. This can be a guild object or the ID of an existing guild. name : builtins.str The name for the emoji. image : hikari.files.Resourceish The 128x128 image for the emoji. Maximum upload size is 256kb. This can be a still or an animated image. Other Parameters         roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, a collection of the roles that will be able to use this emoji. This can be a  hikari.guilds.PartialRole or the ID of an existing role. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.emojis.KnownCustomEmoji The created emoji. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value or if there are no more spaces for the type of emoji in the guild. hikari.errors.ForbiddenError If you are missing  MANAGE_EMOJIS in the server. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_emoji",
"url":65,
"doc":"Edit an emoji in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the emoji on. This can be a guild object or the ID of an existing guild. emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to edit. This can be a  hikari.emojis.CustomEmoji or the ID of an existing emoji. Other Parameters         name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the emoji. roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the new collection of roles that will be able to use this emoji. This can be a  hikari.guilds.PartialRole or the ID of an existing role. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.emojis.KnownCustomEmoji The edited emoji. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing  MANAGE_EMOJIS in the server. hikari.errors.NotFoundError If the guild or the emoji are not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_emoji",
"url":65,
"doc":"Delete an emoji in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the emoji on. This can be a guild object or the ID of an existing guild. emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji] The emoji to delete. This can be a  hikari.emojis.CustomEmoji or the ID of an existing emoji. Raises    hikari.errors.ForbiddenError If you are missing  MANAGE_EMOJIS in the server. hikari.errors.NotFoundError If the guild or the emoji are not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.guild_builder",
"url":65,
"doc":"Make a guild builder to create a guild with. Parameters      name : builtins.str The new guilds name. Returns    - hikari.api.special_endpoints.GuildBuilder The guild builder to use. This will allow to create a guild later with  hikari.api.special_endpoints.GuildBuilder.create . Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once  hikari.api.special_endpoints.GuildBuilder.create is called. Invoking this function itself will not raise any of the above types. See Also     Guild builder:  hikari.api.special_endpoints.GuildBuilder ",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_guild",
"url":65,
"doc":"Fetch a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch. This can be the object or the ID of an existing guild. Returns    - hikari.guilds.RESTGuild The requested guild. Raises    hikari.errors.ForbiddenError If you are not part of the guild. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_guild_preview",
"url":65,
"doc":"Fetch a guild preview. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the preview of. This can be a guild object or the ID of an existing guild. Returns    - hikari.guilds.GuildPreview The requested guild preview.  ! note This will only work for guilds you are a part of or are public. Raises    hikari.errors.NotFoundError If the guild is not found or you are not part of the guild. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_guild",
"url":65,
"doc":"Edit a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. Other Parameters         name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the guild. region : hikari.undefined.UndefinedOr[hikari.voices.VoiceRegionish] If provided, the new voice region for the guild. verification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel] If provided, the new verification level. default_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel] If provided, the new default message notifications level. explicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel] If provided, the new explicit content filter level. afk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel If provided, the new afk channel. Requires  afk_timeout to be set to work. afk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the new afk timeout. icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the  ANIMATED_ICON feature. owner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser ] If provided, the new guild owner.  ! warn You need to be the owner of the server to use this. splash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild splash. Must be a 16:9 image and the guild must have the  INVITE_SPLASH feature. banner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish] If provided, the new guild banner. Must be a 16:9 image and the guild must have the  BANNER feature. system_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new system channel. rules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new rules channel. public_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel If provided, the new public updates channel. preferred_locale : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new preferred locale. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.guilds.RESTGuild The edited guild. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. Or you are missing the hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission or if you tried to pass ownership without being the server owner. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_guild",
"url":65,
"doc":"Delete a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete. This may be the object or the ID of an existing guild. Raises    hikari.errors.ForbiddenError If you are not the owner of the guild. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If you own the guild or if you are not in it. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_guild_channels",
"url":65,
"doc":"Fetch the channels in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the channels from. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.channels.GuildChannel] The requested channels. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_guild_text_channel",
"url":65,
"doc":"Create a text channel in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild. name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). topic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters. nsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW. rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the ammount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.GuildTextChannel The created channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_guild_news_channel",
"url":65,
"doc":"Create a news channel in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild. name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). topic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters. nsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW. rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish] If provided, the ammount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.GuildNewsChannel The created channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_guild_voice_channel",
"url":65,
"doc":"Create a voice channel in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild. name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). user_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit. bitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.GuildVoiceChannel The created channel. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_guild_category",
"url":65,
"doc":"Create a category in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the channel in. This may be the object or the ID of an existing guild. name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.channels.GuildCategory The created category. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.reposition_channels",
"url":65,
"doc":"Reposition the channels in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to reposition the channels in. This may be the object or the ID of an existing guild. positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel A mapping of of the object or the ID of an existing channel to the new position, relative to their parent category, if any. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_CHANNEL permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_member",
"url":65,
"doc":"Fetch a guild member. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to get the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to get the member for. This may be the object or the ID of an existing user. Returns    - hikari.guilds.Member The requested member. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or the user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_members",
"url":65,
"doc":"Fetch the members from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the members of. This may be the object or the ID of an existing guild. Returns    - hikari.iterators.LazyIterator[hikari.guilds.Member] An iterator to fetch the members.  ! note This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it. See  hikari.iterators for the full API for this iterator type. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.  ! note The exceptions on this endpoint will only be raised once the result is awaited or iterated over. Invoking this function itself will not raise anything.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_member",
"url":65,
"doc":"Edit a guild member. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. Other Parameters         nick : hikari.undefined.UndefinedNoneOr[builtins.str] If provided, the new nick for the member. If  builtins.None , will remove the members nick. Requires the  MANAGE_NICKNAMES permission. roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the new roles for the member. Requires the  MANAGE_ROLES permission. mute : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server mute state for the member. Requires the  MUTE_MEMBERS permission. deaf : hikari.undefined.UndefinedOr[builtins.bool] If provided, the new server deaf state for the member. Requires the  DEAFEN_MEMBERS permission. voice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel ] If provided,  builtins.None or the object or the ID of an existing voice channel to move the member to. If  builtins.None , will disconnect the member from voice. Requires the  MOVE_MEMBERS permission and the  CONNECT permission in the original voice channel and the target voice channel.  ! note If the member is not in a voice channel, this will take no effect. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing a permission to do an action. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or the user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_my_nick",
"url":65,
"doc":"Edit the associated token's member nick. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit. This may be the object or the ID of an existing guild. nick : typing.Optional[builtins.str] The new nick. If  builtins.None , will remove the nick. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  CHANGE_NICKNAME permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.add_role_to_member",
"url":65,
"doc":"Add a role to a member. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild where the member is in. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to add the role to. This may be the object or the ID of an existing user. role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to add. This may be the object or the ID of an existing role. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild, user or role are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.remove_role_from_member",
"url":65,
"doc":"Remove a role from a member. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild where the member is in. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to remove the role from. This may be the object or the ID of an existing user. role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to remove. This may be the object or the ID of an existing role. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild, user or role are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.kick_user",
"url":65,
"doc":"Kick a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to kick the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  KICK_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.kick_member",
"url":65,
"doc":"Kick a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to kick the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  KICK_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.ban_user",
"url":65,
"doc":"Ban a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to ban the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters         delete_message_days : hikari.undefined.UndefinedNoneOr[int] If provided, the number of days to delete messages for. This must be between 0 and 7. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.ban_member",
"url":65,
"doc":"Ban a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to ban the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to kick. This may be the object or the ID of an existing user. Other Parameters         delete_message_days : hikari.undefined.UndefinedNoneOr[int] If provided, the number of days to delete messages for. This must be between 0 and 7. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.unban_user",
"url":65,
"doc":"Unban a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to unban the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to unban. This may be the object or the ID of an existing user. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.unban_member",
"url":65,
"doc":"Unban a member from a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to unban the member from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to unban. This may be the object or the ID of an existing user. Other Parameters         reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Raises    hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_ban",
"url":65,
"doc":"Fetch the guild's ban info for a user. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the ban from. This may be the object or the ID of an existing guild. user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser] The user to fetch the ban of. This may be the object or the ID of an existing user. Returns    - hikari.guilds.GuildMemberBan The requested ban info. Raises    hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or user are not found or if the user is not banned. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_bans",
"url":65,
"doc":"Fetch the bans of a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the bans from. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.guilds.GuildMemberBan] The requested bans. Raises    hikari.errors.ForbiddenError If you are missing the  BAN_MEMBERS permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_roles",
"url":65,
"doc":"Fetch the roles of a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the roles from. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.guilds.Role] The requested roles. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.create_role",
"url":65,
"doc":"Create a role. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to create the role in. This may be the object or the ID of an existing guild. Other Parameters         name : hikari.undefined.UndefinedOr[builtins.str] If provided, the name for the role. permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] The permissions to give the role. This will default to setting NO roles if left to the default value. This is in contrast to default behaviour on Discord where some random permissions will be set by default. color : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the role's color. colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for  color . hoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role. mentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.guilds.Role The created role. Raises    builtins.TypeError If both  color and  colour are specified. hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.reposition_roles",
"url":65,
"doc":"Reposition the roles in a guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to reposition the roles in. This may be the object or the ID of an existing guild. positions : typing.Mapping[builtins.int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole A mapping of the position to the role. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_role",
"url":65,
"doc":"Edit a role. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the role in. This may be the object or the ID of an existing guild. role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to edit. This may be the object or the ID of an existing role. Other Parameters         name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name for the role. permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the new permissions for the role. color : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the new color for the role. colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for  color . hoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role. mentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.guilds.Role The edited role. Raises    builtins.TypeError If both  color and  colour are specified. hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or role are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.delete_role",
"url":65,
"doc":"Delete a role. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to delete the role in. This may be the object or the ID of an existing guild. role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole] The role to delete. This may be the object or the ID of an existing role. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_ROLES permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild or role are not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.estimate_guild_prune_count",
"url":65,
"doc":"Estimate the guild prune count. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to estimate the guild prune count for. This may be the object or the ID of an existing guild. Other Parameters         days : hikari.undefined.UndefinedOr[builtins.int] If provided, number of days to count prune for. include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count. Returns    - builtins.int The estimated guild prune count. Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  KICK_MEMBERS permission. hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.begin_guild_prune",
"url":65,
"doc":"Begin the guild prune. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to begin the guild prune in. This may be the object or the ID of an existing guild. Other Parameters         days : hikari.undefined.UndefinedOr[builtins.int] If provided, number of days to count prune for. compute_prune_count: hikari.snowflakes.SnowflakeishOr[builtins.bool] If provided, whether to return the prune count. This is discouraged for large guilds. include_roles : hikari.undefined.UndefinedOr[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole ] If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - typing.Optional[builtins.int] If  compute_prune_count is not provided or  builtins.True , the number of members pruned. Else  builtins.None . Raises    hikari.errors.BadRequestError If any of the fields that are passed have an invalid value. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are missing the  KICK_MEMBERS permission. hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_guild_voice_regions",
"url":65,
"doc":"Fetch the available voice regions for a guild.  ! note Unlike  RESTClient.fetch_voice_regions , this will return the VIP regions if the guild has access to them. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the voice regions for. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.voices.VoiceRegion] The available voice regions for the guild. Raises    hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_guild_invites",
"url":65,
"doc":"Fetch the guild's invites. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the invites for. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.invites.InviteWithMetadata] The invites for the guild. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_integrations",
"url":65,
"doc":"Fetch the guild's integrations. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the integrations for. This may be the object or the ID of an existing guild. Returns    - typing.Sequence[hikari.guilds.Integration] The integrations for the guild. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.NotFoundError If the guild is not found. hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_widget",
"url":65,
"doc":"Fetch a guilds's widget. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the widget from. This can be the object or the ID of an existing guild. Returns    - hikari.guilds.GuildWidget The requested guild widget. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.edit_widget",
"url":65,
"doc":"Fetch a guilds's widget. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to edit the widget in. This can be the object or the ID of an existing guild. Other Parameters         channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel If provided, the channel to set the widget to. If  builtins.None , will not set to any. enabled : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to enable the widget. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.guilds.GuildWidget The edited guild widget. Raises    hikari.errors.ForbiddenError If you are missing the  MANAGE_GUILD permission. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.fetch_vanity_url",
"url":65,
"doc":"Fetch a guild's vanity url. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild to fetch the vanity url from. This can be the object or the ID of an existing guild. Returns    - hikari.invites.VanityURL The requested invite. Raises    hikari.errors.ForbiddenError If you are not part of the guild. hikari.errors.NotFoundError If the guild is not found. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.RateLimitTooLongError Raised in the event that a rate limit occurs that is longer than  max_rate_limit when making a request. hikari.errors.RateLimitedError Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.rest.RESTClientImpl.buckets",
"url":65,
"doc":"Bucket ratelimiter manager."
},
{
"ref":"hikari.impl.rest.RESTClientImpl.global_rate_limit",
"url":65,
"doc":"Global ratelimiter."
},
{
"ref":"hikari.impl.stateful_cache",
"url":66,
"doc":"Basic implementation of a cache for general bots and gateway apps."
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl",
"url":66,
"doc":"In-memory cache implementation."
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis",
"url":66,
"doc":"Remove all the known custom emoji objects from the cache.  ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A cache view of emoji IDs to objects of the emojis that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis_for_guild",
"url":66,
"doc":"Remove the known custom emoji objects cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove the cached emoji objects for.  ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the emojis that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_emoji",
"url":66,
"doc":"Remove a known custom emoji from the cache. Parameters      emoji_id : hikari.snowflakes.Snowflake The ID of the emoji to remove from the cache.  ! note This will not delete emojis that are being kept alive by a reference on a presence entry. Returns    - typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was removed from the cache or  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_emoji",
"url":66,
"doc":"Get a known custom emoji from the cache. Parameters      emoji_id : hikari.snowflakes.Snowflake The ID of the emoji to get from the cache. Returns    - typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view",
"url":66,
"doc":"Get a view of the known custom emoji objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the known custom emojis found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view_for_guild",
"url":66,
"doc":"Get a view of the known custom emojis cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached emoji objects for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of emojis found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_emoji",
"url":66,
"doc":"Add a known custom emoji to the cache. Parameters      emoji : hikari.emojis.KnownCustomEmoji The object of the known custom emoji to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_emoji",
"url":66,
"doc":"Update an emoji object in the cache. Parameters      emoji : hikari.emojis.KnownCustomEmoji The object of the emoji to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.emojis.KnownCustomEmoji], typing.Optional[hikari.emojis.KnownCustomEmoji A tuple of the old cached emoji object if found (else  builtins.None ) and the new cached emoji object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_guilds",
"url":66,
"doc":"Remove all the guild objects from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] The cache view of guild IDs to guild objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild",
"url":66,
"doc":"Remove a guild object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild that was removed from the cache, will be  builtins.None if not found. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_guild",
"url":66,
"doc":"Get a guild from the cache.  ! warning This will return a guild regardless of whether it is available or not. To only query available guilds, use  get_available_guild instead. Likewise, to only query unavailable guilds, use  get_unavailable_guild . Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guild",
"url":66,
"doc":"Get the object of an available guild from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guild",
"url":66,
"doc":"Get the object of a unavailable guild from the cache.  ! note Unlike  Cache.get_available_guild , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guilds_view",
"url":66,
"doc":"Get a view of the available guild objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guilds_view",
"url":66,
"doc":"Get a view of the unavailable guild objects in the cache.  ! note Unlike  Cache.get_available_guilds_view , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_guild",
"url":66,
"doc":"Add a guild object to the cache. Parameters      guild : hikari.guilds.GatewayGuild The object of the guild to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_availability",
"url":66,
"doc":"Set whether a cached guild is available or not. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to set the availability for. is_available : builtins.bool The availability to set for the guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_guild",
"url":66,
"doc":"Update a guild in the cache. Parameters      guild : hikari.guilds.GatewayGuild The object of the guild to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.guilds.GatewayGuild], typing.Optional[hikari.guilds.GatewayGuild A tuple of the old cached guild object if found (else  builtins.None ) and the object of the guild that was added to the cache if it could be added (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels",
"url":66,
"doc":"Remove all guild channels from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels_for_guild",
"url":66,
"doc":"Remove guild channels from the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove cached channels for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild_channel",
"url":66,
"doc":"Remove a guild channel from the cache. Parameters      channel_id : hikari.snowflakes.Snowflake The ID of the guild channel to remove from the cache. Returns    - typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channel",
"url":66,
"doc":"Get a guild channel from the cache. Parameters      channel_id : hikari.snowflakes.Snowflake The ID of the guild channel to get from the cache. Returns    - typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view",
"url":66,
"doc":"Get a view of the guild channels in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view_for_guild",
"url":66,
"doc":"Get a view of the guild channels in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_channel",
"url":66,
"doc":"Add a guild channel to the cache. Parameters      channel : hikari.channels.GuildChannel The guild channel based object to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_guild_channel",
"url":66,
"doc":"Update a guild channel in the cache, Parameters      channel : hikari.channels.GuildChannel The object of the channel to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.channels.GuildChannel], typing.Optional[hikari.channels.GuildChannel A tuple of the old cached guild channel if found (else  builtins.None ) and the new cached guild channel if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites",
"url":66,
"doc":"Remove all the invite objects from the cache. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_guild",
"url":66,
"doc":"Remove the invite objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_channel",
"url":66,
"doc":"Remove the invite objects in the cache for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove invite objects for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to remove invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified channel. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_invite",
"url":66,
"doc":"Remove an invite object from the cache. Parameters      code : str The string code of the invite to remove from the cache. Returns    - typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_invite",
"url":66,
"doc":"Get an invite object from the cache. Parameters      code : str The string code of the invite to get from the cache. Returns    - typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view",
"url":66,
"doc":"Get a view of the invite objects in the cache. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string codes to objects of the invites that were found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_guild",
"url":66,
"doc":"Get a view of the invite objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string code to objects of the invites that were found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_channel",
"url":66,
"doc":"Get a view of the invite objects in the cache for a specified channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get invite objects for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to get invite objects for. Returns    - CacheView[str, invites.InviteWithMetadata] A view of string codes to objects of the invites there were found in the cache for the specified channel.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_invite",
"url":66,
"doc":"Add an invite object to the cache. Parameters      invite : hikari.invites.InviteWithMetadata The object of the invite to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_invite",
"url":66,
"doc":"Update an invite in the cache. Parameters      invite : hikari.invites.InviteWithMetadata The object of the invite to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.invites.InviteWithMetadata], typing.Optional[hikari.invites.InviteWithMetadata A tuple of the old cached invite object if found (else  builtins.None ) and the new cached invite object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_me",
"url":66,
"doc":"Remove the own user object from the cache. Returns    - typing.Optional[hikari.users.OwnUser] The own user object that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_me",
"url":66,
"doc":"Get the own user object from the cache. Returns    - typing.Optional[hikari.users.OwnUser] The own user object that was found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_me",
"url":66,
"doc":"Set the own user object in the cache. Parameters      user : hikari.users.OwnUser The own user object to set in the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_me",
"url":66,
"doc":"Update the own user entry in the cache. Parameters      user : hikari.users.OwnUser The own user object to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.users.OwnUser], typing.Optional[hikari.users.OwnUser A tuple of the old cached own user object if found (else  builtins.None ) and the new cached own user object if it could be cached, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_members",
"url":66,
"doc":"Remove all the guild members in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_members_for_guild",
"url":66,
"doc":"Remove the members for a specific guild from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove cached members for.  ! note This will skip members that are being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the member objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_member",
"url":66,
"doc":"Remove a member object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove a member from the cache for. user_id : hikari.snowflakes.Snowflake The ID of the user to remove a member from the cache for.  ! note You cannot delete a member entry that's being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns    - typing.Optional[hikari.guilds.Member] The object of the member that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_member",
"url":66,
"doc":"Get a member object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake user_id : hikari.snowflakes.Snowflake Returns    - typing.Optional[hikari.guilds.Member] The object of the member found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view",
"url":66,
"doc":"Get a view of all the members objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were found from the cache.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view_for_guild",
"url":66,
"doc":"Get a view of the members cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached member view for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the members cached for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_member",
"url":66,
"doc":"Add a member object to the cache. Parameters      member : hikari.guilds.Member The object of the member to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_member",
"url":66,
"doc":"Update a member in the cache. Parameters      member : hikari.guilds.Member The object of the member to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.guilds.Member], typing.Optional[hikari.guilds.Member A tuple of the old cached member object if found (else  builtins.None ) and the new cached member object if it could be cached (else  builtins.None ) Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences",
"url":66,
"doc":"Remove all the presences in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence A view of guild IDs to views of user IDs to objects of the presences that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences_for_guild",
"url":66,
"doc":"Remove the presences in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove presences for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presences that were removed from the cache for the specified guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_presence",
"url":66,
"doc":"Remove a presence from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove a presence for. user_id : hikari.snowflakes.Snowflake The ID of the user to remove a presence for. Returns    - typing.Optional[hikari.presences.MemberPresence] The object of the presence that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_presence",
"url":66,
"doc":"Get a presence object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get a presence for. user_id : hikari.snowflakes.Snowflake The ID of the user to get a presence for. Returns    - typing.Optional[hikari.presences.MemberPresence] The object of the presence that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view",
"url":66,
"doc":"Get a view of all the presence objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake A view of guild IDs to views of user IDs to objects of the presences found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view_for_guild",
"url":66,
"doc":"Get a view of the presence objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached presence objects for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presence found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_presence",
"url":66,
"doc":"Add a presence object to the cache. Parameters      presence : hikari.presences.MemberPresence The object of the presence to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_presence",
"url":66,
"doc":"Update a presence object in the cache. Parameters      presence : hikari.presences.MemberPresence The object of the presence to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.presences.MemberPresence], typing.Optional[hikari.presences.MemberPresence A tuple of the old cached invite object if found (else  builtins.None and the new cached invite object if it could be cached ( else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles",
"url":66,
"doc":"Remove all role objects from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles_for_guild",
"url":66,
"doc":"Remove role objects from the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove roles for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache for the specific guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_role",
"url":66,
"doc":"Remove a role object form the cache. Parameters      role_id : hikari.snowflakes.Snowflake The ID of the role to remove from the cache. Returns    - typing.Optional[hikari.guilds.Role] The object of the role that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_role",
"url":66,
"doc":"Get a role object from the cache. Parameters      role_id : hikari.snowflakes.Snowflake The ID of the role to get from the cache. Returns    - typing.Optional[hikari.guilds.Role] The object of the role found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view",
"url":66,
"doc":"Get a view of all the role objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view_for_guild",
"url":66,
"doc":"Get a view of the roles in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached roles for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_role",
"url":66,
"doc":"Add a role object to the cache. Parameters      role : hikari.guilds.Role The object of the role to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_role",
"url":66,
"doc":"Update a role in the cache. Parameters      role : hikari.guilds.Role The object of the role to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.guilds.Role], typing.Optional[hikari.guilds.Role A tuple of the old cached role object if found (else  builtins.None and the new cached role object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_users",
"url":66,
"doc":"Clear the user objects from the cache.  ! note This will skip users that are being referenced by other entries within the cache; member entries and DM entries will keep a user alive within the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the user objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_user",
"url":66,
"doc":"Remove a user object from the cache. Parameters      user_id : hikari.snowflakes.Snowflake The ID of the user to remove from the cache.  ! note You cannot delete a user object while it's being referenced by other entries within the cache; member entries and DM entries will keep a user alive within the cache. Returns    - typing.Optional[hikari.users.User] The object of the user that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_user",
"url":66,
"doc":"Get a user object from the cache. Parameters      user_id : hikari.snowflakes.Snowflake The ID of the user to get from the cache. Returns    - typing.Optional[hikari.users.User] The object of the user that was found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_users_view",
"url":66,
"doc":"Get a view of the user objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the users found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_user",
"url":66,
"doc":"Add a user object to the cache. Parameters      user : hikari.users.User The object of the user to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_user",
"url":66,
"doc":"Update a user object in the cache. Parameters      user : hikari.users.User The object of the user to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.users.User], typing.Optional[hikari.users.User A tuple of the old cached user if found (else  builtins.None ) and the newly cached user if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states",
"url":66,
"doc":"Remove all voice state objects from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were removed from the states. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_channel",
"url":66,
"doc":"Remove the voice state objects cached for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove voice states for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to remove voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice state that were removed from the cache for the specified channel. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_guild",
"url":66,
"doc":"Clear the voice state objects cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to the voice state objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.delete_voice_state",
"url":66,
"doc":"Remove a voice state object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild the voice state to remove is related to. user_id : hikari.snowflakes.Snowflake The ID of the user who the voice state to remove belongs to. Returns    - typing.Optional[hikari.voices.VoiceState] The object of the voice state that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_state",
"url":66,
"doc":"Get a voice state object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get a voice state for. user_id :hikari.snowflakes.Snowflake The ID of the user to get a voice state for. Returns    - typing.Optional[hikari.voices.VoiceState] The object of the voice state that was found in the cache, or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view",
"url":66,
"doc":"Get a view of all the voice state objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were found in the cache,",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_channel",
"url":66,
"doc":"Get a view of the voice states cached for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached voice states for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to get the cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified channel.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_guild",
"url":66,
"doc":"Get a view of the voice states cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.set_voice_state",
"url":66,
"doc":"Add a voice state object to the cache. Parameters      voice_state : hikari.voices.VoiceState The object of the voice state to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateful_cache.StatefulCacheImpl.update_voice_state",
"url":66,
"doc":"Update a voice state object in the cache. Parameters      voice_state : hikari.voices.VoiceState The object of the voice state to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.voices.VoiceState], typing.Optional[hikari.voices.VoiceState A tuple of the old cached voice state if found (else  builtins.None ) and the new cached voice state object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.buckets",
"url":67,
"doc":"Rate-limit extensions for RESTful bucketed endpoints. Provides implementations for the complex rate limiting mechanisms that Discord requires for rate limit handling that conforms to the passed bucket headers correctly. This was initially a bit of a headache for me to understand, personally, since there is a lot of \"implicit detail\" that is easy to miss from the documentation. In an attempt to make this somewhat understandable by anyone else, I have tried to document the theory of how this is handled here. What is the theory behind this implementation?                        In this module, we refer to a  hikari.internal.routes.CompiledRoute as a definition of a route with specific major parameter values included (e.g.  POST /channels/123/messages ), and a  hikari.internal.routes.Route as a definition of a route without specific parameter values included (e.g.  POST /channels/{channel}/messages ). We can compile a  hikari.internal.routes.CompiledRoute from a  hikari.internal.routes.Route by providing the corresponding parameters as kwargs, as you may already know. In this module, a \"bucket\" is an internal data structure that tracks and enforces the rate limit state for a specific  hikari.internal.routes.CompiledRoute , and can manage delaying tasks in the event that we begin to get rate limited. It also supports providing in-order execution of queued tasks. Discord allocates types of buckets to routes. If you are making a request and there is a valid rate limit on the route you hit, you should receive an  X-RateLimit-Bucket header from the server in your response. This is a hash that identifies a route based on internal criteria that does not include major parameters. This  X-RateLimitBucket is known in this module as an \"bucket hash\". This means that generally, the route  POST /channels/123/messages and  POST /channels/456/messages will usually sit in the same bucket, but  GET /channels/123/messages/789 and  PATCH /channels/123/messages/789 will usually not share the same bucket. Discord may or may not change this at any time, so hard coding this logic is not a useful thing to be doing. Rate limits, on the other hand, apply to a bucket and are specific to the major parameters of the compiled route. This means that  POST /channels/123/messages and  POST /channels/456/messages do not share the same real bucket, despite Discord providing the same bucket hash. A real bucket hash is the  builtins.str hash of the bucket that Discord sends us in a response concatenated to the corresponding major parameters. This is used for quick bucket indexing internally in this module. One issue that occurs from this is that we cannot effectively hash a  hikari.internal.routes.CompiledRoute that has not yet been hit, meaning that until we receive a response from this endpoint, we have no idea what our rate limits could be, nor the bucket that they sit in. This is usually not problematic, as the first request to an endpoint should never be rate limited unless you are hitting it from elsewhere in the same time window outside your hikari.applications. To manage this situation, unknown endpoints are allocated to a special unlimited bucket until they have an initial bucket hash code allocated from a response. Once this happens, the route is reallocated a dedicated bucket. Unknown buckets have a hardcoded initial hash code internally. Initially acquiring time on a bucket                   Each time you  BaseRateLimiter.acquire() a request timeslice for a given  hikari.internal.routes.Route , several things happen. The first is that we attempt to find the existing bucket for that route, if there is one, or get an unknown bucket otherwise. This is done by creating a real bucket hash from the compiled route. The initial hash is calculated using a lookup table that maps  hikari.internal.routes.CompiledRoute objects to their corresponding initial hash codes, or to the unknown bucket hash code if not yet known. This initial hash is processed by the  hikari.internal.routes.CompiledRoute to provide the real bucket hash we need to get the route's bucket object internally. The  BaseRateLimiter.acquire() method will take the bucket and acquire a new timeslice on it. This takes the form of a  asyncio.Future which should be awaited by the caller and will complete once the caller is allowed to make a request. Most of the time, this is done instantly, but if the bucket has an active rate limit preventing requests being sent, then the future will be paused until the rate limit is over. This may be longer than the rate limit period if you have queued a large number of requests during this limit, as it is first-come-first-served. Acquiring a rate limited bucket will start a bucket-wide task (if not already running) that will wait until the rate limit has completed before allowing more futures to complete. This is done while observing the rate limits again, so can easily begin to re-ratelimit itself if needed. Once the task is complete, it tidies itself up and disposes of itself. This task will complete once the queue becomes empty. The result of  RESTBucketManager.acquire() is a tuple of a  asyncio.Future to await on which completes when you are allowed to proceed with making a request, and a real bucket hash which should be stored temporarily. This will be explained in the next section. Handling the rate limit headers of a response                       - Once you have received your response, you are expected to extract the values of the vital rate limit headers manually and parse them to the correct data types. These headers are:   Date : the response date on the server. This should be parsed to a  datetime.datetime using  email.utils.parsedate_to_datetime .   X-RateLimit-Limit : an  builtins.int describing the max requests in the bucket from empty to being rate limited.   X-RateLimit-Remaining : an  builtins.int describing the remaining number of requests before rate limiting occurs in the current window.   X-RateLimit-Bucket : a  builtins.str containing the initial bucket hash.   X-RateLimit-Reset : a  builtins.float containing the number of seconds since 1st January 1970 at 0:00:00 UTC at which the current ratelimit window resets. This should be parsed to a  datetime.datetime using  datetime.datetime.fromtimestamp , passing  datetime.timezone.utc as  tz . Each of the above values should be passed to the  update_rate_limits method to ensure that the bucket you acquired time from is correctly updated should Discord decide to alter their ratelimits on the fly without warning (including timings and the bucket). This method will manage creating new buckets as needed and resetting vital information in each bucket you use. Tidying up      To prevent unused buckets cluttering up memory, each  RESTBucketManager instance spins up a  asyncio.Task that periodically locks the bucket list (not threadsafe, only using the concept of asyncio not yielding in regular functions) and disposes of any clearly stale buckets that are no longer needed. These will be recreated again in the future if they are needed. When shutting down an application, one must remember to  close() the  RESTBucketManager that has been used. This will ensure the garbage collection task is stopped, and will also ensure any remaining futures in any bucket queues have an  asyncio.CancelledError set on them to prevent deadlocking ratelimited calls that may be waiting to be unlocked. Body-field-specific rate limiting                 - As of the start of June, 2020, Discord appears to be enforcing another layer of rate limiting logic to their HTTP APIs which is field-specific. This means that special rate limits will also exist on some endpoints that limit based on what attributes you send in a JSON or form data payload. No information is sent in headers about these specific limits. You will only be made aware that they exist once you get ratelimited. In the 429 ratelimited response, you will have the  \"global\" attribute set to  builtins.False , and a  \"reset_after\" attribute that differs entirely to the  X-RateLimit-Reset header. Thus, it is important to not assume the value in the 429 response for the reset time is the same as the one in the bucket headers. Hikari's  hikari.api.rest.RESTClient implementation specifically uses the value furthest in the future when working out which bucket to adhere to. It is worth remembering that there is an API limit to the number of 401s, 403s, and 429s you receive, which is around 10,000 per 15 minutes. Passing this limit results in a soft ban of your account. At the time of writing, the only example of this appears to be on the  PATCH /channels/{channel_id} endpoint. This has a limit of two changes per 10 minutes. More details about how this is implemented have yet to be released or documented . Caveats    - These implementations rely on Discord sending consistent buckets back to us. This also begins to crumble if more than one HTTP client is in use, since there is no performent way to communicate shared rate limits between distributed applications. The general concept to follow is that if you are making repeated API calls, or calls that are not event-based (e.g. fetching messages on a timer), then this can be considered a form of API abuse and should be used sparingly."
},
{
"ref":"hikari.impl.buckets.UNKNOWN_HASH",
"url":67,
"doc":"The hash used for an unknown bucket that has not yet been resolved."
},
{
"ref":"hikari.impl.buckets.RESTBucket",
"url":67,
"doc":"Represents a rate limit for an HTTP endpoint. Component to represent an active rate limit bucket on a specific HTTP _route with a specific major parameter combo. This is somewhat similar to the  WindowedBurstRateLimiter in how it works. This algorithm will use fixed-period time windows that have a given limit (capacity). Each time a task requests processing time, it will drip another unit into the bucket. Once the bucket has reached its limit, nothing can drip and new tasks will be queued until the time window finishes. Once the time window finishes, the bucket will empty, returning the current capacity to zero, and tasks that are queued will start being able to drip again. Additional logic is provided by the  RESTBucket.update_rate_limit call which allows dynamically changing the enforced rate limits at any time."
},
{
"ref":"hikari.impl.buckets.RESTBucket.is_unknown",
"url":67,
"doc":"Return  builtins.True if the bucket represents an  UNKNOWN bucket."
},
{
"ref":"hikari.impl.buckets.RESTBucket.acquire",
"url":67,
"doc":"Acquire time on this rate limiter.  ! note You should afterwards invoke  RESTBucket.update_rate_limit to update any rate limit information you are made aware of. Parameters      max_rate_limit : builtins.float The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error. The default is an infinite value, which will thus never time out. Returns    - asyncio.Future[builtins.None] A future that should be awaited immediately. Once the future completes, you are allowed to proceed with your operation. If the reset-after time for the bucket is greater than  max_rate_limit , then this will contain  RateLimitTooLongError as an exception.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucket.update_rate_limit",
"url":67,
"doc":"Amend the rate limit. Parameters      remaining : builtins.int The calls remaining in this time window. limit : builtins.int The total calls allowed in this time window. reset_at : builtins.float The epoch at which to reset the limit.  ! note The  reset_at epoch is expected to be a  time.monotonic_timestamp monotonic epoch, rather than a  time.time date-based epoch.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucket.drip",
"url":67,
"doc":"Decrement the remaining count for this bucket.  ! note If the bucket is marked as  RESTBucket.is_unknown , then this will not do anything.  Unknown buckets have infinite rate limits.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucket.compiled_route",
"url":67,
"doc":"The compiled _route that this rate limit is covering."
},
{
"ref":"hikari.impl.buckets.RESTBucket.get_time_until_reset",
"url":68,
"doc":"Determine how long until the current rate limit is reset. Parameters      now : builtins.float The monotonic  time.monotonic_timestamp timestamp.  ! warning Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour. Returns    - builtins.float The time left to sleep before the rate limit is reset. If no rate limit is in effect, then this will return  0.0 instead.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucket.is_rate_limited",
"url":68,
"doc":"Determine if we are under a rate limit at the given time. Parameters      now : builtins.float The monotonic  time.monotonic_timestamp timestamp. Returns    - builtins.bool  builtins.True if we are being rate limited, or  builtins.False if we are not.  ! warning Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucket.throttle",
"url":68,
"doc":"Perform the throttling rate limiter logic. Iterates repeatedly while the queue is not empty, adhering to any rate limits that occur in the mean time.  ! note You should usually not need to invoke this directly, but if you do, ensure to call it using  asyncio.create_task , and store the task immediately in  throttle_task . When this coroutine function completes, it will set the  throttle_task to  builtins.None . This means you can check if throttling is occurring by checking if  throttle_task is not  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucket.limit",
"url":68,
"doc":"The maximum number of  WindowedBurstRateLimiter.acquire 's allowed in this time window."
},
{
"ref":"hikari.impl.buckets.RESTBucket.period",
"url":68,
"doc":"How long the window lasts for from the start in seconds."
},
{
"ref":"hikari.impl.buckets.RESTBucket.remaining",
"url":68,
"doc":"The number of  WindowedBurstRateLimiter.acquire 's left in this window before you will get rate limited."
},
{
"ref":"hikari.impl.buckets.RESTBucket.reset_at",
"url":68,
"doc":"The  time.monotonic_timestamp that the limit window ends at."
},
{
"ref":"hikari.impl.buckets.RESTBucket.close",
"url":68,
"doc":"Close the rate limiter, and shut down any pending tasks. Once this is invoked, you should not reuse this object.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucket.is_empty",
"url":68,
"doc":"Return  builtins.True if no futures are on the queue being rate limited."
},
{
"ref":"hikari.impl.buckets.RESTBucket.name",
"url":68,
"doc":"The name of the rate limiter."
},
{
"ref":"hikari.impl.buckets.RESTBucket.queue",
"url":68,
"doc":"The queue of any futures under a rate limit."
},
{
"ref":"hikari.impl.buckets.RESTBucket.throttle_task",
"url":68,
"doc":"The throttling task, or  builtins.None if it is not running."
},
{
"ref":"hikari.impl.buckets.RESTBucketManager",
"url":67,
"doc":"The main rate limiter implementation for HTTP clients. This is designed to provide bucketed rate limiting for Discord HTTP endpoints that respects the  X-RateLimit-Bucket rate limit header. To do this, it makes the assumption that any limit can change at any time. Parameters      max_rate_limit : builtins.float The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error."
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.start",
"url":67,
"doc":"Start this ratelimiter up. This spins up internal garbage collection logic in the background to keep memory usage to an optimal level as old routes and bucket hashes get discarded and replaced. Parameters      poll_period : builtins.float Period to poll the garbage collector at in seconds. Defaults to  20 seconds. expire_after : builtins.float Time after which the last  reset_at was hit for a bucket to remove it. Higher values will retain unneeded ratelimit info for longer, but may produce more effective rate-limiting logic as a result. Using  0 will make the bucket get garbage collected as soon as the rate limit has reset. Defaults to  10 seconds.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.close",
"url":67,
"doc":"Close the garbage collector and kill any tasks waiting on ratelimits. Once this has been called, this object is considered to be effectively dead. To reuse it, one should create a new instance.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.gc",
"url":67,
"doc":"The garbage collector loop. This is designed to run in the background and manage removing unused _route references from the rate-limiter collection to save memory. This will run forever until  RESTBucketManager.closed_event is set. This will invoke  RESTBucketManager.do_gc_pass periodically. Parameters      poll_period : builtins.float The period to poll at. expire_after : builtins.float Time after which the last  reset_at was hit for a bucket to remove it. Higher values will retain unneeded ratelimit info for longer, but may produce more effective ratelimiting logic as a result. Using  0 will make the bucket get garbage collected as soon as the rate limit has reset.  ! warning You generally have no need to invoke this directly. Use  RESTBucketManager.start and  RESTBucketManager.close to control this instead.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.do_gc_pass",
"url":67,
"doc":"Perform a single garbage collection pass. This will assess any routes stored in the internal mappings of this object and remove any that are deemed to be inactive or dead in order to save memory. If the removed routes are used again in the future, they will be re-cached automatically. Parameters      expire_after : builtins.float Time after which the last  reset_at was hit for a bucket to remove it. Defaults to  reset_at + 20 seconds. Higher values will retain unneeded ratelimit info for longer, but may produce more effective ratelimiting logic as a result.  ! warning You generally have no need to invoke this directly. Use  RESTBucketManager.start and  RESTBucketManager.close to control this instead.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.acquire",
"url":67,
"doc":"Acquire a bucket for the given _route. Parameters      compiled_route : hikari.internal.routes.CompiledRoute The _route to get the bucket for. Returns    - asyncio.Future[builtins.None] A future to await that completes when you are allowed to run your request logic.  ! note The returned future MUST be awaited, and will complete when your turn to make a call comes along. You are expected to await this and then immediately make your HTTP call. The returned future may already be completed if you can make the call immediately.",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.update_rate_limits",
"url":67,
"doc":"Update the rate limits for a bucket using info from a response. Parameters      compiled_route : hikari.internal.routes.CompiledRoute The compiled _route to get the bucket for. bucket_header : typing.Optional[builtins.str] The  X-RateLimit-Bucket header that was provided in the response. remaining_header : builtins.int The  X-RateLimit-Remaining header cast to an  builtins.int . limit_header : builtins.int The  X-RateLimit-Limit header cast to an  builtins.int . date_header : datetime.datetime The  Date header value as a  datetime.datetime . reset_at_header : datetime.datetime The  X-RateLimit-Reset header value as a  datetime.datetime .",
"func":1
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.is_started",
"url":67,
"doc":"Return  builtins.True if the rate limiter GC task is started."
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.closed_event",
"url":67,
"doc":"An internal event that is set when the object is shut down."
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.gc_task",
"url":67,
"doc":"The internal garbage collector task."
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.max_rate_limit",
"url":67,
"doc":"The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error."
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.real_hashes_to_buckets",
"url":67,
"doc":"Maps full bucket hashes ( X-RateLimit-Bucket appended with a hash of major parameters used in that compiled _route) to their corresponding rate limiters."
},
{
"ref":"hikari.impl.buckets.RESTBucketManager.routes_to_hashes",
"url":67,
"doc":"Maps routes to their  X-RateLimit-Bucket header being used."
},
{
"ref":"hikari.impl.stateful_guild_chunker",
"url":69,
"doc":"Basic implementation of a guild chunker."
},
{
"ref":"hikari.impl.stateful_guild_chunker.StatefulGuildChunkerImpl",
"url":69,
"doc":"Guild chunker implementation. Parameters      app : hikari.traits.BotAware The object of the bot aware app this is bound to. limit : builtins.int The maximum amount of requests that this chunker should store information about for each shard."
},
{
"ref":"hikari.impl.stateful_guild_chunker.StatefulGuildChunkerImpl.fetch_members_for_guild",
"url":69,
"doc":"Request for a guild chunk. Parameters      guild : hikari.guilds.Guild The guild to request chunk for. Other Parameters         timeout : typing.Union[builtins.int, builtins.float, builtins.None] The maximum amount of time the returned stream should spend waiting for the next chunk event to be received before ending the iteration. If  builtins.None then this will never timeout between events. limit : typing.Optional[builtins.int] The limit for how many events the streamer should queue before dropping extra received events. Leave as  builtins.None for this to be unlimited. include_presences : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences. query : builtins.str If not    , request the members which username starts with the string. query_limit : builtins.int Maximum number of members to send matching the query. users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User ] If provided, the users to request for.  ! note To request the full list of members, set  query to    (empty string) and  limit to  0 .  ! note The chunk request will not be sent off until the returned stream is opened.  ! warning Validation errors like  builtins.ValueError and  hikari.errors.MissingIntentError will be delayed until you open the returned stream. Returns    - hikari.event_stream.Streamer[hikari.events.shard_events.MemberChunkEvent] A stream of chunk events for the generated request.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.StatefulGuildChunkerImpl.get_request_status",
"url":69,
"doc":"Return the status of a request. Parameters      nonce : str The unique identifier for the tracked request to get. Returns    - typing.Optional[RequestInformation] Information about the request if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.StatefulGuildChunkerImpl.list_requests_for_shard",
"url":69,
"doc":"List the statuses of requests made for a specific shard. Parameters      shard : typing.Union[hikari.api.shard.GatewayShard, builtins.int] The object or ID of the shard to get the tracked requests for. Returns    - typing.Sequence[RequestInformation] A sequence of data objects of information about the tracked requests for the given shard.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.StatefulGuildChunkerImpl.list_requests_for_guild",
"url":69,
"doc":"List the statuses of requests made for a specific guild. Parameters      guild: hikari.snowflakes.SnowflakeishOr[hikari.guilds.GatewayGuild] The object or ID of the guild to get the tracked requests for. Returns    - typing.Sequence[RequestInformation] A sequence of data objects of information about the tracked requests for the given guild.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.StatefulGuildChunkerImpl.consume_chunk_event",
"url":69,
"doc":"Listen to chunk events. Parameters      event : hikari.events.shard_events.MemberChunkEvent The object of the chunk event that's being consumed.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.StatefulGuildChunkerImpl.request_guild_members",
"url":69,
"doc":"Request for a guild chunk.  ! note For the chunker to track a request the request may need to be made using this method rather than using  hikari.api.shard.GatewayShard.request_guild_members . Parameters      guild : hikari.guilds.Guild The guild to request chunk for. Other Parameters         include_presences : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences. query : builtins.str If not    , request the members which username starts with the string. limit : builtins.int Maximum number of members to send matching the query. users : hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User ] If provided, the users to request for.  ! note To request the full list of members, set  query to    (empty string) and  limit to  0 . Returns    - builtins.str The generated unique nonce used for tracking this request. Raises    ValueError When trying to specify  users with  query / limit , if  limit is not between 0 and 100, both inclusive or if  users length is over 100. hikari.errors.MissingIntentError When trying to request presences without the  GUILD_MEMBERS or when trying to request the full list of members without  GUILD_PRESENCES .",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.StatefulGuildChunkerImpl.close",
"url":69,
"doc":"Close the guild chunker.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream",
"url":69,
"doc":"A specialised event stream used for triggering and streaming chunk events. See Also     Event Stream:  hikari.utilities.event_stream.EventStream "
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.open",
"url":69,
"doc":"Mark this streamer as opened to let it start receiving and queueing events. If called on an already started streamer then this will do nothing.  ! note  async with streamer may be used as a short-cut for opening and closing a stream.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.close",
"url":70,
"doc":"Mark this streamer as closed to stop it from queueing and receiving events. If called on an already closed streamer then this will do nothing.  ! note  async with streamer may be used as a short-cut for opening and closing a streamer.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.filter",
"url":70,
"doc":"Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item that this iterator would return when it is requested. All conditions must evaluate to  builtins.True for the item to be returned. If this is not met, then the item is discared and ignored, the next matching item will be returned instead, if there is one. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.filter \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT]  LazyIterator that only emits values where all conditions are matched.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.chunk",
"url":8,
"doc":"Return results in chunks of up to  chunk_size amount of entries. Parameters      chunk_size : int The limit for how many results should be returned in each chunk. Returns    - LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.map",
"url":8,
"doc":"Map the values to a different value. Parameters      transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the  . operator. Returns    - LazyIterator[AnotherValueT]  LazyIterator that maps each value to another value.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.for_each",
"url":8,
"doc":"Pass each value to a given consumer immediately.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.take_while",
"url":8,
"doc":"Return each item until any conditions fail or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.take_until",
"url":8,
"doc":"Return each item until any conditions pass or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.skip_while",
"url":8,
"doc":"Discard items while all conditions are True. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.skip_until",
"url":8,
"doc":"Discard items while all conditions are False. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.enumerate",
"url":8,
"doc":"Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of  builtins.enumerate which uses much less memory than collecting all the results first and calling  builtins.enumerate across them. Parameters      start : builtins.int Optional int to start at. If omitted, this is  0 . Examples     >>> async for i, item in paginated_results.enumerate():  . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9):  . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3):  . print(i, item) (9, foo) (10, bar) (11, baz) Returns    - LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.limit",
"url":8,
"doc":"Limit the number of items you receive from this async iterator. Parameters      limit : builtins.int The number of items to get. This must be greater than zero. Examples     >>> async for item in paginated_results.limit(3):  . print(item) Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.skip",
"url":8,
"doc":"Drop the given number of items, then yield anything after. Parameters      number : builtins.int The max number of items to drop before any items are yielded. Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.next",
"url":8,
"doc":"Return the next element of this iterator only. Returns    - ValueT The next result. Raises    builtins.LookupError If no more results exist.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.last",
"url":8,
"doc":"Return the last element of this iterator only. Returns    - ValueT The last result.  ! note This method will consume the whole iterator if run. Raises    builtins.LookupError If no result exists.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.reversed",
"url":8,
"doc":"Return a lazy iterator of the remainder of this iterator's values reversed. Returns    - LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.sort",
"url":8,
"doc":"Collect all results, then sort the collection before returning it.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.collect",
"url":8,
"doc":"Collect the results into a given type and return it. Parameters      collector A function that consumes a sequence of values and returns a collection.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.count",
"url":8,
"doc":"Count the number of results. Returns    - builtins.int Number of results found.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.flat_map",
"url":8,
"doc":"Perform a flat mapping operation. This will pass each item in the iterator to the given  function parameter, expecting a new  typing.Iterable or  typing.AsyncIterator to be returned as the result. This means you can map to a new  LazyIterator ,  typing.AsyncIterator ,  typing.Iterable , async generator, or generator. Remember that  typing.Iterator implicitly provides  typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement reactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded lazily. Parameters      flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example    - The following example generates a distinct collection of all mentioned users in the given channel from the past 500 messages.   def iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\" \", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct() )   Returns    - LazyIterator[AnotherValueT] The new lazy iterator to return.",
"func":1
},
{
"ref":"hikari.impl.stateful_guild_chunker.ChunkStream.awaiting",
"url":8,
"doc":"Await each item concurrently in a fixed size window. Parameters      window_size : int The window size of how many tasks to await at once. You can set this to  0 to await everything at once, but see the below warning. Returns    - LazyIterator[ValueT] The new lazy iterator to return.  ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the  fetch_user endpoint seems to be notorious for doing this).  ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a  builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.",
"func":1
},
{
"ref":"hikari.impl.special_endpoints",
"url":71,
"doc":"Special endpoint implementations. You should never need to make any of these objects manually."
},
{
"ref":"hikari.impl.special_endpoints.TypingIndicator",
"url":71,
"doc":"Result type of  hikari.api.rest.RESTClient.trigger_typing . This is an object that can either be awaited like a coroutine to trigger the typing indicator once, or an async context manager to keep triggering the typing indicator repeatedly until the context finishes.  ! note This is a helper class that is used by  hikari.api.rest.RESTClient . You should only ever need to use instances of this class that are produced by that API."
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder",
"url":71,
"doc":"Result type of  hikari.api.rest.RESTClient.guild_builder . This is used to create a guild in a tidy way using the HTTP API, since the logic behind creating a guild on an API level is somewhat confusing and detailed.  ! note This is a helper class that is used by  hikari.api.rest.RESTClient . You should only ever need to use instances of this class that are produced by that API, thus, any details about the constructor are omitted from the following examples for brevity. Examples     Creating an empty guild.   guild = await rest.guild_builder(\"My Server!\").create()   Creating a guild with an icon   from hikari.files import WebResourceStream guild_builder = rest.guild_builder(\"My Server!\") guild_builder.icon = WebResourceStream(\"cat.png\", \"http:  .\") guild = await guild_builder.create()   Adding roles to your guild.   from hikari.permissions import Permissions guild_builder = rest.guild_builder(\"My Server!\") everyone_role_id = guild_builder.add_role(\"@everyone\") admin_role_id = guild_builder.add_role(\"Admins\", permissions=Permissions.ADMINISTRATOR) await guild_builder.create()    ! warning The first role must always be the  @everyone role.  ! note If you call  add_role , the default roles provided by discord will be created. This also applies to the  add_ functions for text channels/voice channels/categories.  ! note Functions that return a  hikari.snowflakes.Snowflake do  not provide the final ID that the object will have once the API call is made. The returned IDs are only able to be used to re-reference particular objects while building the guild format. This is provided to allow creation of channels within categories, and to provide permission overwrites. Adding a text channel to your guild.   guild_builder = rest.guild_builder(\"My Server!\") category_id = guild_builder.add_category(\"My safe place\") channel_id = guild_builder.add_text_channel(\"general\", parent_id=category_id) await guild_builder.create()   Method generated by attrs for class GuildBuilder."
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.name",
"url":71,
"doc":"Name of the guild to create. Returns    - builtins.str The guild name."
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.create",
"url":71,
"doc":"Send the request to Discord to create the guild. The application user will be added to this guild as soon as it is created. All IDs that were provided when building this guild will become invalid and will be replaced with real IDs. Returns    - hikari.guilds.RESTGuild The created guild. Raises    hikari.errors.BadRequestError If any values set in the guild builder are invalid. hikari.errors.UnauthorizedError If you are unauthorized to make the request (invalid/missing token). hikari.errors.ForbiddenError If you are already in 10 guilds. hikari.errors.InternalServerError If an internal error occurs on Discord while handling the request.",
"func":1
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.add_role",
"url":71,
"doc":"Create a role.  ! warning The first role you create must always be the  @everyone role. Parameters      name : builtins.str The role's name. Other Parameters         permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions] If provided, the permissions for the role. color : hikari.undefined.UndefinedOr[hikari.colors.Colorish] If provided, the role's color. colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish] An alias for  color . hoist : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to hoist the role. mentionable : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to make the role mentionable. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters. Returns    - hikari.snowflakes.Snowflake The dummy ID for this role that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID. Raises    builtins.ValueError If you are defining the first role, but did not name it  @everyone . builtins.TypeError If you specify both  color and  colour together or if you try to specify  color ,  colour ,  hoisted ,  mentionable or  position for the  @everyone role.",
"func":1
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.add_category",
"url":71,
"doc":"Create a category channel. Parameters      name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the category. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the category. Returns    - hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.",
"func":1
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.add_text_channel",
"url":71,
"doc":"Create a text channel. Parameters      name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). topic : hikari.undefined.UndefinedOr[builtins.str] If provided, the channels topic. Maximum 1024 characters. nsfw : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to mark the channel as NSFW. rate_limit_per_user : hikari.undefined.UndefinedOr[builtins.int] If provided, the ammount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns    - hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.",
"func":1
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.add_voice_channel",
"url":71,
"doc":"Create a voice channel. Parameters      name : builtins.str The channels name. Must be between 2 and 1000 characters. Other Parameters         position : hikari.undefined.UndefinedOr[builtins.int] If provided, the position of the channel (relative to the category, if any). user_limit : hikari.undefined.UndefinedOr[builtins.int] If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit. bitrate : hikari.undefined.UndefinedOr[builtins.int] If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers. permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite If provided, the permission overwrites for the channel. category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory The category to create the channel under. This may be the object or the ID of an existing category. Returns    - hikari.snowflakes.Snowflake The dummy ID for this channel that can be used temporarily to refer to this object while designing the guild layout. When the guild is created, this will be replaced with a different ID.",
"func":1
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.default_message_notifications",
"url":53,
"doc":"Default message notification level that can be overwritten. If not overridden, this will use the Discord default level."
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.explicit_content_filter_level",
"url":53,
"doc":"Explicit content filter level that can be overwritten. If not overridden, this will use the Discord default level."
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.icon",
"url":53,
"doc":"Guild icon to use that can be overwritten. If not overridden, the guild will not have an icon."
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.region",
"url":53,
"doc":"Guild voice channel region to use that can be overwritten. If not overridden, the guild will use the default voice region for Discord."
},
{
"ref":"hikari.impl.special_endpoints.GuildBuilder.verification_level",
"url":53,
"doc":"Verification level required to join the guild that can be overwritten. If not overridden, the guild will use the default verification level for Discord."
},
{
"ref":"hikari.impl.event_factory",
"url":72,
"doc":"Implementation for a singleton bot event factory."
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl",
"url":72,
"doc":"Implementation for a single-application bot event factory."
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_channel_create_event",
"url":72,
"doc":"Parse a raw payload from Discord into a channel create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.ChannelCreateEvent The parsed channel create event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_channel_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a channel update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.ChannelUpdateEvent The parsed event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_channel_delete_event",
"url":72,
"doc":"Parse a raw payload from Discord into a channel delete event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.ChannelDeleteEvent The parsed channel delete event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_channel_pins_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a channel pins update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.PinsUpdateEvent The parsed channel pins update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_webhook_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a webhook update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.WebhookUpdateEvent The parsed webhook update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_typing_start_event",
"url":72,
"doc":"Parse a raw payload from Discord into a typing start event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.typing_events.TypingEvent The parsed typing start event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_invite_create_event",
"url":72,
"doc":"Parse a raw payload from Discord into an invite create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.InviteCreateEvent The parsed invite create event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_invite_delete_event",
"url":72,
"doc":"Parse a raw payload from Discord into an invite delete event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.channel_events.InviteDeleteEvent The parsed invite delete event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_create_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.GuildAvailableEvent The parsed guild create event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.GuildUpdateEvent The parsed guild update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_leave_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild leave event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.GuildLeaveEvent The parsed guild leave event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_unavailable_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild unavailable event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.GuildUnavailableEvent The parsed guild unavailable event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_ban_add_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild ban add event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.BanCreateEvent The parsed guild ban add event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_ban_remove_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild ban remove event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.BanDeleteEvent The parsed guild ban remove event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_emojis_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild emojis update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.EmojisUpdateEvent The parsed guild emojis update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_integrations_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guilds integrations update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.IntegrationsUpdateEvent The parsed guilds integrations update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_member_add_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild member add event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.member_events.MemberCreateEvent The parsed guild member add event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_member_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild member update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.member_events.MemberUpdateEvent The parsed guild member update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_member_remove_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild member remove event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.member_events.MemberDeleteEvent The parsed guild member remove event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_role_create_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild role create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.role_events.RoleCreateEvent The parsed guild role create event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_role_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild role update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.role_events.RoleUpdateEvent The parsed guild role update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_role_delete_event",
"url":72,
"doc":"Parse a raw payload from Discord into a guild role delete event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.role_events.RoleDeleteEvent The parsed guild role delete event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_presence_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a presence update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.guild_events.PresenceUpdateEvent The parsed presence update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_message_create_event",
"url":72,
"doc":"Parse a raw payload from Discord into a message create event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.message_events.MessageCreateEvent The parsed message create event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_message_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a message update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.message_events.MessageUpdateEvent The parsed message update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_message_delete_event",
"url":72,
"doc":"Parse a raw payload from Discord into a message delete event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.message_events.MessageDeleteEvent The parsed message delete event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_message_delete_bulk_event",
"url":72,
"doc":"Parse a raw payload from Discord into a message delete bulk event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.message_events.MessageDeleteEvent The parsed message delete bulk event object. Raises    builtins.NotImplementedError If a bulk delete occurs in a DM channel.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_message_reaction_add_event",
"url":72,
"doc":"Parse a raw payload from Discord into a message reaction add event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.reaction_events.ReactionAddEvent The parsed message reaction add event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_message_reaction_remove_event",
"url":72,
"doc":"Parse a raw payload from Discord into a message reaction remove event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.reaction_events.ReactionDeleteEvent The parsed message reaction remove event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_message_reaction_remove_all_event",
"url":72,
"doc":"Parse a raw payload from Discord into a message reaction remove all event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.reaction_events.ReactionDeleteAllEvent The parsed message reaction remove all event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_message_reaction_remove_emoji_event",
"url":72,
"doc":"Parse a raw payload from Discord into a message reaction remove emoji event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.reaction_events.ReactionDeleteEmojiEvent The parsed message reaction remove emoji event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_ready_event",
"url":72,
"doc":"Parse a raw payload from Discord into a ready event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.shard_events.ShardReadyEvent The parsed ready event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_own_user_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a own user update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.user_events.OwnUserUpdateEvent The parsed own user update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_guild_member_chunk_event",
"url":72,
"doc":"Parse a raw payload from Discord into a member chunk event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.shard_events.MemberChunkEvent The parsed member chunk object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_voice_state_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a voice state update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.voice_events.VoiceStateUpdateEvent The parsed voice state update event object.",
"func":1
},
{
"ref":"hikari.impl.event_factory.EventFactoryImpl.deserialize_voice_server_update_event",
"url":72,
"doc":"Parse a raw payload from Discord into a voice server update event object. Parameters      shard : hikari.api.shard.GatewayShard The shard that emitted this event. payload : hikari.internal.data_binding.JSONObject The dict payload to parse. Returns    - hikari.events.voice_events.VoiceServerUpdateEvent The parsed voice server update event object.",
"func":1
},
{
"ref":"hikari.impl.rate_limits",
"url":68,
"doc":"Basic lazy ratelimit systems for asyncio. See  hikari.impl.buckets for HTTP-specific rate-limiting logic."
},
{
"ref":"hikari.impl.rate_limits.BaseRateLimiter",
"url":68,
"doc":"Base for any asyncio-based rate limiter being used. Supports being used as a synchronous context manager.  ! warning Async context manager support is not supported and will not be supported."
},
{
"ref":"hikari.impl.rate_limits.BaseRateLimiter.acquire",
"url":68,
"doc":"Acquire permission to perform a task that needs to have rate limit management enforced. Returns    - asyncio.Future[builtins.None] A future that should be awaited. Once the future is complete, you can proceed to execute your rate-limited task.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.BaseRateLimiter.close",
"url":68,
"doc":"Close the rate limiter, cancelling any internal tasks that are executing.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.BurstRateLimiter",
"url":68,
"doc":"Base implementation for a burst-based rate limiter. This provides an internal queue and throttling placeholder, as well as complete logic for safely aborting any pending tasks when being shut down."
},
{
"ref":"hikari.impl.rate_limits.BurstRateLimiter.acquire",
"url":68,
"doc":"Acquire time on this rate limiter. The implementation should define this. Returns    - asyncio.Future[typing.Any] A future that should be immediately awaited. Once the await completes, you are able to proceed with the operation that is under this rate limit.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.BurstRateLimiter.close",
"url":68,
"doc":"Close the rate limiter, and shut down any pending tasks. Once this is invoked, you should not reuse this object.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.BurstRateLimiter.is_empty",
"url":68,
"doc":"Return  builtins.True if no futures are on the queue being rate limited."
},
{
"ref":"hikari.impl.rate_limits.BurstRateLimiter.name",
"url":68,
"doc":"The name of the rate limiter."
},
{
"ref":"hikari.impl.rate_limits.BurstRateLimiter.queue",
"url":68,
"doc":"The queue of any futures under a rate limit."
},
{
"ref":"hikari.impl.rate_limits.BurstRateLimiter.throttle_task",
"url":68,
"doc":"The throttling task, or  builtins.None if it is not running."
},
{
"ref":"hikari.impl.rate_limits.ManualRateLimiter",
"url":68,
"doc":"Rate limit handler for the global HTTP rate limit. This is a non-preemptive rate limiting algorithm that will always return completed futures until  ManualRateLimiter.throttle is invoked. Once this is invoked, any subsequent calls to  ManualRateLimiter.acquire will return incomplete futures that will be enqueued to an internal queue. A task will be spun up to wait for a period of time given to the  ManualRateLimiter.throttle . Once that has passed, the lock will begin to re-consume incomplete futures on the queue, completing them. Triggering a throttle when it is already set will cancel the current throttle task that is sleeping and replace it. This is used to enforce the global HTTP rate limit that will occur \"randomly\" during HTTP API interaction. Expect random occurrences."
},
{
"ref":"hikari.impl.rate_limits.ManualRateLimiter.acquire",
"url":68,
"doc":"Acquire time on this rate limiter. Returns    - asyncio.Future[typing.Any] A future that should be immediately awaited. Once the await completes, you are able to proceed with the operation that is under this rate limit.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.ManualRateLimiter.throttle",
"url":68,
"doc":"Perform the throttling rate limiter logic. Iterates repeatedly while the queue is not empty, adhering to any rate limits that occur in the mean time. Parameters      retry_after : builtins.float How long to sleep for before unlocking and releasing any futures in the queue.  ! note This will invoke  ManualRateLimiter.unlock_later as a scheduled task in the future (it will not await it to finish). When the  ManualRateLimiter.unlock_later coroutine function completes, it should be expected to set the  throttle_task to  builtins.None . This means you can check if throttling is occurring by checking if  throttle_task is not  builtins.None . If this is invoked while another throttle is in progress, that one is cancelled and a new one is started. This enables new rate limits to override existing ones.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.ManualRateLimiter.unlock_later",
"url":68,
"doc":"Sleeps for a while, then removes the lock. Parameters      retry_after : builtins.float How long to sleep for before unlocking and releasing any futures in the queue.  ! note You should not need to invoke this directly. Call  ManualRateLimiter.throttle instead. When the  ManualRateLimiter.unlock_later coroutine function completes, it should be expected to set the  throttle_task to  builtins.None . This means you can check if throttling is occurring by checking if  throttle_task is not  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.rate_limits.ManualRateLimiter.close",
"url":68,
"doc":"Close the rate limiter, and shut down any pending tasks. Once this is invoked, you should not reuse this object.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.ManualRateLimiter.is_empty",
"url":68,
"doc":"Return  builtins.True if no futures are on the queue being rate limited."
},
{
"ref":"hikari.impl.rate_limits.ManualRateLimiter.name",
"url":68,
"doc":"The name of the rate limiter."
},
{
"ref":"hikari.impl.rate_limits.ManualRateLimiter.queue",
"url":68,
"doc":"The queue of any futures under a rate limit."
},
{
"ref":"hikari.impl.rate_limits.ManualRateLimiter.throttle_task",
"url":68,
"doc":"The throttling task, or  builtins.None if it is not running."
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter",
"url":68,
"doc":"Windowed burst rate limiter. Rate limiter for rate limits that last fixed periods of time with a fixed number of times it can be used in that time frame. To use this, you should call WindowedBurstRateLimiter.aquire and await the result immediately before performing your rate-limited task. If the rate limit has been hit, acquiring time will return an incomplete future that is placed on the internal queue. A throttle task is then spun up if not already running that will be expected to provide some implementation of backing off and sleeping for a given period of time until the limit has passed, and then proceed to consume futures from the queue while adhering to those rate limits. If the throttle task is already running, the acquired future will always be incomplete and enqueued regardless of whether the rate limit is actively reached or not. Acquiring a future from this limiter when no throttling task is running and when the rate limit is not reached will always result in the task invoking a drip and a completed future being returned. Dripping is left to the implementation of this class, but will be expected to provide some mechanism for updating the internal statistics to represent that a unit has been placed into the bucket."
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.acquire",
"url":68,
"doc":"Acquire time on this rate limiter. Returns    - asyncio.Future[typing.Any] A future that should be immediately awaited. Once the await completes, you are able to proceed with the operation that is under this rate limit.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.get_time_until_reset",
"url":68,
"doc":"Determine how long until the current rate limit is reset. Parameters      now : builtins.float The monotonic  time.monotonic_timestamp timestamp.  ! warning Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour. Returns    - builtins.float The time left to sleep before the rate limit is reset. If no rate limit is in effect, then this will return  0.0 instead.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.is_rate_limited",
"url":68,
"doc":"Determine if we are under a rate limit at the given time. Parameters      now : builtins.float The monotonic  time.monotonic_timestamp timestamp. Returns    - builtins.bool  builtins.True if we are being rate limited, or  builtins.False if we are not.  ! warning Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.drip",
"url":68,
"doc":"Decrements the remaining counter.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.throttle",
"url":68,
"doc":"Perform the throttling rate limiter logic. Iterates repeatedly while the queue is not empty, adhering to any rate limits that occur in the mean time.  ! note You should usually not need to invoke this directly, but if you do, ensure to call it using  asyncio.create_task , and store the task immediately in  throttle_task . When this coroutine function completes, it will set the  throttle_task to  builtins.None . This means you can check if throttling is occurring by checking if  throttle_task is not  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.limit",
"url":68,
"doc":"The maximum number of  WindowedBurstRateLimiter.acquire 's allowed in this time window."
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.period",
"url":68,
"doc":"How long the window lasts for from the start in seconds."
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.remaining",
"url":68,
"doc":"The number of  WindowedBurstRateLimiter.acquire 's left in this window before you will get rate limited."
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.reset_at",
"url":68,
"doc":"The  time.monotonic_timestamp that the limit window ends at."
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.close",
"url":68,
"doc":"Close the rate limiter, and shut down any pending tasks. Once this is invoked, you should not reuse this object.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.is_empty",
"url":68,
"doc":"Return  builtins.True if no futures are on the queue being rate limited."
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.name",
"url":68,
"doc":"The name of the rate limiter."
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.queue",
"url":68,
"doc":"The queue of any futures under a rate limit."
},
{
"ref":"hikari.impl.rate_limits.WindowedBurstRateLimiter.throttle_task",
"url":68,
"doc":"The throttling task, or  builtins.None if it is not running."
},
{
"ref":"hikari.impl.rate_limits.ExponentialBackOff",
"url":68,
"doc":"Implementation of an asyncio-compatible exponential back-off algorithm with random jitter.  math t_{backoff} = b^{i} + m \\cdot \\mathrm{rand}() Such that \\(t_{backoff}\\) is the backoff time, \\(b\\) is the base, \\(i\\) is the increment that increases by 1 for each invocation, and \\(m\\) is the jitter multiplier. \\(\\mathrm{rand}()\\) returns a value in the range \\([0,1]\\). Parameters      base : builtins.float The base to use. Defaults to  2.0 . maximum : builtins.float The max value the backoff can be in a single iteration. Anything above this will be capped to this base value plus random jitter. jitter_multiplier : builtins.float The multiplier for the random jitter. Defaults to  1.0 . Set to  0 to disable jitter. initial_increment : builtins.int The initial increment to start at. Defaults to  0 . Raises    ValueError If an  builtins.int that's too big to be represented as a  builtins.float or a non-finite value is passed in place of a field that's annotated as  builtins.float ."
},
{
"ref":"hikari.impl.rate_limits.ExponentialBackOff.reset",
"url":68,
"doc":"Reset the exponential back-off.",
"func":1
},
{
"ref":"hikari.impl.rate_limits.ExponentialBackOff.base",
"url":68,
"doc":"The base to use. Defaults to 2.0."
},
{
"ref":"hikari.impl.rate_limits.ExponentialBackOff.increment",
"url":68,
"doc":"The current increment."
},
{
"ref":"hikari.impl.rate_limits.ExponentialBackOff.jitter_multiplier",
"url":68,
"doc":"The multiplier for the random jitter. This defaults to  1.0 . Set to  0.0 to disable jitter."
},
{
"ref":"hikari.impl.rate_limits.ExponentialBackOff.maximum",
"url":68,
"doc":"This is the max value the backoff can be in a single iteration before an  asyncio.TimeoutError is raised."
},
{
"ref":"hikari.impl.stateful_event_manager",
"url":73,
"doc":"Event handling logic for more info."
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl",
"url":73,
"doc":"Provides event handling logic for Discord events."
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_connected",
"url":73,
"doc":"Handle connection events. This is a synthetic event produced by the gateway implementation in Hikari.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_disconnected",
"url":73,
"doc":"Handle disconnection events. This is a synthetic event produced by the gateway implementation in Hikari.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_ready",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway ready for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_resumed",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway resumed for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_channel_create",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway channel-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_channel_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway channel-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_channel_delete",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway channel-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_channel_pins_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway channel-pins-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_create",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_delete",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_ban_add",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-ban-add for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_ban_remove",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-ban-remove for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_emojis_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-emojis-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_integrations_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-integrations-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_member_add",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-member-add for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_member_remove",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-member-remove for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_member_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-member-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_members_chunk",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-members-chunk for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_role_create",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-role-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_role_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-role-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_guild_role_delete",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-role-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_invite_create",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway invite-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_invite_delete",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway invite-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_message_create",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway message-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_message_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway message-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_message_delete",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway message-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_message_delete_bulk",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway message-delete-bulk for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_message_reaction_add",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway message-reaction-add for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_message_reaction_remove",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway message-reaction-remove for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_message_reaction_remove_all",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway message-reaction-remove-all for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_message_reaction_remove_emoji",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway message-reaction-remove-emoji for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_presence_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway presence-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_typing_start",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway typing-start for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_user_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway user-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_voice_state_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway voice-state-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_voice_server_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway voice-server-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.on_webhooks_update",
"url":73,
"doc":"See https: discord.com/developers/docs/topics/gateway webhooks-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.subscribe",
"url":74,
"doc":"Subscribe a given callback to a given event type. Parameters      event_type : typing.Type[T] The event type to listen for. This will also listen for any subclasses of the given type.  T must be a subclass of  hikari.events.base_events.Event . callback Must be a coroutine function to invoke. This should consume an instance of the given event, or an instance of a valid subclass if one exists. Any result is discarded. Example    - The following demonstrates subscribing a callback to message creation events.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.subscribe(MessageCreateEvent, on_message)   Returns    - typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None] The event callback that was passed in. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.get_listeners",
"url":74,
"doc":"Get the listeners for a given event type, if there are any. Parameters      event_type : typing.Type[T] The event type to look for.  T must be a subclass of  hikari.events.base_events.Event . polymorphic : builtins.bool If  builtins.True , this will also return the listeners of the subclasses of the given event type. If  builtins.False , then only listeners for this class specifically are returned. The default is  builtins.True . Returns    - typing.Collection[typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None A copy of the collection of listeners for the event. Will return an empty collection if nothing is registered.  T must be a subclass of  hikari.events.base_events.Event . See Also     Has listener:  hikari.api.event_dispatcher.EventDispatcher.has_listener ",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.unsubscribe",
"url":74,
"doc":"Unsubscribe a given callback from a given event type, if present. Parameters      event_type : typing.Type[T] The event type to unsubscribe from. This must be the same exact type as was originally subscribed with to be removed correctly.  T must derive from  hikari.events.base_events.Event . callback The callback to unsubscribe. Example    - The following demonstrates unsubscribing a callback from a message creation event.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.unsubscribe(MessageCreateEvent, on_message)  ",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.listen",
"url":74,
"doc":"Generate a decorator to subscribe a callback to an event type. This is a second-order decorator. Parameters      event_type : typing.Optional[typing.Type[T The event type to subscribe to. The implementation may allow this to be undefined. If this is the case, the event type will be inferred instead from the type hints on the function signature.  T must be a subclass of  hikari.events.base_events.Event . Returns    - typing.Callable T], T] A decorator for a coroutine function that passes it to  EventDispatcher.subscribe before returning the function reference. See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.dispatch",
"url":74,
"doc":"Dispatch an event. Parameters      event : hikari.events.base_events.Event The event to dispatch. Example    - We can dispatch custom events by first defining a class that derives from  hikari.events.base_events.Event .   import attr from hikari.traits import RESTAware from hikari.events.base_events import Event from hikari.users import User from hikari.snowflakes import Snowflake @attr.s() class EveryoneMentionedEvent(Event): app: RESTAware = attr.ib() author: User = attr.ib()  'The user who mentioned everyone. ' content: str = attr.ib()  'The message that was sent. ' message_id: Snowflake = attr.ib()  'The message ID. ' channel_id: Snowflake = attr.ib()  'The channel ID. '   We can then dispatch our event as we see fit.   from hikari.events.messages import MessageCreateEvent @bot.listen(MessageCreateEvent) async def on_message(event): if \"@everyone\" in event.content or \"@here\" in event.content: event = EveryoneMentionedEvent( author=event.author, content=event.content, message_id=event.id, channel_id=event.channel_id, ) bot.dispatch(event)   This event can be listened to elsewhere by subscribing to it with  EventDispatcher.subscribe .   @bot.listen(EveryoneMentionedEvent) async def on_everyone_mentioned(event): print(event.user, \"just pinged everyone in\", event.channel_id)   Returns    - asyncio.Future[typing.Any] A future that can be optionally awaited. If awaited, the future will complete once all corresponding event listeners have been invoked. If not awaited, this will schedule the dispatch of the events in the background for later. See Also     Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.stream",
"url":74,
"doc":"Return a stream iterator for the given event and sub-events. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. timeout : typing.Optional[builtins.int, builtins.float] How long this streamer should wait for the next event before ending the iteration. If  builtins.None then this will continue until explicitly broken from. limit : typing.Optional[builtins.int] The limit for how many events this should queue at one time before dropping extra incoming events, leave this as  builtins.None for the cache size to be unlimited. Returns    - hikari.event_stream.Streamer[hikari.events.base_events.Event] The async iterator to handle streamed events. This must be started with  async with stream: or  await stream.open() before asynchronously iterating over it.  ! warning If you use  await stream.open() to start the stream then you must also close it with  await stream.close() otherwise it may queue events in memory indefinitely. Examples       async with bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id as stream: async for user_id in stream.map(\"user_id\").limit(50):  .   or using await  open() and await  close()   stream = bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id await stream.open() async for user_id in stream.map(\"user_id\").limit(50)  . await stream.close()   See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.stateful_event_manager.StatefulEventManagerImpl.wait_for",
"url":74,
"doc":"Wait for a given event to occur once, then return the event. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. predicate A function taking the event as the single parameter. This should return  builtins.True if the event is one you want to return, or  builtins.False if the event should not be returned. If left as  None (the default), then the first matching event type that the bot receives (or any subtype) will be the one returned.  ! warn ASYNC PREDICATES ARE NOT SUPPORTED. timeout : typing.Union[builtins.float, builtins.int, builtins.None] The amount of time to wait before raising an  asyncio.TimeoutError and giving up instead. This is measured in seconds. If  builtins.None , then no timeout will be waited for (no timeout can result in \"leaking\" of coroutines that never complete if called in an uncontrolled way, so is not recommended). Returns    - hikari.events.base_events.Event The event that was provided. Raises    asyncio.TimeoutError If the timeout is not  builtins.None and is reached before an event is received that the predicate returns  builtins.True for. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch ",
"func":1
},
{
"ref":"hikari.impl.entity_factory",
"url":75,
"doc":"Basic implementation of an entity factory for general bots and HTTP apps."
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl",
"url":75,
"doc":"Standard implementation for a serializer/deserializer. This will convert objects to/from JSON compatible representations."
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_own_connection",
"url":75,
"doc":"Parse a raw payload from Discord into an own connection object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.applications.OwnConnection The deserialized \"own connection\" object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_own_guild",
"url":75,
"doc":"Parse a raw payload from Discord into an own guild object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.applications.OwnGuild The deserialized \"own guild\" object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_application",
"url":75,
"doc":"Parse a raw payload from Discord into an application object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.applications.Application The deserialized application object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_audit_log",
"url":75,
"doc":"Parse a raw payload from Discord into an audit log object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.audit_logs.AuditLog The deserialized audit log object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_channel_follow",
"url":75,
"doc":"Parse a raw payload from Discord into a channel follow object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.ChannelFollow The deserialized channel follow object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_permission_overwrite",
"url":75,
"doc":"Parse a raw payload from Discord into a permission overwrite object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.PermissionOverwrite The deserialized permission overwrite object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.serialize_permission_overwrite",
"url":75,
"doc":"Serialize a permission overwrite object to a json serializable dict. Parameters      overwrite : hikari.channels.PermissionOverwrite The permission overwrite object to serialize. Returns    - hikari.internal.data_binding.JSONObject The serialized representation of the permission overwrite.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_partial_channel",
"url":75,
"doc":"Parse a raw payload from Discord into a partial channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.PartialChannel The deserialized \"partial channel\" object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_dm",
"url":75,
"doc":"Parse a raw payload from Discord into a DM channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.DMChannel The deserialized DM channel object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_group_dm",
"url":75,
"doc":"Parse a raw payload from Discord into a group DM channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.channels.GroupDMChannel The deserialized group DM object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_category",
"url":75,
"doc":"Parse a raw payload from Discord into a guild category object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.GuildCategory The deserialized guild category object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_text_channel",
"url":75,
"doc":"Parse a raw payload from Discord into a guild text channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.GuildTextChannel The deserialized guild text channel object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_news_channel",
"url":75,
"doc":"Parse a raw payload from Discord into a guild news channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.GuildNewsChannel The deserialized guild news channel object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_store_channel",
"url":75,
"doc":"Parse a raw payload from Discord into a guild store channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.GuildStoreChannel The deserialized guild store channel object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_voice_channel",
"url":75,
"doc":"Parse a raw payload from Discord into a guild voice channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.snowflakes.Snowflake The ID of the guild this channel belongs to. If passed then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is npt included in the channel's payload. Returns    - hikari.channels.GuildVoiceChannel The deserialized guild voice channel object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_channel",
"url":75,
"doc":"Parse a raw payload from Discord into a channel object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this channel belongs to. This will be ignored for DM and group DM channels and will be prioritised over  \"guild_id\" in the payload when passed.  ! note  guild_id currently only covers the gateway GUILD_CREATE event where  \"guild_id\" is not included in the channel's payload. Returns    - hikari.channels.PartialChannel The deserialized partial channel-derived object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload of a guild channel.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_embed",
"url":75,
"doc":"Parse a raw payload from Discord into an embed object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.embeds.Embed The deserialized embed object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.serialize_embed",
"url":75,
"doc":"Serialize an embed object to a json serializable dict. Parameters      embed : hikari.embeds.Embed The embed object to serialize. Returns    - typing.Tuple[hikari.internal.data_binding.JSONObject, typing.List[hikari.files.Resource A tuple with two items in it. The first item will be the serialized embed representation. The second item will be a list of resources to upload with the embed.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_unicode_emoji",
"url":75,
"doc":"Parse a raw payload from Discord into a unicode emoji object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.emojis.UnicodeEmoji The deserialized unicode emoji object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_custom_emoji",
"url":75,
"doc":"Parse a raw payload from Discord into a custom emoji object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.emojis.CustomEmoji The deserialized custom emoji object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_known_custom_emoji",
"url":75,
"doc":"Parse a raw payload from Discord into a known custom emoji object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. guild_id : hikari.snowflakes.Snowflake The ID of the guild this emoji belongs to. This is used to ensure that the guild a known custom emoji belongs to is remembered by allowing for a context based artificial  guild_id attribute. Returns    - hikari.emojis.KnownCustomEmoji The deserialized \"known custom emoji\" object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_emoji",
"url":75,
"doc":"Parse a raw payload from Discord into an emoji object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.emojis.UnicodeEmoji or hikari.emojis.CustomEmoji The deserialized custom or unicode emoji object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_gateway_bot",
"url":75,
"doc":"Parse a raw payload from Discord into a gateway bot object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.sessions.GatewayBot The deserialized gateway bot object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_widget",
"url":75,
"doc":"Parse a raw payload from Discord into a guild widget object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.GuildWidget The deserialized guild widget object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_member",
"url":75,
"doc":"Parse a raw payload from Discord into a member object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         user : hikari.undefined.UndefinedOr[hikari.users.User] The user to attach to this member, should only be passed in situations where \"user\" is not included in the payload. guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this member belongs to. If this is specified then this will be prioritised over  \"guild_id\" in the payload.  ! note  guild_id covers cases such as the GUILD_CREATE gateway event and GET Guild Member where  \"guild_id\" is not included in the returned payload. Returns    - hikari.guilds.Member The deserialized member object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_role",
"url":75,
"doc":"Parse a raw payload from Discord into a role object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. guild_id : hikari.snowflakes.Snowflake The ID of the guild this role belongs to. This is used to ensure that the guild a role belongs to is remembered by allowing for a context based artificial  guild_id attribute. Returns    - hikari.guilds.Role The deserialized role object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_partial_integration",
"url":75,
"doc":"Parse a raw payload from Discord into a partial integration object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.PartialIntegration The deserialized partial integration object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_integration",
"url":75,
"doc":"Parse a raw payload from Discord into an integration object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.Integration The deserialized integration object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_member_ban",
"url":75,
"doc":"Parse a raw payload from Discord into a guild member ban object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.GuildMemberBan The deserialized guild member ban object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_guild_preview",
"url":75,
"doc":"Parse a raw payload from Discord into a guild preview object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.GuildPreview The deserialized guild preview object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_rest_guild",
"url":75,
"doc":"Parse a raw payload from Discord into a guild object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.guilds.RESTGuild The deserialized guild object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_gateway_guild",
"url":75,
"doc":"Parse a raw payload from Discord into a guild object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - GatewayGuildDefinition The deserialized guild object and the internal collections as maps of  hikari.snowflakes.Snowflake mapping to  hikari.channels.GuildChannel ,  hikari.guilds.Member ,  hikari.presences.MemberPresence ,  hikari.guilds.Role , and  hikari.emojis.KnownCustomEmoji . This is provided in several components to allow separate caching and linking between entities in various relational cache implementations internally.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_vanity_url",
"url":75,
"doc":"Parse a raw payload from Discord into a vanity url object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.invites.VanityURL The deserialized vanity url object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_invite",
"url":75,
"doc":"Parse a raw payload from Discord into an invite object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.invites.Invite The deserialized invite object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_invite_with_metadata",
"url":75,
"doc":"Parse a raw payload from Discord into a invite with metadata object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.invites.InviteWithMetadata The deserialized invite with metadata object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_partial_message",
"url":75,
"doc":"Parse a raw payload from Discord into a partial message object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.messages.PartialMessage The deserialized partial message object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_message",
"url":75,
"doc":"Parse a raw payload from Discord into a message object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.messages.Message The deserialized message object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_member_presence",
"url":75,
"doc":"Parse a raw payload from Discord into a member presence object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild the presence belongs to. If this is specified then it is prioritised over  guild_id in the payload.  ! note At the time of writing, the only place where  guild_id will be mandatory is when parsing presences sent in a  GUILD_CREATE event from Discord, since the  guild_id attribute in the payload will have been omitted for redundancy. Returns    - hikari.presences.MemberPresence The deserialized member presence object. Raises    KeyError If  guild_id is not an attribute of the  payload dict, and no guild ID was passed for the  guild_id parameter. If this is raised, no guild ID info was provided anywhere.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_user",
"url":75,
"doc":"Parse a raw payload from Discord into a user object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.users.User The deserialized user object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_my_user",
"url":75,
"doc":"Parse a raw payload from Discord into a user object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.users.OwnUser The deserialized user object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_voice_state",
"url":75,
"doc":"Parse a raw payload from Discord into a voice state object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Other Parameters         guild_id : hikari.undefined.UndefinedOr[hikari.snowflakes.Snowflake] The ID of the guild this voice state belongs to. If this is specified then this will be prioritised over  \"guild_id\" in the payload. member : hikari.undefined.UndefinedOr[hikari.guilds.Member] The object of the member this voice state belongs to. If this is specified then this will be prioritised over  \"member\" in the payload.  ! note At the time of writing,  GUILD_CREATE events are the only known place where neither  guild_id nor  member will be keys on the payload. In this case, you will need to provide the former parameters explicitly. Returns    - hikari.voices.VoiceState The deserialized voice state object. Raises    KeyError If  guild_id is left as  hikari.undefined.UNDEFINED when  \"guild_id\" is not present in the passed payload for the payload of the voice state. This will also be raised if no  member data was passed in any acceptable place.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_voice_region",
"url":75,
"doc":"Parse a raw payload from Discord into a voice region object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.voices.VoiceRegion The deserialized voice region object.",
"func":1
},
{
"ref":"hikari.impl.entity_factory.EntityFactoryImpl.deserialize_webhook",
"url":75,
"doc":"Parse a raw payload from Discord into a webhook object. Parameters      payload : hikari.internal.data_binding.JSONObject The JSON payload to deserialize. Returns    - hikari.webhooks.Webhook The deserialized webhook object.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache",
"url":76,
"doc":"Bare-bones implementation of a cache that never stores anything. This is used to enable compatibility with HTTP applications and stateless bots where desired."
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl",
"url":76,
"doc":"Stateless cache. A stateless cache implementation that implements dummy operations for each of the required attributes of a functional cache implementation.R Any descriptors will always return  builtins.NotImplemented , and any methods will always raise  hikari.errors.HikariError when being invoked. The only state that _is_ stored will be the bot user, as this is generally useful information to always know about, and is required for some functionality such as voice support."
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_emojis",
"url":76,
"doc":"Remove all the known custom emoji objects from the cache.  ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A cache view of emoji IDs to objects of the emojis that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_emojis_for_guild",
"url":76,
"doc":"Remove the known custom emoji objects cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove the cached emoji objects for.  ! note This will skip emojis that are being kept alive by a reference on a presence entry. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the emojis that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_emoji",
"url":76,
"doc":"Remove a known custom emoji from the cache. Parameters      emoji_id : hikari.snowflakes.Snowflake The ID of the emoji to remove from the cache.  ! note This will not delete emojis that are being kept alive by a reference on a presence entry. Returns    - typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was removed from the cache or  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_emoji",
"url":76,
"doc":"Get a known custom emoji from the cache. Parameters      emoji_id : hikari.snowflakes.Snowflake The ID of the emoji to get from the cache. Returns    - typing.Optional[hikari.emojis.KnownCustomEmoji] The object of the emoji that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_emojis_view",
"url":76,
"doc":"Get a view of the known custom emoji objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of the known custom emojis found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_emojis_view_for_guild",
"url":76,
"doc":"Get a view of the known custom emojis cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached emoji objects for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.emojis.KnownCustomEmoji] A view of emoji IDs to objects of emojis found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_emoji",
"url":76,
"doc":"Add a known custom emoji to the cache. Parameters      emoji : hikari.emojis.KnownCustomEmoji The object of the known custom emoji to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_emoji",
"url":76,
"doc":"Update an emoji object in the cache. Parameters      emoji : hikari.emojis.KnownCustomEmoji The object of the emoji to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.emojis.KnownCustomEmoji], typing.Optional[hikari.emojis.KnownCustomEmoji A tuple of the old cached emoji object if found (else  builtins.None ) and the new cached emoji object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_guilds",
"url":76,
"doc":"Remove all the guild objects from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] The cache view of guild IDs to guild objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_guild",
"url":76,
"doc":"Remove a guild object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild that was removed from the cache, will be  builtins.None if not found. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_guild",
"url":76,
"doc":"Get a guild from the cache.  ! warning This will return a guild regardless of whether it is available or not. To only query available guilds, use  get_available_guild instead. Likewise, to only query unavailable guilds, use  get_unavailable_guild . Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_available_guild",
"url":76,
"doc":"Get the object of an available guild from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_unavailable_guild",
"url":76,
"doc":"Get the object of a unavailable guild from the cache.  ! note Unlike  Cache.get_available_guild , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get from the cache. Returns    - typing.Optional[hikari.guilds.GatewayGuild] The object of the guild if found, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_available_guilds_view",
"url":76,
"doc":"Get a view of the available guild objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_unavailable_guilds_view",
"url":76,
"doc":"Get a view of the unavailable guild objects in the cache.  ! note Unlike  Cache.get_available_guilds_view , the objects returned by this method will likely be out of date and inaccurate as they are considered unavailable, meaning that we are not receiving gateway events for this guild. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.GatewayGuild] A view of guild IDs to the guild objects found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_guild",
"url":76,
"doc":"Add a guild object to the cache. Parameters      guild : hikari.guilds.GatewayGuild The object of the guild to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_guild_availability",
"url":76,
"doc":"Set whether a cached guild is available or not. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to set the availability for. is_available : builtins.bool The availability to set for the guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_guild",
"url":76,
"doc":"Update a guild in the cache. Parameters      guild : hikari.guilds.GatewayGuild The object of the guild to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.guilds.GatewayGuild], typing.Optional[hikari.guilds.GatewayGuild A tuple of the old cached guild object if found (else  builtins.None ) and the object of the guild that was added to the cache if it could be added (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_guild_channels",
"url":76,
"doc":"Remove all guild channels from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_guild_channels_for_guild",
"url":76,
"doc":"Remove guild channels from the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove cached channels for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_guild_channel",
"url":76,
"doc":"Remove a guild channel from the cache. Parameters      channel_id : hikari.snowflakes.Snowflake The ID of the guild channel to remove from the cache. Returns    - typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_guild_channel",
"url":76,
"doc":"Get a guild channel from the cache. Parameters      channel_id : hikari.snowflakes.Snowflake The ID of the guild channel to get from the cache. Returns    - typing.Optional[hikari.channels.GuildChannel] The object of the guild channel that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_guild_channels_view",
"url":76,
"doc":"Get a view of the guild channels in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_guild_channels_view_for_guild",
"url":76,
"doc":"Get a view of the guild channels in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.channels.GuildChannel] A view of channel IDs to objects of the guild channels found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_guild_channel",
"url":76,
"doc":"Add a guild channel to the cache. Parameters      channel : hikari.channels.GuildChannel The guild channel based object to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_guild_channel",
"url":76,
"doc":"Update a guild channel in the cache, Parameters      channel : hikari.channels.GuildChannel The object of the channel to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.channels.GuildChannel], typing.Optional[hikari.channels.GuildChannel A tuple of the old cached guild channel if found (else  builtins.None ) and the new cached guild channel if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_invites",
"url":76,
"doc":"Remove all the invite objects from the cache. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_invites_for_guild",
"url":76,
"doc":"Remove the invite objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_invites_for_channel",
"url":76,
"doc":"Remove the invite objects in the cache for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove invite objects for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to remove invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of invite code strings to objects of the invites that were removed from the cache for the specified channel. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_invite",
"url":76,
"doc":"Remove an invite object from the cache. Parameters      code : str The string code of the invite to remove from the cache. Returns    - typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_invite",
"url":76,
"doc":"Get an invite object from the cache. Parameters      code : str The string code of the invite to get from the cache. Returns    - typing.Optional[hikari.invites.InviteWithMetadata] The object of the invite that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_invites_view",
"url":76,
"doc":"Get a view of the invite objects in the cache. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string codes to objects of the invites that were found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_invites_view_for_guild",
"url":76,
"doc":"Get a view of the invite objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get invite objects for. Returns    - CacheView[builtins.str, hikari.invites.InviteWithMetadata] A view of string code to objects of the invites that were found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_invites_view_for_channel",
"url":76,
"doc":"Get a view of the invite objects in the cache for a specified channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get invite objects for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to get invite objects for. Returns    - CacheView[str, invites.InviteWithMetadata] A view of string codes to objects of the invites there were found in the cache for the specified channel.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_invite",
"url":76,
"doc":"Add an invite object to the cache. Parameters      invite : hikari.invites.InviteWithMetadata The object of the invite to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_invite",
"url":76,
"doc":"Update an invite in the cache. Parameters      invite : hikari.invites.InviteWithMetadata The object of the invite to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.invites.InviteWithMetadata], typing.Optional[hikari.invites.InviteWithMetadata A tuple of the old cached invite object if found (else  builtins.None ) and the new cached invite object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_me",
"url":76,
"doc":"Remove the own user object from the cache. Returns    - typing.Optional[hikari.users.OwnUser] The own user object that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_me",
"url":76,
"doc":"Get the own user object from the cache. Returns    - typing.Optional[hikari.users.OwnUser] The own user object that was found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_me",
"url":76,
"doc":"Set the own user object in the cache. Parameters      user : hikari.users.OwnUser The own user object to set in the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_me",
"url":76,
"doc":"Update the own user entry in the cache. Parameters      user : hikari.users.OwnUser The own user object to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.users.OwnUser], typing.Optional[hikari.users.OwnUser A tuple of the old cached own user object if found (else  builtins.None ) and the new cached own user object if it could be cached, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_members",
"url":76,
"doc":"Remove all the guild members in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_members_for_guild",
"url":76,
"doc":"Remove the members for a specific guild from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove cached members for.  ! note This will skip members that are being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the member objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_member",
"url":76,
"doc":"Remove a member object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove a member from the cache for. user_id : hikari.snowflakes.Snowflake The ID of the user to remove a member from the cache for.  ! note You cannot delete a member entry that's being referenced by other entries in the cache; a matching voice state will keep a member entry alive. Returns    - typing.Optional[hikari.guilds.Member] The object of the member that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_member",
"url":76,
"doc":"Get a member object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake user_id : hikari.snowflakes.Snowflake Returns    - typing.Optional[hikari.guilds.Member] The object of the member found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_members_view",
"url":76,
"doc":"Get a view of all the members objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member A view of guild IDs to views of user IDs to objects of the members that were found from the cache.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_members_view_for_guild",
"url":76,
"doc":"Get a view of the members cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached member view for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Member] The view of user IDs to the members cached for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_member",
"url":76,
"doc":"Add a member object to the cache. Parameters      member : hikari.guilds.Member The object of the member to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_member",
"url":76,
"doc":"Update a member in the cache. Parameters      member : hikari.guilds.Member The object of the member to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.guilds.Member], typing.Optional[hikari.guilds.Member A tuple of the old cached member object if found (else  builtins.None ) and the new cached member object if it could be cached (else  builtins.None ) Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_presences",
"url":76,
"doc":"Remove all the presences in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence A view of guild IDs to views of user IDs to objects of the presences that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_presences_for_guild",
"url":76,
"doc":"Remove the presences in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove presences for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presences that were removed from the cache for the specified guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_presence",
"url":76,
"doc":"Remove a presence from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove a presence for. user_id : hikari.snowflakes.Snowflake The ID of the user to remove a presence for. Returns    - typing.Optional[hikari.presences.MemberPresence] The object of the presence that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_presence",
"url":76,
"doc":"Get a presence object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get a presence for. user_id : hikari.snowflakes.Snowflake The ID of the user to get a presence for. Returns    - typing.Optional[hikari.presences.MemberPresence] The object of the presence that was found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_presences_view",
"url":76,
"doc":"Get a view of all the presence objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake A view of guild IDs to views of user IDs to objects of the presences found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_presences_view_for_guild",
"url":76,
"doc":"Get a view of the presence objects in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached presence objects for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.presences.MemberPresence] A view of user IDs to objects of the presence found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_presence",
"url":76,
"doc":"Add a presence object to the cache. Parameters      presence : hikari.presences.MemberPresence The object of the presence to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_presence",
"url":76,
"doc":"Update a presence object in the cache. Parameters      presence : hikari.presences.MemberPresence The object of the presence to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.presences.MemberPresence], typing.Optional[hikari.presences.MemberPresence A tuple of the old cached invite object if found (else  builtins.None and the new cached invite object if it could be cached ( else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_roles",
"url":76,
"doc":"Remove all role objects from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_roles_for_guild",
"url":76,
"doc":"Remove role objects from the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove roles for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were removed from the cache for the specific guild. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_role",
"url":76,
"doc":"Remove a role object form the cache. Parameters      role_id : hikari.snowflakes.Snowflake The ID of the role to remove from the cache. Returns    - typing.Optional[hikari.guilds.Role] The object of the role that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_role",
"url":76,
"doc":"Get a role object from the cache. Parameters      role_id : hikari.snowflakes.Snowflake The ID of the role to get from the cache. Returns    - typing.Optional[hikari.guilds.Role] The object of the role found in the cache or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_roles_view",
"url":76,
"doc":"Get a view of all the role objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_roles_view_for_guild",
"url":76,
"doc":"Get a view of the roles in the cache for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached roles for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.guilds.Role] A view of role IDs to objects of the roles that were found in the cache for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_role",
"url":76,
"doc":"Add a role object to the cache. Parameters      role : hikari.guilds.Role The object of the role to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_role",
"url":76,
"doc":"Update a role in the cache. Parameters      role : hikari.guilds.Role The object of the role to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.guilds.Role], typing.Optional[hikari.guilds.Role A tuple of the old cached role object if found (else  builtins.None and the new cached role object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_users",
"url":76,
"doc":"Clear the user objects from the cache.  ! note This will skip users that are being referenced by other entries within the cache; member entries and DM entries will keep a user alive within the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the user objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_user",
"url":76,
"doc":"Remove a user object from the cache. Parameters      user_id : hikari.snowflakes.Snowflake The ID of the user to remove from the cache.  ! note You cannot delete a user object while it's being referenced by other entries within the cache; member entries and DM entries will keep a user alive within the cache. Returns    - typing.Optional[hikari.users.User] The object of the user that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_user",
"url":76,
"doc":"Get a user object from the cache. Parameters      user_id : hikari.snowflakes.Snowflake The ID of the user to get from the cache. Returns    - typing.Optional[hikari.users.User] The object of the user that was found in the cache, else  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_users_view",
"url":76,
"doc":"Get a view of the user objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.users.User] The view of user IDs to the users found in the cache.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_user",
"url":76,
"doc":"Add a user object to the cache. Parameters      user : hikari.users.User The object of the user to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_user",
"url":76,
"doc":"Update a user object in the cache. Parameters      user : hikari.users.User The object of the user to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.users.User], typing.Optional[hikari.users.User A tuple of the old cached user if found (else  builtins.None ) and the newly cached user if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_voice_states",
"url":76,
"doc":"Remove all voice state objects from the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were removed from the states. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_voice_states_for_guild",
"url":76,
"doc":"Clear the voice state objects cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to the voice state objects that were removed from the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.clear_voice_states_for_channel",
"url":76,
"doc":"Remove the voice state objects cached for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to remove voice states for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to remove voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice state that were removed from the cache for the specified channel. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.delete_voice_state",
"url":76,
"doc":"Remove a voice state object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild the voice state to remove is related to. user_id : hikari.snowflakes.Snowflake The ID of the user who the voice state to remove belongs to. Returns    - typing.Optional[hikari.voices.VoiceState] The object of the voice state that was removed from the cache if found, else  builtins.None . Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_voice_state",
"url":76,
"doc":"Get a voice state object from the cache. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get a voice state for. user_id :hikari.snowflakes.Snowflake The ID of the user to get a voice state for. Returns    - typing.Optional[hikari.voices.VoiceState] The object of the voice state that was found in the cache, or  builtins.None .",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_voice_states_view",
"url":76,
"doc":"Get a view of all the voice state objects in the cache. Returns    - CacheView[hikari.snowflakes.Snowflake, ICacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState A view of guild IDs to views of user IDs to objects of the voice states that were found in the cache,",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_voice_states_view_for_channel",
"url":76,
"doc":"Get a view of the voice states cached for a specific channel. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached voice states for. channel_id : hikari.snowflakes.Snowflake The ID of the channel to get the cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified channel.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.get_voice_states_view_for_guild",
"url":76,
"doc":"Get a view of the voice states cached for a specific guild. Parameters      guild_id : hikari.snowflakes.Snowflake The ID of the guild to get the cached voice states for. Returns    - CacheView[hikari.snowflakes.Snowflake, hikari.voices.VoiceState] A view of user IDs to objects of the voice states found cached for the specified guild.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.set_voice_state",
"url":76,
"doc":"Add a voice state object to the cache. Parameters      voice_state : hikari.voices.VoiceState The object of the voice state to add to the cache. Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_cache.StatelessCacheImpl.update_voice_state",
"url":76,
"doc":"Update a voice state object in the cache. Parameters      voice_state : hikari.voices.VoiceState The object of the voice state to update in the cache. Returns    - typing.Tuple[typing.Optional[hikari.voices.VoiceState], typing.Optional[hikari.voices.VoiceState A tuple of the old cached voice state if found (else  builtins.None ) and the new cached voice state object if it could be cached (else  builtins.None ). Raises    builtins.NotImplementedError When called on a stateless cache implementation.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager",
"url":77,
"doc":"Event handling logic."
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl",
"url":77,
"doc":"Provides event handling logic for Discord events without a cache."
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_connected",
"url":77,
"doc":"Handle connection events. This is a synthetic event produced by the gateway implementation in Hikari.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_disconnected",
"url":77,
"doc":"Handle disconnection events. This is a synthetic event produced by the gateway implementation in Hikari.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_ready",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway ready for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_resumed",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway resumed for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_channel_create",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway channel-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_channel_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway channel-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_channel_delete",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway channel-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_channel_pins_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway channel-pins-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_create",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_delete",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_ban_add",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-ban-add for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_ban_remove",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-ban-remove for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_emojis_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-emojis-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_integrations_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-integrations-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_member_add",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-member-add for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_member_remove",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-member-remove for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_member_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-member-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_members_chunk",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-members-chunk for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_role_create",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-role-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_role_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-role-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_guild_role_delete",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway guild-role-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_invite_create",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway invite-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_invite_delete",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway invite-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_message_create",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway message-create for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_message_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway message-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_message_delete",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway message-delete for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_message_delete_bulk",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway message-delete-bulk for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_message_reaction_add",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway message-reaction-add for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_message_reaction_remove",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway message-reaction-remove for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_message_reaction_remove_all",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway message-reaction-remove-all for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_message_reaction_remove_emoji",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway message-reaction-remove-emoji for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_presence_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway presence-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_typing_start",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway typing-start for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_user_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway user-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_voice_state_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway voice-state-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_voice_server_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway voice-server-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.on_webhooks_update",
"url":77,
"doc":"See https: discord.com/developers/docs/topics/gateway webhooks-update for more info.",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.subscribe",
"url":74,
"doc":"Subscribe a given callback to a given event type. Parameters      event_type : typing.Type[T] The event type to listen for. This will also listen for any subclasses of the given type.  T must be a subclass of  hikari.events.base_events.Event . callback Must be a coroutine function to invoke. This should consume an instance of the given event, or an instance of a valid subclass if one exists. Any result is discarded. Example    - The following demonstrates subscribing a callback to message creation events.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.subscribe(MessageCreateEvent, on_message)   Returns    - typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None] The event callback that was passed in. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.get_listeners",
"url":74,
"doc":"Get the listeners for a given event type, if there are any. Parameters      event_type : typing.Type[T] The event type to look for.  T must be a subclass of  hikari.events.base_events.Event . polymorphic : builtins.bool If  builtins.True , this will also return the listeners of the subclasses of the given event type. If  builtins.False , then only listeners for this class specifically are returned. The default is  builtins.True . Returns    - typing.Collection[typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None A copy of the collection of listeners for the event. Will return an empty collection if nothing is registered.  T must be a subclass of  hikari.events.base_events.Event . See Also     Has listener:  hikari.api.event_dispatcher.EventDispatcher.has_listener ",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.unsubscribe",
"url":74,
"doc":"Unsubscribe a given callback from a given event type, if present. Parameters      event_type : typing.Type[T] The event type to unsubscribe from. This must be the same exact type as was originally subscribed with to be removed correctly.  T must derive from  hikari.events.base_events.Event . callback The callback to unsubscribe. Example    - The following demonstrates unsubscribing a callback from a message creation event.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.unsubscribe(MessageCreateEvent, on_message)  ",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.listen",
"url":74,
"doc":"Generate a decorator to subscribe a callback to an event type. This is a second-order decorator. Parameters      event_type : typing.Optional[typing.Type[T The event type to subscribe to. The implementation may allow this to be undefined. If this is the case, the event type will be inferred instead from the type hints on the function signature.  T must be a subclass of  hikari.events.base_events.Event . Returns    - typing.Callable T], T] A decorator for a coroutine function that passes it to  EventDispatcher.subscribe before returning the function reference. See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.dispatch",
"url":74,
"doc":"Dispatch an event. Parameters      event : hikari.events.base_events.Event The event to dispatch. Example    - We can dispatch custom events by first defining a class that derives from  hikari.events.base_events.Event .   import attr from hikari.traits import RESTAware from hikari.events.base_events import Event from hikari.users import User from hikari.snowflakes import Snowflake @attr.s() class EveryoneMentionedEvent(Event): app: RESTAware = attr.ib() author: User = attr.ib()  'The user who mentioned everyone. ' content: str = attr.ib()  'The message that was sent. ' message_id: Snowflake = attr.ib()  'The message ID. ' channel_id: Snowflake = attr.ib()  'The channel ID. '   We can then dispatch our event as we see fit.   from hikari.events.messages import MessageCreateEvent @bot.listen(MessageCreateEvent) async def on_message(event): if \"@everyone\" in event.content or \"@here\" in event.content: event = EveryoneMentionedEvent( author=event.author, content=event.content, message_id=event.id, channel_id=event.channel_id, ) bot.dispatch(event)   This event can be listened to elsewhere by subscribing to it with  EventDispatcher.subscribe .   @bot.listen(EveryoneMentionedEvent) async def on_everyone_mentioned(event): print(event.user, \"just pinged everyone in\", event.channel_id)   Returns    - asyncio.Future[typing.Any] A future that can be optionally awaited. If awaited, the future will complete once all corresponding event listeners have been invoked. If not awaited, this will schedule the dispatch of the events in the background for later. See Also     Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.stream",
"url":74,
"doc":"Return a stream iterator for the given event and sub-events. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. timeout : typing.Optional[builtins.int, builtins.float] How long this streamer should wait for the next event before ending the iteration. If  builtins.None then this will continue until explicitly broken from. limit : typing.Optional[builtins.int] The limit for how many events this should queue at one time before dropping extra incoming events, leave this as  builtins.None for the cache size to be unlimited. Returns    - hikari.event_stream.Streamer[hikari.events.base_events.Event] The async iterator to handle streamed events. This must be started with  async with stream: or  await stream.open() before asynchronously iterating over it.  ! warning If you use  await stream.open() to start the stream then you must also close it with  await stream.close() otherwise it may queue events in memory indefinitely. Examples       async with bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id as stream: async for user_id in stream.map(\"user_id\").limit(50):  .   or using await  open() and await  close()   stream = bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id await stream.open() async for user_id in stream.map(\"user_id\").limit(50)  . await stream.close()   See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.stateless_event_manager.StatelessEventManagerImpl.wait_for",
"url":74,
"doc":"Wait for a given event to occur once, then return the event. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. predicate A function taking the event as the single parameter. This should return  builtins.True if the event is one you want to return, or  builtins.False if the event should not be returned. If left as  None (the default), then the first matching event type that the bot receives (or any subtype) will be the one returned.  ! warn ASYNC PREDICATES ARE NOT SUPPORTED. timeout : typing.Union[builtins.float, builtins.int, builtins.None] The amount of time to wait before raising an  asyncio.TimeoutError and giving up instead. This is measured in seconds. If  builtins.None , then no timeout will be waited for (no timeout can result in \"leaking\" of coroutines that never complete if called in an uncontrolled way, so is not recommended). Returns    - hikari.events.base_events.Event The event that was provided. Raises    asyncio.TimeoutError If the timeout is not  builtins.None and is reached before an event is received that the predicate returns  builtins.True for. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch ",
"func":1
},
{
"ref":"hikari.impl.event_manager_base",
"url":74,
"doc":"A base implementation for an event manager."
},
{
"ref":"hikari.impl.event_manager_base.EventManagerBase",
"url":74,
"doc":"Provides functionality to consume and dispatch events. Specific event handlers should be in functions named  on_xxx where  xxx is the raw event name being dispatched in lower-case."
},
{
"ref":"hikari.impl.event_manager_base.EventManagerBase.consume_raw_event",
"url":74,
"doc":"",
"func":1
},
{
"ref":"hikari.impl.event_manager_base.EventManagerBase.subscribe",
"url":74,
"doc":"Subscribe a given callback to a given event type. Parameters      event_type : typing.Type[T] The event type to listen for. This will also listen for any subclasses of the given type.  T must be a subclass of  hikari.events.base_events.Event . callback Must be a coroutine function to invoke. This should consume an instance of the given event, or an instance of a valid subclass if one exists. Any result is discarded. Example    - The following demonstrates subscribing a callback to message creation events.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.subscribe(MessageCreateEvent, on_message)   Returns    - typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None] The event callback that was passed in. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.event_manager_base.EventManagerBase.get_listeners",
"url":74,
"doc":"Get the listeners for a given event type, if there are any. Parameters      event_type : typing.Type[T] The event type to look for.  T must be a subclass of  hikari.events.base_events.Event . polymorphic : builtins.bool If  builtins.True , this will also return the listeners of the subclasses of the given event type. If  builtins.False , then only listeners for this class specifically are returned. The default is  builtins.True . Returns    - typing.Collection[typing.Callable T], typing.Coroutine[typing.Any, typing.Any, builtins.None A copy of the collection of listeners for the event. Will return an empty collection if nothing is registered.  T must be a subclass of  hikari.events.base_events.Event . See Also     Has listener:  hikari.api.event_dispatcher.EventDispatcher.has_listener ",
"func":1
},
{
"ref":"hikari.impl.event_manager_base.EventManagerBase.unsubscribe",
"url":74,
"doc":"Unsubscribe a given callback from a given event type, if present. Parameters      event_type : typing.Type[T] The event type to unsubscribe from. This must be the same exact type as was originally subscribed with to be removed correctly.  T must derive from  hikari.events.base_events.Event . callback The callback to unsubscribe. Example    - The following demonstrates unsubscribing a callback from a message creation event.   from hikari.events.messages import MessageCreateEvent async def on_message(event):  . bot.unsubscribe(MessageCreateEvent, on_message)  ",
"func":1
},
{
"ref":"hikari.impl.event_manager_base.EventManagerBase.listen",
"url":74,
"doc":"Generate a decorator to subscribe a callback to an event type. This is a second-order decorator. Parameters      event_type : typing.Optional[typing.Type[T The event type to subscribe to. The implementation may allow this to be undefined. If this is the case, the event type will be inferred instead from the type hints on the function signature.  T must be a subclass of  hikari.events.base_events.Event . Returns    - typing.Callable T], T] A decorator for a coroutine function that passes it to  EventDispatcher.subscribe before returning the function reference. See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.event_manager_base.EventManagerBase.dispatch",
"url":74,
"doc":"Dispatch an event. Parameters      event : hikari.events.base_events.Event The event to dispatch. Example    - We can dispatch custom events by first defining a class that derives from  hikari.events.base_events.Event .   import attr from hikari.traits import RESTAware from hikari.events.base_events import Event from hikari.users import User from hikari.snowflakes import Snowflake @attr.s() class EveryoneMentionedEvent(Event): app: RESTAware = attr.ib() author: User = attr.ib()  'The user who mentioned everyone. ' content: str = attr.ib()  'The message that was sent. ' message_id: Snowflake = attr.ib()  'The message ID. ' channel_id: Snowflake = attr.ib()  'The channel ID. '   We can then dispatch our event as we see fit.   from hikari.events.messages import MessageCreateEvent @bot.listen(MessageCreateEvent) async def on_message(event): if \"@everyone\" in event.content or \"@here\" in event.content: event = EveryoneMentionedEvent( author=event.author, content=event.content, message_id=event.id, channel_id=event.channel_id, ) bot.dispatch(event)   This event can be listened to elsewhere by subscribing to it with  EventDispatcher.subscribe .   @bot.listen(EveryoneMentionedEvent) async def on_everyone_mentioned(event): print(event.user, \"just pinged everyone in\", event.channel_id)   Returns    - asyncio.Future[typing.Any] A future that can be optionally awaited. If awaited, the future will complete once all corresponding event listeners have been invoked. If not awaited, this will schedule the dispatch of the events in the background for later. See Also     Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.event_manager_base.EventManagerBase.stream",
"url":74,
"doc":"Return a stream iterator for the given event and sub-events. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. timeout : typing.Optional[builtins.int, builtins.float] How long this streamer should wait for the next event before ending the iteration. If  builtins.None then this will continue until explicitly broken from. limit : typing.Optional[builtins.int] The limit for how many events this should queue at one time before dropping extra incoming events, leave this as  builtins.None for the cache size to be unlimited. Returns    - hikari.event_stream.Streamer[hikari.events.base_events.Event] The async iterator to handle streamed events. This must be started with  async with stream: or  await stream.open() before asynchronously iterating over it.  ! warning If you use  await stream.open() to start the stream then you must also close it with  await stream.close() otherwise it may queue events in memory indefinitely. Examples       async with bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id as stream: async for user_id in stream.map(\"user_id\").limit(50):  .   or using await  open() and await  close()   stream = bot.stream(events.ReactionAddEvent, timeout=30).filter \"message_id\", message.id await stream.open() async for user_id in stream.map(\"user_id\").limit(50)  . await stream.close()   See Also     Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Unsubscribe:  hikari.api.event_dispatcher.EventDispatcher.unsubscribe Wait for:  hikari.api.event_dispatcher.EventDispatcher.wait_for ",
"func":1
},
{
"ref":"hikari.impl.event_manager_base.EventManagerBase.wait_for",
"url":74,
"doc":"Wait for a given event to occur once, then return the event. Parameters      event_type : typing.Type[hikari.events.base_events.Event] The event type to listen for. This will listen for subclasses of this type additionally. predicate A function taking the event as the single parameter. This should return  builtins.True if the event is one you want to return, or  builtins.False if the event should not be returned. If left as  None (the default), then the first matching event type that the bot receives (or any subtype) will be the one returned.  ! warn ASYNC PREDICATES ARE NOT SUPPORTED. timeout : typing.Union[builtins.float, builtins.int, builtins.None] The amount of time to wait before raising an  asyncio.TimeoutError and giving up instead. This is measured in seconds. If  builtins.None , then no timeout will be waited for (no timeout can result in \"leaking\" of coroutines that never complete if called in an uncontrolled way, so is not recommended). Returns    - hikari.events.base_events.Event The event that was provided. Raises    asyncio.TimeoutError If the timeout is not  builtins.None and is reached before an event is received that the predicate returns  builtins.True for. See Also     Listen:  hikari.api.event_dispatcher.EventDispatcher.listen Stream:  hikari.api.event_dispatcher.EventDispatcher.stream Subscribe:  hikari.api.event_dispatcher.EventDispatcher.subscribe Dispatch:  hikari.api.event_dispatcher.EventDispatcher.dispatch ",
"func":1
},
{
"ref":"hikari.impl.shard",
"url":78,
"doc":"Single-shard implementation for the V8 event gateway for Discord."
},
{
"ref":"hikari.impl.shard.GatewayShardImpl",
"url":78,
"doc":"Implementation of a V6 and V7 compatible gateway. Parameters      compression : typing.Optional[buitlins.str] Compression format to use for the shard. Only supported values are  \"payload_zlib_stream\" or  builtins.None to disable it. initial_activity : typing.Optional[hikari.presences.Activity] The initial activity to appear to have for this shard, or  builtins.None if no activity should be set initially. This is the default. initial_idle_since : typing.Optional[datetime.datetime] The datetime to appear to be idle since, or  builtins.None if the shard should not provide this. The default is  builtins.None . initial_is_afk : bool Whether to appear to be AFK or not on login. Defaults to  builtins.False . initial_status : hikari.presences.Status The initial status to set on login for the shard. Defaults to  hikari.presences.Status.ONLINE . intents : hikari.intents.Intents Collection of intents to use. Unlike on the V6 gateway, this is MANDATORY. large_threshold : builtins.int The number of members to have in a guild for it to be considered large. shard_id : builtins.int The shard ID. shard_count : builtins.int The shard count. event_consumer A non-coroutine function consuming a  GatewayShardImpl , a  builtins.str event name, and a  hikari.internal.data_binding.JSONObject event object as parameters. This should return  builtins.None , and will be called with each event that fires. http_settings : hikari.config.HTTPSettings The HTTP-related settings to use while negotiating a websocket. proxy_settings : hikari.config.ProxySettings The proxy settings to use while negotiating a websocket. data_format : builtins.str Data format to use for inbound data. Only supported format is  \"json\" . token : builtins.str The bot token to use. url : builtins.str The gateway URL to use. This should not contain a query-string or fragments.  ! note If all four of  initial_activity ,  initial_idle_since ,  initial_is_afk , and  initial_status are not defined and left to their default values, then the presence will not be _updated_ on startup at all. If any of these _are_ specified, then any that are not specified will be set to sane defaults, which may change the previous status. This will only occur during startup, and is an artifact of how Discord manages these updates internally. All other calls to update the status of the shard will support partial updates."
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.heartbeat_latency",
"url":78,
"doc":"Return the shard's most recent heartbeat latency. Returns    - builtins.float Heartbeat latency measured in seconds. If the information is not yet available, then this will be  float('nan') instead."
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.id",
"url":78,
"doc":"Return the shard ID for this shard. Returns    - builtins.int The integer 0-based shard ID."
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.intents",
"url":78,
"doc":"Return the intents set on this shard. Returns    - hikari.intents.Intents The intents being used on this shard."
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.is_alive",
"url":78,
"doc":"Return  builtins.True if the shard is alive and connected. Returns    - builtins.bool  builtins.True if connected, or  builtins.False if not."
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.shard_count",
"url":78,
"doc":"Return the total number of shards expected in the entire application. Returns    - builtins.int A number of shards greater than or equal to 1."
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.close",
"url":78,
"doc":"Close the websocket if it is connected, otherwise do nothing.",
"func":1
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.get_user_id",
"url":78,
"doc":"Return the user ID. If the shard has not connected fully yet, this should wait until the ID is set before returning. Returns    - hikari.snowflakes.Snowflake The user ID for the application user.",
"func":1
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.join",
"url":78,
"doc":"Wait for this shard to close, if running.",
"func":1
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.request_guild_members",
"url":78,
"doc":"Request for a guild chunk. Parameters      guild: hikari.guilds.Guild The guild to request chunk for. Other Parameters         include_presences: hikari.undefined.UndefinedOr[builtins.bool] If provided, whether to request presences. query: builtins.str If not    , request the members which username starts with the string. limit: builtins.int Maximum number of members to send matching the query. users: hikari.undefined.UndefinedOr[typing.Sequence[hikari.snowflakes.SnowflakeishOr[hikari.users.User ] If provided, the users to request for. nonce: hikari.undefined.UndefinedOr[builtins.str] If provided, the nonce to be sent with guild chunks.  ! note To request the full list of members, set  query to    (empty string) and  limit to  0 . Raises    ValueError When trying to specify  users with  query / limit , if  limit is not between 0 and 100, both inclusive or if  users length is over 100. hikari.errors.MissingIntentError When trying to request presences without the  GUILD_MEMBERS or when trying to request the full list of members without  GUILD_PRESENCES .",
"func":1
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.start",
"url":78,
"doc":"Start the shard, wait for it to become ready.",
"func":1
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.update_presence",
"url":78,
"doc":"Update the presence of the shard user. If the shard is not alive, no physical data will be sent, however, the new presence settings will be remembered for when the shard does connect. Other Parameters         idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed. afk : hikari.undefined.UndefinedOr[builtins.bool] If  builtins.True , the user is marked as AFK. If  builtins.False , the user is marked as being active. If undefined, this will not be changed. activity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed. status : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed.",
"func":1
},
{
"ref":"hikari.impl.shard.GatewayShardImpl.update_voice_state",
"url":78,
"doc":"Update the voice state for this shard in a given guild. Parameters      guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild] The guild or guild ID to update the voice state for. channel : typing.Optional[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel The channel or channel ID to update the voice state for. If  builtins.None then the bot will leave the voice channel that it is in for the given guild. self_mute : builtins.bool If  builtins.True , the bot will mute itself in that voice channel. If  builtins.False , then it will unmute itself. self_deaf : builtins.bool If  builtins.True , the bot will deafen itself in that voice channel. If  builtins.False , then it will undeafen itself.",
"func":1
},
{
"ref":"hikari.emojis",
"url":17,
"doc":"Application and entities that are used to describe emojis on Discord."
},
{
"ref":"hikari.emojis.Emoji",
"url":17,
"doc":"Base class for all emojis. Any emoji implementation supports being used as a  hikari.files.Resource when uploading an attachment to the API. This is achieved in the same way as using a  hikari.files.WebResource would achieve this. Method generated by attrs for class Emoji."
},
{
"ref":"hikari.emojis.Emoji.name",
"url":17,
"doc":"Return the generic name/representation for this emoji."
},
{
"ref":"hikari.emojis.Emoji.url",
"url":17,
"doc":"URL of the emoji image to display in clients."
},
{
"ref":"hikari.emojis.Emoji.url_name",
"url":17,
"doc":"Name of the part of the emoji to use in requests."
},
{
"ref":"hikari.emojis.Emoji.is_mentionable",
"url":17,
"doc":"Whether the emoji can be mentioned or not."
},
{
"ref":"hikari.emojis.Emoji.mention",
"url":17,
"doc":"Mention string to use to mention the emoji with."
},
{
"ref":"hikari.emojis.Emoji.parse",
"url":17,
"doc":"Parse a given string into an emoji object. Parameters      string : builtins.str The emoji object to parse. Returns    - Emoji The parsed emoji object. This will be a  CustomEmoji if a custom emoji ID or mention, or a  UnicodeEmoji otherwise. Raises    builtins.ValueError If a mention is given that has an invalid format.",
"func":1
},
{
"ref":"hikari.emojis.Emoji.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.emojis.Emoji.filename",
"url":2,
"doc":"Filename of the resource."
},
{
"ref":"hikari.emojis.Emoji.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.emojis.Emoji.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.emojis.UnicodeEmoji",
"url":17,
"doc":"Represents a unicode emoji.  ! warning A word of warning if you try to upload this emoji as a file attachment. While this emoji type can be used to upload the Twemoji representations of this emoji as a PNG, this is NOT foolproof. The mapping between Discord's implementation and official Twemoji bindings is very flaky. Responsible implementations relying on this behaviour will be implemented to expect this behaviour in the form of  hikari.errors.NotFoundError exceptions being raised when a mismatch may occur. It is also likely that this will change in the future without notice, so you will likely be relying on flaky behaviour. If this is proven to be too unstable, this functionality will be removed in a future release after a deprecation period. Method generated by attrs for class UnicodeEmoji."
},
{
"ref":"hikari.emojis.UnicodeEmoji.url_name",
"url":17,
"doc":"Name of the part of the emoji to use in requests."
},
{
"ref":"hikari.emojis.UnicodeEmoji.mention",
"url":17,
"doc":"Mention string to use to mention the emoji with."
},
{
"ref":"hikari.emojis.UnicodeEmoji.codepoints",
"url":17,
"doc":"Integer codepoints that make up this emoji, as UTF-8."
},
{
"ref":"hikari.emojis.UnicodeEmoji.filename",
"url":17,
"doc":"Filename to use if re-uploading this emoji's PNG."
},
{
"ref":"hikari.emojis.UnicodeEmoji.url",
"url":17,
"doc":"Get the URL of the PNG rendition of this emoji. This will use the official Twitter \"twemoji\" repository to fetch this information, as Discord only stores this in a hashed format that uses SVG files, which is not usually of any use. Since this uses \"twemoji\" directly, the emojis may not directly match what is on Discord if Discord have failed to keep their emoji packs up-to-date with this repository. Example    - https: github.com/twitter/twemoji/raw/master/assets/72x72/1f004.png"
},
{
"ref":"hikari.emojis.UnicodeEmoji.unicode_names",
"url":17,
"doc":"Get the unicode name of the emoji as a sequence. This returns the name of each codepoint. If only one codepoint exists, then this will only have one item in the resulting sequence."
},
{
"ref":"hikari.emojis.UnicodeEmoji.unicode_escape",
"url":17,
"doc":"Get the unicode escape string for this emoji."
},
{
"ref":"hikari.emojis.UnicodeEmoji.parse_codepoints",
"url":17,
"doc":"Create a unicode emoji from one or more UTF-32 codepoints.",
"func":1
},
{
"ref":"hikari.emojis.UnicodeEmoji.parse_unicode_escape",
"url":17,
"doc":"Create a unicode emoji from a unicode escape string.",
"func":1
},
{
"ref":"hikari.emojis.UnicodeEmoji.parse",
"url":17,
"doc":"Parse a given string into a unicode emoji object. Parameters      string : builtins.str The emoji object to parse. Returns    - UnicodeEmoji The parsed UnicodeEmoji object.",
"func":1
},
{
"ref":"hikari.emojis.UnicodeEmoji.name",
"url":17,
"doc":"The code points that form the emoji."
},
{
"ref":"hikari.emojis.UnicodeEmoji.is_mentionable",
"url":17,
"doc":"Whether the emoji can be mentioned or not."
},
{
"ref":"hikari.emojis.UnicodeEmoji.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.emojis.UnicodeEmoji.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.emojis.UnicodeEmoji.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.emojis.CustomEmoji",
"url":17,
"doc":"Represents a custom emoji. This is a custom emoji that is from a guild you might not be part of. All CustomEmoji objects and their derivatives act as valid  hikari.files.Resource objects. This means you can use them as a file when sending a message. >>> emojis = await bot.rest.fetch_guild_emojis(12345) >>> picks = random.choices(emojis, 5) >>> await event.reply(files=picks)  ! warning Discord will not provide information on whether these emojis are animated or not when a reaction is removed and an event is fired. This is problematic if you need to try and determine the emoji that was removed. The side effect of this means that mentions for animated emojis will not be correct. This will not be changed as stated here: https: github.com/discord/discord-api-docs/issues/1614 issuecomment-628548913 Method generated by attrs for class CustomEmoji."
},
{
"ref":"hikari.emojis.CustomEmoji.filename",
"url":17,
"doc":"Filename of the resource."
},
{
"ref":"hikari.emojis.CustomEmoji.url_name",
"url":17,
"doc":"Name of the part of the emoji to use in requests."
},
{
"ref":"hikari.emojis.CustomEmoji.mention",
"url":17,
"doc":"Mention string to use to mention the emoji with."
},
{
"ref":"hikari.emojis.CustomEmoji.is_mentionable",
"url":17,
"doc":"Whether the emoji can be mentioned or not."
},
{
"ref":"hikari.emojis.CustomEmoji.url",
"url":17,
"doc":"URL of the emoji image to display in clients."
},
{
"ref":"hikari.emojis.CustomEmoji.parse",
"url":17,
"doc":"Parse a given string into an emoji object. Parameters      string : builtins.str The emoji object to parse. Returns    - Emoji The parsed emoji object. This will be a  CustomEmoji if a custom emoji ID or mention, or a  UnicodeEmoji otherwise. Raises    builtins.ValueError If a mention is given that has an invalid format.",
"func":1
},
{
"ref":"hikari.emojis.CustomEmoji.id",
"url":17,
"doc":"The ID of this entity."
},
{
"ref":"hikari.emojis.CustomEmoji.is_animated",
"url":17,
"doc":"Whether the emoji is animated. Will be  builtins.None when received in Message Reaction Remove and Message Reaction Remove Emoji events."
},
{
"ref":"hikari.emojis.CustomEmoji.name",
"url":17,
"doc":"The name of the emoji."
},
{
"ref":"hikari.emojis.CustomEmoji.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.emojis.CustomEmoji.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.emojis.CustomEmoji.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.emojis.CustomEmoji.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.emojis.KnownCustomEmoji",
"url":17,
"doc":"Represents an emoji that is known from a guild the bot is in. This is a specialization of  CustomEmoji that is from a guild that you _are_ part of. As a result, it contains a lot more information with it. Method generated by attrs for class KnownCustomEmoji."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.app",
"url":17,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.guild_id",
"url":17,
"doc":"The ID of the guild this emoji belongs to."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.is_animated",
"url":17,
"doc":"Whether the emoji is animated. Unlike in  CustomEmoji , this information is always known, and will thus never be  builtins.None ."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.is_available",
"url":17,
"doc":"Whether this emoji can currently be used. May be  builtins.False due to a loss of Sever Boosts on the emoji's guild."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.is_colons_required",
"url":17,
"doc":"Whether this emoji must be wrapped in colons."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.is_managed",
"url":17,
"doc":"Whether the emoji is managed by an integration."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.role_ids",
"url":17,
"doc":"The IDs of the roles that are whitelisted to use this emoji. If this is empty then any user can use this emoji regardless of their roles."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.user",
"url":17,
"doc":"The user that created the emoji.  ! note This will be  builtins.None if you are missing the  MANAGE_EMOJIS permission in the server the emoji is from."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.filename",
"url":17,
"doc":"Filename of the resource."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.url_name",
"url":17,
"doc":"Name of the part of the emoji to use in requests."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.mention",
"url":17,
"doc":"Mention string to use to mention the emoji with."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.is_mentionable",
"url":17,
"doc":"Whether the emoji can be mentioned or not."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.url",
"url":17,
"doc":"URL of the emoji image to display in clients."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.parse",
"url":17,
"doc":"Parse a given string into an emoji object. Parameters      string : builtins.str The emoji object to parse. Returns    - Emoji The parsed emoji object. This will be a  CustomEmoji if a custom emoji ID or mention, or a  UnicodeEmoji otherwise. Raises    builtins.ValueError If a mention is given that has an invalid format.",
"func":1
},
{
"ref":"hikari.emojis.KnownCustomEmoji.id",
"url":17,
"doc":"The ID of this entity."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.name",
"url":17,
"doc":"The name of the emoji."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.stream",
"url":2,
"doc":"Start streaming the content into memory by downloading it. You can use this to fetch the entire resource, parts of the resource, or just to view any metadata that may be provided. Parameters      executor : typing.Optional[concurrent.futures.Executor] Not used. Provided only to match the underlying interface. head_only : builtins.bool Defaults to  builtins.False . If  builtins.True , then the implementation may only retrieve HEAD information if supported. This currently only has any effect for web requests. Examples     Downloading an entire resource at once into memory:   async with obj.stream() as stream: data = await stream.read()   Checking the metadata:   async with obj.stream() as stream: mimetype = stream.mimetype if mimetype is None:  . elif mimetype not in whitelisted_mimetypes:  . else:  .   Fetching the data-uri of a resource:   async with obj.stream() as stream: data_uri = await stream.data_uri()   Returns    - AsyncReaderContextManager[WebReader] An async context manager that when entered, produces the data stream. Raises    hikari.errors.BadRequestError If a 400 is returned. hikari.errors.UnauthorizedError If a 401 is returned. hikari.errors.ForbiddenError If a 403 is returned. hikari.errors.NotFoundError If a 404 is returned. hikari.errors.ClientHTTPResponseError If any other 4xx is returned. hikari.errors.InternalServerError If any other 5xx is returned. hikari.errors.HTTPResponseError If any other unexpected response code is returned.",
"func":1
},
{
"ref":"hikari.emojis.KnownCustomEmoji.extension",
"url":2,
"doc":"File extension, if there is one."
},
{
"ref":"hikari.emojis.KnownCustomEmoji.read",
"url":2,
"doc":"Read the entire resource at once into memory.   data = await resource.read( .)  ^ This is a shortcut for the following  v async with resource.stream( .) as reader: data = await reader.read()    ! warning If you simply wish to re-upload this resource to Discord via any endpoint in Hikari, you should opt to just pass this resource object directly. This way, Hikari can perform byte inception, which significantly reduces the memory usage for your bot as it grows larger. Parameters      executor : typing.Optional[concurrent.futures.Executor] The executor to run in for blocking operations. If  builtins.None , then the default executor is used for the current event loop. Returns    - builtins.bytes The entire resource.",
"func":1
},
{
"ref":"hikari.emojis.Emojiish",
"url":17,
"doc":"Type hint representing a string emoji or an  Emoji -derived object. Examples include: - Unicode emoji strings, such as  \"\ud83d\udc4c\" ,  \"\\N{OK HAND SIGN}\" ,  \"\\U0001f44c\" . - Custom emoji names in the format  name:id , such as  \"rosaThonk:733073048646713364\" . - Derivative instances of  Emoji , i.e.  UnicodeEmoji ,  CustomEmoji and  KnownCustomEmoji ."
},
{
"ref":"hikari.voices",
"url":79,
"doc":"Application and entities that are used to describe voice state on Discord."
},
{
"ref":"hikari.voices.VoiceRegion",
"url":79,
"doc":"Represents a voice region server. Method generated by attrs for class VoiceRegion."
},
{
"ref":"hikari.voices.VoiceRegion.id",
"url":79,
"doc":"The string ID of this region.  ! note Unlike most parts of this API, this ID will always be a string type. This is intentional."
},
{
"ref":"hikari.voices.VoiceRegion.is_custom",
"url":79,
"doc":"Whether this region is custom (e.g. used for events)."
},
{
"ref":"hikari.voices.VoiceRegion.is_deprecated",
"url":79,
"doc":"Whether this region is deprecated."
},
{
"ref":"hikari.voices.VoiceRegion.is_optimal_location",
"url":79,
"doc":"Whether this region's server is closest to the current user's client."
},
{
"ref":"hikari.voices.VoiceRegion.is_vip",
"url":79,
"doc":"Whether this region is vip-only."
},
{
"ref":"hikari.voices.VoiceRegion.name",
"url":79,
"doc":"The name of this region."
},
{
"ref":"hikari.voices.VoiceState",
"url":79,
"doc":"Represents a user's voice connection status. Method generated by attrs for class VoiceState."
},
{
"ref":"hikari.voices.VoiceState.app",
"url":79,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.voices.VoiceState.channel_id",
"url":79,
"doc":"The ID of the channel this user is connected to. This will be  builtins.None if they are leaving voice."
},
{
"ref":"hikari.voices.VoiceState.guild_id",
"url":79,
"doc":"The ID of the guild this voice state is in."
},
{
"ref":"hikari.voices.VoiceState.is_guild_deafened",
"url":79,
"doc":"Whether this user is deafened by the guild."
},
{
"ref":"hikari.voices.VoiceState.is_guild_muted",
"url":79,
"doc":"Whether this user is muted by the guild."
},
{
"ref":"hikari.voices.VoiceState.is_self_deafened",
"url":79,
"doc":"Whether this user is deafened by their client."
},
{
"ref":"hikari.voices.VoiceState.is_self_muted",
"url":79,
"doc":"Whether this user is muted by their client."
},
{
"ref":"hikari.voices.VoiceState.is_streaming",
"url":79,
"doc":"Whether this user is streaming using \"Go Live\"."
},
{
"ref":"hikari.voices.VoiceState.is_suppressed",
"url":79,
"doc":"Whether this user is muted by the current user."
},
{
"ref":"hikari.voices.VoiceState.is_video_enabled",
"url":79,
"doc":"Whether this user's camera is enabled."
},
{
"ref":"hikari.voices.VoiceState.member",
"url":79,
"doc":"The guild member this voice state is for."
},
{
"ref":"hikari.voices.VoiceState.session_id",
"url":79,
"doc":"The string ID of this voice state's session."
},
{
"ref":"hikari.voices.VoiceState.user_id",
"url":79,
"doc":"The ID of the user this voice state is for."
},
{
"ref":"hikari.voices.VoiceRegionish",
"url":79,
"doc":"Type hint for a voice region or name of a voice region. Must be either a  VoiceRegion or  builtins.str ."
},
{
"ref":"hikari.iterators",
"url":8,
"doc":"Lazy iterators for data that requires repeated API calls to retrieve. For consumers of this API, the only class you need to worry about is  LazyIterator . Everything else is internal detail only exposed for people who wish to extend this API further!"
},
{
"ref":"hikari.iterators.LazyIterator",
"url":8,
"doc":"A set of results that are fetched asynchronously from the API as needed. This is a  typing.AsyncIterable and  typing.AsyncIterator with several additional helpful methods provided for convenience. Examples     You can use this in multiple ways. As an async iterable:   >>> async for item in paginated_results:  . process(item)   As an eagerly retrieved set of results (performs all API calls at once, which may be slow for large sets of data):   >>> results = await paginated_results >>>   . which is equivalent to this . >>> results = [item async for item in paginated_results]   As an async iterator (not recommended):   >>> try:  . while True:  . process(await paginated_results.__anext__(  . except StopAsyncIteration:  . pass   Additionally, you can make use of some of the provided helper methods on this class to perform basic operations easily. Iterating across the items with indexes (like  builtins.enumerate for normal iterables):   >>> async for i, item in paginated_results.enumerate():  . print(i, item) (0, foo) (1, bar) (2, baz)   Limiting the number of results you iterate across:   >>> async for item in paginated_results.limit(3):  . process(item)  "
},
{
"ref":"hikari.iterators.LazyIterator.chunk",
"url":8,
"doc":"Return results in chunks of up to  chunk_size amount of entries. Parameters      chunk_size : int The limit for how many results should be returned in each chunk. Returns    - LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.map",
"url":8,
"doc":"Map the values to a different value. Parameters      transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the  . operator. Returns    - LazyIterator[AnotherValueT]  LazyIterator that maps each value to another value.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.for_each",
"url":8,
"doc":"Pass each value to a given consumer immediately.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.filter",
"url":8,
"doc":"Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item that this iterator would return when it is requested. All conditions must evaluate to  builtins.True for the item to be returned. If this is not met, then the item is discared and ignored, the next matching item will be returned instead, if there is one. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.filter \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT]  LazyIterator that only emits values where all conditions are matched.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.take_while",
"url":8,
"doc":"Return each item until any conditions fail or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.take_until",
"url":8,
"doc":"Return each item until any conditions pass or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.skip_while",
"url":8,
"doc":"Discard items while all conditions are True. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.skip_until",
"url":8,
"doc":"Discard items while all conditions are False. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.enumerate",
"url":8,
"doc":"Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of  builtins.enumerate which uses much less memory than collecting all the results first and calling  builtins.enumerate across them. Parameters      start : builtins.int Optional int to start at. If omitted, this is  0 . Examples     >>> async for i, item in paginated_results.enumerate():  . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9):  . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3):  . print(i, item) (9, foo) (10, bar) (11, baz) Returns    - LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.limit",
"url":8,
"doc":"Limit the number of items you receive from this async iterator. Parameters      limit : builtins.int The number of items to get. This must be greater than zero. Examples     >>> async for item in paginated_results.limit(3):  . print(item) Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.skip",
"url":8,
"doc":"Drop the given number of items, then yield anything after. Parameters      number : builtins.int The max number of items to drop before any items are yielded. Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.next",
"url":8,
"doc":"Return the next element of this iterator only. Returns    - ValueT The next result. Raises    builtins.LookupError If no more results exist.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.last",
"url":8,
"doc":"Return the last element of this iterator only. Returns    - ValueT The last result.  ! note This method will consume the whole iterator if run. Raises    builtins.LookupError If no result exists.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.reversed",
"url":8,
"doc":"Return a lazy iterator of the remainder of this iterator's values reversed. Returns    - LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.sort",
"url":8,
"doc":"Collect all results, then sort the collection before returning it.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.collect",
"url":8,
"doc":"Collect the results into a given type and return it. Parameters      collector A function that consumes a sequence of values and returns a collection.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.count",
"url":8,
"doc":"Count the number of results. Returns    - builtins.int Number of results found.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.flat_map",
"url":8,
"doc":"Perform a flat mapping operation. This will pass each item in the iterator to the given  function parameter, expecting a new  typing.Iterable or  typing.AsyncIterator to be returned as the result. This means you can map to a new  LazyIterator ,  typing.AsyncIterator ,  typing.Iterable , async generator, or generator. Remember that  typing.Iterator implicitly provides  typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement reactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded lazily. Parameters      flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example    - The following example generates a distinct collection of all mentioned users in the given channel from the past 500 messages.   def iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\" \", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct() )   Returns    - LazyIterator[AnotherValueT] The new lazy iterator to return.",
"func":1
},
{
"ref":"hikari.iterators.LazyIterator.awaiting",
"url":8,
"doc":"Await each item concurrently in a fixed size window. Parameters      window_size : int The window size of how many tasks to await at once. You can set this to  0 to await everything at once, but see the below warning. Returns    - LazyIterator[ValueT] The new lazy iterator to return.  ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the  fetch_user endpoint seems to be notorious for doing this).  ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a  builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator",
"url":8,
"doc":"A lazy iterator that has all items in-memory and ready. This can be iterated across as a normal iterator, or as an async iterator."
},
{
"ref":"hikari.iterators.FlatLazyIterator.chunk",
"url":8,
"doc":"Return results in chunks of up to  chunk_size amount of entries. Parameters      chunk_size : int The limit for how many results should be returned in each chunk. Returns    - LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.map",
"url":8,
"doc":"Map the values to a different value. Parameters      transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the  . operator. Returns    - LazyIterator[AnotherValueT]  LazyIterator that maps each value to another value.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.for_each",
"url":8,
"doc":"Pass each value to a given consumer immediately.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.filter",
"url":8,
"doc":"Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item that this iterator would return when it is requested. All conditions must evaluate to  builtins.True for the item to be returned. If this is not met, then the item is discared and ignored, the next matching item will be returned instead, if there is one. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.filter \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT]  LazyIterator that only emits values where all conditions are matched.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.take_while",
"url":8,
"doc":"Return each item until any conditions fail or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.take_until",
"url":8,
"doc":"Return each item until any conditions pass or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.skip_while",
"url":8,
"doc":"Discard items while all conditions are True. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.skip_until",
"url":8,
"doc":"Discard items while all conditions are False. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.enumerate",
"url":8,
"doc":"Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of  builtins.enumerate which uses much less memory than collecting all the results first and calling  builtins.enumerate across them. Parameters      start : builtins.int Optional int to start at. If omitted, this is  0 . Examples     >>> async for i, item in paginated_results.enumerate():  . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9):  . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3):  . print(i, item) (9, foo) (10, bar) (11, baz) Returns    - LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.limit",
"url":8,
"doc":"Limit the number of items you receive from this async iterator. Parameters      limit : builtins.int The number of items to get. This must be greater than zero. Examples     >>> async for item in paginated_results.limit(3):  . print(item) Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.skip",
"url":8,
"doc":"Drop the given number of items, then yield anything after. Parameters      number : builtins.int The max number of items to drop before any items are yielded. Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.next",
"url":8,
"doc":"Return the next element of this iterator only. Returns    - ValueT The next result. Raises    builtins.LookupError If no more results exist.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.last",
"url":8,
"doc":"Return the last element of this iterator only. Returns    - ValueT The last result.  ! note This method will consume the whole iterator if run. Raises    builtins.LookupError If no result exists.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.reversed",
"url":8,
"doc":"Return a lazy iterator of the remainder of this iterator's values reversed. Returns    - LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.sort",
"url":8,
"doc":"Collect all results, then sort the collection before returning it.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.collect",
"url":8,
"doc":"Collect the results into a given type and return it. Parameters      collector A function that consumes a sequence of values and returns a collection.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.count",
"url":8,
"doc":"Count the number of results. Returns    - builtins.int Number of results found.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.flat_map",
"url":8,
"doc":"Perform a flat mapping operation. This will pass each item in the iterator to the given  function parameter, expecting a new  typing.Iterable or  typing.AsyncIterator to be returned as the result. This means you can map to a new  LazyIterator ,  typing.AsyncIterator ,  typing.Iterable , async generator, or generator. Remember that  typing.Iterator implicitly provides  typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement reactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded lazily. Parameters      flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example    - The following example generates a distinct collection of all mentioned users in the given channel from the past 500 messages.   def iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\" \", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct() )   Returns    - LazyIterator[AnotherValueT] The new lazy iterator to return.",
"func":1
},
{
"ref":"hikari.iterators.FlatLazyIterator.awaiting",
"url":8,
"doc":"Await each item concurrently in a fixed size window. Parameters      window_size : int The window size of how many tasks to await at once. You can set this to  0 to await everything at once, but see the below warning. Returns    - LazyIterator[ValueT] The new lazy iterator to return.  ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the  fetch_user endpoint seems to be notorious for doing this).  ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a  builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.",
"func":1
},
{
"ref":"hikari.iterators.All",
"url":8,
"doc":"Helper that wraps predicates and invokes them together. Calling this object will pass the input item to each item, returning  builtins.True only when all wrapped predicates return True when called with the given item. For example .   if w(foo) and x(foo) andy(foo) and z(foo):  .   is equivalent to   condition = All([w, x, y, z]) if condition(foo):  .   This behaves like a lazy wrapper implementation of the  builtins.all builtin.  ! note Like the rest of the standard library, this is a short-circuiting operation. This means that if a predicate returns  builtins.False , no predicates after this are invoked, as the result is already known. In this sense, they are invoked in-order.  ! warning You should not generally need to use this outside of extending the iterators API in this library! Operators     -   this(value : ValueT) -> bool : Return  builtins.True if all conditions return  builtins.True when invoked with the given value.   ~this : Return a condition that, when invoked with the value, returns  builtins.False if all conditions were  builtins.True in this object. Parameters       conditions : typing.Callable ValueT], builtins.bool] The predicates to wrap."
},
{
"ref":"hikari.iterators.All.conditions",
"url":8,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.iterators.AttrComparator",
"url":8,
"doc":"A comparator that compares the result of a call with something else. This uses the  spel module internally. Parameters      attr_name : builtins.str The attribute name. Can be prepended with a  . optionally. If the attribute name ends with a  () , then the call is invoked rather than treated as a property (useful for methods like  str.isupper , for example). expected_value : typing.Any The expected value. cast : typing.Optional[typing.Callable ValueT], typing.Any Optional cast to perform on the input value when being called before comparing it to the expected value but after accessing the attribute."
},
{
"ref":"hikari.iterators.AttrComparator.attr_getter",
"url":8,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.iterators.AttrComparator.cast",
"url":8,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.iterators.AttrComparator.expected_value",
"url":8,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.iterators.BufferedLazyIterator",
"url":8,
"doc":"A special kind of lazy iterator that is used by internal components. The purpose of this is to provide an interface to lazily deserialize collections of payloads received from paginated API endpoints such as  GET /channels/{channel_id}/messages , which will return a certain number of messages at a time on a low level. This class provides the base interface for handling lazily decoding each item in those responses and returning them in the expected format when iterating across this object. Implementations are expected to provide a  _next_chunk private method which when awaited returns a lazy generator of each deserialized object to later yield. This will be iterated across lazily by this implementation, thus reducing the amount of work needed if only a few objects out of, say, 100, need to be deserialized. This  _next_chunk should return  builtins.None once the end of all items has been reached. An example would look like the following:   async def some_http_call(i):  . class SomeEndpointLazyIterator(BufferedLazyIterator[SomeObject]): def __init__(self): super().__init__() self._i = 0 def _next_chunk(self) -> typing.Optional[typing.Generator[ValueT, None, None : raw_items = await some_http_call(self._i) self._i += 1 if not raw_items: return None generator = (SomeObject(raw_item) for raw_item in raw_items) return generator  "
},
{
"ref":"hikari.iterators.BufferedLazyIterator.chunk",
"url":8,
"doc":"Return results in chunks of up to  chunk_size amount of entries. Parameters      chunk_size : int The limit for how many results should be returned in each chunk. Returns    - LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.map",
"url":8,
"doc":"Map the values to a different value. Parameters      transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the  . operator. Returns    - LazyIterator[AnotherValueT]  LazyIterator that maps each value to another value.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.for_each",
"url":8,
"doc":"Pass each value to a given consumer immediately.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.filter",
"url":8,
"doc":"Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item that this iterator would return when it is requested. All conditions must evaluate to  builtins.True for the item to be returned. If this is not met, then the item is discared and ignored, the next matching item will be returned instead, if there is one. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.filter \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT]  LazyIterator that only emits values where all conditions are matched.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.take_while",
"url":8,
"doc":"Return each item until any conditions fail or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.take_until",
"url":8,
"doc":"Return each item until any conditions pass or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.skip_while",
"url":8,
"doc":"Discard items while all conditions are True. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.skip_until",
"url":8,
"doc":"Discard items while all conditions are False. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.enumerate",
"url":8,
"doc":"Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of  builtins.enumerate which uses much less memory than collecting all the results first and calling  builtins.enumerate across them. Parameters      start : builtins.int Optional int to start at. If omitted, this is  0 . Examples     >>> async for i, item in paginated_results.enumerate():  . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9):  . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3):  . print(i, item) (9, foo) (10, bar) (11, baz) Returns    - LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.limit",
"url":8,
"doc":"Limit the number of items you receive from this async iterator. Parameters      limit : builtins.int The number of items to get. This must be greater than zero. Examples     >>> async for item in paginated_results.limit(3):  . print(item) Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.skip",
"url":8,
"doc":"Drop the given number of items, then yield anything after. Parameters      number : builtins.int The max number of items to drop before any items are yielded. Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.next",
"url":8,
"doc":"Return the next element of this iterator only. Returns    - ValueT The next result. Raises    builtins.LookupError If no more results exist.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.last",
"url":8,
"doc":"Return the last element of this iterator only. Returns    - ValueT The last result.  ! note This method will consume the whole iterator if run. Raises    builtins.LookupError If no result exists.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.reversed",
"url":8,
"doc":"Return a lazy iterator of the remainder of this iterator's values reversed. Returns    - LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.sort",
"url":8,
"doc":"Collect all results, then sort the collection before returning it.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.collect",
"url":8,
"doc":"Collect the results into a given type and return it. Parameters      collector A function that consumes a sequence of values and returns a collection.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.count",
"url":8,
"doc":"Count the number of results. Returns    - builtins.int Number of results found.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.flat_map",
"url":8,
"doc":"Perform a flat mapping operation. This will pass each item in the iterator to the given  function parameter, expecting a new  typing.Iterable or  typing.AsyncIterator to be returned as the result. This means you can map to a new  LazyIterator ,  typing.AsyncIterator ,  typing.Iterable , async generator, or generator. Remember that  typing.Iterator implicitly provides  typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement reactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded lazily. Parameters      flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example    - The following example generates a distinct collection of all mentioned users in the given channel from the past 500 messages.   def iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\" \", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct() )   Returns    - LazyIterator[AnotherValueT] The new lazy iterator to return.",
"func":1
},
{
"ref":"hikari.iterators.BufferedLazyIterator.awaiting",
"url":8,
"doc":"Await each item concurrently in a fixed size window. Parameters      window_size : int The window size of how many tasks to await at once. You can set this to  0 to await everything at once, but see the below warning. Returns    - LazyIterator[ValueT] The new lazy iterator to return.  ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the  fetch_user endpoint seems to be notorious for doing this).  ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a  builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.",
"func":1
},
{
"ref":"hikari.iterators.ValueT",
"url":8,
"doc":"Type-hint of the type of the value returned by a lazy iterator."
},
{
"ref":"hikari.iterators.AnotherValueT",
"url":8,
"doc":"Type-hint of the type of a value by a mapped lazy iterator."
},
{
"ref":"hikari.invites",
"url":16,
"doc":"Application and entities that are used to describe invites on Discord."
},
{
"ref":"hikari.invites.TargetUserType",
"url":16,
"doc":"The reason a invite targets a user."
},
{
"ref":"hikari.invites.TargetUserType.name",
"url":16,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.invites.TargetUserType.value",
"url":16,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.invites.TargetUserType.STREAM",
"url":16,
"doc":"This invite is targeting a \"Go Live\" stream."
},
{
"ref":"hikari.invites.VanityURL",
"url":16,
"doc":"A special case invite object, that represents a guild's vanity url. Method generated by attrs for class VanityURL."
},
{
"ref":"hikari.invites.VanityURL.app",
"url":16,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.invites.VanityURL.code",
"url":16,
"doc":"The code for this invite."
},
{
"ref":"hikari.invites.VanityURL.uses",
"url":16,
"doc":"The amount of times this invite has been used."
},
{
"ref":"hikari.invites.InviteGuild",
"url":16,
"doc":"Represents the partial data of a guild that is attached to invites. Method generated by attrs for class InviteGuild."
},
{
"ref":"hikari.invites.InviteGuild.splash_url",
"url":16,
"doc":"Splash for the guild, if set."
},
{
"ref":"hikari.invites.InviteGuild.format_splash",
"url":16,
"doc":"Generate the guild's splash image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the splash, or  builtins.None if not set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.invites.InviteGuild.banner",
"url":16,
"doc":"Banner for the guild, if set."
},
{
"ref":"hikari.invites.InviteGuild.format_banner",
"url":16,
"doc":"Generate the guild's banner image, if set. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg and  webp . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL of the banner, or  builtins.None if no banner is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.invites.InviteGuild.banner_hash",
"url":16,
"doc":"The hash for the guild's banner. This is only present if  hikari.guilds.GuildFeature.BANNER is in the  features for this guild. For all other purposes, it is  builtins.None ."
},
{
"ref":"hikari.invites.InviteGuild.description",
"url":16,
"doc":"The guild's description. This is only present if certain  features are set in this guild. Otherwise, this will always be  builtins.None . For all other purposes, it is  builtins.None ."
},
{
"ref":"hikari.invites.InviteGuild.splash_hash",
"url":16,
"doc":"The hash of the splash for the guild, if there is one."
},
{
"ref":"hikari.invites.InviteGuild.vanity_url_code",
"url":16,
"doc":"The vanity URL code for the guild's vanity URL. This is only present if  hikari.guilds.GuildFeature.VANITY_URL is in the  features for this guild. If not, this will always be  builtins.None ."
},
{
"ref":"hikari.invites.InviteGuild.verification_level",
"url":16,
"doc":"The verification level required for a user to participate in this guild."
},
{
"ref":"hikari.invites.InviteGuild.icon_url",
"url":15,
"doc":"Icon for the guild, if set; otherwise  builtins.None ."
},
{
"ref":"hikari.invites.InviteGuild.shard_id",
"url":15,
"doc":"Return the ID of the shard this guild is served by. This may return  None if the application does not have a gateway connection."
},
{
"ref":"hikari.invites.InviteGuild.format_icon",
"url":15,
"doc":"Generate the guild's icon, if set. Parameters      ext : typing.Optional[builtins.str] The extension to use for this URL, defaults to  png or  gif . Supports  png ,  jpeg ,  jpg ,  webp and  gif (when animated). If  builtins.None , then the correct default extension is determined based on whether the icon is animated or not. size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Returns    - typing.Optional[hikari.files.URL] The URL to the resource, or  builtins.None if no icon is set. Raises    builtins.ValueError If  size is not a power of two or not between 16 and 4096.",
"func":1
},
{
"ref":"hikari.invites.InviteGuild.app",
"url":15,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.invites.InviteGuild.features",
"url":15,
"doc":"A list of the features in this guild."
},
{
"ref":"hikari.invites.InviteGuild.icon_hash",
"url":15,
"doc":"The hash for the guild icon, if there is one."
},
{
"ref":"hikari.invites.InviteGuild.id",
"url":15,
"doc":"The ID of this entity."
},
{
"ref":"hikari.invites.InviteGuild.name",
"url":15,
"doc":"The name of the guild."
},
{
"ref":"hikari.invites.InviteGuild.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.invites.Invite",
"url":16,
"doc":"Represents an invite that's used to add users to a guild or group dm. Method generated by attrs for class Invite."
},
{
"ref":"hikari.invites.Invite.app",
"url":16,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.invites.Invite.approximate_active_member_count",
"url":16,
"doc":"The approximate amount of presences in this invite's guild. This is only present when  with_counts is passed as  builtins.True to the GET Invites endpoint."
},
{
"ref":"hikari.invites.Invite.approximate_member_count",
"url":16,
"doc":"The approximate amount of members in this invite's guild. This is only present when  with_counts is passed as  builtins.True to the GET Invites endpoint."
},
{
"ref":"hikari.invites.Invite.channel",
"url":16,
"doc":"The partial object of the channel this invite targets. Will be  builtins.None for invite objects that are attached to gateway events, in which case you should refer to  Invite.channel_id ."
},
{
"ref":"hikari.invites.Invite.channel_id",
"url":16,
"doc":"The ID of the channel this invite targets."
},
{
"ref":"hikari.invites.Invite.code",
"url":16,
"doc":"The code for this invite."
},
{
"ref":"hikari.invites.Invite.guild",
"url":16,
"doc":"The partial object of the guild this invite belongs to. Will be  builtins.None for group DM invites and when attached to a gateway event; for invites received over the gateway you should refer to  Invite.guild_id ."
},
{
"ref":"hikari.invites.Invite.guild_id",
"url":16,
"doc":"The ID of the guild this invite belongs to. Will be  builtins.None for group DM invites."
},
{
"ref":"hikari.invites.Invite.inviter",
"url":16,
"doc":"The object of the user who created this invite."
},
{
"ref":"hikari.invites.Invite.target_user",
"url":16,
"doc":"The object of the user who this invite targets, if set."
},
{
"ref":"hikari.invites.Invite.target_user_type",
"url":16,
"doc":"The type of user target this invite is, if applicable."
},
{
"ref":"hikari.invites.InviteWithMetadata",
"url":16,
"doc":"Extends the base  Invite object with metadata. The metadata is only returned when getting an invite with guild permissions, rather than it's code. Method generated by attrs for class InviteWithMetadata."
},
{
"ref":"hikari.invites.InviteWithMetadata.expires_at",
"url":16,
"doc":"When this invite should expire, if  InviteWithMetadata.max_age is set. If this invite doesn't have a set expiry then this will be  builtins.None ."
},
{
"ref":"hikari.invites.InviteWithMetadata.created_at",
"url":16,
"doc":"When this invite was created."
},
{
"ref":"hikari.invites.InviteWithMetadata.is_temporary",
"url":16,
"doc":"Whether this invite grants temporary membership."
},
{
"ref":"hikari.invites.InviteWithMetadata.max_age",
"url":16,
"doc":"The timedelta of how long this invite will be valid for. If set to  builtins.None then this is unlimited."
},
{
"ref":"hikari.invites.InviteWithMetadata.max_uses",
"url":16,
"doc":"The limit for how many times this invite can be used before it expires. If set to  builtins.None then this is unlimited."
},
{
"ref":"hikari.invites.InviteWithMetadata.uses",
"url":16,
"doc":"The amount of times this invite has been used."
},
{
"ref":"hikari.invites.InviteWithMetadata.app",
"url":16,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.invites.InviteWithMetadata.approximate_active_member_count",
"url":16,
"doc":"The approximate amount of presences in this invite's guild. This is only present when  with_counts is passed as  builtins.True to the GET Invites endpoint."
},
{
"ref":"hikari.invites.InviteWithMetadata.approximate_member_count",
"url":16,
"doc":"The approximate amount of members in this invite's guild. This is only present when  with_counts is passed as  builtins.True to the GET Invites endpoint."
},
{
"ref":"hikari.invites.InviteWithMetadata.channel",
"url":16,
"doc":"The partial object of the channel this invite targets. Will be  builtins.None for invite objects that are attached to gateway events, in which case you should refer to  Invite.channel_id ."
},
{
"ref":"hikari.invites.InviteWithMetadata.channel_id",
"url":16,
"doc":"The ID of the channel this invite targets."
},
{
"ref":"hikari.invites.InviteWithMetadata.code",
"url":16,
"doc":"The code for this invite."
},
{
"ref":"hikari.invites.InviteWithMetadata.guild",
"url":16,
"doc":"The partial object of the guild this invite belongs to. Will be  builtins.None for group DM invites and when attached to a gateway event; for invites received over the gateway you should refer to  Invite.guild_id ."
},
{
"ref":"hikari.invites.InviteWithMetadata.guild_id",
"url":16,
"doc":"The ID of the guild this invite belongs to. Will be  builtins.None for group DM invites."
},
{
"ref":"hikari.invites.InviteWithMetadata.inviter",
"url":16,
"doc":"The object of the user who created this invite."
},
{
"ref":"hikari.invites.InviteWithMetadata.target_user",
"url":16,
"doc":"The object of the user who this invite targets, if set."
},
{
"ref":"hikari.invites.InviteWithMetadata.target_user_type",
"url":16,
"doc":"The type of user target this invite is, if applicable."
},
{
"ref":"hikari.invites.Inviteish",
"url":16,
"doc":"Type hint for an invite, vanity URL, or invite code. This must be a representation of an invite that is a  builtins.str containing the invite code, an  Invite / InviteWithMetadata , or a  VanityURL instance."
},
{
"ref":"hikari.errors",
"url":3,
"doc":"Exceptions and warnings that can be thrown by this library."
},
{
"ref":"hikari.errors.HikariError",
"url":3,
"doc":"Base for an error raised by this API. Any exceptions should derive from this.  ! note You should never initialize this exception directly."
},
{
"ref":"hikari.errors.HikariWarning",
"url":3,
"doc":"Base for a warning raised by this API. Any warnings should derive from this.  ! note You should never initialize this warning directly."
},
{
"ref":"hikari.errors.HikariInterrupt",
"url":3,
"doc":"Exception raised when a kill signal is handled internally. Method generated by attrs for class HikariInterrupt."
},
{
"ref":"hikari.errors.HikariInterrupt.signame",
"url":3,
"doc":"The signal name that was raised."
},
{
"ref":"hikari.errors.HikariInterrupt.signum",
"url":3,
"doc":"The signal number that was raised."
},
{
"ref":"hikari.errors.NotFoundError",
"url":3,
"doc":"Raised when something is not found. Method generated by attrs for class NotFoundError."
},
{
"ref":"hikari.errors.NotFoundError.status",
"url":3,
"doc":"The HTTP status code for the response."
},
{
"ref":"hikari.errors.NotFoundError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.NotFoundError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.NotFoundError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.NotFoundError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.NotFoundError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.RateLimitedError",
"url":3,
"doc":"Raised when a non-global rate limit that cannot be handled occurs. If you receive one of these, you should NOT try again until the given time has passed, either discarding the operation you performed, or waiting until the given time has passed first. Note that it may still be valid to send requests with different attributes in them. A use case for this by Discord appears to be to stop abuse from bots that change channel names, etc, regularly. This kind of action allegedly causes a fair amount of overhead internally for Discord. In the case you encounter this, you may be able to send different requests that manipulate the same entities (in this case editing the same channel) that do not use the same collection of attributes as the previous request. Method generated by attrs for class RateLimitedError."
},
{
"ref":"hikari.errors.RateLimitedError.message",
"url":3,
"doc":"The error message."
},
{
"ref":"hikari.errors.RateLimitedError.retry_after",
"url":3,
"doc":"How many seconds to wait before you can reuse the route with the specific request."
},
{
"ref":"hikari.errors.RateLimitedError.route",
"url":3,
"doc":"The route that produced this error."
},
{
"ref":"hikari.errors.RateLimitedError.status",
"url":3,
"doc":"The HTTP status code for the response."
},
{
"ref":"hikari.errors.RateLimitedError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.RateLimitedError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.RateLimitedError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.RateLimitedError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.RateLimitTooLongError",
"url":3,
"doc":"Internal error raised if the wait for a rate limit is too long. This is similar to  asyncio.TimeoutError in the way that it is used, but this will be raised pre-emptively and immediately if the period of time needed to wait is greater than a user-defined limit. This will almost always be route-specific. If you receive this, it is unlikely that performing the same call for a different channel/guild/user will also have this rate limit. Method generated by attrs for class RateLimitTooLongError."
},
{
"ref":"hikari.errors.RateLimitTooLongError.remaining",
"url":3,
"doc":"The number of requests that are remaining in this window. This will always be  0 symbolically. Returns    - builtins.int The number of requests remaining. Always  0 ."
},
{
"ref":"hikari.errors.RateLimitTooLongError.limit",
"url":3,
"doc":"The maximum number of calls per window for this rate limit."
},
{
"ref":"hikari.errors.RateLimitTooLongError.max_retry_after",
"url":3,
"doc":"How long the client is allowed to wait for at a maximum before raising."
},
{
"ref":"hikari.errors.RateLimitTooLongError.message",
"url":3,
"doc":"The error message."
},
{
"ref":"hikari.errors.RateLimitTooLongError.period",
"url":3,
"doc":"How long the rate limit window lasts for from start to end."
},
{
"ref":"hikari.errors.RateLimitTooLongError.reset_at",
"url":3,
"doc":"UNIX timestamp of when this limit will be lifted."
},
{
"ref":"hikari.errors.RateLimitTooLongError.retry_after",
"url":3,
"doc":"How many seconds to wait before you can retry this specific request."
},
{
"ref":"hikari.errors.RateLimitTooLongError.route",
"url":3,
"doc":"The route that produced this error."
},
{
"ref":"hikari.errors.UnauthorizedError",
"url":3,
"doc":"Raised when you are not authorized to access a specific resource. Method generated by attrs for class UnauthorizedError."
},
{
"ref":"hikari.errors.UnauthorizedError.status",
"url":3,
"doc":"The HTTP status code for the response."
},
{
"ref":"hikari.errors.UnauthorizedError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.UnauthorizedError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.UnauthorizedError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.UnauthorizedError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.UnauthorizedError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ForbiddenError",
"url":3,
"doc":"Raised when you are not allowed to access a specific resource. This means you lack the permissions to do something, either because of permissions set in a guild, or because your application is not whitelisted to use a specific endpoint. Method generated by attrs for class ForbiddenError."
},
{
"ref":"hikari.errors.ForbiddenError.status",
"url":3,
"doc":"The HTTP status code for the response."
},
{
"ref":"hikari.errors.ForbiddenError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ForbiddenError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ForbiddenError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ForbiddenError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ForbiddenError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.BadRequestError",
"url":3,
"doc":"Raised when you send an invalid request somehow. Method generated by attrs for class BadRequestError."
},
{
"ref":"hikari.errors.BadRequestError.status",
"url":3,
"doc":"The HTTP status code for the response."
},
{
"ref":"hikari.errors.BadRequestError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.BadRequestError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.BadRequestError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.BadRequestError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.BadRequestError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.RESTErrorCode",
"url":3,
"doc":"Error codes provided as further info on errors returned by the REST API."
},
{
"ref":"hikari.errors.RESTErrorCode.name",
"url":3,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.errors.RESTErrorCode.value",
"url":3,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_ERROR",
"url":3,
"doc":"Error is not known."
},
{
"ref":"hikari.errors.RESTErrorCode.GENERAL_ERROR",
"url":3,
"doc":"A general error, no further info provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_APPLICATION",
"url":3,
"doc":"Unknown application provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_CHANNEL",
"url":3,
"doc":"Unknown channel provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_GUILD",
"url":3,
"doc":"Unknown guild provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_INTEGRATION",
"url":3,
"doc":"Unknown integration provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_INVITE",
"url":3,
"doc":"Unknown invite provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_MEMBER",
"url":3,
"doc":"Unknown member provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_MESSAGE",
"url":3,
"doc":"Unknown message provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_PERMISSION_OVERWRITE",
"url":3,
"doc":"Unknown permission overwrite provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_ROLE",
"url":3,
"doc":"Unknown role provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_USER",
"url":3,
"doc":"Unknown user provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_EMOJI",
"url":3,
"doc":"Unknown emoji provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_WEBHOOK",
"url":3,
"doc":"Unknown webhook provided."
},
{
"ref":"hikari.errors.RESTErrorCode.UNKNOWN_BAN",
"url":3,
"doc":"Unknown ban provided."
},
{
"ref":"hikari.errors.RESTErrorCode.ANNOUNCEMENT_LIMIT_HIT",
"url":3,
"doc":"Message can not be edited due to announcement rate limits."
},
{
"ref":"hikari.errors.RESTErrorCode.WRITE_LIMIT_HIT",
"url":3,
"doc":"The global write limit on a channel has been hit."
},
{
"ref":"hikari.errors.RESTErrorCode.MAXIMUM_GUILDS",
"url":3,
"doc":"Maximum number of guilds reached (100)."
},
{
"ref":"hikari.errors.RESTErrorCode.MAXIMUM_PINS",
"url":3,
"doc":"Maximum number of pins reached for the channel (50)."
},
{
"ref":"hikari.errors.RESTErrorCode.MAXIMUM_ROLES",
"url":3,
"doc":"Maximum number of guild roles reached (250)."
},
{
"ref":"hikari.errors.RESTErrorCode.MAXIMUM_WEBHOOKS",
"url":3,
"doc":"Maximum number of webhooks in a channel reached (10)."
},
{
"ref":"hikari.errors.RESTErrorCode.MAXIMUM_REACTIONS",
"url":3,
"doc":"Maximum number of reactions on a message reached (20)."
},
{
"ref":"hikari.errors.RESTErrorCode.MAXIMUM_CHANNELS",
"url":3,
"doc":"Maximum number of guild channels reached (500)."
},
{
"ref":"hikari.errors.RESTErrorCode.MAXIMUM_INVITES",
"url":3,
"doc":"Maximum number of invites reached (1000)."
},
{
"ref":"hikari.errors.RESTErrorCode.REQUEST_TOO_LARGE",
"url":3,
"doc":"Request too large. Try sending something smaller in size."
},
{
"ref":"hikari.errors.RESTErrorCode.TEMPORARILY_DISABLED",
"url":3,
"doc":"This feature has been temporarily disabled server-side."
},
{
"ref":"hikari.errors.RESTErrorCode.ALREADY_CROSSPOSTED",
"url":3,
"doc":"This message has already been crossposted."
},
{
"ref":"hikari.errors.RESTErrorCode.MISSING_ACCESS",
"url":3,
"doc":"Missing access."
},
{
"ref":"hikari.errors.RESTErrorCode.PROHIBITED_ON_DM",
"url":3,
"doc":"Cannot execute action on a DM channel."
},
{
"ref":"hikari.errors.RESTErrorCode.NOT_MESSAGE_AUTHOR",
"url":3,
"doc":"Cannot edit a message authored by another user."
},
{
"ref":"hikari.errors.RESTErrorCode.EMPTY_MESSAGE",
"url":3,
"doc":"Cannot send an empty message."
},
{
"ref":"hikari.errors.RESTErrorCode.USER_DM_CLOSED",
"url":3,
"doc":"Cannot send messages to this user."
},
{
"ref":"hikari.errors.RESTErrorCode.MESSAGE_IN_VC",
"url":3,
"doc":"Cannot send messages in a voice channel."
},
{
"ref":"hikari.errors.RESTErrorCode.PINS_ONLY_ON_ORIGIN_CHANNEL",
"url":3,
"doc":"A message can only be pinned to the channel it was sent in."
},
{
"ref":"hikari.errors.RESTErrorCode.PROHIBITED_ON_SYSTEM_MESSAGE",
"url":3,
"doc":"Cannot execute action on a system message."
},
{
"ref":"hikari.errors.RESTErrorCode.MESSAGE_TOO_OLD",
"url":3,
"doc":"A message provided was too old to bulk delete."
},
{
"ref":"hikari.errors.RESTErrorCode.TWO_FACTOR_AUTHENTICATION_REQUIRED",
"url":3,
"doc":"2FA is required to use this endpoint."
},
{
"ref":"hikari.errors.RESTErrorCode.SYSTEM_OVERLOADED",
"url":3,
"doc":"API resource is currently overloaded. Try again a little later."
},
{
"ref":"hikari.errors.HTTPError",
"url":3,
"doc":"Base exception raised if an HTTP error occurs while making a request. Method generated by attrs for class HTTPError."
},
{
"ref":"hikari.errors.HTTPError.message",
"url":3,
"doc":"The error message."
},
{
"ref":"hikari.errors.HTTPResponseError",
"url":3,
"doc":"Base exception for an erroneous HTTP response. Method generated by attrs for class HTTPResponseError."
},
{
"ref":"hikari.errors.HTTPResponseError.code",
"url":3,
"doc":"The error code."
},
{
"ref":"hikari.errors.HTTPResponseError.headers",
"url":3,
"doc":"The headers received in the error response."
},
{
"ref":"hikari.errors.HTTPResponseError.message",
"url":3,
"doc":"The error message."
},
{
"ref":"hikari.errors.HTTPResponseError.raw_body",
"url":3,
"doc":"The response body."
},
{
"ref":"hikari.errors.HTTPResponseError.status",
"url":3,
"doc":"The HTTP status code for the response."
},
{
"ref":"hikari.errors.HTTPResponseError.url",
"url":3,
"doc":"The URL that produced this error message."
},
{
"ref":"hikari.errors.HTTPClientClosedError",
"url":3,
"doc":"Exception raised if an  aiohttp.ClientSession was closed. This fires when using a closed  aiohttp.ClientSession to make a request. Method generated by attrs for class HTTPClientClosedError."
},
{
"ref":"hikari.errors.HTTPClientClosedError.message",
"url":3,
"doc":"The error message."
},
{
"ref":"hikari.errors.ClientHTTPResponseError",
"url":3,
"doc":"Base exception for an erroneous HTTP response that is a client error. All exceptions derived from this base should be treated as 4xx client errors when encountered. Method generated by attrs for class ClientHTTPResponseError."
},
{
"ref":"hikari.errors.ClientHTTPResponseError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ClientHTTPResponseError.status",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ClientHTTPResponseError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ClientHTTPResponseError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ClientHTTPResponseError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ClientHTTPResponseError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.InternalServerError",
"url":3,
"doc":"Base exception for an erroneous HTTP response that is a server error. All exceptions derived from this base should be treated as 5xx server errors when encountered. If you get one of these, it is not your fault! Method generated by attrs for class InternalServerError."
},
{
"ref":"hikari.errors.InternalServerError.url",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.InternalServerError.status",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.InternalServerError.headers",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.InternalServerError.raw_body",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.InternalServerError.message",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.InternalServerError.code",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.ShardCloseCode",
"url":3,
"doc":"Reasons for a shard connection closure."
},
{
"ref":"hikari.errors.ShardCloseCode.is_standard",
"url":3,
"doc":"Return  builtins.True if this is a standard code."
},
{
"ref":"hikari.errors.ShardCloseCode.name",
"url":3,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.errors.ShardCloseCode.value",
"url":3,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.errors.ShardCloseCode.NORMAL_CLOSURE",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.GOING_AWAY",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.PROTOCOL_ERROR",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.TYPE_ERROR",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.ENCODING_ERROR",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.POLICY_VIOLATION",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.TOO_BIG",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.UNEXPECTED_CONDITION",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.UNKNOWN_ERROR",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.UNKNOWN_OPCODE",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.DECODE_ERROR",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.NOT_AUTHENTICATED",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.AUTHENTICATION_FAILED",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.ALREADY_AUTHENTICATED",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.INVALID_SEQ",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.RATE_LIMITED",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.SESSION_TIMEOUT",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.INVALID_SHARD",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.SHARDING_REQUIRED",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.INVALID_VERSION",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.INVALID_INTENT",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.ShardCloseCode.DISALLOWED_INTENT",
"url":3,
"doc":""
},
{
"ref":"hikari.errors.GatewayConnectionError",
"url":3,
"doc":"An exception thrown if a connection issue occurs. Method generated by attrs for class GatewayConnectionError."
},
{
"ref":"hikari.errors.GatewayConnectionError.reason",
"url":3,
"doc":"Return an attribute of instance, which is of type owner."
},
{
"ref":"hikari.errors.GatewayServerClosedConnectionError",
"url":3,
"doc":"An exception raised when the server closes the connection. Method generated by attrs for class GatewayServerClosedConnectionError."
},
{
"ref":"hikari.errors.GatewayServerClosedConnectionError.can_reconnect",
"url":3,
"doc":"Return  builtins.True if we can recover from this closure. If  builtins.True , it will try to reconnect after this is raised rather than it being propagated to the caller. If  builtins.False , this will be raised, thus stopping the applicaiton unless handled explicitly by the user. Returns    - builtins.bool Whether the closure can be recovered from via a reconnect."
},
{
"ref":"hikari.errors.GatewayServerClosedConnectionError.code",
"url":3,
"doc":"Return the close code that was received, if there is one. Returns    - typing.Union[ShardCloseCode, builtins.int, builtins.None] The shard close code if there was one. Will be a  ShardCloseCode if the definition is known. Undocumented close codes may instead be an  builtins.int instead. If no close code was received, this will be  builtins.None ."
},
{
"ref":"hikari.errors.GatewayServerClosedConnectionError.reason",
"url":3,
"doc":"A string to explain the issue."
},
{
"ref":"hikari.errors.GatewayError",
"url":3,
"doc":"A base exception type for anything that can be thrown by the Gateway. Method generated by attrs for class GatewayError."
},
{
"ref":"hikari.errors.GatewayError.reason",
"url":3,
"doc":"A string to explain the issue."
},
{
"ref":"hikari.errors.MissingIntentWarning",
"url":3,
"doc":"Warning raised when subscribing to an event that cannot be fired. This is caused by your application missing certain intents."
},
{
"ref":"hikari.errors.MissingIntentError",
"url":3,
"doc":"Error raised when you try to perform an action without an intent. This is usually raised when querying the cache for something that is unavailable due to certain intents being disabled. Method generated by attrs for class MissingIntentError."
},
{
"ref":"hikari.errors.MissingIntentError.intents",
"url":3,
"doc":"The combination of intents that are missing."
},
{
"ref":"hikari.errors.BulkDeleteError",
"url":3,
"doc":"Exception raised when a bulk delete fails midway through a call. This will contain the list of message items that failed to be deleted, and will have a cause containing the initial exception. Method generated by attrs for class BulkDeleteError."
},
{
"ref":"hikari.errors.BulkDeleteError.percentage_completion",
"url":3,
"doc":"Return the percentage completion of the bulk delete before it failed. Returns    - builtins.float A percentage completion between 0 and 100 inclusive."
},
{
"ref":"hikari.errors.BulkDeleteError.messages_deleted",
"url":3,
"doc":"Any message objects that were deleted before an exception occurred."
},
{
"ref":"hikari.errors.BulkDeleteError.messages_skipped",
"url":3,
"doc":"Any message objects that were skipped due to an exception."
},
{
"ref":"hikari.errors.VoiceError",
"url":3,
"doc":"Error raised when a problem occurs with the voice subsystem."
},
{
"ref":"hikari.webhooks",
"url":80,
"doc":"Application and entities that are used to describe webhooks on Discord."
},
{
"ref":"hikari.webhooks.WebhookType",
"url":80,
"doc":"Types of webhook."
},
{
"ref":"hikari.webhooks.WebhookType.name",
"url":80,
"doc":"Return the name of the enum member as a  builtins.str ."
},
{
"ref":"hikari.webhooks.WebhookType.value",
"url":80,
"doc":"Return the value of the enum member."
},
{
"ref":"hikari.webhooks.WebhookType.INCOMING",
"url":80,
"doc":"Incoming webhook."
},
{
"ref":"hikari.webhooks.WebhookType.CHANNEL_FOLLOWER",
"url":80,
"doc":"Channel Follower webhook."
},
{
"ref":"hikari.webhooks.Webhook",
"url":80,
"doc":"Represents a webhook object on Discord. This is an endpoint that can have messages sent to it using standard HTTP requests, which enables external services that are not bots to send informational messages to specific channels. Method generated by attrs for class Webhook."
},
{
"ref":"hikari.webhooks.Webhook.mention",
"url":80,
"doc":"Return a raw mention string for the given webhook's user.  ! note This exists purely for consistency. Webhooks do not receive events from the gateway, and without some bot backend to support it, will not be able to detect mentions of their webhook. Example    -   >>> some_webhook.mention ' '   Returns    - builtins.str The mention string to use."
},
{
"ref":"hikari.webhooks.Webhook.execute",
"url":80,
"doc":"Execute the webhook to create a message. Parameters      content : hikari.undefined.UndefinedOr[typing.Any] If provided, the message contents. If  hikari.undefined.UNDEFINED , then nothing will be sent in the content. Any other value here will be cast to a  builtins.str . If this is a  hikari.embeds.Embed and no  embed kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone. Likewise, if this is a  hikari.files.Resource , then the content is instead treated as an attachment if no  attachment and no  attachments kwargs are provided. Other Parameters         username : hikari.undefined.UndefinedOr[builtins.str] If provided, the username to override the webhook's username for this request. avatar_url : hikari.undefined.UndefinedOr[builtins.str] If provided, the url of an image to override the webhook's avatar with for this request. tts : hikari.undefined.UndefinedOr[bool] If provided, whether the message will be sent as a TTS message. attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL. attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs. embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed If provided, a sequence of between  1 to  10 embed objects (inclusive) to send with the embed. mentions_everyone : hikari.undefined.UndefinedOr[builtins.bool] If provided, whether the message should parse @everyone/@here mentions. user_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.users.PartialUser derivatives to enforce mentioning specific users. role_mentions : hikari.undefined.UndefinedOr[typing.Union[typing.Collection[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole , builtins.bool If provided, and  builtins.True , all mentions will be parsed. If provided, and  builtins.False , no mentions will be parsed. Alternatively this may be a collection of  hikari.snowflakes.Snowflake , or  hikari.guilds.PartialRole derivatives to enforce mentioning specific roles. Returns    - hikari.messages.Message The created message object. Raises    hikari.errors.NotFoundError If the current webhook is not found. hikari.errors.BadRequestError This can be raised if the file is too large; if the embed exceeds the defined limits; if the message content is specified only and empty or greater than  2000 characters; if neither content, file or embeds are specified. If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. hikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook. builtins.ValueError If either  Webhook.token is  builtins.None or more than 100 unique objects/entities are passed for  role_mentions or  user_mentions. builtins.TypeError If both  attachment and  attachments are specified.",
"func":1
},
{
"ref":"hikari.webhooks.Webhook.delete",
"url":80,
"doc":"Delete this webhook. Other Parameters         use_token : hikari.undefined.UndefinedOr[builtins.bool] If set to  builtins.True then the webhook's token will be used for this request; if set to  builtins.False then bot authorization will be used; if not specified then the webhook's token will be used for the request if it's set else bot authorization. Raises    hikari.errors.NotFoundError If this webhook is not found. hikari.errors.ForbiddenError If you either lack the  MANAGE_WEBHOOKS permission or are not a member of the guild this webhook belongs to. builtins.ValueError If  use_token is passed as  builtins.True when  Webhook.token is  builtins.None .",
"func":1
},
{
"ref":"hikari.webhooks.Webhook.edit",
"url":80,
"doc":"Edit this webhook. Other Parameters         name : hikari.undefined.UndefinedOr[builtins.str] If provided, the new name string. avatar : hikari.undefined.UndefinedOr[hikari.files.Resourceish] If provided, the new avatar image. If  builtins.None , then it is removed. If not specified, nothing is changed. channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.TextChannel If provided, the object or ID of the new channel the given webhook should be moved to. reason : hikari.undefined.UndefinedOr[builtins.str] If provided, the audit log reason explaining why the operation was performed. This field will be used when using the webhook's token rather than bot authorization. use_token : hikari.undefined.UndefinedOr[builtins.bool] If set to  builtins.True then the webhook's token will be used for this request; if set to  builtins.False then bot authorization will be used; if not specified then the webhook's token will be used for the request if it's set else bot authorization. Returns    - hikari.webhooks.Webhook The updated webhook object. Raises    hikari.errors.BadRequestError If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. hikari.errors.NotFoundError If either the webhook or the channel are not found. hikari.errors.ForbiddenError If you either lack the  MANAGE_WEBHOOKS permission or are not a member of the guild this webhook belongs to. hikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook. builtins.ValueError If  use_token is passed as  builtins.True when  Webhook.token is  builtins.None .",
"func":1
},
{
"ref":"hikari.webhooks.Webhook.fetch_channel",
"url":80,
"doc":"Fetch the channel this webhook is for. Returns    - hikari.channels.PartialChannel The object of the channel this webhook targets. Raises    hikari.errors.ForbiddenError If you don't have access to the channel this webhook belongs to. hikari.errors.NotFoundError If the channel this message was created in does not exist.",
"func":1
},
{
"ref":"hikari.webhooks.Webhook.fetch_self",
"url":80,
"doc":"Fetch this webhook. Other Parameters         use_token : hikari.undefined.UndefinedOr[builtins.bool] If set to  builtins.True then the webhook's token will be used for this request; if set to  builtins.False then bot authorization will be used; if not specified then the webhook's token will be used for the request if it's set else bot authorization. Returns    - hikari.webhooks.Webhook The requested webhook object. Raises    hikari.errors.BadRequestError If any invalid snowflake IDs are passed; a snowflake may be invalid due to it being outside of the range of a 64 bit integer. hikari.errors.NotFoundError If the webhook is not found. hikari.errors.ForbiddenError If you're not in the guild that owns this webhook or lack the  MANAGE_WEBHOOKS permission. hikari.errors.UnauthorizedError If you pass a token that's invalid for the target webhook. builtins.ValueError If  use_token is passed as  builtins.True when  Webhook.token is  builtins.None .",
"func":1
},
{
"ref":"hikari.webhooks.Webhook.avatar",
"url":80,
"doc":"URL for this webhook's custom avatar or default avatar. If the webhook has a custom avatar, a URL to this is returned. Otherwise a URL to the default avatar is provided instead."
},
{
"ref":"hikari.webhooks.Webhook.default_avatar",
"url":80,
"doc":"URL for this webhook's default avatar. This is used if no avatar is set."
},
{
"ref":"hikari.webhooks.Webhook.format_avatar",
"url":80,
"doc":"Generate the avatar URL for this webhook's custom avatar if set. If no avatar is specified, return  None . In this case, you should use  default_avatar instead. Parameters      ext : builtins.str The extension to use for this URL, defaults to  png . Supports  png ,  jpeg ,  jpg ,  webp . This will be ignored for default avatars which can only be  png . size : builtins.int The size to set for the URL, defaults to  4096 . Can be any power of two between 16 and 4096. Will be ignored for default avatars. Returns    - typing.Optional[hikari.files.URL] The URL of the resource.  builtins.None if no avatar is set (in this case, use the  default_avatar instead). Raises    builtins.ValueError If  size is not a power of two between 16 and 4096 (inclusive).",
"func":1
},
{
"ref":"hikari.webhooks.Webhook.app",
"url":80,
"doc":"The client application that models may use for procedures."
},
{
"ref":"hikari.webhooks.Webhook.author",
"url":80,
"doc":"The user that created the webhook  ! info This will be  builtins.None when getting a webhook with bot authorization rather than the webhook's token."
},
{
"ref":"hikari.webhooks.Webhook.avatar_hash",
"url":80,
"doc":"The avatar hash of the webhook."
},
{
"ref":"hikari.webhooks.Webhook.channel_id",
"url":80,
"doc":"The channel ID this webhook is for."
},
{
"ref":"hikari.webhooks.Webhook.guild_id",
"url":80,
"doc":"The guild ID of the webhook."
},
{
"ref":"hikari.webhooks.Webhook.id",
"url":80,
"doc":"The ID of this entity."
},
{
"ref":"hikari.webhooks.Webhook.name",
"url":80,
"doc":"The name of the webhook."
},
{
"ref":"hikari.webhooks.Webhook.token",
"url":80,
"doc":"The token for the webhook.  ! info This is only available for incoming webhooks that are created in the channel settings."
},
{
"ref":"hikari.webhooks.Webhook.type",
"url":80,
"doc":"The type of the webhook."
},
{
"ref":"hikari.webhooks.Webhook.created_at",
"url":1,
"doc":"When the object was created."
},
{
"ref":"hikari.traits",
"url":7,
"doc":"Core app interface for application implementations."
},
{
"ref":"hikari.traits.AsyncCallbackT",
"url":7,
"doc":"Type-hint for an asynchronous coroutine function event callback. This should consume a single argument: the event that was dispatched. This is not expected to return anything."
},
{
"ref":"hikari.traits.EventT_co",
"url":7,
"doc":"Type-hint for a covariant event implementation instance. This will bind to the bound event type, or any subclass of that type."
},
{
"ref":"hikari.traits.EventT_inv",
"url":7,
"doc":"Type-hint for an invariant event implementation instance. This will bind to the bound event type only. Subclasses and superclasses will not be matched."
},
{
"ref":"hikari.traits.PredicateT",
"url":7,
"doc":"Type-hint for an event waiter predicate. This should be a function or coroutine function that consumes a covariant instance of the bound event type and returns a boolean that matches  builtins.True if the event is a match for the waiter, or  builtins.False otherwise."
},
{
"ref":"hikari.traits.CacheAware",
"url":7,
"doc":"Structural supertype for a cache-aware object. Any cache-aware objects are able to access the Discord application cache."
},
{
"ref":"hikari.traits.CacheAware.cache",
"url":7,
"doc":"Return the immutable cache implementation for this object. Returns    - hikari.api.cache.Cache The cache component for this object."
},
{
"ref":"hikari.traits.CacheAware.me",
"url":7,
"doc":"Return the bot user, if known. This should be available as soon as the bot has fired the  hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be  builtins.None . Returns    - typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise  builtins.None ."
},
{
"ref":"hikari.traits.DispatcherAware",
"url":7,
"doc":"Structural supertype for a dispatcher-aware object. Dispatcher-aware components are able to register and dispatch event listeners and waiters."
},
{
"ref":"hikari.traits.DispatcherAware.dispatcher",
"url":7,
"doc":"Return the event dispatcher for this object. Returns    - hikari.api.event_dispatcher.EventDispatcher The event dispatcher component."
},
{
"ref":"hikari.traits.EntityFactoryAware",
"url":7,
"doc":"Structural supertype for an entity factory-aware object. These components will be able to construct library entities."
},
{
"ref":"hikari.traits.EntityFactoryAware.entity_factory",
"url":7,
"doc":"Return the entity factory implementation for this object. Returns    - hikari.api.entity_factory.EntityFactory The entity factory component."
},
{
"ref":"hikari.traits.EventFactoryAware",
"url":7,
"doc":"Structural supertype for an event factory-aware object. These components are able to construct library events."
},
{
"ref":"hikari.traits.EventFactoryAware.event_factory",
"url":7,
"doc":"Return the event factory component. Returns    - hikari.api.event_factory.EventFactory The event factory component."
},
{
"ref":"hikari.traits.ExecutorAware",
"url":7,
"doc":"Structural supertype for an executor-aware object. These components will contain an  executor attribute that may return a  concurrent.futures.Executor or  builtins.None if the default  asyncio thread pool for the event loop is used."
},
{
"ref":"hikari.traits.ExecutorAware.executor",
"url":7,
"doc":"Return the executor to use for blocking operations. This may return  builtins.None if the default  asyncio thread pool should be used instead. Returns    - typing.Optional[concurrent.futures.Executor] The executor to use, or  builtins.None to use the  asyncio default instead."
},
{
"ref":"hikari.traits.ChunkerAware",
"url":7,
"doc":"Structural supertype for a guild chunker-aware object. These are able to request member chunks for guilds via the gateway to retrieve mass member and presence information in bulk."
},
{
"ref":"hikari.traits.ChunkerAware.chunker",
"url":7,
"doc":"Return the guild chunker component. Returns    - hikari.api.chunker.GuildChunker The guild chunker component."
},
{
"ref":"hikari.traits.NetworkSettingsAware",
"url":7,
"doc":"Structural supertype for any component aware of network settings."
},
{
"ref":"hikari.traits.NetworkSettingsAware.http_settings",
"url":7,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.traits.NetworkSettingsAware.proxy_settings",
"url":7,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.traits.RESTAware",
"url":7,
"doc":"Structural supertype for a REST-aware object. These are able to perform REST API calls."
},
{
"ref":"hikari.traits.RESTAware.rest",
"url":7,
"doc":"Return the REST client to use for HTTP requests. Returns    - hikari.api.rest.RESTClient The REST client to use."
},
{
"ref":"hikari.traits.RESTAware.entity_factory",
"url":7,
"doc":"Return the entity factory implementation for this object. Returns    - hikari.api.entity_factory.EntityFactory The entity factory component."
},
{
"ref":"hikari.traits.RESTAware.http_settings",
"url":7,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.traits.RESTAware.proxy_settings",
"url":7,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.traits.RESTAware.executor",
"url":7,
"doc":"Return the executor to use for blocking operations. This may return  builtins.None if the default  asyncio thread pool should be used instead. Returns    - typing.Optional[concurrent.futures.Executor] The executor to use, or  builtins.None to use the  asyncio default instead."
},
{
"ref":"hikari.traits.RESTAware.cache",
"url":7,
"doc":"Return the immutable cache implementation for this object. Returns    - hikari.api.cache.Cache The cache component for this object."
},
{
"ref":"hikari.traits.RESTAware.me",
"url":7,
"doc":"Return the bot user, if known. This should be available as soon as the bot has fired the  hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be  builtins.None . Returns    - typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise  builtins.None ."
},
{
"ref":"hikari.traits.ShardAware",
"url":7,
"doc":"Structural supertype for a shard-aware object. These will expose a mapping of shards, the intents in use and the bot user object."
},
{
"ref":"hikari.traits.ShardAware.heartbeat_latencies",
"url":7,
"doc":"Return a mapping of shard ID to heartbeat latency. Any shards that are not yet started will be  float('nan') . Returns    - typing.Mapping[builtins.int, builtins.float] Each shard ID mapped to the corresponding heartbeat latency. Each latency is measured in seconds."
},
{
"ref":"hikari.traits.ShardAware.heartbeat_latency",
"url":7,
"doc":"Return the average heartbeat latency of all started shards. If no shards are started, this will return  float('nan') . Returns    - builtins.float The average heartbeat latency of all started shards, or  float('nan') if no shards are started. This is measured in seconds."
},
{
"ref":"hikari.traits.ShardAware.intents",
"url":7,
"doc":"Return the intents registered for the application. Returns    - hikari.intents.Intents The intents registered on this application."
},
{
"ref":"hikari.traits.ShardAware.shards",
"url":7,
"doc":"Return a mapping of shards in this application instance. Each shard ID is mapped to the corresponding shard instance. If the application has not started, it is acceptable to assume the result of this call will be an empty mapping. Returns    - typing.Mapping[int, hikari.api.shard.GatewayShard] The shard mapping."
},
{
"ref":"hikari.traits.ShardAware.shard_count",
"url":7,
"doc":"Return the number of shards in the total application. This may not be the same as the size of  shards . If the application is auto-sharded, this may be  0 until the shards are started. Returns    - builtins.int The number of shards in the total application."
},
{
"ref":"hikari.traits.ShardAware.update_presence",
"url":7,
"doc":"Update the presence on all shards. This call will patch the presence on each shard. This means that unless you explicitly specify a parameter, the previous value will be retained. This means you do not have to track the global presence in your code. Other Parameters         idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed. afk : hikari.undefined.UndefinedOr[builtins.bool] If  builtins.True , the user is marked as AFK. If  builtins.False , the user is marked as being active. If undefined, this will not be changed. activity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed. status : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed.  ! note This will only send the update payloads to shards that are alive. Any shards that are not alive will cache the new presence for when they do start.  ! note If you want to set presences per shard, access the shard you wish to update (e.g. by using  BotApp.shards ), and call  hikari.api.shard.GatewayShard.update_presence on that shard. This method is simply a facade to make performing this in bulk simpler.",
"func":1
},
{
"ref":"hikari.traits.ShardAware.http_settings",
"url":7,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.traits.ShardAware.proxy_settings",
"url":7,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.traits.ShardAware.executor",
"url":7,
"doc":"Return the executor to use for blocking operations. This may return  builtins.None if the default  asyncio thread pool should be used instead. Returns    - typing.Optional[concurrent.futures.Executor] The executor to use, or  builtins.None to use the  asyncio default instead."
},
{
"ref":"hikari.traits.ShardAware.cache",
"url":7,
"doc":"Return the immutable cache implementation for this object. Returns    - hikari.api.cache.Cache The cache component for this object."
},
{
"ref":"hikari.traits.ShardAware.me",
"url":7,
"doc":"Return the bot user, if known. This should be available as soon as the bot has fired the  hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be  builtins.None . Returns    - typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise  builtins.None ."
},
{
"ref":"hikari.traits.ShardAware.chunker",
"url":7,
"doc":"Return the guild chunker component. Returns    - hikari.api.chunker.GuildChunker The guild chunker component."
},
{
"ref":"hikari.traits.ShardAware.voice",
"url":7,
"doc":"Return the voice connection manager component for this application. Returns    - hikari.api.voice.VoiceComponent The voice component for the application."
},
{
"ref":"hikari.traits.VoiceAware",
"url":7,
"doc":"Structural supertype for a voice-aware object. This is an object that provides a  voice property to allow the creation of custom voice client instances."
},
{
"ref":"hikari.traits.VoiceAware.voice",
"url":7,
"doc":"Return the voice connection manager component for this application. Returns    - hikari.api.voice.VoiceComponent The voice component for the application."
},
{
"ref":"hikari.traits.BotAware",
"url":7,
"doc":"Structural supertype for a component that is aware of all internals."
},
{
"ref":"hikari.traits.BotAware.join",
"url":7,
"doc":"Wait indefinitely until the application closes. This can be placed in a task and cancelled without affecting the application runtime itself. Any exceptions raised by shards will be propagated to here. Other Parameters         until_close : builtins.bool Defaults to  builtins.True . If set, the waiter will stop as soon as a request for shut down is processed. This can allow you to break and begin closing your own resources. If  builtins.False , then this will wait until all shards' tasks have died.",
"func":1
},
{
"ref":"hikari.traits.BotAware.run",
"url":7,
"doc":"Start the bot, wait for all shards to become ready, and then return. Other Parameters         activity : typing.Optional[hikari.presences.Activity] The initial activity to display in the bot user presence, or  builtins.None (default) to not show any. afk : builtins.bool The initial AFK state to display in the bot user presence, or  builtins.False (default) to not show any. close_executor : builtins.bool Defaults to  builtins.False . If  builtins.True , any custom  concurrent.futures.Executor passed to the constructor will be shut down when the application terminates. This does not affect the default executor associated with the event loop, and will not do anything if you do not provide a custom executor to the constructor. idle_since : typing.Optional[datetime.datetime] The  datetime.datetime the user should be marked as being idle since, or  builtins.None (default) to not show this. ignore_session_start_limit : builtins.bool Defaults to  builtins.False . If  builtins.False , then attempting to start more sessions than you are allowed in a 24 hour window will throw a  hikari.errors.GatewayError rather than going ahead and hitting the IDENTIFY limit, which may result in your token being reset. Setting to  builtins.True disables this behavior. large_threshold : builtins.int Threshold for members in a guild before it is treated as being \"large\" and no longer sending member details in the  GUILD CREATE event. Defaults to  250 . shard_ids : typing.Optional[typing.Set[builtins.int The shard IDs to create shards for. If not  builtins.None , then a non- None  shard_count must ALSO be provided. Defaults to  builtins.None , which means the Discord-recommended count is used for your application instead. shard_count : typing.Optional[builtins.int] The number of shards to use in the entire distributed application. Defaults to  builtins.None which results in the count being determined dynamically on startup. status : hikari.presences.Status The initial status to show for the user presence on startup. Defaults to  hikari.presences.Status.ONLINE .",
"func":1
},
{
"ref":"hikari.traits.BotAware.start",
"url":7,
"doc":"Start the bot, wait for all shards to become ready, and then return. Other Parameters         activity : typing.Optional[hikari.presences.Activity] The initial activity to display in the bot user presence, or  builtins.None (default) to not show any. afk : builtins.bool The initial AFK state to display in the bot user presence, or  builtins.False (default) to not show any. idle_since : typing.Optional[datetime.datetime] The  datetime.datetime the user should be marked as being idle since, or  builtins.None (default) to not show this. ignore_session_start_limit : builtins.bool Defaults to  builtins.False . If  builtins.False , then attempting to start more sessions than you are allowed in a 24 hour window will throw a  hikari.errors.GatewayError rather than going ahead and hitting the IDENTIFY limit, which may result in your token being reset. Setting to  builtins.True disables this behavior. large_threshold : builtins.int Threshold for members in a guild before it is treated as being \"large\" and no longer sending member details in the  GUILD CREATE event. Defaults to  250 . shard_ids : typing.Optional[typing.Set[builtins.int The shard IDs to create shards for. If not  builtins.None , then a non- None  shard_count must ALSO be provided. Defaults to  builtins.None , which means the Discord-recommended count is used for your application instead. shard_count : typing.Optional[builtins.int] The number of shards to use in the entire distributed application. Defaults to  builtins.None which results in the count being determined dynamically on startup. status : hikari.presences.Status The initial status to show for the user presence on startup. Defaults to  hikari.presences.Status.ONLINE .",
"func":1
},
{
"ref":"hikari.traits.BotAware.rest",
"url":7,
"doc":"Return the REST client to use for HTTP requests. Returns    - hikari.api.rest.RESTClient The REST client to use."
},
{
"ref":"hikari.traits.BotAware.entity_factory",
"url":7,
"doc":"Return the entity factory implementation for this object. Returns    - hikari.api.entity_factory.EntityFactory The entity factory component."
},
{
"ref":"hikari.traits.BotAware.http_settings",
"url":7,
"doc":"Return the HTTP settings in use by this component. Returns    - hikari.config.HTTPSettings The HTTP settings in use."
},
{
"ref":"hikari.traits.BotAware.proxy_settings",
"url":7,
"doc":"Return the proxy settings in use by this component. Returns    - hikari.config.ProxySettings The proxy settings in use."
},
{
"ref":"hikari.traits.BotAware.executor",
"url":7,
"doc":"Return the executor to use for blocking operations. This may return  builtins.None if the default  asyncio thread pool should be used instead. Returns    - typing.Optional[concurrent.futures.Executor] The executor to use, or  builtins.None to use the  asyncio default instead."
},
{
"ref":"hikari.traits.BotAware.cache",
"url":7,
"doc":"Return the immutable cache implementation for this object. Returns    - hikari.api.cache.Cache The cache component for this object."
},
{
"ref":"hikari.traits.BotAware.me",
"url":7,
"doc":"Return the bot user, if known. This should be available as soon as the bot has fired the  hikari.events.lifetime_events.StartingEvent . Until then, this may or may not be  builtins.None . Returns    - typing.Optional[hikari.users.OwnUser] The bot user, if known, otherwise  builtins.None ."
},
{
"ref":"hikari.traits.BotAware.heartbeat_latencies",
"url":7,
"doc":"Return a mapping of shard ID to heartbeat latency. Any shards that are not yet started will be  float('nan') . Returns    - typing.Mapping[builtins.int, builtins.float] Each shard ID mapped to the corresponding heartbeat latency. Each latency is measured in seconds."
},
{
"ref":"hikari.traits.BotAware.heartbeat_latency",
"url":7,
"doc":"Return the average heartbeat latency of all started shards. If no shards are started, this will return  float('nan') . Returns    - builtins.float The average heartbeat latency of all started shards, or  float('nan') if no shards are started. This is measured in seconds."
},
{
"ref":"hikari.traits.BotAware.intents",
"url":7,
"doc":"Return the intents registered for the application. Returns    - hikari.intents.Intents The intents registered on this application."
},
{
"ref":"hikari.traits.BotAware.shards",
"url":7,
"doc":"Return a mapping of shards in this application instance. Each shard ID is mapped to the corresponding shard instance. If the application has not started, it is acceptable to assume the result of this call will be an empty mapping. Returns    - typing.Mapping[int, hikari.api.shard.GatewayShard] The shard mapping."
},
{
"ref":"hikari.traits.BotAware.shard_count",
"url":7,
"doc":"Return the number of shards in the total application. This may not be the same as the size of  shards . If the application is auto-sharded, this may be  0 until the shards are started. Returns    - builtins.int The number of shards in the total application."
},
{
"ref":"hikari.traits.BotAware.update_presence",
"url":7,
"doc":"Update the presence on all shards. This call will patch the presence on each shard. This means that unless you explicitly specify a parameter, the previous value will be retained. This means you do not have to track the global presence in your code. Other Parameters         idle_since : hikari.undefined.UndefinedNoneOr[datetime.datetime] The datetime that the user started being idle. If undefined, this will not be changed. afk : hikari.undefined.UndefinedOr[builtins.bool] If  builtins.True , the user is marked as AFK. If  builtins.False , the user is marked as being active. If undefined, this will not be changed. activity : hikari.undefined.UndefinedNoneOr[hikari.presences.Activity] The activity to appear to be playing. If undefined, this will not be changed. status : hikari.undefined.UndefinedOr[hikari.presences.Status] The web status to show. If undefined, this will not be changed.  ! note This will only send the update payloads to shards that are alive. Any shards that are not alive will cache the new presence for when they do start.  ! note If you want to set presences per shard, access the shard you wish to update (e.g. by using  BotApp.shards ), and call  hikari.api.shard.GatewayShard.update_presence on that shard. This method is simply a facade to make performing this in bulk simpler.",
"func":1
},
{
"ref":"hikari.traits.BotAware.chunker",
"url":7,
"doc":"Return the guild chunker component. Returns    - hikari.api.chunker.GuildChunker The guild chunker component."
},
{
"ref":"hikari.traits.BotAware.voice",
"url":7,
"doc":"Return the voice connection manager component for this application. Returns    - hikari.api.voice.VoiceComponent The voice component for the application."
},
{
"ref":"hikari.traits.BotAware.event_factory",
"url":7,
"doc":"Return the event factory component. Returns    - hikari.api.event_factory.EventFactory The event factory component."
},
{
"ref":"hikari.traits.BotAware.dispatcher",
"url":7,
"doc":"Return the event dispatcher for this object. Returns    - hikari.api.event_dispatcher.EventDispatcher The event dispatcher component."
},
{
"ref":"hikari.event_stream",
"url":70,
"doc":"Streamers used for asynchronously iterating through gateway events."
},
{
"ref":"hikari.event_stream.Streamer",
"url":70,
"doc":"A base abstract class for all event streamers. Unlike  hikari.iterators.LazyIterator (which this extends), an event streamer must be started and closed. Examples     A streamer may either be started and closed using  async with syntax where  Streamer.open and  Streamer.close are implicitly called based on context.   async with Streamer(app, EventType, timeout=50) as stream: async for entry in stream:  .   A streamer may also be directly started and closed using the  Streamer.close and  Streamer.open . Note that if you don't call  Streamer.close after opening a streamer when you're finished with it then it may queue events events in memory indefinitely.   stream = Streamer(app, EventType, timeout=50) await stream.open() async for event in stream:  . await stream.close()   See Also     LazyIterator:  hikari.iterators.LazyIterator "
},
{
"ref":"hikari.event_stream.Streamer.close",
"url":70,
"doc":"Mark this streamer as closed to stop it from queueing and receiving events. If called on an already closed streamer then this will do nothing.  ! note  async with streamer may be used as a short-cut for opening and closing a streamer.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.open",
"url":70,
"doc":"Mark this streamer as opened to let it start receiving and queueing events. If called on an already started streamer then this will do nothing.  ! note  async with streamer may be used as a short-cut for opening and closing a stream.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.chunk",
"url":8,
"doc":"Return results in chunks of up to  chunk_size amount of entries. Parameters      chunk_size : int The limit for how many results should be returned in each chunk. Returns    - LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.map",
"url":8,
"doc":"Map the values to a different value. Parameters      transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the  . operator. Returns    - LazyIterator[AnotherValueT]  LazyIterator that maps each value to another value.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.for_each",
"url":8,
"doc":"Pass each value to a given consumer immediately.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.filter",
"url":8,
"doc":"Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item that this iterator would return when it is requested. All conditions must evaluate to  builtins.True for the item to be returned. If this is not met, then the item is discared and ignored, the next matching item will be returned instead, if there is one. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.filter \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT]  LazyIterator that only emits values where all conditions are matched.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.take_while",
"url":8,
"doc":"Return each item until any conditions fail or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.take_until",
"url":8,
"doc":"Return each item until any conditions pass or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.skip_while",
"url":8,
"doc":"Discard items while all conditions are True. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.skip_until",
"url":8,
"doc":"Discard items while all conditions are False. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.enumerate",
"url":8,
"doc":"Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of  builtins.enumerate which uses much less memory than collecting all the results first and calling  builtins.enumerate across them. Parameters      start : builtins.int Optional int to start at. If omitted, this is  0 . Examples     >>> async for i, item in paginated_results.enumerate():  . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9):  . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3):  . print(i, item) (9, foo) (10, bar) (11, baz) Returns    - LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.limit",
"url":8,
"doc":"Limit the number of items you receive from this async iterator. Parameters      limit : builtins.int The number of items to get. This must be greater than zero. Examples     >>> async for item in paginated_results.limit(3):  . print(item) Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.skip",
"url":8,
"doc":"Drop the given number of items, then yield anything after. Parameters      number : builtins.int The max number of items to drop before any items are yielded. Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.next",
"url":8,
"doc":"Return the next element of this iterator only. Returns    - ValueT The next result. Raises    builtins.LookupError If no more results exist.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.last",
"url":8,
"doc":"Return the last element of this iterator only. Returns    - ValueT The last result.  ! note This method will consume the whole iterator if run. Raises    builtins.LookupError If no result exists.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.reversed",
"url":8,
"doc":"Return a lazy iterator of the remainder of this iterator's values reversed. Returns    - LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.sort",
"url":8,
"doc":"Collect all results, then sort the collection before returning it.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.collect",
"url":8,
"doc":"Collect the results into a given type and return it. Parameters      collector A function that consumes a sequence of values and returns a collection.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.count",
"url":8,
"doc":"Count the number of results. Returns    - builtins.int Number of results found.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.flat_map",
"url":8,
"doc":"Perform a flat mapping operation. This will pass each item in the iterator to the given  function parameter, expecting a new  typing.Iterable or  typing.AsyncIterator to be returned as the result. This means you can map to a new  LazyIterator ,  typing.AsyncIterator ,  typing.Iterable , async generator, or generator. Remember that  typing.Iterator implicitly provides  typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement reactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded lazily. Parameters      flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example    - The following example generates a distinct collection of all mentioned users in the given channel from the past 500 messages.   def iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\" \", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct() )   Returns    - LazyIterator[AnotherValueT] The new lazy iterator to return.",
"func":1
},
{
"ref":"hikari.event_stream.Streamer.awaiting",
"url":8,
"doc":"Await each item concurrently in a fixed size window. Parameters      window_size : int The window size of how many tasks to await at once. You can set this to  0 to await everything at once, but see the below warning. Returns    - LazyIterator[ValueT] The new lazy iterator to return.  ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the  fetch_user endpoint seems to be notorious for doing this).  ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a  builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream",
"url":70,
"doc":"An implementation of an event  Streamer class.  ! note While calling  EventStream.filter on an active \"opened\" event stream will return a wrapping lazy iterator, calling it on an inactive \"closed\" event stream will return the event stream and add the given predicates to the streamer."
},
{
"ref":"hikari.event_stream.EventStream.close",
"url":70,
"doc":"Mark this streamer as closed to stop it from queueing and receiving events. If called on an already closed streamer then this will do nothing.  ! note  async with streamer may be used as a short-cut for opening and closing a streamer.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.filter",
"url":70,
"doc":"Filter the items by one or more conditions. Each condition is treated as a predicate, being called with each item that this iterator would return when it is requested. All conditions must evaluate to  builtins.True for the item to be returned. If this is not met, then the item is discared and ignored, the next matching item will be returned instead, if there is one. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.filter \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT]  LazyIterator that only emits values where all conditions are matched.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.open",
"url":70,
"doc":"Mark this streamer as opened to let it start receiving and queueing events. If called on an already started streamer then this will do nothing.  ! note  async with streamer may be used as a short-cut for opening and closing a stream.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.chunk",
"url":8,
"doc":"Return results in chunks of up to  chunk_size amount of entries. Parameters      chunk_size : int The limit for how many results should be returned in each chunk. Returns    - LazyIterator[typing.Sequence[ValueT  LazyIterator that emits each chunked sequence.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.map",
"url":8,
"doc":"Map the values to a different value. Parameters      transformation : typing.Union[typing.Callable ValueT], builtins.bool], builtins.str] The function to use to map the attribute. This may alternatively be a string attribute name to replace the input value with. You can provide nested attributes using the  . operator. Returns    - LazyIterator[AnotherValueT]  LazyIterator that maps each value to another value.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.for_each",
"url":8,
"doc":"Pass each value to a given consumer immediately.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.take_while",
"url":8,
"doc":"Return each item until any conditions fail or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are not matched.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.take_until",
"url":8,
"doc":"Return each item until any conditions pass or the end is reached. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.take_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values until any conditions are matched.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.skip_while",
"url":8,
"doc":"Discard items while all conditions are True. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_while \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has been met. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.skip_until",
"url":8,
"doc":"Discard items while all conditions are False. Items after this will be yielded as normal. Parameters       predicates : typing.Union[typing.Callable ValueT], builtins.bool], typing.Tuple[builtins.str, typing.Any Predicates to invoke. These are functions that take a value and return  builtins.True if it is of interest, or  builtins.False otherwise. These may instead include 2- builtins.tuple objects consisting of a  builtins.str attribute name (nested attributes are referred to using the  . operator), and values to compare for equality. This allows you to specify conditions such as  members.skip_until \"user.bot\", True  .  attrs : typing.Any Alternative to passing 2-tuples. Cannot specify nested attributes using this method. Returns    - LazyIterator[ValueT] LazyIterator that only emits values once a condition has failed. All items before this are discarded.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.enumerate",
"url":8,
"doc":"Enumerate the paginated results lazily. This behaves as an asyncio-friendly version of  builtins.enumerate which uses much less memory than collecting all the results first and calling  builtins.enumerate across them. Parameters      start : builtins.int Optional int to start at. If omitted, this is  0 . Examples     >>> async for i, item in paginated_results.enumerate():  . print(i, item) (0, foo) (1, bar) (2, baz) (3, bork) (4, qux) >>> async for i, item in paginated_results.enumerate(start=9):  . print(i, item) (9, foo) (10, bar) (11, baz) (12, bork) (13, qux) >>> async for i, item in paginated_results.enumerate(start=9).limit(3):  . print(i, item) (9, foo) (10, bar) (11, baz) Returns    - LazyIterator[typing.Tuple[builtins.int, T A paginated results view that asynchronously yields an increasing counter in a tuple with each result, lazily.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.limit",
"url":8,
"doc":"Limit the number of items you receive from this async iterator. Parameters      limit : builtins.int The number of items to get. This must be greater than zero. Examples     >>> async for item in paginated_results.limit(3):  . print(item) Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields a maximum of the given number of items before completing.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.skip",
"url":8,
"doc":"Drop the given number of items, then yield anything after. Parameters      number : builtins.int The max number of items to drop before any items are yielded. Returns    - LazyIterator[ValueT] A paginated results view that asynchronously yields all items AFTER the given number of items are discarded first.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.next",
"url":8,
"doc":"Return the next element of this iterator only. Returns    - ValueT The next result. Raises    builtins.LookupError If no more results exist.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.last",
"url":8,
"doc":"Return the last element of this iterator only. Returns    - ValueT The last result.  ! note This method will consume the whole iterator if run. Raises    builtins.LookupError If no result exists.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.reversed",
"url":8,
"doc":"Return a lazy iterator of the remainder of this iterator's values reversed. Returns    - LazyIterator[ValueT] The lazy iterator of this iterator's remaining values reversed.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.sort",
"url":8,
"doc":"Collect all results, then sort the collection before returning it.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.collect",
"url":8,
"doc":"Collect the results into a given type and return it. Parameters      collector A function that consumes a sequence of values and returns a collection.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.count",
"url":8,
"doc":"Count the number of results. Returns    - builtins.int Number of results found.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.flat_map",
"url":8,
"doc":"Perform a flat mapping operation. This will pass each item in the iterator to the given  function parameter, expecting a new  typing.Iterable or  typing.AsyncIterator to be returned as the result. This means you can map to a new  LazyIterator ,  typing.AsyncIterator ,  typing.Iterable , async generator, or generator. Remember that  typing.Iterator implicitly provides  typing.Iterable compatibility. This is used to provide lazy conversions, and can be used to implement reactive-like pipelines if desired. All results are combined into one large lazy iterator and yielded lazily. Parameters      flattener A function that returns either an async iterator or iterator of new values. Could be an attribute name instead. Example    - The following example generates a distinct collection of all mentioned users in the given channel from the past 500 messages.   def iter_mentioned_users(message: hikari.Message) -> typing.Iterable[Snowflake]: for match in re.findall(r\" \", message.content): yield Snowflake(match) mentioned_users = await ( channel .history() .limit(500) .map(\".content\") .flat_map(iter_mentioned_users) .distinct() )   Returns    - LazyIterator[AnotherValueT] The new lazy iterator to return.",
"func":1
},
{
"ref":"hikari.event_stream.EventStream.awaiting",
"url":8,
"doc":"Await each item concurrently in a fixed size window. Parameters      window_size : int The window size of how many tasks to await at once. You can set this to  0 to await everything at once, but see the below warning. Returns    - LazyIterator[ValueT] The new lazy iterator to return.  ! warning Setting a large window size, or setting it to 0 to await everything is a dangerous thing to do if you are making API calls. Some endpoints will get ratelimited and cause a backup of waiting tasks, others may begin to spam global rate limits instead (the  fetch_user endpoint seems to be notorious for doing this).  ! note This call assumes that the iterator contains awaitable values as input. MyPy cannot detect this nicely, so any cast is forced internally. If the item is not awaitable, you will receive a  builtins.TypeError instead. You have been warned. You cannot escape the ways of the duck type young grasshopper.",
"func":1
}
]