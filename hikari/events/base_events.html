<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.events.base_events API documentation</title>
<meta name="description" content="Base types and functions for events in Hikari." />
<meta property="og:title" content="hikari.events.base_events module documentation" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png" />
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions" />
<meta property="theme-color" content="#ff029a" />
<link rel="shortcut icon" type="image/png" href="https://hikari-py.github.io/hikari/logo.png"/>
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet"/>
<style>
* {
scrollbar-color: #202324 #454a4d;
scroll-behavior: smooth;
}
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
}
small.smaller {
font-size: 0.75em;
}
body {
background-color: #181A1B;
color: #C9C5C0;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<!-- body.mako -->
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="https://hikari-py.github.io/hikari/logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small>v2.0.0.dev92</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/hikari/index.html">Home</a></li>
<li class="nav-item active"><a class="nav-link" href="/hikari/hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" >
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.events -- Events that can be fired by Hikari's gateway implementation." href="index.html"
>events</a></li>
<li class="breadcrumb-item active"><a href="#">base_events</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Base types and functions for events in Hikari.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_required_intents_for -- Retrieve the intents that are required to listen to an event type …" href="#hikari.events.base_events.get_required_intents_for"
>get_required_intents_for</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="is_no_recursive_throw_event -- Return True if this event is marked as `___norecursivethrow___`." href="#hikari.events.base_events.is_no_recursive_throw_event"
>is_no_recursive_throw_event</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="no_recursive_throw -- Decorate an event type to indicate errors should not be handled …" href="#hikari.events.base_events.no_recursive_throw"
>no_recursive_throw</a></li>
<li class="text-truncate monospaced"><small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="requires_intents -- Decorate an event type to define what intents it requires …" href="#hikari.events.base_events.requires_intents"
>requires_intents</a></li>
</ul>
<ul class="list-unstyled text-truncate">
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="Event -- Base event type that all Hikari events should subclass …" href="#hikari.events.base_events.Event"
>Event</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="#hikari.events.base_events.Event.app"
>app</a>
</li>
<br />
</ul>
</li>
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ExceptionEvent -- Event that is raised when another event handler raises an `Exception` …" href="#hikari.events.base_events.ExceptionEvent"
>ExceptionEvent</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="#hikari.events.base_events.ExceptionEvent.app"
>app</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="exc_info -- Exception triplet that follows the same format as `sys.exc_info` …" href="#hikari.events.base_events.ExceptionEvent.exc_info"
>exc_info</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="exception -- Exception that was raised …" href="#hikari.events.base_events.ExceptionEvent.exception"
>exception</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="failed_callback -- Event callback that threw an exception …" href="#hikari.events.base_events.ExceptionEvent.failed_callback"
>failed_callback</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="failed_event -- Event instance that caused the exception …" href="#hikari.events.base_events.ExceptionEvent.failed_event"
>failed_event</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="retry -- Invoke the failed event again …" href="#hikari.events.base_events.ExceptionEvent.retry"
>retry</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard -- Shard that received the event, if there was one associated …" href="#hikari.events.base_events.ExceptionEvent.shard"
>shard</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/events/base_events.py#L0-L238" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Base types and functions for events in Hikari.&#34;&#34;&#34;
from __future__ import annotations

__all__: typing.List[str] = [
    &#34;Event&#34;,
    &#34;ExceptionEvent&#34;,
    &#34;is_no_recursive_throw_event&#34;,
    &#34;no_recursive_throw&#34;,
    &#34;get_required_intents_for&#34;,
    &#34;requires_intents&#34;,
]

import abc
import inspect
import typing

import attr

from hikari import intents
from hikari import traits
from hikari.api import shard as gateway_shard
from hikari.internal import attr_extensions

if typing.TYPE_CHECKING:
    import types

T = typing.TypeVar(&#34;T&#34;)
REQUIRED_INTENTS_ATTR: typing.Final[str] = &#34;___requiresintents___&#34;
NO_RECURSIVE_THROW_ATTR: typing.Final[str] = &#34;___norecursivethrow___&#34;


@attr.s(kw_only=True, slots=True, weakref_slot=False)
class Event(abc.ABC):
    &#34;&#34;&#34;Base event type that all Hikari events should subclass.&#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def app(self) -&gt; traits.RESTAware:
        &#34;&#34;&#34;App instance for this application.

        Returns
        -------
        hikari.traits.RESTAware
            The REST-aware app trait.
        &#34;&#34;&#34;


def get_required_intents_for(event_type: typing.Type[Event]) -&gt; typing.Collection[intents.Intents]:
    &#34;&#34;&#34;Retrieve the intents that are required to listen to an event type.

    Parameters
    ----------
    event_type : typing.Type[Event]
        The event type to get required intents for.

    Returns
    -------
    typing.Collection[hikari.intents.Intents]
        Collection of acceptable subset combinations of intent needed to
        be able to receive the given event type.
    &#34;&#34;&#34;
    return typing.cast(&#34;typing.Collection[typing.Any]&#34;, getattr(event_type, REQUIRED_INTENTS_ATTR, ()))


def requires_intents(first: intents.Intents, *rest: intents.Intents) -&gt; typing.Callable[[T], T]:
    &#34;&#34;&#34;Decorate an event type to define what intents it requires.

    Parameters
    ----------
    first : hikari.intents.Intents
        First combination of intents that are acceptable in order to receive
        the decorated event type.
    *rest : hikari.intents.Intents
        Zero or more additional combinations of intents to require for this
        event to be subscribed to.
    &#34;&#34;&#34;

    def decorator(cls: T) -&gt; T:
        required_intents = [first, *rest]
        setattr(cls, REQUIRED_INTENTS_ATTR, required_intents)
        doc = inspect.getdoc(cls) or &#34;&#34;
        doc += &#34;\n\nThis requires one of the following combinations of intents in order to be dispatched:\n\n&#34;
        for intent_group in required_intents:
            preview = &#34; + &#34;.join(
                f&#34;`{type(i).__module__}.{type(i).__qualname__}.{i.name}`&#34; for i in intent_group.split()
            )
            doc += f&#34; - {preview}\n&#34;

        cls.__doc__ = doc
        return cls

    return decorator


def no_recursive_throw() -&gt; typing.Callable[[typing.Type[T]], typing.Type[T]]:
    &#34;&#34;&#34;Decorate an event type to indicate errors should not be handled.

    This is useful for exception event types that you do not want to
    have invoked recursively.
    &#34;&#34;&#34;

    def decorator(cls: typing.Type[T]) -&gt; typing.Type[T]:
        setattr(cls, NO_RECURSIVE_THROW_ATTR, True)
        doc = inspect.getdoc(cls) or &#34;&#34;
        doc += inspect.cleandoc(
            &#34;\n\n\n&#34;
            &#34;!!! warning\n&#34;
            &#34;   Any exceptions raised by handlers for this event will be dumped to the\n&#34;
            &#34;   application logger and silently discarded, preventing recursive loops\n&#34;
            &#34;   produced by faulty exception event handling. Thus, it is imperative\n&#34;
            &#34;   that you ensure any exceptions are explicitly caught within handlers\n&#34;
            &#34;   for this event if they may occur.\n&#34;
        )
        cls.__doc__ = doc
        return cls

    return decorator


def is_no_recursive_throw_event(obj: typing.Union[T, typing.Type[T]]) -&gt; bool:
    &#34;&#34;&#34;Return True if this event is marked as `___norecursivethrow___`.&#34;&#34;&#34;
    return typing.cast(&#34;bool&#34;, getattr(obj, NO_RECURSIVE_THROW_ATTR, False))


FailedEventT = typing.TypeVar(&#34;FailedEventT&#34;, bound=Event)
FailedCallbackT = typing.Callable[[FailedEventT], typing.Coroutine[typing.Any, typing.Any, None]]


@no_recursive_throw()
@attr_extensions.with_copy
@attr.s(kw_only=True, slots=True, weakref_slot=False)
class ExceptionEvent(Event, typing.Generic[FailedEventT]):
    &#34;&#34;&#34;Event that is raised when another event handler raises an `Exception`.

    !!! note
        Only exceptions that derive from `builtins.Exception` will be caught.
        Other exceptions outside this range will propagate past this callback.
        This prevents event handlers interfering with critical exceptions
        such as `KeyboardError` which would have potentially undesired
        side-effects on the application runtime.
    &#34;&#34;&#34;

    exception: Exception = attr.ib()
    &#34;&#34;&#34;Exception that was raised.

    Returns
    -------
    builtins.Exception
        Exception that was raised in the event handler.
    &#34;&#34;&#34;

    failed_event: FailedEventT = attr.ib()
    &#34;&#34;&#34;Event instance that caused the exception.

    Returns
    -------
    hikari.events.base_events.Event
        Event that was being processed when the exception occurred.
    &#34;&#34;&#34;

    # MyPy thinks the attr.ib type hint on the `failed_callback` implies it is a function
    # defined in class scope, and thus thinks referring to it will make it a bound method.
    # To get around this, we make this attribute hidden and make a property that casts it
    # for us to remove this effect. This functionally changes nothing but it helps MyPy.
    _failed_callback: FailedCallbackT[FailedEventT] = attr.ib()

    @property
    def app(self) -&gt; traits.RESTAware:
        # &lt;&lt;inherited docstring from Event&gt;&gt;.
        return self.failed_event.app

    @property
    def shard(self) -&gt; typing.Optional[gateway_shard.GatewayShard]:
        &#34;&#34;&#34;Shard that received the event, if there was one associated.

        Returns
        -------
        typing.Optional[hikari.api.shard.GatewayShard]
            Shard that raised this exception.

            This may be `builtins.None` if no specific shard was the cause of this
            exception (e.g. when starting up or shutting down).
        &#34;&#34;&#34;
        shard = getattr(self.failed_event, &#34;shard&#34;, None)
        if isinstance(shard, gateway_shard.GatewayShard):
            return shard
        return None

    @property
    def failed_callback(self) -&gt; FailedCallbackT[FailedEventT]:
        &#34;&#34;&#34;Event callback that threw an exception.

        Returns
        -------
        callback
            Event callback that failed execution.
        &#34;&#34;&#34;
        return self._failed_callback

    @property
    def exc_info(self) -&gt; typing.Tuple[typing.Type[Exception], Exception, typing.Optional[types.TracebackType]]:
        &#34;&#34;&#34;Exception triplet that follows the same format as `sys.exc_info`.

        Returns
        -------
        builtins.tuple[typing.Type[Exception], Exception, typing.Optional[types.TracebackType]]
            The `sys.exc_info`-compatible tuple of the exception type, the
            exception instance, and the traceback of the exception.
        &#34;&#34;&#34;
        return type(self.exception), self.exception, self.exception.__traceback__

    async def retry(self) -&gt; None:
        &#34;&#34;&#34;Invoke the failed event again.

        If an exception is thrown this time, it will need to be manually
        caught in-code, or will be discarded.
        &#34;&#34;&#34;
        await self._failed_callback(self.failed_event)</code></pre>
</details>
</div>
</div>
<h2 id="functions-heading">Functions</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<pre><code id="hikari.events.base_events.get_required_intents_for" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_required_intents_for" href="#hikari.events.base_events.get_required_intents_for" id="hikari.events.base_events.get_required_intents_for">get_required_intents_for</a>(
    event_type: <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='#hikari.events.base_events.Event'>Event</a>],
) -> Collection[<a href='../intents.html#hikari.intents.Intents'>Intents</a>]: ...</code></pre>
</dt>
<dd>
<p>Retrieve the intents that are required to listen to an event type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_type</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='#hikari.events.base_events.Event'>Event</a>]</code></dt>
<dd>The event type to get required intents for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Collection'>Collection</a>[<a href='../intents.html#hikari.intents.Intents'>Intents</a>]</code></dt>
<dd>Collection of acceptable subset combinations of intent needed to
be able to receive the given event type.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/events/base_events.py#L69-L83" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_required_intents_for(event_type: typing.Type[Event]) -&gt; typing.Collection[intents.Intents]:
    &#34;&#34;&#34;Retrieve the intents that are required to listen to an event type.

    Parameters
    ----------
    event_type : typing.Type[Event]
        The event type to get required intents for.

    Returns
    -------
    typing.Collection[hikari.intents.Intents]
        Collection of acceptable subset combinations of intent needed to
        be able to receive the given event type.
    &#34;&#34;&#34;
    return typing.cast(&#34;typing.Collection[typing.Any]&#34;, getattr(event_type, REQUIRED_INTENTS_ATTR, ()))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.events.base_events.is_no_recursive_throw_event" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="is_no_recursive_throw_event" href="#hikari.events.base_events.is_no_recursive_throw_event" id="hikari.events.base_events.is_no_recursive_throw_event">is_no_recursive_throw_event</a>(
    obj: <a href='https://docs.python.org/3/library/typing.html#typing.Union'>Union</a>[T, <a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[T]],
) -> <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>: ...</code></pre>
</dt>
<dd>
<p>Return True if this event is marked as <code>___norecursivethrow___</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/events/base_events.py#L141-L143" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def is_no_recursive_throw_event(obj: typing.Union[T, typing.Type[T]]) -&gt; bool:
    &#34;&#34;&#34;Return True if this event is marked as `___norecursivethrow___`.&#34;&#34;&#34;
    return typing.cast(&#34;bool&#34;, getattr(obj, NO_RECURSIVE_THROW_ATTR, False))</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.events.base_events.no_recursive_throw" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="no_recursive_throw" href="#hikari.events.base_events.no_recursive_throw" id="hikari.events.base_events.no_recursive_throw">no_recursive_throw</a>() -> Callable[[Type[~T]], Type[~T]]: ...</code></pre>
</dt>
<dd>
<p>Decorate an event type to indicate errors should not be handled.</p>
<p>This is useful for exception event types that you do not want to
have invoked recursively.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/events/base_events.py#L116-L138" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def no_recursive_throw() -&gt; typing.Callable[[typing.Type[T]], typing.Type[T]]:
    &#34;&#34;&#34;Decorate an event type to indicate errors should not be handled.

    This is useful for exception event types that you do not want to
    have invoked recursively.
    &#34;&#34;&#34;

    def decorator(cls: typing.Type[T]) -&gt; typing.Type[T]:
        setattr(cls, NO_RECURSIVE_THROW_ATTR, True)
        doc = inspect.getdoc(cls) or &#34;&#34;
        doc += inspect.cleandoc(
            &#34;\n\n\n&#34;
            &#34;!!! warning\n&#34;
            &#34;   Any exceptions raised by handlers for this event will be dumped to the\n&#34;
            &#34;   application logger and silently discarded, preventing recursive loops\n&#34;
            &#34;   produced by faulty exception event handling. Thus, it is imperative\n&#34;
            &#34;   that you ensure any exceptions are explicitly caught within handlers\n&#34;
            &#34;   for this event if they may occur.\n&#34;
        )
        cls.__doc__ = doc
        return cls

    return decorator</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.events.base_events.requires_intents" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="requires_intents" href="#hikari.events.base_events.requires_intents" id="hikari.events.base_events.requires_intents">requires_intents</a>(
    first: <a href='../intents.html#hikari.intents.Intents'>intents.Intents</a>,
    *rest: <a href='../intents.html#hikari.intents.Intents'>intents.Intents</a>,
) -> Callable[[~T], ~T]: ...</code></pre>
</dt>
<dd>
<p>Decorate an event type to define what intents it requires.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>first</code></strong> :&ensp;<code><a href='../intents.html#hikari.intents.Intents'>Intents</a></code></dt>
<dd>First combination of intents that are acceptable in order to receive
the decorated event type.</dd>
<dt><strong><code>*rest</code></strong> :&ensp;<code><a href='../intents.html#hikari.intents.Intents'>Intents</a></code></dt>
<dd>Zero or more additional combinations of intents to require for this
event to be subscribed to.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/events/base_events.py#L86-L113" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def requires_intents(first: intents.Intents, *rest: intents.Intents) -&gt; typing.Callable[[T], T]:
    &#34;&#34;&#34;Decorate an event type to define what intents it requires.

    Parameters
    ----------
    first : hikari.intents.Intents
        First combination of intents that are acceptable in order to receive
        the decorated event type.
    *rest : hikari.intents.Intents
        Zero or more additional combinations of intents to require for this
        event to be subscribed to.
    &#34;&#34;&#34;

    def decorator(cls: T) -&gt; T:
        required_intents = [first, *rest]
        setattr(cls, REQUIRED_INTENTS_ATTR, required_intents)
        doc = inspect.getdoc(cls) or &#34;&#34;
        doc += &#34;\n\nThis requires one of the following combinations of intents in order to be dispatched:\n\n&#34;
        for intent_group in required_intents:
            preview = &#34; + &#34;.join(
                f&#34;`{type(i).__module__}.{type(i).__qualname__}.{i.name}`&#34; for i in intent_group.split()
            )
            doc += f&#34; - {preview}\n&#34;

        cls.__doc__ = doc
        return cls

    return decorator</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
</section>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="Event -- Base event type that all Hikari events should subclass …" href="#hikari.events.base_events.Event"
>Event</a></h4>
</dt>
<dd>
<pre><code id="hikari.events.base_events.Event" class="hljs python"><abbr title='A standard Python type.'>class</abbr> Event: ...</code></pre>
<p>Base event type that all Hikari events should subclass.</p>
<p>Method generated by attrs for class Event.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/events/base_events.py#L54-L66" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class Event(abc.ABC):
    &#34;&#34;&#34;Base event type that all Hikari events should subclass.&#34;&#34;&#34;

    @property
    @abc.abstractmethod
    def app(self) -&gt; traits.RESTAware:
        &#34;&#34;&#34;App instance for this application.

        Returns
        -------
        hikari.traits.RESTAware
            The REST-aware app trait.
        &#34;&#34;&#34;</code></pre>
</details>
<div class="sep"></div>
<h5>Subclasses</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ExceptionEvent -- Event that is raised when another event handler raises an `Exception` …" href="#hikari.events.base_events.ExceptionEvent"
>ExceptionEvent</a></dt>
<dd class="nested"><p>Event that is raised when another event handler raises an <code><a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a></code> …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="StartedEvent -- Event that is triggered after the application has started …" href="lifetime_events.html#hikari.events.lifetime_events.StartedEvent"
>StartedEvent</a></dt>
<dd class="nested"><p>Event that is triggered after the application has started …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="StartingEvent -- Event that is triggered before the application connects to discord …" href="lifetime_events.html#hikari.events.lifetime_events.StartingEvent"
>StartingEvent</a></dt>
<dd class="nested"><p>Event that is triggered before the application connects to discord …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="StoppedEvent -- Event that is triggered once the application has disconnected …" href="lifetime_events.html#hikari.events.lifetime_events.StoppedEvent"
>StoppedEvent</a></dt>
<dd class="nested"><p>Event that is triggered once the application has disconnected …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="StoppingEvent -- Event that is triggered as soon as the application is requested to close …" href="lifetime_events.html#hikari.events.lifetime_events.StoppingEvent"
>StoppingEvent</a></dt>
<dd class="nested"><p>Event that is triggered as soon as the application is requested to close …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ShardEvent -- Base class for any event that was shard-specific …" href="shard_events.html#hikari.events.shard_events.ShardEvent"
>ShardEvent</a></dt>
<dd class="nested"><p>Base class for any event that was shard-specific …</p></dd>
</dl>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="Event -- Base event type that all Hikari events should subclass …" href="#hikari.events.base_events.Event"
>Event</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='An abstract method or property that must be overridden in a derived class.'>abstract</abbr> <abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="#hikari.events.base_events.Event.app" id="hikari.events.base_events.Event.app" >app</a> : <a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></pre>
</dt>
<dd><p>App instance for this application.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></dt>
<dd>The REST-aware app trait.</dd>
</dl></dd>
</dl>
<div class="sep"></div>
</dd>
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ExceptionEvent -- Event that is raised when another event handler raises an `Exception` …" href="#hikari.events.base_events.ExceptionEvent"
>ExceptionEvent</a></h4>
</dt>
<dd>
<pre><code id="hikari.events.base_events.ExceptionEvent" class="hljs python"><abbr title='A standard Python type.'>class</abbr> ExceptionEvent (
    *,
    exception: <a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a>,
    failed_event: FailedEventT,
    failed_callback: FailedCallbackT[FailedEventT],
): ...</code></pre>
<p>Event that is raised when another event handler raises an <code><a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a></code>.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Only exceptions that derive from <code><a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a></code> will be caught.
Other exceptions outside this range will propagate past this callback.
This prevents event handlers interfering with critical exceptions
such as <code>KeyboardError</code> which would have potentially undesired
side-effects on the application runtime.!!! warning</p>
</div>
<p>Any exceptions raised by handlers for this event will be dumped to the
application logger and silently discarded, preventing recursive loops
produced by faulty exception event handling. Thus, it is imperative
that you ensure any exceptions are explicitly caught within handlers
for this event if they may occur.</p>
<p>Method generated by attrs for class ExceptionEvent.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/events/base_events.py#L153-L239" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class ExceptionEvent(Event, typing.Generic[FailedEventT]):
    &#34;&#34;&#34;Event that is raised when another event handler raises an `Exception`.

    !!! note
        Only exceptions that derive from `builtins.Exception` will be caught.
        Other exceptions outside this range will propagate past this callback.
        This prevents event handlers interfering with critical exceptions
        such as `KeyboardError` which would have potentially undesired
        side-effects on the application runtime.
    &#34;&#34;&#34;

    exception: Exception = attr.ib()
    &#34;&#34;&#34;Exception that was raised.

    Returns
    -------
    builtins.Exception
        Exception that was raised in the event handler.
    &#34;&#34;&#34;

    failed_event: FailedEventT = attr.ib()
    &#34;&#34;&#34;Event instance that caused the exception.

    Returns
    -------
    hikari.events.base_events.Event
        Event that was being processed when the exception occurred.
    &#34;&#34;&#34;

    # MyPy thinks the attr.ib type hint on the `failed_callback` implies it is a function
    # defined in class scope, and thus thinks referring to it will make it a bound method.
    # To get around this, we make this attribute hidden and make a property that casts it
    # for us to remove this effect. This functionally changes nothing but it helps MyPy.
    _failed_callback: FailedCallbackT[FailedEventT] = attr.ib()

    @property
    def app(self) -&gt; traits.RESTAware:
        # &lt;&lt;inherited docstring from Event&gt;&gt;.
        return self.failed_event.app

    @property
    def shard(self) -&gt; typing.Optional[gateway_shard.GatewayShard]:
        &#34;&#34;&#34;Shard that received the event, if there was one associated.

        Returns
        -------
        typing.Optional[hikari.api.shard.GatewayShard]
            Shard that raised this exception.

            This may be `builtins.None` if no specific shard was the cause of this
            exception (e.g. when starting up or shutting down).
        &#34;&#34;&#34;
        shard = getattr(self.failed_event, &#34;shard&#34;, None)
        if isinstance(shard, gateway_shard.GatewayShard):
            return shard
        return None

    @property
    def failed_callback(self) -&gt; FailedCallbackT[FailedEventT]:
        &#34;&#34;&#34;Event callback that threw an exception.

        Returns
        -------
        callback
            Event callback that failed execution.
        &#34;&#34;&#34;
        return self._failed_callback

    @property
    def exc_info(self) -&gt; typing.Tuple[typing.Type[Exception], Exception, typing.Optional[types.TracebackType]]:
        &#34;&#34;&#34;Exception triplet that follows the same format as `sys.exc_info`.

        Returns
        -------
        builtins.tuple[typing.Type[Exception], Exception, typing.Optional[types.TracebackType]]
            The `sys.exc_info`-compatible tuple of the exception type, the
            exception instance, and the traceback of the exception.
        &#34;&#34;&#34;
        return type(self.exception), self.exception, self.exception.__traceback__

    async def retry(self) -&gt; None:
        &#34;&#34;&#34;Invoke the failed event again.

        If an exception is thrown this time, it will need to be manually
        caught in-code, or will be discarded.
        &#34;&#34;&#34;
        await self._failed_callback(self.failed_event)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="ExceptionEvent -- Event that is raised when another event handler raises an `Exception` …" href="#hikari.events.base_events.ExceptionEvent"
>ExceptionEvent</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type that represents some form of information or entity.'>dataclass</abbr></em></small> <a title="Event -- Base event type that all Hikari events should subclass …" href="#hikari.events.base_events.Event"
>Event</a></dt>
<dd class="nested"><p>Base event type that all Hikari events should subclass …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="typing.Generic -- Abstract base class for generic types …" href="https://docs.python.org/3/library/typing.html#typing.Generic"
>Generic</a></dt>
<dd class="nested"><p>Abstract base class for generic types …</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="app -- App instance for this application …" href="#hikari.events.base_events.ExceptionEvent.app" id="hikari.events.base_events.ExceptionEvent.app" >app</a> : <a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></pre>
</dt>
<dd><p>App instance for this application.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../traits.html#hikari.traits.RESTAware'>RESTAware</a></code></dt>
<dd>The REST-aware app trait.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="exc_info -- Exception triplet that follows the same format as `sys.exc_info` …" href="#hikari.events.base_events.ExceptionEvent.exc_info" id="hikari.events.base_events.ExceptionEvent.exc_info" >exc_info</a> : <a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a>], <a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/types.html#types.TracebackType'>types.TracebackType</a>]]</code></pre>
</dt>
<dd><p>Exception triplet that follows the same format as <code><a href='https://docs.python.org/3/library/sys.html#sys.exc_info'>sys.exc_info</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/stdtypes.html#tuple'>tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Type'>Type</a>[<a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a>], <a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a>, <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/types.html#types.TracebackType'>types.TracebackType</a>]]</code></dt>
<dd>The <code><a href='https://docs.python.org/3/library/sys.html#sys.exc_info'>sys.exc_info</a></code>-compatible tuple of the exception type, the
exception instance, and the traceback of the exception.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="exception -- Exception that was raised …" href="#hikari.events.base_events.ExceptionEvent.exception" id="hikari.events.base_events.ExceptionEvent.exception" >exception</a> : <a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a></code></pre>
</dt>
<dd><p>Exception that was raised.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#Exception'>Exception</a></code></dt>
<dd>Exception that was raised in the event handler.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="failed_callback -- Event callback that threw an exception …" href="#hikari.events.base_events.ExceptionEvent.failed_callback" id="hikari.events.base_events.ExceptionEvent.failed_callback" >failed_callback</a> : Callable[[~FailedEventT], Coroutine[Any, Any, None]]</code></pre>
</dt>
<dd><p>Event callback that threw an exception.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/glossary.html#term-callback'>callback</a></code></dt>
<dd>Event callback that failed execution.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="failed_event -- Event instance that caused the exception …" href="#hikari.events.base_events.ExceptionEvent.failed_event" id="hikari.events.base_events.ExceptionEvent.failed_event" >failed_event</a> : ~FailedEventT</code></pre>
</dt>
<dd><p>Event instance that caused the exception.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='#hikari.events.base_events.Event'>Event</a></code></dt>
<dd>Event that was being processed when the exception occurred.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard -- Shard that received the event, if there was one associated …" href="#hikari.events.base_events.ExceptionEvent.shard" id="hikari.events.base_events.ExceptionEvent.shard" >shard</a> : Union[<a href='../api/shard.html#hikari.api.shard.GatewayShard'>GatewayShard</a>, None]</code></pre>
</dt>
<dd><p>Shard that received the event, if there was one associated.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../api/shard.html#hikari.api.shard.GatewayShard'>GatewayShard</a>]</code></dt>
<dd>
<p>Shard that raised this exception.</p>
<p>This may be <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no specific shard was the cause of this
exception (e.g. when starting up or shutting down).</p>
</dd>
</dl></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.events.base_events.ExceptionEvent.retry" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="retry" href="#hikari.events.base_events.ExceptionEvent.retry" id="hikari.events.base_events.ExceptionEvent.retry">retry</a>() -> None: ...</code></pre>
</dt>
<dd>
<p>Invoke the failed event again.</p>
<p>If an exception is thrown this time, it will need to be manually
caught in-code, or will be discarded.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/events/base_events.py#L233-L239" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def retry(self) -&gt; None:
    &#34;&#34;&#34;Invoke the failed event again.

    If an exception is thrown this time, it will need to be manually
    caught in-code, or will be discarded.
    &#34;&#34;&#34;
    await self._failed_callback(self.failed_event)</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</dl>
</section>
</div>
</div>
</div>
<!-- Search script and dependencies -->
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../search.html#' + encodeURIComponent(query);
window.location.href = url;
};
</script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>