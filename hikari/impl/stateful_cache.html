<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.impl.stateful_cache API documentation</title>
<meta name="description" content="Basic implementation of a cache for general bots and gateway apps." />
<meta property="og:title" content="hikari.impl.stateful_cache module documentation" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png" />
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions" />
<meta property="theme-color" content="#ff029a" />
<link rel="shortcut icon" type="image/png" href="https://hikari-py.github.io/hikari/logo.png"/>
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet"/>
<style>
* {
scrollbar-color: #202324 #454a4d;
scroll-behavior: smooth;
}
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
}
small.smaller {
font-size: 0.75em;
}
body {
background-color: #181A1B;
color: #C9C5C0;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<!-- body.mako -->
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="https://hikari-py.github.io/hikari/logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small>v2.0.0.dev92</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/hikari/index.html">Home</a></li>
<li class="nav-item active"><a class="nav-link" href="/hikari/hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" >
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.impl -- Basic implementations of application components …" href="index.html"
>impl</a></li>
<li class="breadcrumb-item active"><a href="#">stateful_cache</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Basic implementation of a cache for general bots and gateway apps.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="StatefulCacheImpl -- In-memory cache implementation." href="#hikari.impl.stateful_cache.StatefulCacheImpl"
>StatefulCacheImpl</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_emojis -- Remove all the known custom emoji objects from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis"
>clear_emojis</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_emojis_for_guild -- Remove the known custom emoji objects cached for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis_for_guild"
>clear_emojis_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_guild_channels -- Remove all guild channels from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels"
>clear_guild_channels</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_guild_channels_for_guild -- Remove guild channels from the cache for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels_for_guild"
>clear_guild_channels_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_guilds -- Remove all the guild objects from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_guilds"
>clear_guilds</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_invites -- Remove all the invite objects from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites"
>clear_invites</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_invites_for_channel -- Remove the invite objects in the cache for a specific channel …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_channel"
>clear_invites_for_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_invites_for_guild -- Remove the invite objects in the cache for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_guild"
>clear_invites_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_members -- Remove all the guild members in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_members"
>clear_members</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_members_for_guild -- Remove the members for a specific guild from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_members_for_guild"
>clear_members_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_presences -- Remove all the presences in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences"
>clear_presences</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_presences_for_guild -- Remove the presences in the cache for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences_for_guild"
>clear_presences_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_roles -- Remove all role objects from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles"
>clear_roles</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_roles_for_guild -- Remove role objects from the cache for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles_for_guild"
>clear_roles_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_users -- Clear the user objects from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_users"
>clear_users</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_voice_states -- Remove all voice state objects from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states"
>clear_voice_states</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_voice_states_for_channel -- Remove the voice state objects cached for a specific channel …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_channel"
>clear_voice_states_for_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="clear_voice_states_for_guild -- Clear the voice state objects cached for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_guild"
>clear_voice_states_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_emoji -- Remove a known custom emoji from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_emoji"
>delete_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_guild -- Remove a guild object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild"
>delete_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_guild_channel -- Remove a guild channel from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild_channel"
>delete_guild_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_invite -- Remove an invite object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_invite"
>delete_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_me -- Remove the own user object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_me"
>delete_me</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_member -- Remove a member object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_member"
>delete_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_presence -- Remove a presence from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_presence"
>delete_presence</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_role -- Remove a role object form the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_role"
>delete_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_user -- Remove a user object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_user"
>delete_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="delete_voice_state -- Remove a voice state object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_voice_state"
>delete_voice_state</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_available_guild -- Get the object of an available guild from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guild"
>get_available_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_available_guilds_view -- Get a view of the available guild objects in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guilds_view"
>get_available_guilds_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_emoji -- Get a known custom emoji from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_emoji"
>get_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_emojis_view -- Get a view of the known custom emoji objects in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view"
>get_emojis_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_emojis_view_for_guild -- Get a view of the known custom emojis cached for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view_for_guild"
>get_emojis_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guild -- Get a guild from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_guild"
>get_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guild_channel -- Get a guild channel from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channel"
>get_guild_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guild_channels_view -- Get a view of the guild channels in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view"
>get_guild_channels_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_guild_channels_view_for_guild -- Get a view of the guild channels in the cache for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view_for_guild"
>get_guild_channels_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_invite -- Get an invite object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_invite"
>get_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_invites_view -- Get a view of the invite objects in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view"
>get_invites_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_invites_view_for_channel -- Get a view of the invite objects in the cache for a specified channel …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_channel"
>get_invites_view_for_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_invites_view_for_guild -- Get a view of the invite objects in the cache for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_guild"
>get_invites_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_me -- Get the own user object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_me"
>get_me</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_member -- Get a member object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_member"
>get_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_members_view -- Get a view of all the members objects in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view"
>get_members_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_members_view_for_guild -- Get a view of the members cached for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view_for_guild"
>get_members_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_presence -- Get a presence object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_presence"
>get_presence</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_presences_view -- Get a view of all the presence objects in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view"
>get_presences_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_presences_view_for_guild -- Get a view of the presence objects in the cache for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view_for_guild"
>get_presences_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_role -- Get a role object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_role"
>get_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_roles_view -- Get a view of all the role objects in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view"
>get_roles_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_roles_view_for_guild -- Get a view of the roles in the cache for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view_for_guild"
>get_roles_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_unavailable_guild -- Get the object of a unavailable guild from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guild"
>get_unavailable_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_unavailable_guilds_view -- Get a view of the unavailable guild objects in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guilds_view"
>get_unavailable_guilds_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_user -- Get a user object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_user"
>get_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_users_view -- Get a view of the user objects in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_users_view"
>get_users_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_voice_state -- Get a voice state object from the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_state"
>get_voice_state</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_voice_states_view -- Get a view of all the voice state objects in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view"
>get_voice_states_view</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_voice_states_view_for_channel -- Get a view of the voice states cached for a specific channel …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_channel"
>get_voice_states_view_for_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="get_voice_states_view_for_guild -- Get a view of the voice states cached for a specific guild …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_guild"
>get_voice_states_view_for_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_emoji -- Add a known custom emoji to the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_emoji"
>set_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_guild -- Add a guild object to the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_guild"
>set_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_guild_availability -- Set whether a cached guild is available or not …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_availability"
>set_guild_availability</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_guild_channel -- Add a guild channel to the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_channel"
>set_guild_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_invite -- Add an invite object to the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_invite"
>set_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_me -- Set the own user object in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_me"
>set_me</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_member -- Add a member object to the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_member"
>set_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_presence -- Add a presence object to the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_presence"
>set_presence</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_role -- Add a role object to the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_role"
>set_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_user -- Add a user object to the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_user"
>set_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="set_voice_state -- Add a voice state object to the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_voice_state"
>set_voice_state</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_emoji -- Update an emoji object in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_emoji"
>update_emoji</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_guild -- Update a guild in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_guild"
>update_guild</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_guild_channel -- Update a guild channel in the cache, …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_guild_channel"
>update_guild_channel</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_invite -- Update an invite in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_invite"
>update_invite</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_me -- Update the own user entry in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_me"
>update_me</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_member -- Update a member in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_member"
>update_member</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_presence -- Update a presence object in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_presence"
>update_presence</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_role -- Update a role in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_role"
>update_role</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_user -- Update a user object in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_user"
>update_user</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A standard Python function.'>def</abbr></em></small> <a title="update_voice_state -- Update a voice state object in the cache …" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_voice_state"
>update_voice_state</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L0-L1599" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Basic implementation of a cache for general bots and gateway apps.&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.List[str] = [&#34;StatefulCacheImpl&#34;]

import copy
import logging
import typing

from hikari import channels
from hikari import emojis
from hikari import errors
from hikari import guilds
from hikari import intents as intents_
from hikari import invites
from hikari import presences
from hikari import snowflakes
from hikari import undefined
from hikari import users
from hikari import voices
from hikari.api import cache
from hikari.internal import cache as cache_utility
from hikari.internal import collections

if typing.TYPE_CHECKING:
    from hikari import traits

_KeyT = typing.TypeVar(&#34;_KeyT&#34;, bound=typing.Hashable)
_LOGGER: typing.Final[logging.Logger] = logging.getLogger(&#34;hikari.cache&#34;)
_ValueT = typing.TypeVar(&#34;_ValueT&#34;)


class _VoidMapping(typing.MutableMapping[_KeyT, _ValueT]):
    &#34;&#34;&#34;A mapping object that doesn&#39;t store any objects and ignores mutation.

    This is used for cases where we&#39;d otherwise be building a new dict just to
    pass it to a chainable method and then let it fall out of scope.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = ()

    def __delitem__(self, _: _KeyT) -&gt; None:
        return None

    def __getitem__(self, key: _KeyT) -&gt; typing.NoReturn:
        raise KeyError(key)

    def __iter__(self) -&gt; typing.Iterator[_KeyT]:
        yield from ()

    def __len__(self) -&gt; typing.Literal[0]:
        return 0

    def __setitem__(self, _: _KeyT, __: _ValueT) -&gt; None:
        return None


_VOID_MAPPING: typing.Final[typing.MutableMapping[typing.Any, typing.Any]] = _VoidMapping()
&#34;&#34;&#34;A constant instance of `_VoidMapping` used within the cache.&#34;&#34;&#34;


#  TODO: do we want to hide entities that are marked as &#34;deleted&#34; and being kept alive by references?
class StatefulCacheImpl(cache.MutableCache):
    &#34;&#34;&#34;In-memory cache implementation.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_app&#34;,
        &#34;_emoji_entries&#34;,
        &#34;_guild_channel_entries&#34;,
        &#34;_guild_entries&#34;,
        &#34;_intents&#34;,
        &#34;_invite_entries&#34;,
        &#34;_me&#34;,
        &#34;_role_entries&#34;,
        &#34;_unknown_custom_emoji_entries&#34;,
        &#34;_user_entries&#34;,
    )

    # For the sake of keeping things clean, the annotations are being kept separate from the assignment here.
    _app: traits.RESTAware
    _me: typing.Optional[users.OwnUser]
    _emoji_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.KnownCustomEmojiData]
    _guild_channel_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, channels.GuildChannel]
    _guild_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.GuildRecord]
    _invite_entries: collections.ExtendedMutableMapping[str, cache_utility.InviteData]
    _role_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, guilds.Role]
    _unknown_custom_emoji_entries: collections.ExtendedMutableMapping[
        snowflakes.Snowflake,
        cache_utility.GenericRefWrapper[emojis.CustomEmoji],
    ]
    _user_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
    _intents: intents_.Intents

    def __init__(self, app: traits.RESTAware, intents: intents_.Intents) -&gt; None:
        self._app = app
        self._me = None
        self._emoji_entries = collections.FreezableDict()
        self._guild_channel_entries = collections.FreezableDict()
        self._guild_entries = collections.FreezableDict()
        self._invite_entries = collections.FreezableDict()
        self._role_entries = collections.FreezableDict()
        # This is a purely internal cache used for handling the caching and de-duplicating of the unknown custom emojis
        # found attached to cached presence activities.
        self._unknown_custom_emoji_entries = collections.FreezableDict()
        self._user_entries = collections.FreezableDict()
        self._intents = intents

    def _assert_has_intent(self, intents: intents_.Intents, /) -&gt; None:
        if self._intents ^ intents:
            raise errors.MissingIntentError(intents) from None

    def _is_intent_enabled(self, intents: intents_.Intents, /) -&gt; bool:
        return (self._intents &amp; intents) == intents

    def _build_emoji(
        self,
        emoji_data: cache_utility.KnownCustomEmojiData,
        cached_users: typing.Optional[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = None,
    ) -&gt; emojis.KnownCustomEmoji:
        user: typing.Optional[users.User] = None
        if cached_users is not None and emoji_data.user_id is not None:
            user = copy.copy(cached_users[emoji_data.user_id].object)
        elif emoji_data.user_id is not None:
            user = copy.copy(self._user_entries[emoji_data.user_id].object)

        return emoji_data.build_entity(app=self._app, user=user)

    def _increment_emoji_ref_count(self, emoji_id: snowflakes.Snowflake, increment: int = 1) -&gt; None:
        self._emoji_entries[emoji_id].ref_count += increment

    def _garbage_collect_emoji(self, emoji_id: snowflakes.Snowflake, decrement: int = 0) -&gt; None:
        emoji_data = self._emoji_entries.get(emoji_id)

        if emoji_data is None:
            return None

        emoji_data.ref_count -= decrement

        if self._can_remove_emoji(emoji_data):
            del self._emoji_entries[emoji_id]

    @staticmethod
    def _can_remove_emoji(emoji: cache_utility.KnownCustomEmojiData) -&gt; bool:
        return emoji.has_been_deleted is True and emoji.ref_count &lt; 1

    def _clear_emojis(
        self,
        guild_id: undefined.UndefinedOr[snowflakes.Snowflake] = undefined.UNDEFINED,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        emoji_ids: typing.Iterable[snowflakes.Snowflake]
        if guild_id is undefined.UNDEFINED:
            emoji_ids = self._emoji_entries.freeze()
        else:
            guild_record = self._guild_entries.get(guild_id)
            # TODO: explicit is not None vs implicit if statement consistency.
            if guild_record is None or guild_record.emojis is None:
                return cache_utility.EmptyCacheView()

            emoji_ids = guild_record.emojis
            guild_record.emojis = None
            self._remove_guild_record_if_empty(guild_id)

        cached_emojis = {}
        cached_users = {}

        for emoji_id in emoji_ids:
            emoji_data = self._emoji_entries[emoji_id]
            emoji_data.has_been_deleted = True
            if not self._can_remove_emoji(emoji_data):
                continue

            del self._emoji_entries[emoji_id]
            cached_emojis[emoji_id] = emoji_data

            if emoji_data.user_id is not None:
                cached_users[emoji_data.user_id] = self._user_entries[emoji_data.user_id]
                self._garbage_collect_user(emoji_data.user_id, decrement=1)

        return cache_utility.StatefulCacheMappingView(
            cached_emojis, builder=lambda emoji: self._build_emoji(emoji, cached_users=cached_users)
        )

    def clear_emojis(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        result = self._clear_emojis()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.emojis is not None:  # TODO: add test coverage for this.
                guild_record.emojis = None
                self._remove_guild_record_if_empty(guild_id)

        return result

    def clear_emojis_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        return self._clear_emojis(guild_id)

    def delete_emoji(self, emoji_id: snowflakes.Snowflake, /) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
        emoji_data = self._emoji_entries.pop(emoji_id, None)
        if emoji_data is None:
            return None

        emoji_data.has_been_deleted = True
        if not self._can_remove_emoji(emoji_data):
            return None

        emoji = self._build_emoji(emoji_data)

        if emoji_data.user_id is not None:
            self._garbage_collect_user(emoji_data.user_id, decrement=1)

        guild_record = self._guild_entries.get(emoji_data.guild_id)
        if guild_record and guild_record.emojis:  # TODO: should this make assumptions and be flat?
            guild_record.emojis.remove(emoji_id)

            if not guild_record.emojis:
                guild_record.emojis = None

        return emoji

    def get_emoji(self, emoji_id: snowflakes.Snowflake, /) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
        return self._build_emoji(self._emoji_entries[emoji_id]) if emoji_id in self._emoji_entries else None

    def _get_emojis_view(  # TODO: split out the two cases (specific guild vs global)
        self, guild_id: undefined.UndefinedOr[snowflakes.Snowflake] = undefined.UNDEFINED
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        cached_emojis = {}
        cached_users = {}
        emoji_ids: typing.Iterable[snowflakes.Snowflake]

        if guild_id is undefined.UNDEFINED:
            emoji_ids = self._emoji_entries.freeze()
        else:
            guild_record = self._guild_entries.get(guild_id)
            if guild_record is None or not guild_record.emojis:
                return cache_utility.EmptyCacheView()

            emoji_ids = tuple(guild_record.emojis)

        for emoji_id in emoji_ids:
            emoji_data = self._emoji_entries[emoji_id]
            cached_emojis[emoji_id] = emoji_data

            if emoji_data.user_id is not None:
                cached_users[emoji_data.user_id] = self._user_entries[emoji_data.user_id]

        return cache_utility.StatefulCacheMappingView(
            cached_emojis, builder=lambda emoji: self._build_emoji(emoji, cached_users=cached_users)
        )

    def get_emojis_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        return self._get_emojis_view()

    def get_emojis_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        return self._get_emojis_view(guild_id=guild_id)

    def set_emoji(self, emoji: emojis.KnownCustomEmoji, /) -&gt; None:
        if emoji.user is not None:
            self.set_user(emoji.user)
            if emoji.id not in self._emoji_entries:
                self._increment_user_ref_count(emoji.user.id)

        self._emoji_entries[emoji.id] = cache_utility.KnownCustomEmojiData.build_from_entity(emoji)
        guild_container = self._get_or_create_guild_record(emoji.guild_id)

        if guild_container.emojis is None:  # TODO: add test cases when it is not None?
            guild_container.emojis = collections.SnowflakeSet()

        guild_container.emojis.add(emoji.id)

    def update_emoji(
        self, emoji: emojis.KnownCustomEmoji, /
    ) -&gt; typing.Tuple[typing.Optional[emojis.KnownCustomEmoji], typing.Optional[emojis.KnownCustomEmoji]]:
        cached_emoji = self.get_emoji(emoji.id)
        self.set_emoji(emoji)
        return cached_emoji, self.get_emoji(emoji.id)

    def _remove_guild_record_if_empty(self, guild_id: snowflakes.Snowflake) -&gt; None:
        if guild_id in self._guild_entries and not self._guild_entries[guild_id]:
            del self._guild_entries[guild_id]

    def _get_or_create_guild_record(self, guild_id: snowflakes.Snowflake) -&gt; cache_utility.GuildRecord:
        if guild_id not in self._guild_entries:
            self._guild_entries[guild_id] = cache_utility.GuildRecord()

        return self._guild_entries[guild_id]

    def clear_guilds(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        cached_guilds = {}

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.guild is None:
                continue

            cached_guilds[guild_id] = guild_record.guild
            guild_record.guild = None
            guild_record.is_available = None
            self._remove_guild_record_if_empty(guild_id)

        return (
            cache_utility.StatefulCacheMappingView(cached_guilds) if cached_guilds else cache_utility.EmptyCacheView()
        )

    def delete_guild(self, guild_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.GatewayGuild]:
        if guild_id not in self._guild_entries:
            return None

        guild_record = self._guild_entries[guild_id]
        guild = guild_record.guild

        if guild is not None:
            guild_record.guild = None
            guild_record.is_available = None
            self._remove_guild_record_if_empty(guild_id)

        return guild

    def _get_guild(
        self, guild_id: snowflakes.Snowflake, /, *, availability: bool
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.guild is None or guild_record.is_available is not availability:
            return None

        return copy.copy(guild_record.guild)

    def get_guild(self, guild_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.GatewayGuild]:
        if (guild := self._get_guild(guild_id, availability=True)) is not None:
            return guild
        return self._get_guild(guild_id, availability=False)

    def get_available_guild(self, guild_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.GatewayGuild]:
        return self._get_guild(guild_id, availability=True)

    def get_unavailable_guild(self, guild_id: snowflakes.Snowflake) -&gt; typing.Optional[guilds.GatewayGuild]:
        return self._get_guild(guild_id, availability=False)

    def _get_guilds_view(self, *, availability: bool) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        entries = self._guild_entries.freeze()
        # We may have a guild record without a guild object in cases where we&#39;re caching other entities that belong to
        # the guild therefore we want to make sure record.guild isn&#39;t None.
        results = {
            sf: guild_record.guild
            for sf, guild_record in entries.items()
            if guild_record.guild and guild_record.is_available is availability
        }
        return cache_utility.StatefulCacheMappingView(results) if results else cache_utility.EmptyCacheView()

    def get_available_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        return self._get_guilds_view(availability=True)

    def get_unavailable_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        return self._get_guilds_view(availability=False)

    def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
        guild_record = self._get_or_create_guild_record(guild.id)
        guild_record.guild = copy.copy(guild)
        guild_record.is_available = True

    def set_guild_availability(self, guild_id: snowflakes.Snowflake, is_available: bool, /) -&gt; None:
        guild_record = self._guild_entries.get(guild_id)

        if guild_record is not None and guild_record.guild is not None:
            guild_record.is_available = is_available

    def update_guild(
        self, guild: guilds.GatewayGuild, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.GatewayGuild], typing.Optional[guilds.GatewayGuild]]:
        guild = copy.copy(guild)
        guild_record = self._guild_entries.get(guild.id)
        cached_guild = guild_record.guild if guild_record is not None else None

        # We have to manually update these because inconsistency by Discord.
        if cached_guild is not None:
            guild.member_count = cached_guild.member_count
            guild.joined_at = cached_guild.joined_at
            guild.is_large = cached_guild.is_large

        self.set_guild(guild)
        guild_record = self._guild_entries.get(guild.id)
        return cached_guild, guild_record.guild if guild_record is not None else None

    def clear_guild_channels(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        cached_channels = self._guild_channel_entries
        self._guild_channel_entries = collections.FreezableDict()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.channels is not None:
                guild_record.channels = None
                self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(cached_channels)

    def clear_guild_channels_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.channels is None:
            return cache_utility.EmptyCacheView()

        # Tuple casts like this avoid edge case issues which would be caused by guild_record.channels being modified
        # while we&#39;re iterating over it
        cached_channels = {sf: self._guild_channel_entries.pop(sf) for sf in tuple(guild_record.channels)}
        guild_record.channels = None
        self._remove_guild_record_if_empty(guild_id)
        return cache_utility.StatefulCacheMappingView(cached_channels)

    def delete_guild_channel(self, channel_id: snowflakes.Snowflake, /) -&gt; typing.Optional[channels.GuildChannel]:
        channel = self._guild_channel_entries.pop(channel_id, None)

        if channel is None:
            return None

        # TODO: flat and make assumptions?
        guild_record = self._guild_entries.get(channel.guild_id)
        if guild_record and guild_record.channels is not None:
            guild_record.channels.remove(channel_id)
            if not guild_record.channels:
                guild_record.channels = None
                self._remove_guild_record_if_empty(channel.guild_id)

        return channel

    def get_guild_channel(self, channel_id: snowflakes.Snowflake, /) -&gt; typing.Optional[channels.GuildChannel]:
        channel = self._guild_channel_entries.get(channel_id)
        return cache_utility.copy_guild_channel(channel) if channel is not None else None

    def get_guild_channels_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        return cache_utility.GuildChannelCacheMappingView(self._guild_channel_entries.freeze())

    def get_guild_channels_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or not guild_record.channels:
            return cache_utility.EmptyCacheView()

        # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
        # iterating over them.
        cached_channels = {sf: self._guild_channel_entries[sf] for sf in tuple(guild_record.channels)}

        def sorter(args: typing.Tuple[snowflakes.Snowflake, channels.GuildChannel]) -&gt; typing.Tuple[int, int, int]:
            channel = args[1]
            if isinstance(channel, channels.GuildCategory):
                return channel.position, -1, 0

            parent_position = -1 if channel.parent_id is None else cached_channels[channel.parent_id].position

            if not isinstance(channel, channels.GuildVoiceChannel):
                return parent_position, 0, channel.position

            return parent_position, 1, channel.position

        cached_channels = dict(sorted(cached_channels.items(), key=sorter))
        return cache_utility.GuildChannelCacheMappingView(cached_channels)

    def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
        self._guild_channel_entries[channel.id] = cache_utility.copy_guild_channel(channel)
        guild_record = self._get_or_create_guild_record(channel.guild_id)

        if guild_record.channels is None:
            guild_record.channels = collections.SnowflakeSet()

        guild_record.channels.add(channel.id)

    def update_guild_channel(
        self, channel: channels.GuildChannel, /
    ) -&gt; typing.Tuple[typing.Optional[channels.GuildChannel], typing.Optional[channels.GuildChannel]]:
        cached_channel = self.get_guild_channel(channel.id)
        self.set_guild_channel(channel)
        return cached_channel, self.get_guild_channel(channel.id)

    def _build_invite(
        self,
        invite_data: cache_utility.InviteData,
        cached_users: undefined.UndefinedOr[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = undefined.UNDEFINED,
    ) -&gt; invites.InviteWithMetadata:
        inviter: typing.Optional[users.User] = None
        if cached_users is not undefined.UNDEFINED and invite_data.inviter_id is not None:
            inviter = copy.copy(cached_users[invite_data.inviter_id].object)
        elif invite_data.inviter_id is not None:
            inviter = copy.copy(self._user_entries[invite_data.inviter_id].object)

        target_user: typing.Optional[users.User] = None
        if cached_users is not undefined.UNDEFINED and invite_data.target_user_id is not None:
            target_user = copy.copy(cached_users[invite_data.target_user_id].object)
        elif invite_data.target_user_id is not None:
            target_user = copy.copy(self._user_entries[invite_data.target_user_id].object)

        return invite_data.build_entity(app=self._app, inviter=inviter, target_user=target_user)

    def _clear_invites(  # TODO: split out into two cases (global and specific guild)
        self,
        guild_id: undefined.UndefinedOr[snowflakes.Snowflake] = undefined.UNDEFINED,
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        invite_codes: typing.Iterable[str]
        if guild_id is not undefined.UNDEFINED:
            guild_record = self._guild_entries.get(guild_id)

            if guild_record is None or guild_record.invites is None:
                return cache_utility.EmptyCacheView()

            # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
            # iterating over them.
            invite_codes = tuple(guild_record.invites)
            guild_record.invites = None
            self._remove_guild_record_if_empty(guild_id)

        else:
            invite_codes = self._invite_entries.freeze()

        cached_invites = {}
        cached_users = {}

        for code in invite_codes:
            invite_data = self._invite_entries.pop(code)
            cached_invites[code] = invite_data

            if invite_data.inviter_id is not None:
                cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]
                self._garbage_collect_user(invite_data.inviter_id, decrement=1)

            if invite_data.target_user_id is not None:
                cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]
                self._garbage_collect_user(invite_data.target_user_id, decrement=1)

        return cache_utility.StatefulCacheMappingView(
            cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
        )

    def clear_invites(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        return self._clear_invites()

    def clear_invites_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        return self._clear_invites(guild_id=guild_id)

    def clear_invites_for_channel(
        self, guild_id: snowflakes.Snowflake, channel_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.invites is None:
            return cache_utility.EmptyCacheView()

        cached_invites = {}
        cached_users = {}

        # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
        # iterating over them.
        for code in tuple(guild_record.invites):
            invite_data = self._invite_entries[code]
            if invite_data.channel_id != channel_id:
                continue

            cached_invites[code] = invite_data
            del self._invite_entries[code]
            guild_record.invites.remove(code)

            if invite_data.inviter_id is not None:
                cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]
                self._garbage_collect_user(invite_data.inviter_id, decrement=1)

            if invite_data.target_user_id is not None:
                cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]
                self._garbage_collect_user(invite_data.target_user_id, decrement=1)

        if not guild_record.invites:
            guild_record.invites = None
            self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(
            cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
        )

    def delete_invite(self, code: str, /) -&gt; typing.Optional[invites.InviteWithMetadata]:
        if code not in self._invite_entries:
            return None

        invite = self._build_invite(self._invite_entries.pop(code))

        if invite.inviter is not None:
            self._garbage_collect_user(invite.inviter.id, decrement=1)

        if invite.target_user is not None:
            self._garbage_collect_user(invite.target_user.id, decrement=1)

        if invite.guild_id is not None:  # TODO: test case when this is None?
            guild_record = self._guild_entries.get(invite.guild_id)
            if guild_record and guild_record.invites is not None:
                guild_record.invites.remove(code)

                if not guild_record.invites:
                    guild_record.invites = None  # TODO: test when this is set to None
                    self._remove_guild_record_if_empty(invite.guild_id)

        return invite

    def get_invite(self, code: str, /) -&gt; typing.Optional[invites.InviteWithMetadata]:
        return self._build_invite(self._invite_entries[code]) if code in self._invite_entries else None

    def _get_invites_view(  # TODO: split out into two separate cases (global and specific guild)
        self, guild_id: undefined.UndefinedOr[snowflakes.Snowflake] = undefined.UNDEFINED
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        invite_ids: typing.Iterable[str]
        if guild_id is undefined.UNDEFINED:
            invite_ids = self._invite_entries.freeze()

        else:
            guild_entry = self._guild_entries.get(guild_id)
            if guild_entry is None or guild_entry.invites is None:
                return cache_utility.EmptyCacheView()

            # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
            # iterating over them.
            invite_ids = tuple(guild_entry.invites)

        cached_invites = {}
        cached_users = {}

        for code in invite_ids:
            invite_data = self._invite_entries[code]
            cached_invites[code] = invite_data

            if invite_data.inviter_id is not None:
                cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]

            if invite_data.target_user_id is not None:
                cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]

        return cache_utility.StatefulCacheMappingView(
            cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
        )

    def get_invites_view(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        return self._get_invites_view()

    def get_invites_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        return self._get_invites_view(guild_id=guild_id)

    def get_invites_view_for_channel(
        self,
        guild_id: snowflakes.Snowflake,
        channel_id: snowflakes.Snowflake,
        /,
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        guild_entry = self._guild_entries.get(guild_id)
        if guild_entry is None or guild_entry.invites is None:
            return cache_utility.EmptyCacheView()

        cached_invites = {}
        cached_users = {}
        invite_ids: typing.Iterable[str]

        # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
        # iterating over them.
        for code in tuple(guild_entry.invites):
            invite_data = self._invite_entries[code]
            if invite_data.channel_id != channel_id:
                continue

            cached_invites[code] = invite_data
            guild_entry.invites.remove(code)
            del self._invite_entries[code]

            if invite_data.inviter_id is not None:
                cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]

            if invite_data.target_user_id is not None:
                cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]

        if not guild_entry.channels:  # TODO: test coverage
            guild_entry.channels = None
            self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(
            cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
        )

    def set_invite(self, invite: invites.InviteWithMetadata, /) -&gt; None:
        if invite.inviter is not None:
            self.set_user(invite.inviter)
            if invite.code not in self._invite_entries:
                self._increment_user_ref_count(invite.inviter.id)

        if invite.target_user is not None:
            self.set_user(invite.target_user)
            if invite.code not in self._invite_entries:
                self._increment_user_ref_count(invite.target_user.id)

        self._invite_entries[invite.code] = cache_utility.InviteData.build_from_entity(invite)
        if invite.guild_id:
            guild_entry = self._get_or_create_guild_record(invite.guild_id)

            if guild_entry.invites is None:
                guild_entry.invites = []

            guild_entry.invites.append(invite.code)

    def update_invite(
        self, invite: invites.InviteWithMetadata, /
    ) -&gt; typing.Tuple[typing.Optional[invites.InviteWithMetadata], typing.Optional[invites.InviteWithMetadata]]:
        cached_invite = self.get_invite(invite.code)
        self.set_invite(invite)
        return cached_invite, self.get_invite(invite.code)

    def delete_me(self) -&gt; typing.Optional[users.OwnUser]:
        cached_user = self._me
        self._me = None
        return cached_user

    def get_me(self) -&gt; typing.Optional[users.OwnUser]:
        return copy.copy(self._me)

    def set_me(self, user: users.OwnUser, /) -&gt; None:
        self._me = copy.copy(user)

    def update_me(
        self, user: users.OwnUser, /
    ) -&gt; typing.Tuple[typing.Optional[users.OwnUser], typing.Optional[users.OwnUser]]:
        _LOGGER.debug(&#34;setting my user to %s&#34;, user)
        cached_user = self.get_me()
        self.set_me(user)
        return cached_user, self._me

    def _build_member(
        self,
        member_data: cache_utility.MemberData,
        cached_users: typing.Optional[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = None,
    ) -&gt; guilds.Member:
        if cached_users is None:
            user = copy.copy(self._user_entries[member_data.id].object)
        else:
            user = copy.copy(cached_users[member_data.id].object)

        return member_data.build_entity(user=user)

    @staticmethod
    def _can_remove_member(member: cache_utility.MemberData, guild_record: cache_utility.GuildRecord) -&gt; bool:
        if member.has_been_deleted is False:
            return False

        return bool(not guild_record.voice_states or member.id not in guild_record.voice_states)

    def _garbage_collect_member(
        self, guild_record: cache_utility.GuildRecord, member: cache_utility.MemberData
    ) -&gt; None:
        if guild_record.members is None or member.id not in guild_record.members:
            return

        if not self._can_remove_member(member, guild_record):
            return

        del guild_record.members[member.id]
        if not guild_record.members:
            guild_record.members = None
            self._remove_guild_record_if_empty(member.guild_id)

    def _chainable_remove_member(
        self,
        member: cache_utility.MemberData,
        guild_record: cache_utility.GuildRecord,
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; typing.Optional[cache_utility.MemberData]:
        assert guild_record.members is not None
        member.has_been_deleted = True
        if not self._can_remove_member(member, guild_record):
            return None

        if member.id not in cached_users:
            cached_users[member.id] = self._user_entries[member.id]

        self._garbage_collect_user(member.id, decrement=1)
        del guild_record.members[member.id]

        if not guild_record.members:
            guild_record.members = None
            self._remove_guild_record_if_empty(member.guild_id)

        return member

    def clear_members(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
        views = {}
        cached_users = self._user_entries.freeze()

        def build_member(member: cache_utility.MemberData) -&gt; guilds.Member:
            return self._build_member(member, cached_users=cached_users)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.members:
                continue

            #  This takes roughly half the time a two-layered for loop where we
            #  assign to the members dict on every inner-iteration takes.
            members_gen = (
                self._chainable_remove_member(m, guild_record, _VOID_MAPPING)
                for m in guild_record.members.freeze().values()
            )
            # _chainable_remove_member will only return the member data object if they could be removed, else None.
            cached_members = {member.id: member for member in members_gen if member is not None}
            views[guild_id] = cache_utility.StatefulCacheMappingView(cached_members, builder=build_member)

        return cache_utility.StatefulCacheMappingView(views)

    def clear_members_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.members is None:
            return cache_utility.EmptyCacheView()

        cached_members = guild_record.members.freeze()
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        members_gen = (self._chainable_remove_member(m, guild_record, cached_users) for m in cached_members.values())
        # _chainable_remove_member will only return the member data object if they could be removed, else None.
        cached_members = {member.id: member for member in members_gen if member is not None}
        return cache_utility.StatefulCacheMappingView(
            cached_members, builder=lambda member: self._build_member(member, cached_users=cached_users)
        )

    def delete_member(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[guilds.Member]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.members is None:
            return None

        member_data = guild_record.members.get(user_id)
        if member_data is None:
            return None

        member = self._build_member(member_data)
        # _chainable_remove_member will only return the member data object if they could be removed, else None.
        return member if self._chainable_remove_member(member_data, guild_record, _VOID_MAPPING) is not None else None

    def get_member(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[guilds.Member]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.members is None:
            return None

        member = guild_record.members.get(user_id)
        return self._build_member(member) if member is not None else None

    def get_members_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
        cached_users = self._user_entries.freeze()

        def member_builder(member: cache_utility.MemberData) -&gt; guilds.Member:
            return self._build_member(member, cached_users=cached_users)

        return cache_utility.Cache3DMappingView(
            {
                guild_id: cache_utility.StatefulCacheMappingView(view.members, builder=member_builder)
                for guild_id, view in self._guild_entries.freeze().items()
                if view.members
            }
        )

    def get_members_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.members is None:
            return cache_utility.EmptyCacheView()

        cached_members = {
            user_id: member for user_id, member in guild_record.members.freeze().items() if not member.has_been_deleted
        }
        cached_users = {user_id: self._user_entries[user_id] for user_id in cached_members}

        return cache_utility.StatefulCacheMappingView(
            cached_members, builder=lambda member: self._build_member(member, cached_users=cached_users)
        )

    def set_member(self, member: guilds.Member, /) -&gt; None:
        guild_record = self._get_or_create_guild_record(member.guild_id)
        self.set_user(member.user)
        member_data = cache_utility.MemberData.build_from_entity(member)

        if guild_record.members is None:  # TODO: test when this is not None
            guild_record.members = collections.FreezableDict()

        if member.user.id not in guild_record.members:
            self._increment_user_ref_count(member.user.id)

        guild_record.members[member_data.id] = member_data

    def update_member(
        self, member: guilds.Member, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.Member], typing.Optional[guilds.Member]]:
        cached_member = self.get_member(member.guild_id, member.user.id)
        self.set_member(member)
        return cached_member, self.get_member(member.guild_id, member.user.id)

    def _build_presence(
        self,
        presence_data: cache_utility.MemberPresenceData,
        cached_emojis: typing.Optional[
            typing.Mapping[
                snowflakes.Snowflake,
                typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
            ]
        ] = None,
        cached_users: typing.Optional[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = None,
    ) -&gt; presences.MemberPresence:
        presence_kwargs: typing.MutableSequence[typing.Mapping[str, typing.Optional[emojis.Emoji]]] = []
        for activity_data in presence_data.activities:
            identifier = activity_data.emoji_id_or_name
            if identifier is None:
                presence_kwargs.append({&#34;emoji&#34;: None})

            elif isinstance(identifier, str):
                presence_kwargs.append({&#34;emoji&#34;: emojis.UnicodeEmoji(identifier)})

            elif cached_emojis:
                emoji = cached_emojis[identifier]
                if isinstance(emoji, cache_utility.KnownCustomEmojiData):
                    presence_kwargs.append({&#34;emoji&#34;: self._build_emoji(emoji, cached_users=cached_users)})
                else:
                    presence_kwargs.append({&#34;emoji&#34;: copy.copy(emoji.object)})

            elif identifier in self._emoji_entries:
                presence_kwargs.append(
                    {&#34;emoji&#34;: self._build_emoji(self._emoji_entries[identifier], cached_users=cached_users)}
                )

            else:
                presence_kwargs.append({&#34;emoji&#34;: copy.copy(self._unknown_custom_emoji_entries[identifier].object)})

        return presence_data.build_entity(app=self._app, presence_kwargs=presence_kwargs)

    def _garbage_collect_unknown_custom_emoji(self, emoji_id: snowflakes.Snowflake, decrement: int = 0) -&gt; None:
        emoji = self._unknown_custom_emoji_entries.get(emoji_id)
        if emoji is None:
            return None

        emoji.ref_count -= decrement
        if emoji.ref_count &lt; 1:
            del self._unknown_custom_emoji_entries[emoji_id]

    def _chainable_remove_presence_assets(
        self,
        presence_data: cache_utility.MemberPresenceData,
        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.KnownCustomEmojiData, cache_utility.GenericRefWrapper[emojis.CustomEmoji]],
        ],
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; None:
        for activity_data in presence_data.activities:
            emoji_identifier = activity_data.emoji_id_or_name
            if emoji_identifier is None or isinstance(emoji_identifier, str):
                continue

            if emoji_identifier in self._emoji_entries:
                if emoji_identifier not in cached_emojis:
                    known_emoji_data = self._emoji_entries[emoji_identifier]

                    if known_emoji_data.user_id is not None and known_emoji_data.user_id not in cached_users:
                        cached_users[known_emoji_data.user_id] = self._user_entries[known_emoji_data.user_id]

                    cached_emojis[emoji_identifier] = known_emoji_data

                self._garbage_collect_emoji(emoji_identifier, decrement=-1)

            else:
                if emoji_identifier not in cached_emojis:
                    cached_emojis[emoji_identifier] = self._unknown_custom_emoji_entries[emoji_identifier]

                self._garbage_collect_unknown_custom_emoji(emoji_identifier, decrement=1)

    def clear_presences(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
        views = {}
        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        def build_presence(presence: cache_utility.MemberPresenceData) -&gt; presences.MemberPresence:
            return self._build_presence(presence, cached_users=cached_users, cached_emojis=cached_emojis)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.presences:
                continue

            cached_presences: typing.MutableMapping[
                snowflakes.Snowflake, cache_utility.MemberPresenceData
            ] = guild_record.presences
            guild_record.presences = None

            for presence in cached_presences.values():
                self._chainable_remove_presence_assets(presence, cached_emojis, cached_users)

            self._remove_guild_record_if_empty(guild_id)
            views[guild_id] = cache_utility.StatefulCacheMappingView(cached_presences, builder=build_presence)

        return cache_utility.StatefulCacheMappingView(views)

    def clear_presences_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.presences is None:
            return cache_utility.EmptyCacheView()

        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_presences: typing.MutableMapping[
            snowflakes.Snowflake, cache_utility.MemberPresenceData
        ] = guild_record.presences
        guild_record.presences = None

        for presence in cached_presences.values():
            self._chainable_remove_presence_assets(presence, cached_emojis, cached_users)

        self._remove_guild_record_if_empty(guild_id)
        return cache_utility.StatefulCacheMappingView(
            cached_presences,
            builder=lambda presence_data_: self._build_presence(
                presence_data_, cached_users=cached_users, cached_emojis=cached_emojis
            ),
        )

    def delete_presence(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[presences.MemberPresence]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.presences is None:
            return None

        presence_data = guild_record.presences.pop(user_id, None)

        if presence_data is None:
            return None

        presence = self._build_presence(presence_data)
        # _VOID_MAPPING is used here to avoid duplicating logic as we don&#39;t actually care about the assets there were
        # removed in this case as we&#39;ve already built the presence.
        self._chainable_remove_presence_assets(presence_data, _VOID_MAPPING, _VOID_MAPPING)

        if not guild_record.presences:
            guild_record.presences = None
            self._remove_guild_record_if_empty(guild_id)

        return presence

    def get_presence(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[presences.MemberPresence]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.presences is None:
            return None

        return self._build_presence(guild_record.presences[user_id]) if user_id in guild_record.presences else None

    def _chainable_get_presence_assets(
        self,
        presence_data: cache_utility.MemberPresenceData,
        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.KnownCustomEmojiData, cache_utility.GenericRefWrapper[emojis.CustomEmoji]],
        ],
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; None:
        for activity_data in presence_data.activities:
            emoji_identifier = activity_data.emoji_id_or_name

            if emoji_identifier is None or isinstance(emoji_identifier, str) or emoji_identifier in cached_emojis:
                continue

            if emoji_identifier in self._emoji_entries:
                emoji_data = self._emoji_entries[emoji_identifier]

                if emoji_data.user_id is not None and emoji_data.user_id not in cached_users:
                    cached_users[emoji_data.user_id] = self._user_entries[emoji_data.user_id]

                cached_emojis[emoji_identifier] = emoji_data

            else:
                cached_emojis[emoji_identifier] = self._unknown_custom_emoji_entries[emoji_identifier]

    def get_presences_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
        views = {}

        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
        ] = self._unknown_custom_emoji_entries.freeze()  # type: ignore[assignment]  # TODO: open mypy issue
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        def presence_builder(presence: cache_utility.MemberPresenceData) -&gt; presences.MemberPresence:
            return self._build_presence(presence, cached_users=cached_users, cached_emojis=cached_emojis)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.presences:
                continue

            cached_presences = guild_record.presences.freeze()

            for presence in cached_presences.values():
                self._chainable_get_presence_assets(presence, cached_emojis, cached_users)

            views[guild_id] = cache_utility.StatefulCacheMappingView(cached_presences, builder=presence_builder)

        return cache_utility.Cache3DMappingView(views)

    def get_presences_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.presences is None:
            return cache_utility.EmptyCacheView()

        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_presences = guild_record.presences.freeze()

        for presence in cached_presences.values():
            self._chainable_get_presence_assets(presence, cached_emojis, cached_users)

        return cache_utility.StatefulCacheMappingView(
            cached_presences,
            builder=lambda presence_data_: self._build_presence(
                presence_data_, cached_users=cached_users, cached_emojis=cached_emojis
            ),
        )

    def set_presence(self, presence: presences.MemberPresence, /) -&gt; None:
        presence_data = cache_utility.MemberPresenceData.build_from_entity(presence)

        for activity in presence.activities:
            emoji = activity.emoji
            if emoji is None or not isinstance(emoji, emojis.CustomEmoji):
                continue

            if emoji.id in self._emoji_entries:
                self._increment_emoji_ref_count(emoji.id)

            elif emoji.id in self._unknown_custom_emoji_entries:
                self._unknown_custom_emoji_entries[emoji.id].ref_count += 1
                self._unknown_custom_emoji_entries[emoji.id].object = copy.copy(emoji)

            else:
                self._unknown_custom_emoji_entries[emoji.id] = cache_utility.GenericRefWrapper(
                    object=copy.copy(emoji), ref_count=1
                )

        guild_record = self._get_or_create_guild_record(presence.guild_id)
        if guild_record.presences is None:
            guild_record.presences = collections.FreezableDict()

        guild_record.presences[presence.user_id] = presence_data

    def update_presence(
        self, presence: presences.MemberPresence, /
    ) -&gt; typing.Tuple[typing.Optional[presences.MemberPresence], typing.Optional[presences.MemberPresence]]:
        cached_presence = self.get_presence(presence.guild_id, presence.user_id)
        self.set_presence(presence)
        return cached_presence, self.get_presence(presence.guild_id, presence.user_id)

    def clear_roles(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._role_entries:
            return cache_utility.EmptyCacheView()

        roles = self._role_entries
        self._role_entries = collections.FreezableDict()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.roles is not None:  # TODO: test coverage for this
                guild_record.roles = None
                self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(roles)

    def clear_roles_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or not guild_record.roles:
            return cache_utility.EmptyCacheView()

        view = cache_utility.StatefulCacheMappingView(
            {role_id: self._role_entries[role_id] for role_id in guild_record.roles}
        )
        guild_record.roles = None
        self._remove_guild_record_if_empty(guild_id)
        return view

    def delete_role(self, role_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.Role]:
        role = self._role_entries.pop(role_id, None)
        if role is None:
            return None

        guild_record = self._guild_entries.get(role.guild_id)
        if guild_record and guild_record.roles is not None:
            guild_record.roles.remove(role_id)

            if not guild_record.roles:  # TODO: should this make assumptions and be flat?
                guild_record.roles = None
                self._remove_guild_record_if_empty(role.guild_id)

        return role

    def get_role(self, role_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.Role]:
        return self._role_entries.get(role_id)

    def get_roles_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        cached_roles = self._role_entries.freeze()
        return cache_utility.StatefulCacheMappingView(cached_roles)

    def get_roles_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.roles is None:
            return cache_utility.EmptyCacheView()

        # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
        # iterating over them.
        return cache_utility.StatefulCacheMappingView(
            {role_id: self._role_entries[role_id] for role_id in tuple(guild_record.roles)}
        )

    def set_role(self, role: guilds.Role, /) -&gt; None:
        self._role_entries[role.id] = role
        guild_record = self._get_or_create_guild_record(role.guild_id)

        if guild_record.roles is None:  # TODO: test when this is not None
            guild_record.roles = collections.SnowflakeSet()

        guild_record.roles.add(role.id)

    def update_role(
        self, role: guilds.Role, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.Role], typing.Optional[guilds.Role]]:
        cached_role = self.get_role(role.id)
        self.set_role(role)
        return cached_role, self.get_role(role.id)

    @staticmethod
    def _can_remove_user(user_data: typing.Optional[cache_utility.GenericRefWrapper[users.User]]) -&gt; bool:
        return bool(user_data and user_data.ref_count == 0)

    def _increment_user_ref_count(self, user_id: snowflakes.Snowflake, increment: int = 1) -&gt; None:
        self._user_entries[user_id].ref_count += increment

    def _garbage_collect_user(self, user_id: snowflakes.Snowflake, *, decrement: typing.Optional[int] = None) -&gt; None:
        if decrement is not None and user_id in self._user_entries:
            self._increment_user_ref_count(user_id, -decrement)

        if self._can_remove_user(self._user_entries.get(user_id)):
            del self._user_entries[user_id]

    def clear_users(self) -&gt; cache.CacheView[snowflakes.Snowflake, users.User]:
        if not self._user_entries:
            return cache_utility.EmptyCacheView()

        cached_users = {}

        for user_id, user in self._user_entries.freeze().items():
            if user.ref_count &gt; 0:
                continue

            cached_users[user_id] = user.object
            del self._user_entries[user_id]

        return cache_utility.StatefulCacheMappingView(cached_users) if cached_users else cache_utility.EmptyCacheView()

    def delete_user(self, user_id: snowflakes.Snowflake, /) -&gt; typing.Optional[users.User]:
        if self._can_remove_user(self._user_entries.get(user_id)):
            return self._user_entries.pop(user_id).object

        return None

    def get_user(self, user_id: snowflakes.Snowflake, /) -&gt; typing.Optional[users.User]:
        return copy.copy(self._user_entries[user_id].object) if user_id in self._user_entries else None

    def get_users_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, users.User]:
        if not self._user_entries:
            return cache_utility.EmptyCacheView()

        cached_users = self._user_entries.freeze()
        return cache_utility.StatefulCacheMappingView(cached_users, unpack=True)

    def set_user(self, user: users.User, /) -&gt; None:
        try:
            self._user_entries[user.id].object = copy.copy(user)
        except KeyError:
            self._user_entries[user.id] = cache_utility.GenericRefWrapper(object=copy.copy(user), ref_count=0)

    def update_user(
        self, user: users.User, /
    ) -&gt; typing.Tuple[typing.Optional[users.User], typing.Optional[users.User]]:
        cached_user = self.get_user(user.id)
        self.set_user(user)
        return cached_user, self.get_user(user.id)

    def _build_voice_state(
        self,
        voice_data: cache_utility.VoiceStateData,
        cached_members: typing.Optional[typing.Mapping[snowflakes.Snowflake, cache_utility.MemberData]] = None,
        cached_users: typing.Optional[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = None,
    ) -&gt; voices.VoiceState:
        if cached_members:
            member = self._build_member(cached_members[voice_data.user_id], cached_users=cached_users)
        else:
            guild_record = self._guild_entries[voice_data.guild_id]
            assert guild_record.members is not None
            member_data = guild_record.members[voice_data.user_id]
            member = self._build_member(member_data, cached_users=cached_users)

        return voice_data.build_entity(app=self._app, member=member)

    def _chainable_remove_voice_state_assets(
        self,
        voice_state: cache_utility.VoiceStateData,
        guild_record: cache_utility.GuildRecord,
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData],
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; None:
        assert guild_record.members is not None
        member = guild_record.members[voice_state.user_id]
        cached_members[voice_state.user_id] = member

        if voice_state.user_id not in cached_users:
            cached_users[voice_state.user_id] = self._user_entries[voice_state.user_id]

        self._garbage_collect_member(guild_record, member)

    def clear_voice_states(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
        views: typing.MutableMapping[
            snowflakes.Snowflake, cache_utility.StatefulCacheMappingView[snowflakes.Snowflake, voices.VoiceState]
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        def builder_generator(
            cached_members_: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData]
        ) -&gt; typing.Callable[[cache_utility.VoiceStateData], voices.VoiceState]:
            return lambda voice_data: self._build_voice_state(
                voice_data, cached_members=cached_members_, cached_users=cached_users
            )

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.voice_states:
                continue

            assert guild_record.members is not None
            cached_voice_states = guild_record.voice_states
            guild_record.voice_states = None
            cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}

            for voice_state in cached_voice_states.values():
                self._chainable_remove_voice_state_assets(voice_state, guild_record, cached_members, cached_users)

            self._remove_guild_record_if_empty(guild_id)
            views[guild_id] = cache_utility.StatefulCacheMappingView(
                cached_voice_states, builder=builder_generator(cached_members)
            )

        return cache_utility.StatefulCacheMappingView(views)

    def clear_voice_states_for_channel(
        self, guild_id: snowflakes.Snowflake, channel_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        assert guild_record.members is not None
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_voice_states = {}

        for user_id, voice_state in guild_record.voice_states.items():
            if voice_state.channel_id == channel_id:
                cached_voice_states[voice_state.user_id] = voice_state
                self._chainable_remove_voice_state_assets(voice_state, guild_record, cached_members, cached_users)

        if not guild_record.voice_states:
            guild_record.voice_states = None
            self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(
            cached_voice_states,
            builder=lambda voice_state: self._build_voice_state(
                voice_state, cached_members=cached_members, cached_users=cached_users
            ),
        )

    def clear_voice_states_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)

        if guild_record is None or guild_record.voice_states is None:
            return cache_utility.EmptyCacheView()

        assert guild_record.members is not None
        cached_voice_states = guild_record.voice_states
        guild_record.voice_states = None
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        for voice_state in cached_voice_states.values():
            self._chainable_remove_voice_state_assets(voice_state, guild_record, cached_members, cached_users)

        self._remove_guild_record_if_empty(guild_id)
        return cache_utility.StatefulCacheMappingView(
            cached_voice_states,
            builder=lambda voice_data: self._build_voice_state(
                voice_data, cached_members=cached_members, cached_users=cached_users
            ),
        )

    def delete_voice_state(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None:
            return None

        voice_state_data = guild_record.voice_states.pop(user_id, None) if guild_record.voice_states else None
        if voice_state_data is None:
            return None

        if not guild_record.voice_states:
            guild_record.voice_states = None

        voice_state = self._build_voice_state(voice_state_data)
        self._chainable_remove_voice_state_assets(voice_state_data, guild_record, _VOID_MAPPING, _VOID_MAPPING)
        self._remove_guild_record_if_empty(guild_id)
        return voice_state

    def get_voice_state(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        voice_data = guild_record.voice_states.get(user_id) if guild_record and guild_record.voice_states else None
        return self._build_voice_state(voice_data) if voice_data else None

    def _chainable_get_voice_states_assets(
        self,
        voice_state: cache_utility.VoiceStateData,
        guild_record: cache_utility.GuildRecord,
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData],
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; None:
        assert guild_record.members is not None
        cached_members[voice_state.user_id] = guild_record.members[voice_state.user_id]

        if voice_state.user_id not in cached_users:
            cached_users[voice_state.user_id] = self._user_entries[voice_state.user_id]

    def get_voice_states_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
        views: typing.MutableMapping[
            snowflakes.Snowflake, cache_utility.StatefulCacheMappingView[snowflakes.Snowflake, voices.VoiceState]
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData]

        def builder_generator(
            cached_members_: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData]
        ) -&gt; typing.Callable[[cache_utility.VoiceStateData], voices.VoiceState]:
            return lambda voice_state_: self._build_voice_state(
                voice_state_, cached_members=cached_members_, cached_users=cached_users
            )

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.voice_states:
                continue

            cached_voice_states = guild_record.voice_states.freeze()
            cached_members = {}

            for voice_state in cached_voice_states.values():
                self._chainable_get_voice_states_assets(voice_state, guild_record, cached_members, cached_users)

            views[guild_id] = cache_utility.StatefulCacheMappingView(
                cached_voice_states, builder=builder_generator(cached_members)
            )

        return cache_utility.Cache3DMappingView(views)

    def get_voice_states_view_for_channel(
        self, guild_id: snowflakes.Snowflake, channel_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.voice_states is None:
            return cache_utility.EmptyCacheView()

        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_voice_states = guild_record.voice_states.freeze()

        for voice_state in cached_voice_states.values():
            if voice_state.channel_id == channel_id:
                self._chainable_get_voice_states_assets(voice_state, guild_record, cached_members, cached_users)

        return cache_utility.StatefulCacheMappingView(
            cached_voice_states,
            builder=lambda voice_data: self._build_voice_state(
                voice_data, cached_members=cached_members, cached_users=cached_users
            ),
        )

    def get_voice_states_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.voice_states is None:
            return cache_utility.EmptyCacheView()

        voice_states = guild_record.voice_states.freeze()
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        for voice_state in voice_states.values():
            self._chainable_get_voice_states_assets(voice_state, guild_record, cached_members, cached_users)

        return cache_utility.StatefulCacheMappingView(
            voice_states,
            builder=lambda voice_data: self._build_voice_state(
                voice_data, cached_members=cached_members, cached_users=cached_users
            ),
        )

    def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
        guild_record = self._get_or_create_guild_record(voice_state.guild_id)

        if guild_record.voice_states is None:  # TODO: test when this is not None
            guild_record.voice_states = collections.FreezableDict()

        # TODO: account for this method not setting the member in some cases later on
        self.set_member(voice_state.member)
        assert guild_record.members is not None
        guild_record.members[voice_state.member.id].has_been_deleted = True
        guild_record.voice_states[voice_state.user_id] = cache_utility.VoiceStateData.build_from_entity(voice_state)

    def update_voice_state(
        self, voice_state: voices.VoiceState, /
    ) -&gt; typing.Tuple[typing.Optional[voices.VoiceState], typing.Optional[voices.VoiceState]]:
        cached_voice_state = self.get_voice_state(voice_state.guild_id, voice_state.user_id)
        self.set_voice_state(voice_state)
        return cached_voice_state, self.get_voice_state(voice_state.guild_id, voice_state.user_id)</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="StatefulCacheImpl -- In-memory cache implementation." href="#hikari.impl.stateful_cache.StatefulCacheImpl"
>StatefulCacheImpl</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl" class="hljs python"><abbr title='A standard Python type.'>class</abbr> StatefulCacheImpl (
    app: <a href='../traits.html#hikari.traits.RESTAware'>traits.RESTAware</a>,
    intents: <a href='../intents.html#hikari.intents.Intents'>intents_.Intents</a>,
): ...</code></pre>
<p>In-memory cache implementation.</p>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L85-L1600" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class StatefulCacheImpl(cache.MutableCache):
    &#34;&#34;&#34;In-memory cache implementation.&#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_app&#34;,
        &#34;_emoji_entries&#34;,
        &#34;_guild_channel_entries&#34;,
        &#34;_guild_entries&#34;,
        &#34;_intents&#34;,
        &#34;_invite_entries&#34;,
        &#34;_me&#34;,
        &#34;_role_entries&#34;,
        &#34;_unknown_custom_emoji_entries&#34;,
        &#34;_user_entries&#34;,
    )

    # For the sake of keeping things clean, the annotations are being kept separate from the assignment here.
    _app: traits.RESTAware
    _me: typing.Optional[users.OwnUser]
    _emoji_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.KnownCustomEmojiData]
    _guild_channel_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, channels.GuildChannel]
    _guild_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.GuildRecord]
    _invite_entries: collections.ExtendedMutableMapping[str, cache_utility.InviteData]
    _role_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, guilds.Role]
    _unknown_custom_emoji_entries: collections.ExtendedMutableMapping[
        snowflakes.Snowflake,
        cache_utility.GenericRefWrapper[emojis.CustomEmoji],
    ]
    _user_entries: collections.ExtendedMutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
    _intents: intents_.Intents

    def __init__(self, app: traits.RESTAware, intents: intents_.Intents) -&gt; None:
        self._app = app
        self._me = None
        self._emoji_entries = collections.FreezableDict()
        self._guild_channel_entries = collections.FreezableDict()
        self._guild_entries = collections.FreezableDict()
        self._invite_entries = collections.FreezableDict()
        self._role_entries = collections.FreezableDict()
        # This is a purely internal cache used for handling the caching and de-duplicating of the unknown custom emojis
        # found attached to cached presence activities.
        self._unknown_custom_emoji_entries = collections.FreezableDict()
        self._user_entries = collections.FreezableDict()
        self._intents = intents

    def _assert_has_intent(self, intents: intents_.Intents, /) -&gt; None:
        if self._intents ^ intents:
            raise errors.MissingIntentError(intents) from None

    def _is_intent_enabled(self, intents: intents_.Intents, /) -&gt; bool:
        return (self._intents &amp; intents) == intents

    def _build_emoji(
        self,
        emoji_data: cache_utility.KnownCustomEmojiData,
        cached_users: typing.Optional[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = None,
    ) -&gt; emojis.KnownCustomEmoji:
        user: typing.Optional[users.User] = None
        if cached_users is not None and emoji_data.user_id is not None:
            user = copy.copy(cached_users[emoji_data.user_id].object)
        elif emoji_data.user_id is not None:
            user = copy.copy(self._user_entries[emoji_data.user_id].object)

        return emoji_data.build_entity(app=self._app, user=user)

    def _increment_emoji_ref_count(self, emoji_id: snowflakes.Snowflake, increment: int = 1) -&gt; None:
        self._emoji_entries[emoji_id].ref_count += increment

    def _garbage_collect_emoji(self, emoji_id: snowflakes.Snowflake, decrement: int = 0) -&gt; None:
        emoji_data = self._emoji_entries.get(emoji_id)

        if emoji_data is None:
            return None

        emoji_data.ref_count -= decrement

        if self._can_remove_emoji(emoji_data):
            del self._emoji_entries[emoji_id]

    @staticmethod
    def _can_remove_emoji(emoji: cache_utility.KnownCustomEmojiData) -&gt; bool:
        return emoji.has_been_deleted is True and emoji.ref_count &lt; 1

    def _clear_emojis(
        self,
        guild_id: undefined.UndefinedOr[snowflakes.Snowflake] = undefined.UNDEFINED,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        emoji_ids: typing.Iterable[snowflakes.Snowflake]
        if guild_id is undefined.UNDEFINED:
            emoji_ids = self._emoji_entries.freeze()
        else:
            guild_record = self._guild_entries.get(guild_id)
            # TODO: explicit is not None vs implicit if statement consistency.
            if guild_record is None or guild_record.emojis is None:
                return cache_utility.EmptyCacheView()

            emoji_ids = guild_record.emojis
            guild_record.emojis = None
            self._remove_guild_record_if_empty(guild_id)

        cached_emojis = {}
        cached_users = {}

        for emoji_id in emoji_ids:
            emoji_data = self._emoji_entries[emoji_id]
            emoji_data.has_been_deleted = True
            if not self._can_remove_emoji(emoji_data):
                continue

            del self._emoji_entries[emoji_id]
            cached_emojis[emoji_id] = emoji_data

            if emoji_data.user_id is not None:
                cached_users[emoji_data.user_id] = self._user_entries[emoji_data.user_id]
                self._garbage_collect_user(emoji_data.user_id, decrement=1)

        return cache_utility.StatefulCacheMappingView(
            cached_emojis, builder=lambda emoji: self._build_emoji(emoji, cached_users=cached_users)
        )

    def clear_emojis(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        result = self._clear_emojis()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.emojis is not None:  # TODO: add test coverage for this.
                guild_record.emojis = None
                self._remove_guild_record_if_empty(guild_id)

        return result

    def clear_emojis_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        return self._clear_emojis(guild_id)

    def delete_emoji(self, emoji_id: snowflakes.Snowflake, /) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
        emoji_data = self._emoji_entries.pop(emoji_id, None)
        if emoji_data is None:
            return None

        emoji_data.has_been_deleted = True
        if not self._can_remove_emoji(emoji_data):
            return None

        emoji = self._build_emoji(emoji_data)

        if emoji_data.user_id is not None:
            self._garbage_collect_user(emoji_data.user_id, decrement=1)

        guild_record = self._guild_entries.get(emoji_data.guild_id)
        if guild_record and guild_record.emojis:  # TODO: should this make assumptions and be flat?
            guild_record.emojis.remove(emoji_id)

            if not guild_record.emojis:
                guild_record.emojis = None

        return emoji

    def get_emoji(self, emoji_id: snowflakes.Snowflake, /) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
        return self._build_emoji(self._emoji_entries[emoji_id]) if emoji_id in self._emoji_entries else None

    def _get_emojis_view(  # TODO: split out the two cases (specific guild vs global)
        self, guild_id: undefined.UndefinedOr[snowflakes.Snowflake] = undefined.UNDEFINED
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        cached_emojis = {}
        cached_users = {}
        emoji_ids: typing.Iterable[snowflakes.Snowflake]

        if guild_id is undefined.UNDEFINED:
            emoji_ids = self._emoji_entries.freeze()
        else:
            guild_record = self._guild_entries.get(guild_id)
            if guild_record is None or not guild_record.emojis:
                return cache_utility.EmptyCacheView()

            emoji_ids = tuple(guild_record.emojis)

        for emoji_id in emoji_ids:
            emoji_data = self._emoji_entries[emoji_id]
            cached_emojis[emoji_id] = emoji_data

            if emoji_data.user_id is not None:
                cached_users[emoji_data.user_id] = self._user_entries[emoji_data.user_id]

        return cache_utility.StatefulCacheMappingView(
            cached_emojis, builder=lambda emoji: self._build_emoji(emoji, cached_users=cached_users)
        )

    def get_emojis_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        return self._get_emojis_view()

    def get_emojis_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
        return self._get_emojis_view(guild_id=guild_id)

    def set_emoji(self, emoji: emojis.KnownCustomEmoji, /) -&gt; None:
        if emoji.user is not None:
            self.set_user(emoji.user)
            if emoji.id not in self._emoji_entries:
                self._increment_user_ref_count(emoji.user.id)

        self._emoji_entries[emoji.id] = cache_utility.KnownCustomEmojiData.build_from_entity(emoji)
        guild_container = self._get_or_create_guild_record(emoji.guild_id)

        if guild_container.emojis is None:  # TODO: add test cases when it is not None?
            guild_container.emojis = collections.SnowflakeSet()

        guild_container.emojis.add(emoji.id)

    def update_emoji(
        self, emoji: emojis.KnownCustomEmoji, /
    ) -&gt; typing.Tuple[typing.Optional[emojis.KnownCustomEmoji], typing.Optional[emojis.KnownCustomEmoji]]:
        cached_emoji = self.get_emoji(emoji.id)
        self.set_emoji(emoji)
        return cached_emoji, self.get_emoji(emoji.id)

    def _remove_guild_record_if_empty(self, guild_id: snowflakes.Snowflake) -&gt; None:
        if guild_id in self._guild_entries and not self._guild_entries[guild_id]:
            del self._guild_entries[guild_id]

    def _get_or_create_guild_record(self, guild_id: snowflakes.Snowflake) -&gt; cache_utility.GuildRecord:
        if guild_id not in self._guild_entries:
            self._guild_entries[guild_id] = cache_utility.GuildRecord()

        return self._guild_entries[guild_id]

    def clear_guilds(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        cached_guilds = {}

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.guild is None:
                continue

            cached_guilds[guild_id] = guild_record.guild
            guild_record.guild = None
            guild_record.is_available = None
            self._remove_guild_record_if_empty(guild_id)

        return (
            cache_utility.StatefulCacheMappingView(cached_guilds) if cached_guilds else cache_utility.EmptyCacheView()
        )

    def delete_guild(self, guild_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.GatewayGuild]:
        if guild_id not in self._guild_entries:
            return None

        guild_record = self._guild_entries[guild_id]
        guild = guild_record.guild

        if guild is not None:
            guild_record.guild = None
            guild_record.is_available = None
            self._remove_guild_record_if_empty(guild_id)

        return guild

    def _get_guild(
        self, guild_id: snowflakes.Snowflake, /, *, availability: bool
    ) -&gt; typing.Optional[guilds.GatewayGuild]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.guild is None or guild_record.is_available is not availability:
            return None

        return copy.copy(guild_record.guild)

    def get_guild(self, guild_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.GatewayGuild]:
        if (guild := self._get_guild(guild_id, availability=True)) is not None:
            return guild
        return self._get_guild(guild_id, availability=False)

    def get_available_guild(self, guild_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.GatewayGuild]:
        return self._get_guild(guild_id, availability=True)

    def get_unavailable_guild(self, guild_id: snowflakes.Snowflake) -&gt; typing.Optional[guilds.GatewayGuild]:
        return self._get_guild(guild_id, availability=False)

    def _get_guilds_view(self, *, availability: bool) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        entries = self._guild_entries.freeze()
        # We may have a guild record without a guild object in cases where we&#39;re caching other entities that belong to
        # the guild therefore we want to make sure record.guild isn&#39;t None.
        results = {
            sf: guild_record.guild
            for sf, guild_record in entries.items()
            if guild_record.guild and guild_record.is_available is availability
        }
        return cache_utility.StatefulCacheMappingView(results) if results else cache_utility.EmptyCacheView()

    def get_available_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        return self._get_guilds_view(availability=True)

    def get_unavailable_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
        return self._get_guilds_view(availability=False)

    def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
        guild_record = self._get_or_create_guild_record(guild.id)
        guild_record.guild = copy.copy(guild)
        guild_record.is_available = True

    def set_guild_availability(self, guild_id: snowflakes.Snowflake, is_available: bool, /) -&gt; None:
        guild_record = self._guild_entries.get(guild_id)

        if guild_record is not None and guild_record.guild is not None:
            guild_record.is_available = is_available

    def update_guild(
        self, guild: guilds.GatewayGuild, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.GatewayGuild], typing.Optional[guilds.GatewayGuild]]:
        guild = copy.copy(guild)
        guild_record = self._guild_entries.get(guild.id)
        cached_guild = guild_record.guild if guild_record is not None else None

        # We have to manually update these because inconsistency by Discord.
        if cached_guild is not None:
            guild.member_count = cached_guild.member_count
            guild.joined_at = cached_guild.joined_at
            guild.is_large = cached_guild.is_large

        self.set_guild(guild)
        guild_record = self._guild_entries.get(guild.id)
        return cached_guild, guild_record.guild if guild_record is not None else None

    def clear_guild_channels(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        cached_channels = self._guild_channel_entries
        self._guild_channel_entries = collections.FreezableDict()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.channels is not None:
                guild_record.channels = None
                self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(cached_channels)

    def clear_guild_channels_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.channels is None:
            return cache_utility.EmptyCacheView()

        # Tuple casts like this avoid edge case issues which would be caused by guild_record.channels being modified
        # while we&#39;re iterating over it
        cached_channels = {sf: self._guild_channel_entries.pop(sf) for sf in tuple(guild_record.channels)}
        guild_record.channels = None
        self._remove_guild_record_if_empty(guild_id)
        return cache_utility.StatefulCacheMappingView(cached_channels)

    def delete_guild_channel(self, channel_id: snowflakes.Snowflake, /) -&gt; typing.Optional[channels.GuildChannel]:
        channel = self._guild_channel_entries.pop(channel_id, None)

        if channel is None:
            return None

        # TODO: flat and make assumptions?
        guild_record = self._guild_entries.get(channel.guild_id)
        if guild_record and guild_record.channels is not None:
            guild_record.channels.remove(channel_id)
            if not guild_record.channels:
                guild_record.channels = None
                self._remove_guild_record_if_empty(channel.guild_id)

        return channel

    def get_guild_channel(self, channel_id: snowflakes.Snowflake, /) -&gt; typing.Optional[channels.GuildChannel]:
        channel = self._guild_channel_entries.get(channel_id)
        return cache_utility.copy_guild_channel(channel) if channel is not None else None

    def get_guild_channels_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        return cache_utility.GuildChannelCacheMappingView(self._guild_channel_entries.freeze())

    def get_guild_channels_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or not guild_record.channels:
            return cache_utility.EmptyCacheView()

        # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
        # iterating over them.
        cached_channels = {sf: self._guild_channel_entries[sf] for sf in tuple(guild_record.channels)}

        def sorter(args: typing.Tuple[snowflakes.Snowflake, channels.GuildChannel]) -&gt; typing.Tuple[int, int, int]:
            channel = args[1]
            if isinstance(channel, channels.GuildCategory):
                return channel.position, -1, 0

            parent_position = -1 if channel.parent_id is None else cached_channels[channel.parent_id].position

            if not isinstance(channel, channels.GuildVoiceChannel):
                return parent_position, 0, channel.position

            return parent_position, 1, channel.position

        cached_channels = dict(sorted(cached_channels.items(), key=sorter))
        return cache_utility.GuildChannelCacheMappingView(cached_channels)

    def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
        self._guild_channel_entries[channel.id] = cache_utility.copy_guild_channel(channel)
        guild_record = self._get_or_create_guild_record(channel.guild_id)

        if guild_record.channels is None:
            guild_record.channels = collections.SnowflakeSet()

        guild_record.channels.add(channel.id)

    def update_guild_channel(
        self, channel: channels.GuildChannel, /
    ) -&gt; typing.Tuple[typing.Optional[channels.GuildChannel], typing.Optional[channels.GuildChannel]]:
        cached_channel = self.get_guild_channel(channel.id)
        self.set_guild_channel(channel)
        return cached_channel, self.get_guild_channel(channel.id)

    def _build_invite(
        self,
        invite_data: cache_utility.InviteData,
        cached_users: undefined.UndefinedOr[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = undefined.UNDEFINED,
    ) -&gt; invites.InviteWithMetadata:
        inviter: typing.Optional[users.User] = None
        if cached_users is not undefined.UNDEFINED and invite_data.inviter_id is not None:
            inviter = copy.copy(cached_users[invite_data.inviter_id].object)
        elif invite_data.inviter_id is not None:
            inviter = copy.copy(self._user_entries[invite_data.inviter_id].object)

        target_user: typing.Optional[users.User] = None
        if cached_users is not undefined.UNDEFINED and invite_data.target_user_id is not None:
            target_user = copy.copy(cached_users[invite_data.target_user_id].object)
        elif invite_data.target_user_id is not None:
            target_user = copy.copy(self._user_entries[invite_data.target_user_id].object)

        return invite_data.build_entity(app=self._app, inviter=inviter, target_user=target_user)

    def _clear_invites(  # TODO: split out into two cases (global and specific guild)
        self,
        guild_id: undefined.UndefinedOr[snowflakes.Snowflake] = undefined.UNDEFINED,
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        invite_codes: typing.Iterable[str]
        if guild_id is not undefined.UNDEFINED:
            guild_record = self._guild_entries.get(guild_id)

            if guild_record is None or guild_record.invites is None:
                return cache_utility.EmptyCacheView()

            # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
            # iterating over them.
            invite_codes = tuple(guild_record.invites)
            guild_record.invites = None
            self._remove_guild_record_if_empty(guild_id)

        else:
            invite_codes = self._invite_entries.freeze()

        cached_invites = {}
        cached_users = {}

        for code in invite_codes:
            invite_data = self._invite_entries.pop(code)
            cached_invites[code] = invite_data

            if invite_data.inviter_id is not None:
                cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]
                self._garbage_collect_user(invite_data.inviter_id, decrement=1)

            if invite_data.target_user_id is not None:
                cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]
                self._garbage_collect_user(invite_data.target_user_id, decrement=1)

        return cache_utility.StatefulCacheMappingView(
            cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
        )

    def clear_invites(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        return self._clear_invites()

    def clear_invites_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        return self._clear_invites(guild_id=guild_id)

    def clear_invites_for_channel(
        self, guild_id: snowflakes.Snowflake, channel_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.invites is None:
            return cache_utility.EmptyCacheView()

        cached_invites = {}
        cached_users = {}

        # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
        # iterating over them.
        for code in tuple(guild_record.invites):
            invite_data = self._invite_entries[code]
            if invite_data.channel_id != channel_id:
                continue

            cached_invites[code] = invite_data
            del self._invite_entries[code]
            guild_record.invites.remove(code)

            if invite_data.inviter_id is not None:
                cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]
                self._garbage_collect_user(invite_data.inviter_id, decrement=1)

            if invite_data.target_user_id is not None:
                cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]
                self._garbage_collect_user(invite_data.target_user_id, decrement=1)

        if not guild_record.invites:
            guild_record.invites = None
            self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(
            cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
        )

    def delete_invite(self, code: str, /) -&gt; typing.Optional[invites.InviteWithMetadata]:
        if code not in self._invite_entries:
            return None

        invite = self._build_invite(self._invite_entries.pop(code))

        if invite.inviter is not None:
            self._garbage_collect_user(invite.inviter.id, decrement=1)

        if invite.target_user is not None:
            self._garbage_collect_user(invite.target_user.id, decrement=1)

        if invite.guild_id is not None:  # TODO: test case when this is None?
            guild_record = self._guild_entries.get(invite.guild_id)
            if guild_record and guild_record.invites is not None:
                guild_record.invites.remove(code)

                if not guild_record.invites:
                    guild_record.invites = None  # TODO: test when this is set to None
                    self._remove_guild_record_if_empty(invite.guild_id)

        return invite

    def get_invite(self, code: str, /) -&gt; typing.Optional[invites.InviteWithMetadata]:
        return self._build_invite(self._invite_entries[code]) if code in self._invite_entries else None

    def _get_invites_view(  # TODO: split out into two separate cases (global and specific guild)
        self, guild_id: undefined.UndefinedOr[snowflakes.Snowflake] = undefined.UNDEFINED
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        invite_ids: typing.Iterable[str]
        if guild_id is undefined.UNDEFINED:
            invite_ids = self._invite_entries.freeze()

        else:
            guild_entry = self._guild_entries.get(guild_id)
            if guild_entry is None or guild_entry.invites is None:
                return cache_utility.EmptyCacheView()

            # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
            # iterating over them.
            invite_ids = tuple(guild_entry.invites)

        cached_invites = {}
        cached_users = {}

        for code in invite_ids:
            invite_data = self._invite_entries[code]
            cached_invites[code] = invite_data

            if invite_data.inviter_id is not None:
                cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]

            if invite_data.target_user_id is not None:
                cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]

        return cache_utility.StatefulCacheMappingView(
            cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
        )

    def get_invites_view(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        return self._get_invites_view()

    def get_invites_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        return self._get_invites_view(guild_id=guild_id)

    def get_invites_view_for_channel(
        self,
        guild_id: snowflakes.Snowflake,
        channel_id: snowflakes.Snowflake,
        /,
    ) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
        guild_entry = self._guild_entries.get(guild_id)
        if guild_entry is None or guild_entry.invites is None:
            return cache_utility.EmptyCacheView()

        cached_invites = {}
        cached_users = {}
        invite_ids: typing.Iterable[str]

        # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
        # iterating over them.
        for code in tuple(guild_entry.invites):
            invite_data = self._invite_entries[code]
            if invite_data.channel_id != channel_id:
                continue

            cached_invites[code] = invite_data
            guild_entry.invites.remove(code)
            del self._invite_entries[code]

            if invite_data.inviter_id is not None:
                cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]

            if invite_data.target_user_id is not None:
                cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]

        if not guild_entry.channels:  # TODO: test coverage
            guild_entry.channels = None
            self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(
            cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
        )

    def set_invite(self, invite: invites.InviteWithMetadata, /) -&gt; None:
        if invite.inviter is not None:
            self.set_user(invite.inviter)
            if invite.code not in self._invite_entries:
                self._increment_user_ref_count(invite.inviter.id)

        if invite.target_user is not None:
            self.set_user(invite.target_user)
            if invite.code not in self._invite_entries:
                self._increment_user_ref_count(invite.target_user.id)

        self._invite_entries[invite.code] = cache_utility.InviteData.build_from_entity(invite)
        if invite.guild_id:
            guild_entry = self._get_or_create_guild_record(invite.guild_id)

            if guild_entry.invites is None:
                guild_entry.invites = []

            guild_entry.invites.append(invite.code)

    def update_invite(
        self, invite: invites.InviteWithMetadata, /
    ) -&gt; typing.Tuple[typing.Optional[invites.InviteWithMetadata], typing.Optional[invites.InviteWithMetadata]]:
        cached_invite = self.get_invite(invite.code)
        self.set_invite(invite)
        return cached_invite, self.get_invite(invite.code)

    def delete_me(self) -&gt; typing.Optional[users.OwnUser]:
        cached_user = self._me
        self._me = None
        return cached_user

    def get_me(self) -&gt; typing.Optional[users.OwnUser]:
        return copy.copy(self._me)

    def set_me(self, user: users.OwnUser, /) -&gt; None:
        self._me = copy.copy(user)

    def update_me(
        self, user: users.OwnUser, /
    ) -&gt; typing.Tuple[typing.Optional[users.OwnUser], typing.Optional[users.OwnUser]]:
        _LOGGER.debug(&#34;setting my user to %s&#34;, user)
        cached_user = self.get_me()
        self.set_me(user)
        return cached_user, self._me

    def _build_member(
        self,
        member_data: cache_utility.MemberData,
        cached_users: typing.Optional[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = None,
    ) -&gt; guilds.Member:
        if cached_users is None:
            user = copy.copy(self._user_entries[member_data.id].object)
        else:
            user = copy.copy(cached_users[member_data.id].object)

        return member_data.build_entity(user=user)

    @staticmethod
    def _can_remove_member(member: cache_utility.MemberData, guild_record: cache_utility.GuildRecord) -&gt; bool:
        if member.has_been_deleted is False:
            return False

        return bool(not guild_record.voice_states or member.id not in guild_record.voice_states)

    def _garbage_collect_member(
        self, guild_record: cache_utility.GuildRecord, member: cache_utility.MemberData
    ) -&gt; None:
        if guild_record.members is None or member.id not in guild_record.members:
            return

        if not self._can_remove_member(member, guild_record):
            return

        del guild_record.members[member.id]
        if not guild_record.members:
            guild_record.members = None
            self._remove_guild_record_if_empty(member.guild_id)

    def _chainable_remove_member(
        self,
        member: cache_utility.MemberData,
        guild_record: cache_utility.GuildRecord,
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; typing.Optional[cache_utility.MemberData]:
        assert guild_record.members is not None
        member.has_been_deleted = True
        if not self._can_remove_member(member, guild_record):
            return None

        if member.id not in cached_users:
            cached_users[member.id] = self._user_entries[member.id]

        self._garbage_collect_user(member.id, decrement=1)
        del guild_record.members[member.id]

        if not guild_record.members:
            guild_record.members = None
            self._remove_guild_record_if_empty(member.guild_id)

        return member

    def clear_members(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
        views = {}
        cached_users = self._user_entries.freeze()

        def build_member(member: cache_utility.MemberData) -&gt; guilds.Member:
            return self._build_member(member, cached_users=cached_users)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.members:
                continue

            #  This takes roughly half the time a two-layered for loop where we
            #  assign to the members dict on every inner-iteration takes.
            members_gen = (
                self._chainable_remove_member(m, guild_record, _VOID_MAPPING)
                for m in guild_record.members.freeze().values()
            )
            # _chainable_remove_member will only return the member data object if they could be removed, else None.
            cached_members = {member.id: member for member in members_gen if member is not None}
            views[guild_id] = cache_utility.StatefulCacheMappingView(cached_members, builder=build_member)

        return cache_utility.StatefulCacheMappingView(views)

    def clear_members_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.members is None:
            return cache_utility.EmptyCacheView()

        cached_members = guild_record.members.freeze()
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        members_gen = (self._chainable_remove_member(m, guild_record, cached_users) for m in cached_members.values())
        # _chainable_remove_member will only return the member data object if they could be removed, else None.
        cached_members = {member.id: member for member in members_gen if member is not None}
        return cache_utility.StatefulCacheMappingView(
            cached_members, builder=lambda member: self._build_member(member, cached_users=cached_users)
        )

    def delete_member(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[guilds.Member]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.members is None:
            return None

        member_data = guild_record.members.get(user_id)
        if member_data is None:
            return None

        member = self._build_member(member_data)
        # _chainable_remove_member will only return the member data object if they could be removed, else None.
        return member if self._chainable_remove_member(member_data, guild_record, _VOID_MAPPING) is not None else None

    def get_member(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[guilds.Member]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.members is None:
            return None

        member = guild_record.members.get(user_id)
        return self._build_member(member) if member is not None else None

    def get_members_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
        cached_users = self._user_entries.freeze()

        def member_builder(member: cache_utility.MemberData) -&gt; guilds.Member:
            return self._build_member(member, cached_users=cached_users)

        return cache_utility.Cache3DMappingView(
            {
                guild_id: cache_utility.StatefulCacheMappingView(view.members, builder=member_builder)
                for guild_id, view in self._guild_entries.freeze().items()
                if view.members
            }
        )

    def get_members_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.members is None:
            return cache_utility.EmptyCacheView()

        cached_members = {
            user_id: member for user_id, member in guild_record.members.freeze().items() if not member.has_been_deleted
        }
        cached_users = {user_id: self._user_entries[user_id] for user_id in cached_members}

        return cache_utility.StatefulCacheMappingView(
            cached_members, builder=lambda member: self._build_member(member, cached_users=cached_users)
        )

    def set_member(self, member: guilds.Member, /) -&gt; None:
        guild_record = self._get_or_create_guild_record(member.guild_id)
        self.set_user(member.user)
        member_data = cache_utility.MemberData.build_from_entity(member)

        if guild_record.members is None:  # TODO: test when this is not None
            guild_record.members = collections.FreezableDict()

        if member.user.id not in guild_record.members:
            self._increment_user_ref_count(member.user.id)

        guild_record.members[member_data.id] = member_data

    def update_member(
        self, member: guilds.Member, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.Member], typing.Optional[guilds.Member]]:
        cached_member = self.get_member(member.guild_id, member.user.id)
        self.set_member(member)
        return cached_member, self.get_member(member.guild_id, member.user.id)

    def _build_presence(
        self,
        presence_data: cache_utility.MemberPresenceData,
        cached_emojis: typing.Optional[
            typing.Mapping[
                snowflakes.Snowflake,
                typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
            ]
        ] = None,
        cached_users: typing.Optional[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = None,
    ) -&gt; presences.MemberPresence:
        presence_kwargs: typing.MutableSequence[typing.Mapping[str, typing.Optional[emojis.Emoji]]] = []
        for activity_data in presence_data.activities:
            identifier = activity_data.emoji_id_or_name
            if identifier is None:
                presence_kwargs.append({&#34;emoji&#34;: None})

            elif isinstance(identifier, str):
                presence_kwargs.append({&#34;emoji&#34;: emojis.UnicodeEmoji(identifier)})

            elif cached_emojis:
                emoji = cached_emojis[identifier]
                if isinstance(emoji, cache_utility.KnownCustomEmojiData):
                    presence_kwargs.append({&#34;emoji&#34;: self._build_emoji(emoji, cached_users=cached_users)})
                else:
                    presence_kwargs.append({&#34;emoji&#34;: copy.copy(emoji.object)})

            elif identifier in self._emoji_entries:
                presence_kwargs.append(
                    {&#34;emoji&#34;: self._build_emoji(self._emoji_entries[identifier], cached_users=cached_users)}
                )

            else:
                presence_kwargs.append({&#34;emoji&#34;: copy.copy(self._unknown_custom_emoji_entries[identifier].object)})

        return presence_data.build_entity(app=self._app, presence_kwargs=presence_kwargs)

    def _garbage_collect_unknown_custom_emoji(self, emoji_id: snowflakes.Snowflake, decrement: int = 0) -&gt; None:
        emoji = self._unknown_custom_emoji_entries.get(emoji_id)
        if emoji is None:
            return None

        emoji.ref_count -= decrement
        if emoji.ref_count &lt; 1:
            del self._unknown_custom_emoji_entries[emoji_id]

    def _chainable_remove_presence_assets(
        self,
        presence_data: cache_utility.MemberPresenceData,
        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.KnownCustomEmojiData, cache_utility.GenericRefWrapper[emojis.CustomEmoji]],
        ],
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; None:
        for activity_data in presence_data.activities:
            emoji_identifier = activity_data.emoji_id_or_name
            if emoji_identifier is None or isinstance(emoji_identifier, str):
                continue

            if emoji_identifier in self._emoji_entries:
                if emoji_identifier not in cached_emojis:
                    known_emoji_data = self._emoji_entries[emoji_identifier]

                    if known_emoji_data.user_id is not None and known_emoji_data.user_id not in cached_users:
                        cached_users[known_emoji_data.user_id] = self._user_entries[known_emoji_data.user_id]

                    cached_emojis[emoji_identifier] = known_emoji_data

                self._garbage_collect_emoji(emoji_identifier, decrement=-1)

            else:
                if emoji_identifier not in cached_emojis:
                    cached_emojis[emoji_identifier] = self._unknown_custom_emoji_entries[emoji_identifier]

                self._garbage_collect_unknown_custom_emoji(emoji_identifier, decrement=1)

    def clear_presences(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
        views = {}
        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        def build_presence(presence: cache_utility.MemberPresenceData) -&gt; presences.MemberPresence:
            return self._build_presence(presence, cached_users=cached_users, cached_emojis=cached_emojis)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.presences:
                continue

            cached_presences: typing.MutableMapping[
                snowflakes.Snowflake, cache_utility.MemberPresenceData
            ] = guild_record.presences
            guild_record.presences = None

            for presence in cached_presences.values():
                self._chainable_remove_presence_assets(presence, cached_emojis, cached_users)

            self._remove_guild_record_if_empty(guild_id)
            views[guild_id] = cache_utility.StatefulCacheMappingView(cached_presences, builder=build_presence)

        return cache_utility.StatefulCacheMappingView(views)

    def clear_presences_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.presences is None:
            return cache_utility.EmptyCacheView()

        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_presences: typing.MutableMapping[
            snowflakes.Snowflake, cache_utility.MemberPresenceData
        ] = guild_record.presences
        guild_record.presences = None

        for presence in cached_presences.values():
            self._chainable_remove_presence_assets(presence, cached_emojis, cached_users)

        self._remove_guild_record_if_empty(guild_id)
        return cache_utility.StatefulCacheMappingView(
            cached_presences,
            builder=lambda presence_data_: self._build_presence(
                presence_data_, cached_users=cached_users, cached_emojis=cached_emojis
            ),
        )

    def delete_presence(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[presences.MemberPresence]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.presences is None:
            return None

        presence_data = guild_record.presences.pop(user_id, None)

        if presence_data is None:
            return None

        presence = self._build_presence(presence_data)
        # _VOID_MAPPING is used here to avoid duplicating logic as we don&#39;t actually care about the assets there were
        # removed in this case as we&#39;ve already built the presence.
        self._chainable_remove_presence_assets(presence_data, _VOID_MAPPING, _VOID_MAPPING)

        if not guild_record.presences:
            guild_record.presences = None
            self._remove_guild_record_if_empty(guild_id)

        return presence

    def get_presence(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[presences.MemberPresence]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.presences is None:
            return None

        return self._build_presence(guild_record.presences[user_id]) if user_id in guild_record.presences else None

    def _chainable_get_presence_assets(
        self,
        presence_data: cache_utility.MemberPresenceData,
        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.KnownCustomEmojiData, cache_utility.GenericRefWrapper[emojis.CustomEmoji]],
        ],
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; None:
        for activity_data in presence_data.activities:
            emoji_identifier = activity_data.emoji_id_or_name

            if emoji_identifier is None or isinstance(emoji_identifier, str) or emoji_identifier in cached_emojis:
                continue

            if emoji_identifier in self._emoji_entries:
                emoji_data = self._emoji_entries[emoji_identifier]

                if emoji_data.user_id is not None and emoji_data.user_id not in cached_users:
                    cached_users[emoji_data.user_id] = self._user_entries[emoji_data.user_id]

                cached_emojis[emoji_identifier] = emoji_data

            else:
                cached_emojis[emoji_identifier] = self._unknown_custom_emoji_entries[emoji_identifier]

    def get_presences_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
        views = {}

        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
        ] = self._unknown_custom_emoji_entries.freeze()  # type: ignore[assignment]  # TODO: open mypy issue
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        def presence_builder(presence: cache_utility.MemberPresenceData) -&gt; presences.MemberPresence:
            return self._build_presence(presence, cached_users=cached_users, cached_emojis=cached_emojis)

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.presences:
                continue

            cached_presences = guild_record.presences.freeze()

            for presence in cached_presences.values():
                self._chainable_get_presence_assets(presence, cached_emojis, cached_users)

            views[guild_id] = cache_utility.StatefulCacheMappingView(cached_presences, builder=presence_builder)

        return cache_utility.Cache3DMappingView(views)

    def get_presences_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.presences is None:
            return cache_utility.EmptyCacheView()

        cached_emojis: typing.MutableMapping[
            snowflakes.Snowflake,
            typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_presences = guild_record.presences.freeze()

        for presence in cached_presences.values():
            self._chainable_get_presence_assets(presence, cached_emojis, cached_users)

        return cache_utility.StatefulCacheMappingView(
            cached_presences,
            builder=lambda presence_data_: self._build_presence(
                presence_data_, cached_users=cached_users, cached_emojis=cached_emojis
            ),
        )

    def set_presence(self, presence: presences.MemberPresence, /) -&gt; None:
        presence_data = cache_utility.MemberPresenceData.build_from_entity(presence)

        for activity in presence.activities:
            emoji = activity.emoji
            if emoji is None or not isinstance(emoji, emojis.CustomEmoji):
                continue

            if emoji.id in self._emoji_entries:
                self._increment_emoji_ref_count(emoji.id)

            elif emoji.id in self._unknown_custom_emoji_entries:
                self._unknown_custom_emoji_entries[emoji.id].ref_count += 1
                self._unknown_custom_emoji_entries[emoji.id].object = copy.copy(emoji)

            else:
                self._unknown_custom_emoji_entries[emoji.id] = cache_utility.GenericRefWrapper(
                    object=copy.copy(emoji), ref_count=1
                )

        guild_record = self._get_or_create_guild_record(presence.guild_id)
        if guild_record.presences is None:
            guild_record.presences = collections.FreezableDict()

        guild_record.presences[presence.user_id] = presence_data

    def update_presence(
        self, presence: presences.MemberPresence, /
    ) -&gt; typing.Tuple[typing.Optional[presences.MemberPresence], typing.Optional[presences.MemberPresence]]:
        cached_presence = self.get_presence(presence.guild_id, presence.user_id)
        self.set_presence(presence)
        return cached_presence, self.get_presence(presence.guild_id, presence.user_id)

    def clear_roles(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        if not self._role_entries:
            return cache_utility.EmptyCacheView()

        roles = self._role_entries
        self._role_entries = collections.FreezableDict()

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if guild_record.roles is not None:  # TODO: test coverage for this
                guild_record.roles = None
                self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(roles)

    def clear_roles_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or not guild_record.roles:
            return cache_utility.EmptyCacheView()

        view = cache_utility.StatefulCacheMappingView(
            {role_id: self._role_entries[role_id] for role_id in guild_record.roles}
        )
        guild_record.roles = None
        self._remove_guild_record_if_empty(guild_id)
        return view

    def delete_role(self, role_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.Role]:
        role = self._role_entries.pop(role_id, None)
        if role is None:
            return None

        guild_record = self._guild_entries.get(role.guild_id)
        if guild_record and guild_record.roles is not None:
            guild_record.roles.remove(role_id)

            if not guild_record.roles:  # TODO: should this make assumptions and be flat?
                guild_record.roles = None
                self._remove_guild_record_if_empty(role.guild_id)

        return role

    def get_role(self, role_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.Role]:
        return self._role_entries.get(role_id)

    def get_roles_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        cached_roles = self._role_entries.freeze()
        return cache_utility.StatefulCacheMappingView(cached_roles)

    def get_roles_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.roles is None:
            return cache_utility.EmptyCacheView()

        # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
        # iterating over them.
        return cache_utility.StatefulCacheMappingView(
            {role_id: self._role_entries[role_id] for role_id in tuple(guild_record.roles)}
        )

    def set_role(self, role: guilds.Role, /) -&gt; None:
        self._role_entries[role.id] = role
        guild_record = self._get_or_create_guild_record(role.guild_id)

        if guild_record.roles is None:  # TODO: test when this is not None
            guild_record.roles = collections.SnowflakeSet()

        guild_record.roles.add(role.id)

    def update_role(
        self, role: guilds.Role, /
    ) -&gt; typing.Tuple[typing.Optional[guilds.Role], typing.Optional[guilds.Role]]:
        cached_role = self.get_role(role.id)
        self.set_role(role)
        return cached_role, self.get_role(role.id)

    @staticmethod
    def _can_remove_user(user_data: typing.Optional[cache_utility.GenericRefWrapper[users.User]]) -&gt; bool:
        return bool(user_data and user_data.ref_count == 0)

    def _increment_user_ref_count(self, user_id: snowflakes.Snowflake, increment: int = 1) -&gt; None:
        self._user_entries[user_id].ref_count += increment

    def _garbage_collect_user(self, user_id: snowflakes.Snowflake, *, decrement: typing.Optional[int] = None) -&gt; None:
        if decrement is not None and user_id in self._user_entries:
            self._increment_user_ref_count(user_id, -decrement)

        if self._can_remove_user(self._user_entries.get(user_id)):
            del self._user_entries[user_id]

    def clear_users(self) -&gt; cache.CacheView[snowflakes.Snowflake, users.User]:
        if not self._user_entries:
            return cache_utility.EmptyCacheView()

        cached_users = {}

        for user_id, user in self._user_entries.freeze().items():
            if user.ref_count &gt; 0:
                continue

            cached_users[user_id] = user.object
            del self._user_entries[user_id]

        return cache_utility.StatefulCacheMappingView(cached_users) if cached_users else cache_utility.EmptyCacheView()

    def delete_user(self, user_id: snowflakes.Snowflake, /) -&gt; typing.Optional[users.User]:
        if self._can_remove_user(self._user_entries.get(user_id)):
            return self._user_entries.pop(user_id).object

        return None

    def get_user(self, user_id: snowflakes.Snowflake, /) -&gt; typing.Optional[users.User]:
        return copy.copy(self._user_entries[user_id].object) if user_id in self._user_entries else None

    def get_users_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, users.User]:
        if not self._user_entries:
            return cache_utility.EmptyCacheView()

        cached_users = self._user_entries.freeze()
        return cache_utility.StatefulCacheMappingView(cached_users, unpack=True)

    def set_user(self, user: users.User, /) -&gt; None:
        try:
            self._user_entries[user.id].object = copy.copy(user)
        except KeyError:
            self._user_entries[user.id] = cache_utility.GenericRefWrapper(object=copy.copy(user), ref_count=0)

    def update_user(
        self, user: users.User, /
    ) -&gt; typing.Tuple[typing.Optional[users.User], typing.Optional[users.User]]:
        cached_user = self.get_user(user.id)
        self.set_user(user)
        return cached_user, self.get_user(user.id)

    def _build_voice_state(
        self,
        voice_data: cache_utility.VoiceStateData,
        cached_members: typing.Optional[typing.Mapping[snowflakes.Snowflake, cache_utility.MemberData]] = None,
        cached_users: typing.Optional[
            typing.Mapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]]
        ] = None,
    ) -&gt; voices.VoiceState:
        if cached_members:
            member = self._build_member(cached_members[voice_data.user_id], cached_users=cached_users)
        else:
            guild_record = self._guild_entries[voice_data.guild_id]
            assert guild_record.members is not None
            member_data = guild_record.members[voice_data.user_id]
            member = self._build_member(member_data, cached_users=cached_users)

        return voice_data.build_entity(app=self._app, member=member)

    def _chainable_remove_voice_state_assets(
        self,
        voice_state: cache_utility.VoiceStateData,
        guild_record: cache_utility.GuildRecord,
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData],
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; None:
        assert guild_record.members is not None
        member = guild_record.members[voice_state.user_id]
        cached_members[voice_state.user_id] = member

        if voice_state.user_id not in cached_users:
            cached_users[voice_state.user_id] = self._user_entries[voice_state.user_id]

        self._garbage_collect_member(guild_record, member)

    def clear_voice_states(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
        views: typing.MutableMapping[
            snowflakes.Snowflake, cache_utility.StatefulCacheMappingView[snowflakes.Snowflake, voices.VoiceState]
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        def builder_generator(
            cached_members_: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData]
        ) -&gt; typing.Callable[[cache_utility.VoiceStateData], voices.VoiceState]:
            return lambda voice_data: self._build_voice_state(
                voice_data, cached_members=cached_members_, cached_users=cached_users
            )

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.voice_states:
                continue

            assert guild_record.members is not None
            cached_voice_states = guild_record.voice_states
            guild_record.voice_states = None
            cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}

            for voice_state in cached_voice_states.values():
                self._chainable_remove_voice_state_assets(voice_state, guild_record, cached_members, cached_users)

            self._remove_guild_record_if_empty(guild_id)
            views[guild_id] = cache_utility.StatefulCacheMappingView(
                cached_voice_states, builder=builder_generator(cached_members)
            )

        return cache_utility.StatefulCacheMappingView(views)

    def clear_voice_states_for_channel(
        self, guild_id: snowflakes.Snowflake, channel_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or not guild_record.voice_states:
            return cache_utility.EmptyCacheView()

        assert guild_record.members is not None
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_voice_states = {}

        for user_id, voice_state in guild_record.voice_states.items():
            if voice_state.channel_id == channel_id:
                cached_voice_states[voice_state.user_id] = voice_state
                self._chainable_remove_voice_state_assets(voice_state, guild_record, cached_members, cached_users)

        if not guild_record.voice_states:
            guild_record.voice_states = None
            self._remove_guild_record_if_empty(guild_id)

        return cache_utility.StatefulCacheMappingView(
            cached_voice_states,
            builder=lambda voice_state: self._build_voice_state(
                voice_state, cached_members=cached_members, cached_users=cached_users
            ),
        )

    def clear_voice_states_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)

        if guild_record is None or guild_record.voice_states is None:
            return cache_utility.EmptyCacheView()

        assert guild_record.members is not None
        cached_voice_states = guild_record.voice_states
        guild_record.voice_states = None
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        for voice_state in cached_voice_states.values():
            self._chainable_remove_voice_state_assets(voice_state, guild_record, cached_members, cached_users)

        self._remove_guild_record_if_empty(guild_id)
        return cache_utility.StatefulCacheMappingView(
            cached_voice_states,
            builder=lambda voice_data: self._build_voice_state(
                voice_data, cached_members=cached_members, cached_users=cached_users
            ),
        )

    def delete_voice_state(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None:
            return None

        voice_state_data = guild_record.voice_states.pop(user_id, None) if guild_record.voice_states else None
        if voice_state_data is None:
            return None

        if not guild_record.voice_states:
            guild_record.voice_states = None

        voice_state = self._build_voice_state(voice_state_data)
        self._chainable_remove_voice_state_assets(voice_state_data, guild_record, _VOID_MAPPING, _VOID_MAPPING)
        self._remove_guild_record_if_empty(guild_id)
        return voice_state

    def get_voice_state(
        self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
    ) -&gt; typing.Optional[voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        voice_data = guild_record.voice_states.get(user_id) if guild_record and guild_record.voice_states else None
        return self._build_voice_state(voice_data) if voice_data else None

    def _chainable_get_voice_states_assets(
        self,
        voice_state: cache_utility.VoiceStateData,
        guild_record: cache_utility.GuildRecord,
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData],
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]],
    ) -&gt; None:
        assert guild_record.members is not None
        cached_members[voice_state.user_id] = guild_record.members[voice_state.user_id]

        if voice_state.user_id not in cached_users:
            cached_users[voice_state.user_id] = self._user_entries[voice_state.user_id]

    def get_voice_states_view(
        self,
    ) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
        views: typing.MutableMapping[
            snowflakes.Snowflake, cache_utility.StatefulCacheMappingView[snowflakes.Snowflake, voices.VoiceState]
        ] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData]

        def builder_generator(
            cached_members_: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData]
        ) -&gt; typing.Callable[[cache_utility.VoiceStateData], voices.VoiceState]:
            return lambda voice_state_: self._build_voice_state(
                voice_state_, cached_members=cached_members_, cached_users=cached_users
            )

        for guild_id, guild_record in self._guild_entries.freeze().items():
            if not guild_record.voice_states:
                continue

            cached_voice_states = guild_record.voice_states.freeze()
            cached_members = {}

            for voice_state in cached_voice_states.values():
                self._chainable_get_voice_states_assets(voice_state, guild_record, cached_members, cached_users)

            views[guild_id] = cache_utility.StatefulCacheMappingView(
                cached_voice_states, builder=builder_generator(cached_members)
            )

        return cache_utility.Cache3DMappingView(views)

    def get_voice_states_view_for_channel(
        self, guild_id: snowflakes.Snowflake, channel_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.voice_states is None:
            return cache_utility.EmptyCacheView()

        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
        cached_voice_states = guild_record.voice_states.freeze()

        for voice_state in cached_voice_states.values():
            if voice_state.channel_id == channel_id:
                self._chainable_get_voice_states_assets(voice_state, guild_record, cached_members, cached_users)

        return cache_utility.StatefulCacheMappingView(
            cached_voice_states,
            builder=lambda voice_data: self._build_voice_state(
                voice_data, cached_members=cached_members, cached_users=cached_users
            ),
        )

    def get_voice_states_view_for_guild(
        self, guild_id: snowflakes.Snowflake, /
    ) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
        guild_record = self._guild_entries.get(guild_id)
        if guild_record is None or guild_record.voice_states is None:
            return cache_utility.EmptyCacheView()

        voice_states = guild_record.voice_states.freeze()
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
        cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

        for voice_state in voice_states.values():
            self._chainable_get_voice_states_assets(voice_state, guild_record, cached_members, cached_users)

        return cache_utility.StatefulCacheMappingView(
            voice_states,
            builder=lambda voice_data: self._build_voice_state(
                voice_data, cached_members=cached_members, cached_users=cached_users
            ),
        )

    def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
        guild_record = self._get_or_create_guild_record(voice_state.guild_id)

        if guild_record.voice_states is None:  # TODO: test when this is not None
            guild_record.voice_states = collections.FreezableDict()

        # TODO: account for this method not setting the member in some cases later on
        self.set_member(voice_state.member)
        assert guild_record.members is not None
        guild_record.members[voice_state.member.id].has_been_deleted = True
        guild_record.voice_states[voice_state.user_id] = cache_utility.VoiceStateData.build_from_entity(voice_state)

    def update_voice_state(
        self, voice_state: voices.VoiceState, /
    ) -&gt; typing.Tuple[typing.Optional[voices.VoiceState], typing.Optional[voices.VoiceState]]:
        cached_voice_state = self.get_voice_state(voice_state.guild_id, voice_state.user_id)
        self.set_voice_state(voice_state)
        return cached_voice_state, self.get_voice_state(voice_state.guild_id, voice_state.user_id)</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="StatefulCacheImpl -- In-memory cache implementation." href="#hikari.impl.stateful_cache.StatefulCacheImpl"
>StatefulCacheImpl</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></dt>
<dd class="nested"><p>Cache that exposes read-only operations as well as mutation operations …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="Cache -- Interface describing the operations a cache component should provide …" href="../api/cache.html#hikari.api.cache.Cache"
>Cache</a></dt>
<dd class="nested"><p>Interface describing the operations a cache component should provide …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_emojis" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis">clear_emojis</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_emojis -- Remove all the known custom emoji objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_emojis"
>clear_emojis</a></code>
</p>
<p>Remove all the known custom emoji objects from the cache.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will skip emojis that are being kept alive by a reference
on a presence entry.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>A cache view of emoji IDs to objects of the emojis that were
removed from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L207-L215" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_emojis(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
    result = self._clear_emojis()

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if guild_record.emojis is not None:  # TODO: add test coverage for this.
            guild_record.emojis = None
            self._remove_guild_record_if_empty(guild_id)

    return result</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_emojis_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_emojis_for_guild">clear_emojis_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_emojis_for_guild -- Remove the known custom emoji objects cached for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_emojis_for_guild"
>clear_emojis_for_guild</a></code>
</p>
<p>Remove the known custom emoji objects cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove the cached emoji objects for.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will skip emojis that are being kept alive by a reference
on a presence entry.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>A view of emoji IDs to objects of the emojis that were removed
from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L217-L220" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_emojis_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
    return self._clear_emojis(guild_id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_guild_channels" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels">clear_guild_channels</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_guild_channels -- Remove all guild channels from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_guild_channels"
>clear_guild_channels</a></code>
</p>
<p>Remove all guild channels from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>A view of channel IDs to objects of the guild channels that were
removed from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L409-L418" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_guild_channels(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
    cached_channels = self._guild_channel_entries
    self._guild_channel_entries = collections.FreezableDict()

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if guild_record.channels is not None:
            guild_record.channels = None
            self._remove_guild_record_if_empty(guild_id)

    return cache_utility.StatefulCacheMappingView(cached_channels)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_guild_channels_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_guild_channels_for_guild">clear_guild_channels_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_guild_channels_for_guild -- Remove guild channels from the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_guild_channels_for_guild"
>clear_guild_channels_for_guild</a></code>
</p>
<p>Remove guild channels from the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove cached channels for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>A view of channel IDs to objects of the guild channels that were
removed from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L420-L432" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_guild_channels_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.channels is None:
        return cache_utility.EmptyCacheView()

    # Tuple casts like this avoid edge case issues which would be caused by guild_record.channels being modified
    # while we&#39;re iterating over it
    cached_channels = {sf: self._guild_channel_entries.pop(sf) for sf in tuple(guild_record.channels)}
    guild_record.channels = None
    self._remove_guild_record_if_empty(guild_id)
    return cache_utility.StatefulCacheMappingView(cached_channels)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_guilds" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_guilds" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_guilds" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_guilds">clear_guilds</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_guilds -- Remove all the guild objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_guilds"
>clear_guilds</a></code>
</p>
<p>Remove all the guild objects from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The cache view of guild IDs to guild objects that were removed from
the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L314-L328" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_guilds(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
    cached_guilds = {}

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if guild_record.guild is None:
            continue

        cached_guilds[guild_id] = guild_record.guild
        guild_record.guild = None
        guild_record.is_available = None
        self._remove_guild_record_if_empty(guild_id)

    return (
        cache_utility.StatefulCacheMappingView(cached_guilds) if cached_guilds else cache_utility.EmptyCacheView()
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_invites" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites">clear_invites</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_invites -- Remove all the invite objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_invites"
>clear_invites</a></code>
</p>
<p>Remove all the invite objects from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of invite code strings to objects of the invites that were
removed from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L559-L560" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_invites(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    return self._clear_invites()</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_channel" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_invites_for_channel" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_channel" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_channel">clear_invites_for_channel</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    channel_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_invites_for_channel -- Remove the invite objects in the cache for a specific channel …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_invites_for_channel"
>clear_invites_for_channel</a></code>
</p>
<p>Remove the invite objects in the cache for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove invite objects for.</dd>
<dt><strong><code>channel_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the channel to remove invite objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of invite code strings to objects of the invites that were
removed from the cache for the specified channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L567-L602" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_invites_for_channel(
    self, guild_id: snowflakes.Snowflake, channel_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.invites is None:
        return cache_utility.EmptyCacheView()

    cached_invites = {}
    cached_users = {}

    # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
    # iterating over them.
    for code in tuple(guild_record.invites):
        invite_data = self._invite_entries[code]
        if invite_data.channel_id != channel_id:
            continue

        cached_invites[code] = invite_data
        del self._invite_entries[code]
        guild_record.invites.remove(code)

        if invite_data.inviter_id is not None:
            cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]
            self._garbage_collect_user(invite_data.inviter_id, decrement=1)

        if invite_data.target_user_id is not None:
            cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]
            self._garbage_collect_user(invite_data.target_user_id, decrement=1)

    if not guild_record.invites:
        guild_record.invites = None
        self._remove_guild_record_if_empty(guild_id)

    return cache_utility.StatefulCacheMappingView(
        cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_invites_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_invites_for_guild">clear_invites_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_invites_for_guild -- Remove the invite objects in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_invites_for_guild"
>clear_invites_for_guild</a></code>
</p>
<p>Remove the invite objects in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove invite objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of invite code strings to objects of the invites that were
removed from the cache for the specified guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L562-L565" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_invites_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    return self._clear_invites(guild_id=guild_id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_members" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_members" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_members" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_members">clear_members</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_members -- Remove all the guild members in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_members"
>clear_members</a></code>
</p>
<p>Remove all the guild members in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, ICacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the members
that were removed from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L814-L837" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_members(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
    views = {}
    cached_users = self._user_entries.freeze()

    def build_member(member: cache_utility.MemberData) -&gt; guilds.Member:
        return self._build_member(member, cached_users=cached_users)

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if not guild_record.members:
            continue

        #  This takes roughly half the time a two-layered for loop where we
        #  assign to the members dict on every inner-iteration takes.
        members_gen = (
            self._chainable_remove_member(m, guild_record, _VOID_MAPPING)
            for m in guild_record.members.freeze().values()
        )
        # _chainable_remove_member will only return the member data object if they could be removed, else None.
        cached_members = {member.id: member for member in members_gen if member is not None}
        views[guild_id] = cache_utility.StatefulCacheMappingView(cached_members, builder=build_member)

    return cache_utility.StatefulCacheMappingView(views)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_members_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_members_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_members_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_members_for_guild">clear_members_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_members_for_guild -- Remove the members for a specific guild from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_members_for_guild"
>clear_members_for_guild</a></code>
</p>
<p>Remove the members for a specific guild from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove cached members for.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will skip members that are being referenced by other entries in
the cache; a matching voice state will keep a member entry alive.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>The view of user IDs to the member objects that were removed from
the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L839-L853" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_members_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.members is None:
        return cache_utility.EmptyCacheView()

    cached_members = guild_record.members.freeze()
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
    members_gen = (self._chainable_remove_member(m, guild_record, cached_users) for m in cached_members.values())
    # _chainable_remove_member will only return the member data object if they could be removed, else None.
    cached_members = {member.id: member for member in members_gen if member is not None}
    return cache_utility.StatefulCacheMappingView(
        cached_members, builder=lambda member: self._build_member(member, cached_users=cached_users)
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_presences" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences">clear_presences</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_presences -- Remove all the presences in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_presences"
>clear_presences</a></code>
</p>
<p>Remove all the presences in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, ICacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the presences
that were removed from the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1011-L1039" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_presences(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
    views = {}
    cached_emojis: typing.MutableMapping[
        snowflakes.Snowflake,
        typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
    ] = {}
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

    def build_presence(presence: cache_utility.MemberPresenceData) -&gt; presences.MemberPresence:
        return self._build_presence(presence, cached_users=cached_users, cached_emojis=cached_emojis)

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if not guild_record.presences:
            continue

        cached_presences: typing.MutableMapping[
            snowflakes.Snowflake, cache_utility.MemberPresenceData
        ] = guild_record.presences
        guild_record.presences = None

        for presence in cached_presences.values():
            self._chainable_remove_presence_assets(presence, cached_emojis, cached_users)

        self._remove_guild_record_if_empty(guild_id)
        views[guild_id] = cache_utility.StatefulCacheMappingView(cached_presences, builder=build_presence)

    return cache_utility.StatefulCacheMappingView(views)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_presences_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_presences_for_guild">clear_presences_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_presences_for_guild -- Remove the presences in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_presences_for_guild"
>clear_presences_for_guild</a></code>
</p>
<p>Remove the presences in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove presences for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]</code></dt>
<dd>A view of user IDs to objects of the presences that were removed
from the cache for the specified guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1041-L1067" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_presences_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.presences is None:
        return cache_utility.EmptyCacheView()

    cached_emojis: typing.MutableMapping[
        snowflakes.Snowflake,
        typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
    ] = {}
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
    cached_presences: typing.MutableMapping[
        snowflakes.Snowflake, cache_utility.MemberPresenceData
    ] = guild_record.presences
    guild_record.presences = None

    for presence in cached_presences.values():
        self._chainable_remove_presence_assets(presence, cached_emojis, cached_users)

    self._remove_guild_record_if_empty(guild_id)
    return cache_utility.StatefulCacheMappingView(
        cached_presences,
        builder=lambda presence_data_: self._build_presence(
            presence_data_, cached_users=cached_users, cached_emojis=cached_emojis
        ),
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_roles" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles">clear_roles</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_roles -- Remove all role objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_roles"
>clear_roles</a></code>
</p>
<p>Remove all role objects from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>A view of role IDs to objects of the roles that were removed from
the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1211-L1223" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_roles(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
    if not self._role_entries:
        return cache_utility.EmptyCacheView()

    roles = self._role_entries
    self._role_entries = collections.FreezableDict()

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if guild_record.roles is not None:  # TODO: test coverage for this
            guild_record.roles = None
            self._remove_guild_record_if_empty(guild_id)

    return cache_utility.StatefulCacheMappingView(roles)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_roles_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_roles_for_guild">clear_roles_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_roles_for_guild -- Remove role objects from the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_roles_for_guild"
>clear_roles_for_guild</a></code>
</p>
<p>Remove role objects from the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove roles for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>A view of role IDs to objects of the roles that were removed from
the cache for the specific guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1225-L1237" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_roles_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or not guild_record.roles:
        return cache_utility.EmptyCacheView()

    view = cache_utility.StatefulCacheMappingView(
        {role_id: self._role_entries[role_id] for role_id in guild_record.roles}
    )
    guild_record.roles = None
    self._remove_guild_record_if_empty(guild_id)
    return view</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_users" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_users" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_users" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_users">clear_users</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../users.html#hikari.users.User'>User</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_users -- Clear the user objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_users"
>clear_users</a></code>
</p>
<p>Clear the user objects from the cache.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will skip users that are being referenced by other entries
within the cache; member entries and DM entries
will keep a user alive within the cache.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>The view of user IDs to the user objects that were removed from the
cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1304-L1317" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_users(self) -&gt; cache.CacheView[snowflakes.Snowflake, users.User]:
    if not self._user_entries:
        return cache_utility.EmptyCacheView()

    cached_users = {}

    for user_id, user in self._user_entries.freeze().items():
        if user.ref_count &gt; 0:
            continue

        cached_users[user_id] = user.object
        del self._user_entries[user_id]

    return cache_utility.StatefulCacheMappingView(cached_users) if cached_users else cache_utility.EmptyCacheView()</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_voice_states" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states">clear_voice_states</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_voice_states -- Remove all voice state objects from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_voice_states"
>clear_voice_states</a></code>
</p>
<p>Remove all voice state objects from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, ICacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the voice
states that were removed from the states.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1382-L1414" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_voice_states(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
    views: typing.MutableMapping[
        snowflakes.Snowflake, cache_utility.StatefulCacheMappingView[snowflakes.Snowflake, voices.VoiceState]
    ] = {}
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

    def builder_generator(
        cached_members_: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData]
    ) -&gt; typing.Callable[[cache_utility.VoiceStateData], voices.VoiceState]:
        return lambda voice_data: self._build_voice_state(
            voice_data, cached_members=cached_members_, cached_users=cached_users
        )

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if not guild_record.voice_states:
            continue

        assert guild_record.members is not None
        cached_voice_states = guild_record.voice_states
        guild_record.voice_states = None
        cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}

        for voice_state in cached_voice_states.values():
            self._chainable_remove_voice_state_assets(voice_state, guild_record, cached_members, cached_users)

        self._remove_guild_record_if_empty(guild_id)
        views[guild_id] = cache_utility.StatefulCacheMappingView(
            cached_voice_states, builder=builder_generator(cached_members)
        )

    return cache_utility.StatefulCacheMappingView(views)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_channel" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_voice_states_for_channel" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_channel" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_channel">clear_voice_states_for_channel</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    channel_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_voice_states_for_channel -- Remove the voice state objects cached for a specific channel …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_voice_states_for_channel"
>clear_voice_states_for_channel</a></code>
</p>
<p>Remove the voice state objects cached for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove voice states for.</dd>
<dt><strong><code>channel_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the channel to remove voice states for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>A view of user IDs to objects of the voice state that were removed
from the cache for the specified channel.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1416-L1442" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_voice_states_for_channel(
    self, guild_id: snowflakes.Snowflake, channel_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or not guild_record.voice_states:
        return cache_utility.EmptyCacheView()

    assert guild_record.members is not None
    cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
    cached_voice_states = {}

    for user_id, voice_state in guild_record.voice_states.items():
        if voice_state.channel_id == channel_id:
            cached_voice_states[voice_state.user_id] = voice_state
            self._chainable_remove_voice_state_assets(voice_state, guild_record, cached_members, cached_users)

    if not guild_record.voice_states:
        guild_record.voice_states = None
        self._remove_guild_record_if_empty(guild_id)

    return cache_utility.StatefulCacheMappingView(
        cached_voice_states,
        builder=lambda voice_state: self._build_voice_state(
            voice_state, cached_members=cached_members, cached_users=cached_users
        ),
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="clear_voice_states_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.clear_voice_states_for_guild">clear_voice_states_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="clear_voice_states_for_guild -- Clear the voice state objects cached for a specific guild …" href="../api/cache.html#hikari.api.cache.MutableCache.clear_voice_states_for_guild"
>clear_voice_states_for_guild</a></code>
</p>
<p>Clear the voice state objects cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove cached voice states for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>A view of user IDs to the voice state objects that were removed from
the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1444-L1467" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def clear_voice_states_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
    guild_record = self._guild_entries.get(guild_id)

    if guild_record is None or guild_record.voice_states is None:
        return cache_utility.EmptyCacheView()

    assert guild_record.members is not None
    cached_voice_states = guild_record.voice_states
    guild_record.voice_states = None
    cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

    for voice_state in cached_voice_states.values():
        self._chainable_remove_voice_state_assets(voice_state, guild_record, cached_members, cached_users)

    self._remove_guild_record_if_empty(guild_id)
    return cache_utility.StatefulCacheMappingView(
        cached_voice_states,
        builder=lambda voice_data: self._build_voice_state(
            voice_data, cached_members=cached_members, cached_users=cached_users
        ),
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_emoji" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_emoji" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_emoji" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_emoji">delete_emoji</a>(
    emoji_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_emoji -- Remove a known custom emoji from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_emoji"
>delete_emoji</a></code>
</p>
<p>Remove a known custom emoji from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the emoji to remove from the cache.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>This will not delete emojis that are being kept alive by a reference
on a presence entry.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>The object of the emoji that was removed from the cache or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L222-L243" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_emoji(self, emoji_id: snowflakes.Snowflake, /) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
    emoji_data = self._emoji_entries.pop(emoji_id, None)
    if emoji_data is None:
        return None

    emoji_data.has_been_deleted = True
    if not self._can_remove_emoji(emoji_data):
        return None

    emoji = self._build_emoji(emoji_data)

    if emoji_data.user_id is not None:
        self._garbage_collect_user(emoji_data.user_id, decrement=1)

    guild_record = self._guild_entries.get(emoji_data.guild_id)
    if guild_record and guild_record.emojis:  # TODO: should this make assumptions and be flat?
        guild_record.emojis.remove(emoji_id)

        if not guild_record.emojis:
            guild_record.emojis = None

    return emoji</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild">delete_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_guild -- Remove a guild object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_guild"
>delete_guild</a></code>
</p>
<p>Remove a guild object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object of the guild that was removed from the cache, will be
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if not found.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L330-L342" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_guild(self, guild_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.GatewayGuild]:
    if guild_id not in self._guild_entries:
        return None

    guild_record = self._guild_entries[guild_id]
    guild = guild_record.guild

    if guild is not None:
        guild_record.guild = None
        guild_record.is_available = None
        self._remove_guild_record_if_empty(guild_id)

    return guild</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild_channel" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_guild_channel" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild_channel" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_guild_channel">delete_guild_channel</a>(
    channel_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_guild_channel -- Remove a guild channel from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_guild_channel"
>delete_guild_channel</a></code>
</p>
<p>Remove a guild channel from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild channel to remove from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The object of the guild channel that was removed from the cache if
found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L434-L448" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_guild_channel(self, channel_id: snowflakes.Snowflake, /) -&gt; typing.Optional[channels.GuildChannel]:
    channel = self._guild_channel_entries.pop(channel_id, None)

    if channel is None:
        return None

    # TODO: flat and make assumptions?
    guild_record = self._guild_entries.get(channel.guild_id)
    if guild_record and guild_record.channels is not None:
        guild_record.channels.remove(channel_id)
        if not guild_record.channels:
            guild_record.channels = None
            self._remove_guild_record_if_empty(channel.guild_id)

    return channel</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_invite" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_invite" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_invite" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_invite">delete_invite</a>(
    code: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    /,
) -> Union[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_invite -- Remove an invite object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_invite"
>delete_invite</a></code>
</p>
<p>Remove an invite object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The string code of the invite to remove from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>The object of the invite that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L604-L625" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_invite(self, code: str, /) -&gt; typing.Optional[invites.InviteWithMetadata]:
    if code not in self._invite_entries:
        return None

    invite = self._build_invite(self._invite_entries.pop(code))

    if invite.inviter is not None:
        self._garbage_collect_user(invite.inviter.id, decrement=1)

    if invite.target_user is not None:
        self._garbage_collect_user(invite.target_user.id, decrement=1)

    if invite.guild_id is not None:  # TODO: test case when this is None?
        guild_record = self._guild_entries.get(invite.guild_id)
        if guild_record and guild_record.invites is not None:
            guild_record.invites.remove(code)

            if not guild_record.invites:
                guild_record.invites = None  # TODO: test when this is set to None
                self._remove_guild_record_if_empty(invite.guild_id)

    return invite</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_me" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_me" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_me" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_me">delete_me</a>() -> Union[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_me -- Remove the own user object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_me"
>delete_me</a></code>
</p>
<p>Remove the own user object from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>]</code></dt>
<dd>The own user object that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L737-L740" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_me(self) -&gt; typing.Optional[users.OwnUser]:
    cached_user = self._me
    self._me = None
    return cached_user</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_member" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_member" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_member" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_member">delete_member</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    user_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../guilds.html#hikari.guilds.Member'>Member</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_member -- Remove a member object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_member"
>delete_member</a></code>
</p>
<p>Remove a member object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove a member from the cache for.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the user to remove a member from the cache for.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>You cannot delete a member entry that's being referenced by other
entries in the cache; a matching voice state will keep a member
entry alive.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>The object of the member that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L855-L868" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_member(
    self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
) -&gt; typing.Optional[guilds.Member]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.members is None:
        return None

    member_data = guild_record.members.get(user_id)
    if member_data is None:
        return None

    member = self._build_member(member_data)
    # _chainable_remove_member will only return the member data object if they could be removed, else None.
    return member if self._chainable_remove_member(member_data, guild_record, _VOID_MAPPING) is not None else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_presence" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_presence" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_presence" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_presence">delete_presence</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    user_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_presence -- Remove a presence from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_presence"
>delete_presence</a></code>
</p>
<p>Remove a presence from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to remove a presence for.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the user to remove a presence for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]</code></dt>
<dd>The object of the presence that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1069-L1090" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_presence(
    self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
) -&gt; typing.Optional[presences.MemberPresence]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.presences is None:
        return None

    presence_data = guild_record.presences.pop(user_id, None)

    if presence_data is None:
        return None

    presence = self._build_presence(presence_data)
    # _VOID_MAPPING is used here to avoid duplicating logic as we don&#39;t actually care about the assets there were
    # removed in this case as we&#39;ve already built the presence.
    self._chainable_remove_presence_assets(presence_data, _VOID_MAPPING, _VOID_MAPPING)

    if not guild_record.presences:
        guild_record.presences = None
        self._remove_guild_record_if_empty(guild_id)

    return presence</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_role" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_role" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_role" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_role">delete_role</a>(
    role_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../guilds.html#hikari.guilds.Role'>Role</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_role -- Remove a role object form the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_role"
>delete_role</a></code>
</p>
<p>Remove a role object form the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the role to remove from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>The object of the role that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1239-L1252" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_role(self, role_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.Role]:
    role = self._role_entries.pop(role_id, None)
    if role is None:
        return None

    guild_record = self._guild_entries.get(role.guild_id)
    if guild_record and guild_record.roles is not None:
        guild_record.roles.remove(role_id)

        if not guild_record.roles:  # TODO: should this make assumptions and be flat?
            guild_record.roles = None
            self._remove_guild_record_if_empty(role.guild_id)

    return role</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_user" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_user" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_user" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_user">delete_user</a>(
    user_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../users.html#hikari.users.User'>User</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_user -- Remove a user object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_user"
>delete_user</a></code>
</p>
<p>Remove a user object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the user to remove from the cache.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>You cannot delete a user object while it's being referenced by other
entries within the cache; member entries and DM
entries will keep a user alive within the cache.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>The object of the user that was removed from the cache if found,
else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1319-L1323" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_user(self, user_id: snowflakes.Snowflake, /) -&gt; typing.Optional[users.User]:
    if self._can_remove_user(self._user_entries.get(user_id)):
        return self._user_entries.pop(user_id).object

    return None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_voice_state" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="delete_voice_state" href="#hikari.impl.stateful_cache.StatefulCacheImpl.delete_voice_state" id="hikari.impl.stateful_cache.StatefulCacheImpl.delete_voice_state">delete_voice_state</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    user_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="delete_voice_state -- Remove a voice state object from the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.delete_voice_state"
>delete_voice_state</a></code>
</p>
<p>Remove a voice state object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild the voice state to remove is related to.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the user who the voice state to remove belongs to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>The object of the voice state that was removed from the cache if
found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1469-L1486" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def delete_voice_state(
    self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
) -&gt; typing.Optional[voices.VoiceState]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None:
        return None

    voice_state_data = guild_record.voice_states.pop(user_id, None) if guild_record.voice_states else None
    if voice_state_data is None:
        return None

    if not guild_record.voice_states:
        guild_record.voice_states = None

    voice_state = self._build_voice_state(voice_state_data)
    self._chainable_remove_voice_state_assets(voice_state_data, guild_record, _VOID_MAPPING, _VOID_MAPPING)
    self._remove_guild_record_if_empty(guild_id)
    return voice_state</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_available_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guild">get_available_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_available_guild -- Get the object of an available guild from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_available_guild"
>get_available_guild</a></code>
</p>
<p>Get the object of an available guild from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object of the guild if found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L358-L359" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_available_guild(self, guild_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.GatewayGuild]:
    return self._get_guild(guild_id, availability=True)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guilds_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_available_guilds_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guilds_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_available_guilds_view">get_available_guilds_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_available_guilds_view -- Get a view of the available guild objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_available_guilds_view"
>get_available_guilds_view</a></code>
</p>
<p>Get a view of the available guild objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>A view of guild IDs to the guild objects found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L375-L376" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_available_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
    return self._get_guilds_view(availability=True)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_emoji" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_emoji" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_emoji" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_emoji">get_emoji</a>(
    emoji_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_emoji -- Get a known custom emoji from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_emoji"
>get_emoji</a></code>
</p>
<p>Get a known custom emoji from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the emoji to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>The object of the emoji that was found in the cache or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L245-L246" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_emoji(self, emoji_id: snowflakes.Snowflake, /) -&gt; typing.Optional[emojis.KnownCustomEmoji]:
    return self._build_emoji(self._emoji_entries[emoji_id]) if emoji_id in self._emoji_entries else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_emojis_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view">get_emojis_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_emojis_view -- Get a view of the known custom emoji objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_emojis_view"
>get_emojis_view</a></code>
</p>
<p>Get a view of the known custom emoji objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>A view of emoji IDs to objects of the known custom emojis found in
the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L275-L276" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_emojis_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
    return self._get_emojis_view()</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_emojis_view_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_emojis_view_for_guild">get_emojis_view_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_emojis_view_for_guild -- Get a view of the known custom emojis cached for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_emojis_view_for_guild"
>get_emojis_view_for_guild</a></code>
</p>
<p>Get a view of the known custom emojis cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get the cached emoji objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]</code></dt>
<dd>A view of emoji IDs to objects of emojis found in the cache for the
specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L278-L281" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_emojis_view_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, emojis.KnownCustomEmoji]:
    return self._get_emojis_view(guild_id=guild_id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_guild">get_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_guild -- Get a guild from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_guild"
>get_guild</a></code>
</p>
<p>Get a guild from the cache.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>This will return a guild regardless of whether it is available or
not. To only query available guilds, use <code>get_available_guild</code>
instead. Likewise, to only query unavailable guilds, use
<code>get_unavailable_guild</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object of the guild if found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L353-L356" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guild(self, guild_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.GatewayGuild]:
    if (guild := self._get_guild(guild_id, availability=True)) is not None:
        return guild
    return self._get_guild(guild_id, availability=False)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channel" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guild_channel" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channel" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channel">get_guild_channel</a>(
    channel_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_guild_channel -- Get a guild channel from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_guild_channel"
>get_guild_channel</a></code>
</p>
<p>Get a guild channel from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild channel to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>The object of the guild channel that was found in the cache or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L450-L452" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guild_channel(self, channel_id: snowflakes.Snowflake, /) -&gt; typing.Optional[channels.GuildChannel]:
    channel = self._guild_channel_entries.get(channel_id)
    return cache_utility.copy_guild_channel(channel) if channel is not None else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guild_channels_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view">get_guild_channels_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_guild_channels_view -- Get a view of the guild channels in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_guild_channels_view"
>get_guild_channels_view</a></code>
</p>
<p>Get a view of the guild channels in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>A view of channel IDs to objects of the guild channels found in the
cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L454-L455" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guild_channels_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
    return cache_utility.GuildChannelCacheMappingView(self._guild_channel_entries.freeze())</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_guild_channels_view_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_guild_channels_view_for_guild">get_guild_channels_view_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_guild_channels_view_for_guild -- Get a view of the guild channels in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_guild_channels_view_for_guild"
>get_guild_channels_view_for_guild</a></code>
</p>
<p>Get a view of the guild channels in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]</code></dt>
<dd>A view of channel IDs to objects of the guild channels found in the
cache for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L457-L481" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_guild_channels_view_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, channels.GuildChannel]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or not guild_record.channels:
        return cache_utility.EmptyCacheView()

    # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
    # iterating over them.
    cached_channels = {sf: self._guild_channel_entries[sf] for sf in tuple(guild_record.channels)}

    def sorter(args: typing.Tuple[snowflakes.Snowflake, channels.GuildChannel]) -&gt; typing.Tuple[int, int, int]:
        channel = args[1]
        if isinstance(channel, channels.GuildCategory):
            return channel.position, -1, 0

        parent_position = -1 if channel.parent_id is None else cached_channels[channel.parent_id].position

        if not isinstance(channel, channels.GuildVoiceChannel):
            return parent_position, 0, channel.position

        return parent_position, 1, channel.position

    cached_channels = dict(sorted(cached_channels.items(), key=sorter))
    return cache_utility.GuildChannelCacheMappingView(cached_channels)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_invite" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_invite" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_invite" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_invite">get_invite</a>(
    code: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    /,
) -> Union[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_invite -- Get an invite object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_invite"
>get_invite</a></code>
</p>
<p>Get an invite object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>code</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The string code of the invite to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>The object of the invite that was found in the cache or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L627-L628" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_invite(self, code: str, /) -&gt; typing.Optional[invites.InviteWithMetadata]:
    return self._build_invite(self._invite_entries[code]) if code in self._invite_entries else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_invites_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view">get_invites_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_invites_view -- Get a view of the invite objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_invites_view"
>get_invites_view</a></code>
</p>
<p>Get a view of the invite objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of string codes to objects of the invites that were found in
the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L663-L664" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_invites_view(self) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    return self._get_invites_view()</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_channel" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_invites_view_for_channel" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_channel" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_channel">get_invites_view_for_channel</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    channel_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_invites_view_for_channel -- Get a view of the invite objects in the cache for a specified channel …" href="../api/cache.html#hikari.api.cache.Cache.get_invites_view_for_channel"
>get_invites_view_for_channel</a></code>
</p>
<p>Get a view of the invite objects in the cache for a specified channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get invite objects for.</dd>
<dt><strong><code>channel_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the channel to get invite objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>]</code></dt>
<dd>A view of string codes to objects of the invites there were found in
the cache for the specified channel.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L671-L708" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_invites_view_for_channel(
    self,
    guild_id: snowflakes.Snowflake,
    channel_id: snowflakes.Snowflake,
    /,
) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    guild_entry = self._guild_entries.get(guild_id)
    if guild_entry is None or guild_entry.invites is None:
        return cache_utility.EmptyCacheView()

    cached_invites = {}
    cached_users = {}
    invite_ids: typing.Iterable[str]

    # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
    # iterating over them.
    for code in tuple(guild_entry.invites):
        invite_data = self._invite_entries[code]
        if invite_data.channel_id != channel_id:
            continue

        cached_invites[code] = invite_data
        guild_entry.invites.remove(code)
        del self._invite_entries[code]

        if invite_data.inviter_id is not None:
            cached_users[invite_data.inviter_id] = self._user_entries[invite_data.inviter_id]

        if invite_data.target_user_id is not None:
            cached_users[invite_data.target_user_id] = self._user_entries[invite_data.target_user_id]

    if not guild_entry.channels:  # TODO: test coverage
        guild_entry.channels = None
        self._remove_guild_record_if_empty(guild_id)

    return cache_utility.StatefulCacheMappingView(
        cached_invites, builder=lambda invite_data: self._build_invite(invite_data, cached_users=cached_users)
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_invites_view_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_invites_view_for_guild">get_invites_view_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_invites_view_for_guild -- Get a view of the invite objects in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_invites_view_for_guild"
>get_invites_view_for_guild</a></code>
</p>
<p>Get a view of the invite objects in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get invite objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]</code></dt>
<dd>A view of string code to objects of the invites that were found in
the cache for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L666-L669" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_invites_view_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[str, invites.InviteWithMetadata]:
    return self._get_invites_view(guild_id=guild_id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_me" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_me" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_me" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_me">get_me</a>() -> Union[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_me -- Get the own user object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_me"
>get_me</a></code>
</p>
<p>Get the own user object from the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>]</code></dt>
<dd>The own user object that was found in the cache, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L742-L743" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_me(self) -&gt; typing.Optional[users.OwnUser]:
    return copy.copy(self._me)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_member" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_member" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_member" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_member">get_member</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    user_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../guilds.html#hikari.guilds.Member'>Member</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_member -- Get a member object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_member"
>get_member</a></code>
</p>
<p>Get a member object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>The object of the member found in the cache, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L870-L878" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_member(
    self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
) -&gt; typing.Optional[guilds.Member]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.members is None:
        return None

    member = guild_record.members.get(user_id)
    return self._build_member(member) if member is not None else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_members_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view">get_members_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_members_view -- Get a view of all the members objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_members_view"
>get_members_view</a></code>
</p>
<p>Get a view of all the members objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, ICacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the members
that were found from the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L880-L894" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_members_view(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, guilds.Member]]:
    cached_users = self._user_entries.freeze()

    def member_builder(member: cache_utility.MemberData) -&gt; guilds.Member:
        return self._build_member(member, cached_users=cached_users)

    return cache_utility.Cache3DMappingView(
        {
            guild_id: cache_utility.StatefulCacheMappingView(view.members, builder=member_builder)
            for guild_id, view in self._guild_entries.freeze().items()
            if view.members
        }
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_members_view_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_members_view_for_guild">get_members_view_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_members_view_for_guild -- Get a view of the members cached for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_members_view_for_guild"
>get_members_view_for_guild</a></code>
</p>
<p>Get a view of the members cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get the cached member view for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Member'>Member</a>]</code></dt>
<dd>The view of user IDs to the members cached for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L896-L910" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_members_view_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Member]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.members is None:
        return cache_utility.EmptyCacheView()

    cached_members = {
        user_id: member for user_id, member in guild_record.members.freeze().items() if not member.has_been_deleted
    }
    cached_users = {user_id: self._user_entries[user_id] for user_id in cached_members}

    return cache_utility.StatefulCacheMappingView(
        cached_members, builder=lambda member: self._build_member(member, cached_users=cached_users)
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_presence" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_presence" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_presence" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_presence">get_presence</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    user_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_presence -- Get a presence object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_presence"
>get_presence</a></code>
</p>
<p>Get a presence object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get a presence for.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the user to get a presence for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]</code></dt>
<dd>The object of the presence that was found in the cache or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1092-L1099" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_presence(
    self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
) -&gt; typing.Optional[presences.MemberPresence]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.presences is None:
        return None

    return self._build_presence(guild_record.presences[user_id]) if user_id in guild_record.presences else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_presences_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view">get_presences_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_presences_view -- Get a view of all the presence objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_presences_view"
>get_presences_view</a></code>
</p>
<p>Get a view of all the presence objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, ICacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the presences
found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1127-L1152" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_presences_view(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]]:
    views = {}

    cached_emojis: typing.MutableMapping[
        snowflakes.Snowflake,
        typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
    ] = self._unknown_custom_emoji_entries.freeze()  # type: ignore[assignment]  # TODO: open mypy issue
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

    def presence_builder(presence: cache_utility.MemberPresenceData) -&gt; presences.MemberPresence:
        return self._build_presence(presence, cached_users=cached_users, cached_emojis=cached_emojis)

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if not guild_record.presences:
            continue

        cached_presences = guild_record.presences.freeze()

        for presence in cached_presences.values():
            self._chainable_get_presence_assets(presence, cached_emojis, cached_users)

        views[guild_id] = cache_utility.StatefulCacheMappingView(cached_presences, builder=presence_builder)

    return cache_utility.Cache3DMappingView(views)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_presences_view_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_presences_view_for_guild">get_presences_view_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_presences_view_for_guild -- Get a view of the presence objects in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_presences_view_for_guild"
>get_presences_view_for_guild</a></code>
</p>
<p>Get a view of the presence objects in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get the cached presence objects for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]</code></dt>
<dd>A view of user IDs to objects of the presence found in the cache
for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1154-L1176" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_presences_view_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, presences.MemberPresence]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.presences is None:
        return cache_utility.EmptyCacheView()

    cached_emojis: typing.MutableMapping[
        snowflakes.Snowflake,
        typing.Union[cache_utility.GenericRefWrapper[emojis.CustomEmoji], cache_utility.KnownCustomEmojiData],
    ] = {}
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
    cached_presences = guild_record.presences.freeze()

    for presence in cached_presences.values():
        self._chainable_get_presence_assets(presence, cached_emojis, cached_users)

    return cache_utility.StatefulCacheMappingView(
        cached_presences,
        builder=lambda presence_data_: self._build_presence(
            presence_data_, cached_users=cached_users, cached_emojis=cached_emojis
        ),
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_role" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_role" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_role" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_role">get_role</a>(
    role_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../guilds.html#hikari.guilds.Role'>Role</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_role -- Get a role object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_role"
>get_role</a></code>
</p>
<p>Get a role object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the role to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>The object of the role found in the cache or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1254-L1255" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_role(self, role_id: snowflakes.Snowflake, /) -&gt; typing.Optional[guilds.Role]:
    return self._role_entries.get(role_id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_roles_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view">get_roles_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_roles_view -- Get a view of all the role objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_roles_view"
>get_roles_view</a></code>
</p>
<p>Get a view of all the role objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>A view of role IDs to objects of the roles found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1257-L1259" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_roles_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
    cached_roles = self._role_entries.freeze()
    return cache_utility.StatefulCacheMappingView(cached_roles)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_roles_view_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_roles_view_for_guild">get_roles_view_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_roles_view_for_guild -- Get a view of the roles in the cache for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_roles_view_for_guild"
>get_roles_view_for_guild</a></code>
</p>
<p>Get a view of the roles in the cache for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get the cached roles for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.Role'>Role</a>]</code></dt>
<dd>A view of role IDs to objects of the roles that were found in the
cache for the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1261-L1272" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_roles_view_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.Role]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.roles is None:
        return cache_utility.EmptyCacheView()

    # Tuple casts like this avoids edge case issues which would be caused by arrays being modified while we&#39;re
    # iterating over them.
    return cache_utility.StatefulCacheMappingView(
        {role_id: self._role_entries[role_id] for role_id in tuple(guild_record.roles)}
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_unavailable_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guild">get_unavailable_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
) -> Union[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_unavailable_guild -- Get the object of a unavailable guild from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_unavailable_guild"
>get_unavailable_guild</a></code>
</p>
<p>Get the object of a unavailable guild from the cache.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Unlike <code>Cache.get_available_guild</code>, the objects returned by this
method will likely be out of date and inaccurate as they are
considered unavailable, meaning that we are not receiving gateway
events for this guild.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>The object of the guild if found, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L361-L362" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_unavailable_guild(self, guild_id: snowflakes.Snowflake) -&gt; typing.Optional[guilds.GatewayGuild]:
    return self._get_guild(guild_id, availability=False)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guilds_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_unavailable_guilds_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guilds_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_unavailable_guilds_view">get_unavailable_guilds_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_unavailable_guilds_view -- Get a view of the unavailable guild objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_unavailable_guilds_view"
>get_unavailable_guilds_view</a></code>
</p>
<p>Get a view of the unavailable guild objects in the cache.</p>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>Unlike <code>Cache.get_available_guilds_view</code>, the objects returned by
this method will likely be out of date and inaccurate as they are
considered unavailable, meaning that we are not receiving gateway
events for this guild.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]</code></dt>
<dd>A view of guild IDs to the guild objects found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L378-L379" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_unavailable_guilds_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, guilds.GatewayGuild]:
    return self._get_guilds_view(availability=False)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_user" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_user" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_user" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_user">get_user</a>(
    user_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../users.html#hikari.users.User'>User</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_user -- Get a user object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_user"
>get_user</a></code>
</p>
<p>Get a user object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the user to get from the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>The object of the user that was found in the cache, else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1325-L1326" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_user(self, user_id: snowflakes.Snowflake, /) -&gt; typing.Optional[users.User]:
    return copy.copy(self._user_entries[user_id].object) if user_id in self._user_entries else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_users_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_users_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_users_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_users_view">get_users_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../users.html#hikari.users.User'>User</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_users_view -- Get a view of the user objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_users_view"
>get_users_view</a></code>
</p>
<p>Get a view of the user objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../users.html#hikari.users.User'>User</a>]</code></dt>
<dd>The view of user IDs to the users found in the cache.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1328-L1333" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_users_view(self) -&gt; cache.CacheView[snowflakes.Snowflake, users.User]:
    if not self._user_entries:
        return cache_utility.EmptyCacheView()

    cached_users = self._user_entries.freeze()
    return cache_utility.StatefulCacheMappingView(cached_users, unpack=True)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_state" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_voice_state" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_state" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_state">get_voice_state</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    user_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> Union[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>, None]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_voice_state -- Get a voice state object from the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_voice_state"
>get_voice_state</a></code>
</p>
<p>Get a voice state object from the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get a voice state for.</dd>
</dl>
<p>user_id :hikari.snowflakes.Snowflake
The ID of the user to get a voice state for.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>The object of the voice state that was found in the cache, or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1488-L1493" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_voice_state(
    self, guild_id: snowflakes.Snowflake, user_id: snowflakes.Snowflake, /
) -&gt; typing.Optional[voices.VoiceState]:
    guild_record = self._guild_entries.get(guild_id)
    voice_data = guild_record.voice_states.get(user_id) if guild_record and guild_record.voice_states else None
    return self._build_voice_state(voice_data) if voice_data else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_voice_states_view" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view">get_voice_states_view</a>() -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_voice_states_view -- Get a view of all the voice state objects in the cache …" href="../api/cache.html#hikari.api.cache.Cache.get_voice_states_view"
>get_voice_states_view</a></code>
</p>
<p>Get a view of all the voice state objects in the cache.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, ICacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]]</code></dt>
<dd>A view of guild IDs to views of user IDs to objects of the voice
states that were found in the cache,</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1508-L1538" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_voice_states_view(
    self,
) -&gt; cache.CacheView[snowflakes.Snowflake, cache.CacheView[snowflakes.Snowflake, voices.VoiceState]]:
    views: typing.MutableMapping[
        snowflakes.Snowflake, cache_utility.StatefulCacheMappingView[snowflakes.Snowflake, voices.VoiceState]
    ] = {}
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
    cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData]

    def builder_generator(
        cached_members_: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData]
    ) -&gt; typing.Callable[[cache_utility.VoiceStateData], voices.VoiceState]:
        return lambda voice_state_: self._build_voice_state(
            voice_state_, cached_members=cached_members_, cached_users=cached_users
        )

    for guild_id, guild_record in self._guild_entries.freeze().items():
        if not guild_record.voice_states:
            continue

        cached_voice_states = guild_record.voice_states.freeze()
        cached_members = {}

        for voice_state in cached_voice_states.values():
            self._chainable_get_voice_states_assets(voice_state, guild_record, cached_members, cached_users)

        views[guild_id] = cache_utility.StatefulCacheMappingView(
            cached_voice_states, builder=builder_generator(cached_members)
        )

    return cache_utility.Cache3DMappingView(views)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_channel" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_voice_states_view_for_channel" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_channel" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_channel">get_voice_states_view_for_channel</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    channel_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_voice_states_view_for_channel -- Get a view of the voice states cached for a specific channel …" href="../api/cache.html#hikari.api.cache.Cache.get_voice_states_view_for_channel"
>get_voice_states_view_for_channel</a></code>
</p>
<p>Get a view of the voice states cached for a specific channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get the cached voice states for.</dd>
<dt><strong><code>channel_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the channel to get the cached voice states for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>A view of user IDs to objects of the voice states found cached for
the specified channel.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1540-L1560" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_voice_states_view_for_channel(
    self, guild_id: snowflakes.Snowflake, channel_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.voice_states is None:
        return cache_utility.EmptyCacheView()

    cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}
    cached_voice_states = guild_record.voice_states.freeze()

    for voice_state in cached_voice_states.values():
        if voice_state.channel_id == channel_id:
            self._chainable_get_voice_states_assets(voice_state, guild_record, cached_members, cached_users)

    return cache_utility.StatefulCacheMappingView(
        cached_voice_states,
        builder=lambda voice_data: self._build_voice_state(
            voice_data, cached_members=cached_members, cached_users=cached_users
        ),
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="get_voice_states_view_for_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.get_voice_states_view_for_guild">get_voice_states_view_for_guild</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    /,
) -> <a href='../api/cache.html#hikari.api.cache.CacheView'>CacheView</a>[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="get_voice_states_view_for_guild -- Get a view of the voice states cached for a specific guild …" href="../api/cache.html#hikari.api.cache.Cache.get_voice_states_view_for_guild"
>get_voice_states_view_for_guild</a></code>
</p>
<p>Get a view of the voice states cached for a specific guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to get the cached voice states for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>CacheView[<a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>, <a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]</code></dt>
<dd>A view of user IDs to objects of the voice states found cached for
the specified guild.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1562-L1581" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def get_voice_states_view_for_guild(
    self, guild_id: snowflakes.Snowflake, /
) -&gt; cache.CacheView[snowflakes.Snowflake, voices.VoiceState]:
    guild_record = self._guild_entries.get(guild_id)
    if guild_record is None or guild_record.voice_states is None:
        return cache_utility.EmptyCacheView()

    voice_states = guild_record.voice_states.freeze()
    cached_members: typing.MutableMapping[snowflakes.Snowflake, cache_utility.MemberData] = {}
    cached_users: typing.MutableMapping[snowflakes.Snowflake, cache_utility.GenericRefWrapper[users.User]] = {}

    for voice_state in voice_states.values():
        self._chainable_get_voice_states_assets(voice_state, guild_record, cached_members, cached_users)

    return cache_utility.StatefulCacheMappingView(
        voice_states,
        builder=lambda voice_data: self._build_voice_state(
            voice_data, cached_members=cached_members, cached_users=cached_users
        ),
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_emoji" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_emoji" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_emoji" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_emoji">set_emoji</a>(
    emoji: <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_emoji -- Add a known custom emoji to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_emoji"
>set_emoji</a></code>
</p>
<p>Add a known custom emoji to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The object of the known custom emoji to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L283-L295" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_emoji(self, emoji: emojis.KnownCustomEmoji, /) -&gt; None:
    if emoji.user is not None:
        self.set_user(emoji.user)
        if emoji.id not in self._emoji_entries:
            self._increment_user_ref_count(emoji.user.id)

    self._emoji_entries[emoji.id] = cache_utility.KnownCustomEmojiData.build_from_entity(emoji)
    guild_container = self._get_or_create_guild_record(emoji.guild_id)

    if guild_container.emojis is None:  # TODO: add test cases when it is not None?
        guild_container.emojis = collections.SnowflakeSet()

    guild_container.emojis.add(emoji.id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_guild">set_guild</a>(
    guild: <a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_guild -- Add a guild object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_guild"
>set_guild</a></code>
</p>
<p>Add a guild object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a></code></dt>
<dd>The object of the guild to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L381-L384" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_guild(self, guild: guilds.GatewayGuild, /) -&gt; None:
    guild_record = self._get_or_create_guild_record(guild.id)
    guild_record.guild = copy.copy(guild)
    guild_record.is_available = True</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_availability" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_guild_availability" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_availability" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_availability">set_guild_availability</a>(
    guild_id: <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>snowflakes.Snowflake</a>,
    is_available: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_guild_availability -- Set whether a cached guild is available or not …" href="../api/cache.html#hikari.api.cache.MutableCache.set_guild_availability"
>set_guild_availability</a></code>
</p>
<p>Set whether a cached guild is available or not.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild_id</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The ID of the guild to set the availability for.</dd>
<dt><strong><code>is_available</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>The availability to set for the guild.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L386-L390" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_guild_availability(self, guild_id: snowflakes.Snowflake, is_available: bool, /) -&gt; None:
    guild_record = self._guild_entries.get(guild_id)

    if guild_record is not None and guild_record.guild is not None:
        guild_record.is_available = is_available</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_channel" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_guild_channel" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_channel" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_guild_channel">set_guild_channel</a>(
    channel: <a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_guild_channel -- Add a guild channel to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_guild_channel"
>set_guild_channel</a></code>
</p>
<p>Add a guild channel to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a></code></dt>
<dd>The guild channel based object to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L483-L490" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_guild_channel(self, channel: channels.GuildChannel, /) -&gt; None:
    self._guild_channel_entries[channel.id] = cache_utility.copy_guild_channel(channel)
    guild_record = self._get_or_create_guild_record(channel.guild_id)

    if guild_record.channels is None:
        guild_record.channels = collections.SnowflakeSet()

    guild_record.channels.add(channel.id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_invite" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_invite" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_invite" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_invite">set_invite</a>(
    invite: <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_invite -- Add an invite object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_invite"
>set_invite</a></code>
</p>
<p>Add an invite object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a></code></dt>
<dd>The object of the invite to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L710-L728" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_invite(self, invite: invites.InviteWithMetadata, /) -&gt; None:
    if invite.inviter is not None:
        self.set_user(invite.inviter)
        if invite.code not in self._invite_entries:
            self._increment_user_ref_count(invite.inviter.id)

    if invite.target_user is not None:
        self.set_user(invite.target_user)
        if invite.code not in self._invite_entries:
            self._increment_user_ref_count(invite.target_user.id)

    self._invite_entries[invite.code] = cache_utility.InviteData.build_from_entity(invite)
    if invite.guild_id:
        guild_entry = self._get_or_create_guild_record(invite.guild_id)

        if guild_entry.invites is None:
            guild_entry.invites = []

        guild_entry.invites.append(invite.code)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_me" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_me" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_me" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_me">set_me</a>(
    user: <a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_me -- Set the own user object in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_me"
>set_me</a></code>
</p>
<p>Set the own user object in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The own user object to set in the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L745-L746" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_me(self, user: users.OwnUser, /) -&gt; None:
    self._me = copy.copy(user)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_member" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_member" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_member" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_member">set_member</a>(
    member: <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_member -- Add a member object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_member"
>set_member</a></code>
</p>
<p>Add a member object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>member</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code></dt>
<dd>The object of the member to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L912-L923" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_member(self, member: guilds.Member, /) -&gt; None:
    guild_record = self._get_or_create_guild_record(member.guild_id)
    self.set_user(member.user)
    member_data = cache_utility.MemberData.build_from_entity(member)

    if guild_record.members is None:  # TODO: test when this is not None
        guild_record.members = collections.FreezableDict()

    if member.user.id not in guild_record.members:
        self._increment_user_ref_count(member.user.id)

    guild_record.members[member_data.id] = member_data</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_presence" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_presence" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_presence" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_presence">set_presence</a>(
    presence: <a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_presence -- Add a presence object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_presence"
>set_presence</a></code>
</p>
<p>Add a presence object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>presence</code></strong> :&ensp;<code><a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a></code></dt>
<dd>The object of the presence to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1178-L1202" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_presence(self, presence: presences.MemberPresence, /) -&gt; None:
    presence_data = cache_utility.MemberPresenceData.build_from_entity(presence)

    for activity in presence.activities:
        emoji = activity.emoji
        if emoji is None or not isinstance(emoji, emojis.CustomEmoji):
            continue

        if emoji.id in self._emoji_entries:
            self._increment_emoji_ref_count(emoji.id)

        elif emoji.id in self._unknown_custom_emoji_entries:
            self._unknown_custom_emoji_entries[emoji.id].ref_count += 1
            self._unknown_custom_emoji_entries[emoji.id].object = copy.copy(emoji)

        else:
            self._unknown_custom_emoji_entries[emoji.id] = cache_utility.GenericRefWrapper(
                object=copy.copy(emoji), ref_count=1
            )

    guild_record = self._get_or_create_guild_record(presence.guild_id)
    if guild_record.presences is None:
        guild_record.presences = collections.FreezableDict()

    guild_record.presences[presence.user_id] = presence_data</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_role" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_role" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_role" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_role">set_role</a>(
    role: <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_role -- Add a role object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_role"
>set_role</a></code>
</p>
<p>Add a role object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Role'>Role</a></code></dt>
<dd>The object of the role to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1274-L1281" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_role(self, role: guilds.Role, /) -&gt; None:
    self._role_entries[role.id] = role
    guild_record = self._get_or_create_guild_record(role.guild_id)

    if guild_record.roles is None:  # TODO: test when this is not None
        guild_record.roles = collections.SnowflakeSet()

    guild_record.roles.add(role.id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_user" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_user" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_user" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_user">set_user</a>(
    user: <a href='../users.html#hikari.users.User'>users.User</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_user -- Add a user object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_user"
>set_user</a></code>
</p>
<p>Add a user object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../users.html#hikari.users.User'>User</a></code></dt>
<dd>The object of the user to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1335-L1339" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_user(self, user: users.User, /) -&gt; None:
    try:
        self._user_entries[user.id].object = copy.copy(user)
    except KeyError:
        self._user_entries[user.id] = cache_utility.GenericRefWrapper(object=copy.copy(user), ref_count=0)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.set_voice_state" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="set_voice_state" href="#hikari.impl.stateful_cache.StatefulCacheImpl.set_voice_state" id="hikari.impl.stateful_cache.StatefulCacheImpl.set_voice_state">set_voice_state</a>(
    voice_state: <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>,
    /,
) -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="set_voice_state -- Add a voice state object to the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.set_voice_state"
>set_voice_state</a></code>
</p>
<p>Add a voice state object to the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>voice_state</code></strong> :&ensp;<code><a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a></code></dt>
<dd>The object of the voice state to add to the cache.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1583-L1593" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def set_voice_state(self, voice_state: voices.VoiceState, /) -&gt; None:
    guild_record = self._get_or_create_guild_record(voice_state.guild_id)

    if guild_record.voice_states is None:  # TODO: test when this is not None
        guild_record.voice_states = collections.FreezableDict()

    # TODO: account for this method not setting the member in some cases later on
    self.set_member(voice_state.member)
    assert guild_record.members is not None
    guild_record.members[voice_state.member.id].has_been_deleted = True
    guild_record.voice_states[voice_state.user_id] = cache_utility.VoiceStateData.build_from_entity(voice_state)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_emoji" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_emoji" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_emoji" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_emoji">update_emoji</a>(
    emoji: <a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>emojis.KnownCustomEmoji</a>,
    /,
) -> Tuple[Union[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>, None], Union[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_emoji -- Update an emoji object in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_emoji"
>update_emoji</a></code>
</p>
<p>Update an emoji object in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>emoji</code></strong> :&ensp;<code><a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a></code></dt>
<dd>The object of the emoji to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../emojis.html#hikari.emojis.KnownCustomEmoji'>KnownCustomEmoji</a>]]</code></dt>
<dd>A tuple of the old cached emoji object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the new cached emoji object if it could be cached (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L297-L302" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_emoji(
    self, emoji: emojis.KnownCustomEmoji, /
) -&gt; typing.Tuple[typing.Optional[emojis.KnownCustomEmoji], typing.Optional[emojis.KnownCustomEmoji]]:
    cached_emoji = self.get_emoji(emoji.id)
    self.set_emoji(emoji)
    return cached_emoji, self.get_emoji(emoji.id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_guild" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_guild" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_guild" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_guild">update_guild</a>(
    guild: <a href='../guilds.html#hikari.guilds.GatewayGuild'>guilds.GatewayGuild</a>,
    /,
) -> Tuple[Union[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>, None], Union[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_guild -- Update a guild in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_guild"
>update_guild</a></code>
</p>
<p>Update a guild in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a></code></dt>
<dd>The object of the guild to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.GatewayGuild'>GatewayGuild</a>]]</code></dt>
<dd>A tuple of the old cached guild object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the object of the guild that was added to the cache if it could
be added (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L392-L407" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_guild(
    self, guild: guilds.GatewayGuild, /
) -&gt; typing.Tuple[typing.Optional[guilds.GatewayGuild], typing.Optional[guilds.GatewayGuild]]:
    guild = copy.copy(guild)
    guild_record = self._guild_entries.get(guild.id)
    cached_guild = guild_record.guild if guild_record is not None else None

    # We have to manually update these because inconsistency by Discord.
    if cached_guild is not None:
        guild.member_count = cached_guild.member_count
        guild.joined_at = cached_guild.joined_at
        guild.is_large = cached_guild.is_large

    self.set_guild(guild)
    guild_record = self._guild_entries.get(guild.id)
    return cached_guild, guild_record.guild if guild_record is not None else None</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_guild_channel" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_guild_channel" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_guild_channel" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_guild_channel">update_guild_channel</a>(
    channel: <a href='../channels.html#hikari.channels.GuildChannel'>channels.GuildChannel</a>,
    /,
) -> Tuple[Union[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>, None], Union[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_guild_channel -- Update a guild channel in the cache, …" href="../api/cache.html#hikari.api.cache.MutableCache.update_guild_channel"
>update_guild_channel</a></code>
</p>
<p>Update a guild channel in the cache,</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a></code></dt>
<dd>The object of the channel to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../channels.html#hikari.channels.GuildChannel'>GuildChannel</a>]]</code></dt>
<dd>A tuple of the old cached guild channel if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the new cached guild channel if it could be cached
(else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L492-L497" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_guild_channel(
    self, channel: channels.GuildChannel, /
) -&gt; typing.Tuple[typing.Optional[channels.GuildChannel], typing.Optional[channels.GuildChannel]]:
    cached_channel = self.get_guild_channel(channel.id)
    self.set_guild_channel(channel)
    return cached_channel, self.get_guild_channel(channel.id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_invite" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_invite" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_invite" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_invite">update_invite</a>(
    invite: <a href='../invites.html#hikari.invites.InviteWithMetadata'>invites.InviteWithMetadata</a>,
    /,
) -> Tuple[Union[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>, None], Union[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_invite -- Update an invite in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_invite"
>update_invite</a></code>
</p>
<p>Update an invite in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>invite</code></strong> :&ensp;<code><a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a></code></dt>
<dd>The object of the invite to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../invites.html#hikari.invites.InviteWithMetadata'>InviteWithMetadata</a>]]</code></dt>
<dd>A tuple of the old cached invite object if found (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>) and the new cached invite object if it could be
cached (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L730-L735" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_invite(
    self, invite: invites.InviteWithMetadata, /
) -&gt; typing.Tuple[typing.Optional[invites.InviteWithMetadata], typing.Optional[invites.InviteWithMetadata]]:
    cached_invite = self.get_invite(invite.code)
    self.set_invite(invite)
    return cached_invite, self.get_invite(invite.code)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_me" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_me" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_me" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_me">update_me</a>(
    user: <a href='../users.html#hikari.users.OwnUser'>users.OwnUser</a>,
    /,
) -> Tuple[Union[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>, None], Union[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_me -- Update the own user entry in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_me"
>update_me</a></code>
</p>
<p>Update the own user entry in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../users.html#hikari.users.OwnUser'>OwnUser</a></code></dt>
<dd>The own user object to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.OwnUser'>OwnUser</a>]]</code></dt>
<dd>A tuple of the old cached own user object if found (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>) and the new cached own user object if it could be
cached, else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L748-L754" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_me(
    self, user: users.OwnUser, /
) -&gt; typing.Tuple[typing.Optional[users.OwnUser], typing.Optional[users.OwnUser]]:
    _LOGGER.debug(&#34;setting my user to %s&#34;, user)
    cached_user = self.get_me()
    self.set_me(user)
    return cached_user, self._me</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_member" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_member" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_member" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_member">update_member</a>(
    member: <a href='../guilds.html#hikari.guilds.Member'>guilds.Member</a>,
    /,
) -> Tuple[Union[<a href='../guilds.html#hikari.guilds.Member'>Member</a>, None], Union[<a href='../guilds.html#hikari.guilds.Member'>Member</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_member -- Update a member in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_member"
>update_member</a></code>
</p>
<p>Update a member in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>member</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Member'>Member</a></code></dt>
<dd>The object of the member to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Member'>Member</a>]]</code></dt>
<dd>A tuple of the old cached member object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the new cached member object if it could be cached (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L925-L930" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_member(
    self, member: guilds.Member, /
) -&gt; typing.Tuple[typing.Optional[guilds.Member], typing.Optional[guilds.Member]]:
    cached_member = self.get_member(member.guild_id, member.user.id)
    self.set_member(member)
    return cached_member, self.get_member(member.guild_id, member.user.id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_presence" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_presence" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_presence" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_presence">update_presence</a>(
    presence: <a href='../presences.html#hikari.presences.MemberPresence'>presences.MemberPresence</a>,
    /,
) -> Tuple[Union[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>, None], Union[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_presence -- Update a presence object in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_presence"
>update_presence</a></code>
</p>
<p>Update a presence object in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>presence</code></strong> :&ensp;<code><a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a></code></dt>
<dd>The object of the presence to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.MemberPresence'>MemberPresence</a>]]</code></dt>
<dd>A tuple of the old cached invite object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>
and the new cached invite object if it could be cached ( else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1204-L1209" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_presence(
    self, presence: presences.MemberPresence, /
) -&gt; typing.Tuple[typing.Optional[presences.MemberPresence], typing.Optional[presences.MemberPresence]]:
    cached_presence = self.get_presence(presence.guild_id, presence.user_id)
    self.set_presence(presence)
    return cached_presence, self.get_presence(presence.guild_id, presence.user_id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_role" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_role" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_role" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_role">update_role</a>(
    role: <a href='../guilds.html#hikari.guilds.Role'>guilds.Role</a>,
    /,
) -> Tuple[Union[<a href='../guilds.html#hikari.guilds.Role'>Role</a>, None], Union[<a href='../guilds.html#hikari.guilds.Role'>Role</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_role -- Update a role in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_role"
>update_role</a></code>
</p>
<p>Update a role in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Role'>Role</a></code></dt>
<dd>The object of the role to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../guilds.html#hikari.guilds.Role'>Role</a>]]</code></dt>
<dd>A tuple of the old cached role object if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>
and the new cached role object if it could be cached (else
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1283-L1288" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_role(
    self, role: guilds.Role, /
) -&gt; typing.Tuple[typing.Optional[guilds.Role], typing.Optional[guilds.Role]]:
    cached_role = self.get_role(role.id)
    self.set_role(role)
    return cached_role, self.get_role(role.id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_user" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_user" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_user" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_user">update_user</a>(
    user: <a href='../users.html#hikari.users.User'>users.User</a>,
    /,
) -> Tuple[Union[<a href='../users.html#hikari.users.User'>User</a>, None], Union[<a href='../users.html#hikari.users.User'>User</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_user -- Update a user object in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_user"
>update_user</a></code>
</p>
<p>Update a user object in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code><a href='../users.html#hikari.users.User'>User</a></code></dt>
<dd>The object of the user to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>User</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../users.html#hikari.users.User'>User</a>]]</code></dt>
<dd>A tuple of the old cached user if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>) and
the newly cached user if it could be cached (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1341-L1346" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_user(
    self, user: users.User, /
) -&gt; typing.Tuple[typing.Optional[users.User], typing.Optional[users.User]]:
    cached_user = self.get_user(user.id)
    self.set_user(user)
    return cached_user, self.get_user(user.id)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.stateful_cache.StatefulCacheImpl.update_voice_state" class="hljs python"><abbr title='A standard Python function.'>def</abbr> <a title="update_voice_state" href="#hikari.impl.stateful_cache.StatefulCacheImpl.update_voice_state" id="hikari.impl.stateful_cache.StatefulCacheImpl.update_voice_state">update_voice_state</a>(
    voice_state: <a href='../voices.html#hikari.voices.VoiceState'>voices.VoiceState</a>,
    /,
) -> Tuple[Union[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>, None], Union[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>, None]]: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="MutableCache -- Cache that exposes read-only operations as well as mutation operations …" href="../api/cache.html#hikari.api.cache.MutableCache"
>MutableCache</a></code>.<code><a title="update_voice_state -- Update a voice state object in the cache …" href="../api/cache.html#hikari.api.cache.MutableCache.update_voice_state"
>update_voice_state</a></code>
</p>
<p>Update a voice state object in the cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>voice_state</code></strong> :&ensp;<code><a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a></code></dt>
<dd>The object of the voice state to update in the cache.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/typing.html#typing.Tuple'>Tuple</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>], <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../voices.html#hikari.voices.VoiceState'>VoiceState</a>]]</code></dt>
<dd>A tuple of the old cached voice state if found (else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>)
and the new cached voice state object if it could be cached
(else <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#NotImplementedError'>NotImplementedError</a></code></dt>
<dd>When called on a stateless cache implementation.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/stateful_cache.py#L1595-L1600" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">def update_voice_state(
    self, voice_state: voices.VoiceState, /
) -&gt; typing.Tuple[typing.Optional[voices.VoiceState], typing.Optional[voices.VoiceState]]:
    cached_voice_state = self.get_voice_state(voice_state.guild_id, voice_state.user_id)
    self.set_voice_state(voice_state)
    return cached_voice_state, self.get_voice_state(voice_state.guild_id, voice_state.user_id)</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</dl>
</section>
</div>
</div>
</div>
<!-- Search script and dependencies -->
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../search.html#' + encodeURIComponent(query);
window.location.href = url;
};
</script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>