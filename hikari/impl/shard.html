<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!--
Copyright (c) 2020 Nekokatt
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>hikari.impl.shard API documentation</title>
<meta name="description" content="Single-shard implementation for the V8 event gateway for Discord." />
<meta property="og:title" content="hikari.impl.shard module documentation" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://hikari-py.github.io/hikari/logo.png" />
<meta property="og:description" content="A Discord Bot framework for modern Python and asyncio built on good intentions" />
<meta property="theme-color" content="#ff029a" />
<link rel="shortcut icon" type="image/png" href="https://hikari-py.github.io/hikari/logo.png"/>
<!--<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>.gsc-control-cse {padding:0 !important;margin-top:1em}</style>-->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" rel="stylesheet"/>
<style>
* {
scrollbar-color: #202324 #454a4d;
scroll-behavior: smooth;
}
img#logo {
border-radius: 15px;
width: 30px;
height: 30px;
margin-right: 0.5em;
}
small.smaller {
font-size: 0.75em;
}
body {
background-color: #181A1B;
color: #C9C5C0;
}
h1 {
margin-top: 3rem;
}
h2 {
margin-top: 1.75rem;
margin-bottom: 1em;
}
h3 {
margin-top: 1.25rem;
}
h4 {
margin-top: 1rem;
}
.nav-section {
margin-top: 2em;
}
.monospaced {
font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}
a.sidebar-nav-pill,
a.sidebar-nav-pill:active,
a.sidebar-nav-pill:hover {
color: #BDB7AF;
}
.module-source > details > pre {
display: block;
overflow-x: auto;
overflow-y: auto;
max-height: 600px;
font-size: 0.8em;
}
a {
color: #DE4F91;
}
a:hover {
color: #64B1F2;
}
.jumbotron {
background-color: #232627;
}
.breadcrumb-item.inactive > a {
color: #d264d0 !important;
}
.breadcrumb-item.active > a {
color: #de4f91 !important;
}
.breadcrumb-item+.breadcrumb-item::before {
content: ".";
}
.module-breadcrumb {
padding-left: 0 !important;
background-color: #232627;
}
ul.nested {
margin-left: 1em;
}
h2#parameters::after {
margin-left: 2em;
}
dt {
margin-left: 2em;
}
dd {
margin-left: 4em;
}
dl.no-nest > dt {
margin-left: 0em;
}
dl.no-nest > dd {
margin-left: 2em;
}
dl.root {
margin-bottom: 2em;
}
.definition {
display: block;
margin-bottom: 8em !important;
}
.definition .row {
display: block;
margin-bottom: 4em !important;
}
.definition h2 {
font-size: 1em;
font-weight: bolder;
}
.sep {
height: 2em;
}
code {
color: #DB61D9;
}
code .active {
color: #e83e8c;
}
code a {
color: #E94A93;
}
a.dotted:hover, abbr:hover {
text-decoration: underline #9E9689 dotted !important;
}
a.dotted, abbr {
text-decoration: none !important;
}
.gsc-search-box, .gsc-search-box-tools, .gsc-control-cse {
background: none !important;
border: none !important;
}
.gsc-search-button-v2, .gsc-search-button-v2:hover, .gsc-search-button-v2:focus {
color: var(--success) !important;
border-color: var(--success) !important;
background: none !important;
padding: 6px 32px !important;
font-size: inherit !important;
}
.gsc-search-button-v2 > svg {
fill: var(--success) !important;
}
.gsc-input-box {
border-radius: 3px;
}
.gsc-control-cse {
width: 300px !important;
margin-top: 0 !important;
}
.gsc-control-cse .gsc-control-cse-en {
margin-top: 0 !important;
}
.bg-dark {
background-color: #2C2F31 !important;
}
.text-muted {
color: #9E9689 !important;
}
.alert-primary {
color: #7CC3FF;
background-color: #262A2B;
border-color: #003B7B;
}
.alert-secondary {
color: #C2BCB4;
background-color: #282B2C;
border-color: #3B4042;
}
.alert-success {
color: #99E6AB;
background-color: #1A3E29;
border-color: #255A32;
}
.alert-info {
color: #8EE3F1;
background-color: #143B43;
border-color: #1E5961;
}
.alert-warning {
color: #FBD770;
background-color: #513E00;
border-color: #7B5C00;
}
.alert-danger {
color: rgb(225, 134, 143);
background-color: rgb(67, 12, 17);
border-color: rgb(104, 18, 27);
}
mark {
background-color: #333333;
border-radius: 0.1em;
color: #DB61D9;
}
</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<!-- body.mako -->
<nav id="main-nav" class="navbar navbar-dark navbar-expand-lg bg-dark">
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"/>
</button>
<a class="navbar-brand" href="https://github.com/hikari-py/hikari"><img class="d-inline-block align-top" src="https://hikari-py.github.io/hikari/logo.png" id="logo" alt="hikari logo" loading="lazy"/>Hikari <small>v2.0.0.dev92</small></a>
<div class="collapse navbar-collapse" id="navbarNavDropdown">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/hikari/index.html">Home</a></li>
<li class="nav-item active"><a class="nav-link" href="/hikari/hikari/index.html">Documentation</a></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/hikari-py/hikari">GitHub</a></li>
<li class="nav-item"><a class="nav-link" href="https://pypi.org/project/hikari">PyPI</a></li>
<li class="nav-item"><a class="nav-link" href="https://discord.gg/Jx4cNGG">Discord Server</a></li>
</ul>
<form class="form-inline" >
<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search" id="lunr-search"/>
<button class="btn btn-outline-success my-2 my-sm-0" type="submit">&gt;</button>
</form>
</div>
</nav>
<div class="jumbotron jumbotron-fluid">
<div class="container">
<h1 class="display-4"><code>
<nav aria-label="breadcrumb">
<ol class="breadcrumb module-breadcrumb">
<li class="breadcrumb-item inactive"><a title="hikari -- A sane Python framework for writing modern Discord bots …" href="../index.html"
>hikari</a></li>
<li class="breadcrumb-item inactive"><a title="hikari.impl -- Basic implementations of application components …" href="index.html"
>impl</a></li>
<li class="breadcrumb-item active"><a href="#">shard</a></li>
</ol>
</nav>
</code></h1>
<p class="lead"><p>Single-shard implementation for the V8 event gateway for Discord.</p></p>
</div>
</div>
<div class="container-xl">
<div class="row">
<div class="d-md-none d-lg-block col-lg-5 col-xl-4">
<!--<nav class="nav" id="content-nav">-->
<h3>This module</h3>
<ul class="list-unstyled text-truncate">
<li class="monospaced">
<small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="GatewayShardImpl -- Implementation of a V6 and V7 compatible gateway …" href="#hikari.impl.shard.GatewayShardImpl"
>GatewayShardImpl</a>
<ul class="list-unstyled nested text-truncate">
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="close -- Close the websocket if it is connected, otherwise do nothing." href="#hikari.impl.shard.GatewayShardImpl.close"
>close</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="get_user_id -- Return the user ID …" href="#hikari.impl.shard.GatewayShardImpl.get_user_id"
>get_user_id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="heartbeat_latency -- Return the shard's most recent heartbeat latency …" href="#hikari.impl.shard.GatewayShardImpl.heartbeat_latency"
>heartbeat_latency</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- Return the shard ID for this shard …" href="#hikari.impl.shard.GatewayShardImpl.id"
>id</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="intents -- Return the intents set on this shard …" href="#hikari.impl.shard.GatewayShardImpl.intents"
>intents</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_alive -- Return `builtins.True` if the shard is alive and connected …" href="#hikari.impl.shard.GatewayShardImpl.is_alive"
>is_alive</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="join -- Wait for this shard to close, if running." href="#hikari.impl.shard.GatewayShardImpl.join"
>join</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="request_guild_members -- Request for a guild chunk …" href="#hikari.impl.shard.GatewayShardImpl.request_guild_members"
>request_guild_members</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard_count -- Return the total number of shards expected in the entire application …" href="#hikari.impl.shard.GatewayShardImpl.shard_count"
>shard_count</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="start -- Start the shard, wait for it to become ready." href="#hikari.impl.shard.GatewayShardImpl.start"
>start</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="update_presence -- Update the presence of the shard user …" href="#hikari.impl.shard.GatewayShardImpl.update_presence"
>update_presence</a>
</li>
<li class="text-truncate monospaced">
<small class='text-muted'><em><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr></em></small> <a title="update_voice_state -- Update the voice state for this shard in a given guild …" href="#hikari.impl.shard.GatewayShardImpl.update_voice_state"
>update_voice_state</a>
</li>
<br />
</ul>
</li>
</ul>
<!--</nav>-->
</div>
<div class="col-xs-12 col-lg-7 col-xl-8">
<div class="row">
<div class="col module-source">
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/shard.py#L0-L988" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# cython: language_level=3
# Copyright (c) 2020 Nekokatt
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
&#34;&#34;&#34;Single-shard implementation for the V8 event gateway for Discord.&#34;&#34;&#34;

from __future__ import annotations

__all__: typing.List[str] = [&#34;GatewayShardImpl&#34;]

import asyncio
import contextlib
import json
import logging
import platform
import sys
import typing
import urllib.parse
import zlib

import aiohttp

from hikari import _about as about
from hikari import errors
from hikari import intents as intents_
from hikari import presences
from hikari import snowflakes
from hikari import undefined
from hikari.api import shard
from hikari.impl import rate_limits
from hikari.internal import data_binding
from hikari.internal import net
from hikari.internal import time
from hikari.internal import ux

if typing.TYPE_CHECKING:
    import datetime

    import aiohttp.http_websocket
    import aiohttp.typedefs

    from hikari import channels
    from hikari import config
    from hikari import guilds
    from hikari import users as users_

# Important attributes
_D: typing.Final[str] = sys.intern(&#34;d&#34;)
_T: typing.Final[str] = sys.intern(&#34;t&#34;)
_S: typing.Final[str] = sys.intern(&#34;s&#34;)
_OP: typing.Final[str] = sys.intern(&#34;op&#34;)

# Opcodes.
_DISPATCH: typing.Final[int] = 0
_HEARTBEAT: typing.Final[int] = 1
_IDENTIFY: typing.Final[int] = 2
_PRESENCE_UPDATE: typing.Final[int] = 3
_VOICE_STATE_UPDATE: typing.Final[int] = 4
_RESUME: typing.Final[int] = 6
_RECONNECT: typing.Final[int] = 7
_REQUEST_GUILD_MEMBERS: typing.Final[int] = 8
_INVALID_SESSION: typing.Final[int] = 9
_HELLO: typing.Final[int] = 10
_HEARTBEAT_ACK: typing.Final[int] = 11
# If we disconnect within this period of time after starting, we should
# use an exponential backoff before restarting.
_BACKOFF_WINDOW: typing.Final[float] = 30.0
_BACKOFF_BASE: typing.Final[float] = 1.85
_BACKOFF_INCREMENT_START: typing.Final[int] = 2
_BACKOFF_CAP: typing.Final[float] = 60.0
# Discord seems to invalidate sessions if I send a 1xxx, which is useless
# for invalid session and reconnect messages where I want to be able to
# resume.
_RESUME_CLOSE_CODE: typing.Final[int] = 3_000
# Per-shard sending rate-limit
_TOTAL_RATELIMIT: typing.Final[typing.Tuple[float, int]] = (60.0, 120)
# Rate-limit for chunking requests (used to prevent saturating the entire
# ratelimit window).
_CHUNKING_RATELIMIT: typing.Final[typing.Tuple[float, int]] = (60.0, 60)
# Supported gateway version
_VERSION: int = 8


def _log_filterer(token: str) -&gt; typing.Callable[[str], str]:
    def filterer(entry: str) -&gt; str:
        return entry.replace(token, &#34;**REDACTED TOKEN**&#34;)

    return filterer


if typing.TYPE_CHECKING:
    # noinspection PyProtectedMember,PyUnresolvedReferences
    _ZlibDecompressor = zlib._Decompress


@typing.final
class _GatewayTransport(aiohttp.ClientWebSocketResponse):
    &#34;&#34;&#34;Internal component to handle lower-level communication logic.

    This includes translating aiohttp error conditions to hikari ones,
    handling inbound zlib packets, creating the websocket and client session,
    and ensuring all resources are freed deterministically where possible.

    Payload logging is also performed here.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (&#34;zlib&#34;, &#34;logger&#34;, &#34;log_filterer&#34;, &#34;sent_close&#34;)

    # Initialized from `connect&#39;
    zlib: _ZlibDecompressor
    logger: logging.Logger
    log_filterer: typing.Callable[[str], str]
    sent_close: bool

    def __init__(self, *args: typing.Any, **kwargs: typing.Any) -&gt; None:
        super().__init__(*args, **kwargs)
        self.zlib = zlib.decompressobj()
        self.sent_close = False

    async def send_close(self, *, code: int = 1000, message: bytes = b&#34;&#34;) -&gt; bool:
        # aiohttp may close the socket by invoking close() internally. By giving
        # a different name, we can ensure aiohttp won&#39;t invoke this method.
        # We can then guarantee any call to this method was made by us, as
        # opposed to, for example, Windows injecting a spurious EOF when
        # something disconnects, which makes aiohttp just shut down as if we
        # did it.
        if not self.sent_close:
            self.logger.debug(&#34;sending close frame with code %s and message %s&#34;, int(code), message)
            try:
                return await asyncio.wait_for(super().close(code=code, message=message), timeout=5)
            except asyncio.TimeoutError:
                self.logger.debug(&#34;failed to send close frame in time, probably connection issues&#34;)
        return False

    async def receive_json(
        self,
        *,
        loads: aiohttp.typedefs.JSONDecoder = json.loads,
        timeout: typing.Optional[float] = None,
    ) -&gt; typing.Any:
        pl = await self._receive_and_check(timeout)
        if self.logger.getEffectiveLevel() &lt;= ux.TRACE:
            filtered = self.log_filterer(pl)  # type: ignore
            self.logger.log(ux.TRACE, &#34;received payload with size %s\n    %s&#34;, len(pl), filtered)
        return loads(pl)

    async def send_json(
        self,
        data: data_binding.JSONObject,
        compress: typing.Optional[int] = None,
        *,
        dumps: aiohttp.typedefs.JSONEncoder = json.dumps,
    ) -&gt; None:
        pl = dumps(data)
        if self.logger.getEffectiveLevel() &lt;= ux.TRACE:
            filtered = self.log_filterer(pl)  # type: ignore
            self.logger.log(ux.TRACE, &#34;sending payload with size %s\n    %s&#34;, len(pl), filtered)
        await self.send_str(pl, compress)

    async def _receive_and_check(self, timeout: typing.Optional[float], /) -&gt; str:
        buff = bytearray()

        while True:
            message = await self.receive(timeout)

            if message.type == aiohttp.WSMsgType.CLOSE:
                close_code = int(message.data)
                reason = message.extra
                self.logger.error(&#34;connection closed with code %s (%s)&#34;, close_code, reason)

                can_reconnect = close_code &lt; 4000 or close_code in (
                    errors.ShardCloseCode.UNKNOWN_ERROR,
                    errors.ShardCloseCode.DECODE_ERROR,
                    errors.ShardCloseCode.INVALID_SEQ,
                    errors.ShardCloseCode.SESSION_TIMEOUT,
                    errors.ShardCloseCode.RATE_LIMITED,
                )

                # Assume we can always resume first.
                raise errors.GatewayServerClosedConnectionError(reason, close_code, can_reconnect)

            elif message.type == aiohttp.WSMsgType.CLOSING or message.type == aiohttp.WSMsgType.CLOSED:
                # May be caused by the server shutting us down.
                # May be caused by Windows injecting an EOF if something disconnects, as some
                # network drivers appear to do this.
                raise errors.GatewayError(&#34;Socket has closed&#34;)

            elif len(buff) != 0 and message.type != aiohttp.WSMsgType.BINARY:
                raise errors.GatewayError(f&#34;Unexpected message type received {message.type.name}, expected BINARY&#34;)

            elif message.type == aiohttp.WSMsgType.BINARY:
                buff.extend(message.data)

                if buff.endswith(b&#34;\x00\x00\xff\xff&#34;):
                    return self.zlib.decompress(buff).decode(&#34;utf-8&#34;)

            elif message.type == aiohttp.WSMsgType.TEXT:
                return message.data  # type: ignore

            else:
                # Assume exception for now.
                ex = self.exception()
                self.logger.warning(
                    &#34;encountered unexpected error: %s&#34;,
                    ex,
                    exc_info=ex if self.logger.isEnabledFor(logging.DEBUG) else None,
                )
                raise errors.GatewayError(&#34;Unexpected websocket exception from gateway&#34;) from ex

    @classmethod
    @contextlib.asynccontextmanager
    async def connect(
        cls,
        *,
        http_settings: config.HTTPSettings,
        logger: logging.Logger,
        proxy_settings: config.ProxySettings,
        log_filterer: typing.Callable[[str], str],
        url: str,
    ) -&gt; typing.AsyncGenerator[_GatewayTransport, None]:
        &#34;&#34;&#34;Generate a single-use websocket connection.

        This uses a single connection in a TCP connector pool, with a one-use
        aiohttp client session.

        This also handles waiting for transports to be closed properly first,
        and keeps all of the nested boilerplate out of the way of the
        rest of the code, for the most part anyway.
        &#34;&#34;&#34;
        exit_stack = contextlib.AsyncExitStack()

        try:
            connector = net.create_tcp_connector(http_settings, dns_cache=False, limit=1)
            client_session = await exit_stack.enter_async_context(
                net.create_client_session(connector, True, http_settings, True, proxy_settings.trust_env, cls)
            )

            web_socket = await exit_stack.enter_async_context(
                client_session.ws_connect(
                    max_msg_size=0,
                    proxy=proxy_settings.url,
                    proxy_headers=proxy_settings.headers,
                    url=url,
                )
            )

            assert isinstance(web_socket, cls)

            raised = False
            try:
                web_socket.logger = logger
                # We store this so we can remove it from debug logs
                # which enables people to send me logs in issues safely.
                # Also MyPy raises a false positive about this...
                web_socket.log_filterer = log_filterer  # type: ignore

                yield web_socket
            except errors.GatewayError:
                raised = True
                raise
            except Exception as ex:
                raised = True
                raise errors.GatewayError(f&#34;Unexpected {type(ex).__name__}: {ex}&#34;) from ex
            finally:
                if web_socket.closed:
                    logger.log(ux.TRACE, &#34;ws was already closed&#34;)

                elif raised:
                    await web_socket.send_close(
                        code=errors.ShardCloseCode.UNEXPECTED_CONDITION,
                        message=b&#34;unexpected fatal client error :-(&#34;,
                    )

                elif not web_socket._closing:
                    # We use a special close code here that prevents Discord
                    # randomly invalidating our session. Undocumented behaviour is
                    # nice like that...
                    await web_socket.send_close(
                        code=_RESUME_CLOSE_CODE,
                        message=b&#34;client is shutting down&#34;,
                    )

        except (aiohttp.ClientOSError, aiohttp.ClientConnectionError, aiohttp.WSServerHandshakeError) as ex:
            # Windows will sometimes raise an aiohttp.ClientOSError
            # If we cannot do DNS lookup, this will fail with a ClientConnectionError
            # usually.
            raise errors.GatewayConnectionError(f&#34;Failed to connect to Discord: {ex!r}&#34;) from ex

        finally:
            await exit_stack.aclose()

            # We have to sleep to allow aiohttp time to close SSL transports...
            # https://github.com/aio-libs/aiohttp/issues/1925
            # https://docs.aiohttp.org/en/stable/client_advanced.html#graceful-shutdown
            await asyncio.sleep(0.25)


@typing.final
class GatewayShardImpl(shard.GatewayShard):
    &#34;&#34;&#34;Implementation of a V6 and V7 compatible gateway.

    Parameters
    ----------
    compression : typing.Optional[buitlins.str]
        Compression format to use for the shard. Only supported values are
        `&#34;payload_zlib_stream&#34;` or `builtins.None` to disable it.
    initial_activity : typing.Optional[hikari.presences.Activity]
        The initial activity to appear to have for this shard, or
        `builtins.None` if no activity should be set initially. This is the
        default.
    initial_idle_since : typing.Optional[datetime.datetime]
        The datetime to appear to be idle since, or `builtins.None` if the
        shard should not provide this. The default is `builtins.None`.
    initial_is_afk : bool
        Whether to appear to be AFK or not on login. Defaults to
        `builtins.False`.
    initial_status : hikari.presences.Status
        The initial status to set on login for the shard. Defaults to
        `hikari.presences.Status.ONLINE`.
    intents : hikari.intents.Intents
        Collection of intents to use. Unlike on the V6 gateway, this is
        MANDATORY.
    large_threshold : builtins.int
        The number of members to have in a guild for it to be considered large.
    shard_id : builtins.int
        The shard ID.
    shard_count : builtins.int
        The shard count.
    event_consumer
        A non-coroutine function consuming a `GatewayShardImpl`,
        a `builtins.str` event name, and a
        `hikari.internal.data_binding.JSONObject` event object as parameters.
        This should return `builtins.None`, and will be called with each event
        that fires.
    http_settings : hikari.config.HTTPSettings
        The HTTP-related settings to use while negotiating a websocket.
    proxy_settings : hikari.config.ProxySettings
        The proxy settings to use while negotiating a websocket.
    data_format : builtins.str
        Data format to use for inbound data. Only supported format is
        `&#34;json&#34;`.
    token : builtins.str
        The bot token to use.
    url : builtins.str
        The gateway URL to use. This should not contain a query-string or
        fragments.

    !!! note
        If all four of `initial_activity`, `initial_idle_since`,
        `initial_is_afk`, and `initial_status` are not defined and left to their
        default values, then the presence will not be _updated_ on startup
        at all.
        If any of these _are_ specified, then any that are not specified will
        be set to sane defaults, which may change the previous status. This will
        only occur during startup, and is an artifact of how Discord manages
        these updates internally. All other calls to update the status of
        the shard will support partial updates.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_activity&#34;,
        &#34;_closed&#34;,
        &#34;_closing&#34;,
        &#34;_chunking_rate_limit&#34;,
        &#34;_event_consumer&#34;,
        &#34;_handshake_completed&#34;,
        &#34;_heartbeat_latency&#34;,
        &#34;_http_settings&#34;,
        &#34;_idle_since&#34;,
        &#34;_intents&#34;,
        &#34;_is_afk&#34;,
        &#34;_large_threshold&#34;,
        &#34;_last_heartbeat_ack_received&#34;,
        &#34;_last_heartbeat_sent&#34;,
        &#34;_logger&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_run_task&#34;,
        &#34;_seq&#34;,
        &#34;_session_id&#34;,
        &#34;_shard_count&#34;,
        &#34;_shard_id&#34;,
        &#34;_status&#34;,
        &#34;_token&#34;,
        &#34;_total_rate_limit&#34;,
        &#34;_url&#34;,
        &#34;_user_id&#34;,
        &#34;_ws&#34;,
    )

    def __init__(
        self,
        *,
        compression: typing.Optional[str] = shard.GatewayCompression.PAYLOAD_ZLIB_STREAM,
        initial_activity: typing.Optional[presences.Activity] = None,
        initial_idle_since: typing.Optional[datetime.datetime] = None,
        initial_is_afk: bool = False,
        initial_status: presences.Status = presences.Status.ONLINE,
        intents: intents_.Intents,
        large_threshold: int = 250,
        shard_id: int = 0,
        shard_count: int = 1,
        event_consumer: typing.Callable[[shard.GatewayShard, str, data_binding.JSONObject], None],
        http_settings: config.HTTPSettings,
        proxy_settings: config.ProxySettings,
        data_format: str = shard.GatewayDataFormat.JSON,
        token: str,
        url: str,
    ) -&gt; None:

        if data_format != shard.GatewayDataFormat.JSON:
            raise NotImplementedError(f&#34;Unsupported gateway data format: {data_format}&#34;)

        query = {&#34;v&#34;: _VERSION, &#34;encoding&#34;: str(data_format)}

        if compression is not None:
            if compression == shard.GatewayCompression.PAYLOAD_ZLIB_STREAM:
                query[&#34;compress&#34;] = &#34;zlib-stream&#34;
            else:
                raise NotImplementedError(f&#34;Unsupported compression format {compression}&#34;)

        scheme, netloc, path, params, _, _ = urllib.parse.urlparse(url, allow_fragments=True)
        new_query = urllib.parse.urlencode(query)

        self._activity = initial_activity
        self._closing = asyncio.Event()
        self._closed = asyncio.Event()
        self._chunking_rate_limit = rate_limits.WindowedBurstRateLimiter(
            f&#34;shard {shard_id} chunking rate limit&#34;,
            *_CHUNKING_RATELIMIT,
        )
        self._event_consumer = event_consumer
        self._handshake_completed = asyncio.Event()
        self._heartbeat_latency = float(&#34;nan&#34;)
        self._http_settings = http_settings
        self._idle_since = initial_idle_since
        self._intents = intents
        self._is_afk = initial_is_afk
        self._large_threshold = large_threshold
        self._last_heartbeat_ack_received = float(&#34;nan&#34;)
        self._last_heartbeat_sent = float(&#34;nan&#34;)
        self._logger = logging.getLogger(f&#34;hikari.gateway.{shard_id}&#34;)
        self._proxy_settings = proxy_settings
        self._run_task: typing.Optional[asyncio.Task[None]] = None
        self._seq: typing.Optional[int] = None
        self._session_id: typing.Optional[str] = None
        self._shard_count = shard_count
        self._shard_id = shard_id
        self._status = initial_status
        self._token = token
        self._total_rate_limit = rate_limits.WindowedBurstRateLimiter(
            f&#34;shard {shard_id} total rate limit&#34;,
            *_TOTAL_RATELIMIT,
        )
        self._url = urllib.parse.urlunparse((scheme, netloc, path, params, new_query, &#34;&#34;))
        self._user_id: typing.Optional[snowflakes.Snowflake] = None
        self._ws: typing.Optional[_GatewayTransport] = None

    @property
    def heartbeat_latency(self) -&gt; float:
        return self._heartbeat_latency

    @property
    def id(self) -&gt; int:
        return self._shard_id

    @property
    def intents(self) -&gt; intents_.Intents:
        return self._intents

    @property
    def is_alive(self) -&gt; bool:
        return self._run_task is not None and not self._run_task.done()

    @property
    def shard_count(self) -&gt; int:
        return self._shard_count

    async def close(self) -&gt; None:
        if not self._closing.is_set():
            try:
                if self._ws is not None:
                    self._logger.debug(
                        &#34;shard.close() was called and the websocket was still alive -- &#34;
                        &#34;disconnecting immediately with GOING AWAY&#34;
                    )
                    await self._ws.close(code=errors.ShardCloseCode.GOING_AWAY, message=b&#34;shard disconnecting&#34;)
                self._closing.set()
            finally:
                self._chunking_rate_limit.close()
                self._total_rate_limit.close()

    async def get_user_id(self) -&gt; snowflakes.Snowflake:
        await self._handshake_completed.wait()
        if self._user_id is None:
            raise RuntimeError(&#34;user_id was not known, this is probably a bug&#34;)
        return self._user_id

    async def join(self) -&gt; None:
        &#34;&#34;&#34;Wait for this shard to close, if running.&#34;&#34;&#34;
        await self._closed.wait()

    async def request_guild_members(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        include_presences: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        query: str = &#34;&#34;,
        limit: int = 0,
        users: undefined.UndefinedOr[typing.Sequence[snowflakes.SnowflakeishOr[users_.User]]] = undefined.UNDEFINED,
        nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if not query and not limit and not self._intents &amp; intents_.Intents.GUILD_MEMBERS:
            raise errors.MissingIntentError(intents_.Intents.GUILD_MEMBERS)

        if include_presences is not undefined.UNDEFINED and not self._intents &amp; intents_.Intents.GUILD_PRESENCES:
            raise errors.MissingIntentError(intents_.Intents.GUILD_PRESENCES)

        if users is not undefined.UNDEFINED and (query or limit):
            raise ValueError(&#34;Cannot specify limit/query with users&#34;)

        if not 0 &lt;= limit &lt;= 100:
            raise ValueError(&#34;&#39;limit&#39; must be between 0 and 100, both inclusive&#34;)

        if users is not undefined.UNDEFINED and len(users) &gt; 100:
            raise ValueError(&#34;&#39;users&#39; is limited to 100 users&#34;)

        if nonce is not undefined.UNDEFINED and len(bytes(nonce, &#34;utf-8&#34;)) &gt; 32:
            raise ValueError(&#34;&#39;nonce&#39; can be no longer than 32 byte characters long.&#34;)

        await self._chunking_rate_limit.acquire()

        payload = data_binding.JSONObjectBuilder()
        payload.put_snowflake(&#34;guild_id&#34;, guild)
        payload.put(&#34;presences&#34;, include_presences)
        payload.put(&#34;query&#34;, query)
        payload.put(&#34;limit&#34;, limit)
        payload.put_snowflake_array(&#34;user_ids&#34;, users)
        payload.put(&#34;nonce&#34;, nonce)

        await self._ws.send_json({_OP: _REQUEST_GUILD_MEMBERS, _D: payload})  # type: ignore[union-attr]

    async def start(self) -&gt; None:
        if self._run_task is not None:
            raise RuntimeError(&#34;Cannot run more than one instance of one shard concurrently&#34;)

        run_task = asyncio.create_task(self._run(), name=f&#34;run shard {self._shard_id}&#34;)
        self._run_task = run_task
        waiter = asyncio.create_task(self._handshake_completed.wait(), name=f&#34;wait for shard {self._shard_id} to start&#34;)
        done, _ = await asyncio.wait((waiter, run_task), return_when=asyncio.FIRST_COMPLETED)
        waiter.cancel()

        if done and waiter not in done:
            # This might throw an error, or it might not, depending on what we do with it.
            # This occurs if the run task finished before the handshake completion event,
            # which implies the shard died before it could become ready/resume...
            self._run_task = None
            run_task.result()
            raise asyncio.CancelledError(f&#34;Shard {self._shard_id} was closed before it could start successfully&#34;)

    async def update_presence(
        self,
        *,
        idle_since: undefined.UndefinedNoneOr[datetime.datetime] = undefined.UNDEFINED,
        afk: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        activity: undefined.UndefinedNoneOr[presences.Activity] = undefined.UNDEFINED,
        status: undefined.UndefinedOr[presences.Status] = undefined.UNDEFINED,
    ) -&gt; None:
        presence_payload = self._serialize_and_store_presence_payload(
            idle_since=idle_since,
            afk=afk,
            activity=activity,
            status=status,
        )
        payload: data_binding.JSONObject = {_OP: _PRESENCE_UPDATE, _D: presence_payload}
        await self._ws.send_json(payload)  # type: ignore[union-attr]

    async def update_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: typing.Optional[snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]],
        *,
        self_mute: bool = False,
        self_deaf: bool = False,
    ) -&gt; None:
        await self._ws.send_json(  # type: ignore[union-attr]
            {
                _OP: _VOICE_STATE_UPDATE,
                _D: {
                    &#34;guild_id&#34;: str(int(guild)),
                    &#34;channel_id&#34;: str(int(channel)) if channel is not None else None,
                    &#34;mute&#34;: self_mute,
                    &#34;deaf&#34;: self_deaf,
                },
            }
        )

    def _dispatch(self, name: str, seq: int, data: data_binding.JSONObject) -&gt; None:
        # This is invoked a lot, and we don&#39;t need to explicitly await anything, so it should
        # not be a coroutine. Makes event dispatches much much faster under significant load.

        self._seq = seq

        if name == &#34;READY&#34;:
            self._session_id = data[&#34;session_id&#34;]
            user_pl = data[&#34;user&#34;]
            user_id = user_pl[&#34;id&#34;]
            self._user_id = snowflakes.Snowflake(user_id)
            tag = user_pl[&#34;username&#34;] + &#34;#&#34; + user_pl[&#34;discriminator&#34;]
            unavailable_guild_count = len(data[&#34;guilds&#34;])
            version = data[&#34;v&#34;]
            self._logger.info(
                &#34;shard is ready: %s guilds, %s (%s), session %r on v%s gateway&#34;,
                unavailable_guild_count,
                tag,
                user_id,
                self._session_id,
                version,
            )
            self._handshake_completed.set()

        elif name == &#34;RESUME&#34;:
            self._logger.info(&#34;shard has resumed [session:%s, seq:%s]&#34;, self._session_id, self._seq)
            self._handshake_completed.set()

        self._event_consumer(self, name, data)

    async def _identify(self) -&gt; None:
        payload: data_binding.JSONObject = {
            _OP: _IDENTIFY,
            _D: {
                &#34;token&#34;: self._token,
                &#34;compress&#34;: False,
                &#34;large_threshold&#34;: self._large_threshold,
                &#34;properties&#34;: {
                    &#34;$os&#34;: f&#34;{platform.system()} {platform.architecture()[0]}&#34;,
                    &#34;$browser&#34;: f&#34;aiohttp {aiohttp.__version__}&#34;,
                    &#34;$device&#34;: f&#34;hikari {about.__version__}&#34;,
                },
                &#34;shard&#34;: [self._shard_id, self._shard_count],
            },
        }

        payload[_D][&#34;intents&#34;] = self._intents

        payload[_D][&#34;presence&#34;] = self._serialize_and_store_presence_payload()

        await self._ws.send_json(payload)  # type: ignore[union-attr]

    async def _heartbeat(self, heartbeat_interval: float) -&gt; bool:
        # Return True if zombied or should reconnect, false if time to die forever.
        # Prevent immediately zombie-ing.
        self._last_heartbeat_ack_received = time.monotonic()
        self._logger.debug(&#34;starting heartbeat with interval %ss&#34;, heartbeat_interval)

        while not self._closing.is_set() and not self._closed.is_set():
            if self._last_heartbeat_ack_received &lt;= self._last_heartbeat_sent:
                # Gateway is zombie, close and request reconnect.
                self._logger.warning(
                    &#34;connection has not received a HEARTBEAT_ACK for approx %.1fs and is being disconnected, &#34;
                    &#34;expect a reconnect shortly&#34;,
                    time.monotonic() - self._last_heartbeat_ack_received,
                )
                return True

            self._logger.log(
                ux.TRACE, &#34;preparing to send HEARTBEAT [s:%s, interval:%ss]&#34;, self._seq, heartbeat_interval
            )

            await self._send_heartbeat()

            try:
                await asyncio.wait_for(self._closing.wait(), timeout=heartbeat_interval)
                # We are closing
                break
            except asyncio.TimeoutError:
                # We should continue
                continue

        self._logger.debug(&#34;heartbeat task is finishing now&#34;)
        return False

    async def _poll_events(self) -&gt; typing.Optional[bool]:
        payload = await self._ws.receive_json(timeout=5)  # type: ignore[union-attr]

        op = payload[_OP]  # opcode int
        d = payload[_D]  # data/payload. Usually a dict or a bool for INVALID_SESSION

        if op == _DISPATCH:
            t = payload[_T]  # event name str
            s = payload[_S]  # seq int
            self._logger.log(ux.TRACE, &#34;dispatching %s with seq %s&#34;, t, s)
            self._dispatch(t, s, d)
        elif op == _HEARTBEAT:
            await self._send_heartbeat_ack()
            self._logger.log(ux.TRACE, &#34;sent HEARTBEAT&#34;)
        elif op == _HEARTBEAT_ACK:
            now = time.monotonic()
            self._last_heartbeat_ack_received = now
            self._heartbeat_latency = now - self._last_heartbeat_sent
            self._logger.log(ux.TRACE, &#34;received HEARTBEAT ACK in %.1fms&#34;, self._heartbeat_latency * 1_000)
        elif op == _RECONNECT:
            # We should be able to resume...
            self._logger.info(&#34;received instruction to reconnect, will resume existing session&#34;)
            return True
        elif op == _INVALID_SESSION:
            # We can resume if the payload was `true`.
            if not d:
                self._logger.info(&#34;received invalid session, will need to start a new session&#34;)
                self._seq = None
                self._session_id = None
            else:
                self._logger.info(&#34;received invalid session, will resume existing session&#34;)
            return True
        else:
            self._logger.log(ux.TRACE, &#34;unknown opcode %s received, it will be ignored...&#34;, op)

        return None

    async def _resume(self) -&gt; None:
        await self._ws.send_json(  # type: ignore[union-attr]
            {
                _OP: _RESUME,
                _D: {&#34;token&#34;: self._token, &#34;seq&#34;: self._seq, &#34;session_id&#34;: self._session_id},
            }
        )

    async def _run(self) -&gt; None:
        self._closed.clear()
        self._closing.clear()
        last_started_at = -float(&#34;inf&#34;)

        backoff = rate_limits.ExponentialBackOff(
            base=_BACKOFF_BASE,
            maximum=_BACKOFF_CAP,
            initial_increment=_BACKOFF_INCREMENT_START,
        )

        try:
            while not self._closing.is_set() and not self._closed.is_set():
                if time.monotonic() - last_started_at &lt; _BACKOFF_WINDOW:
                    backoff_time = next(backoff)
                    self._logger.info(&#34;backing off reconnecting for %.2fs&#34;, backoff_time)

                    try:
                        await asyncio.wait_for(self._closing.wait(), timeout=backoff_time)
                        # We were told to close.
                        return
                    except asyncio.TimeoutError:
                        # We are going to run once.
                        pass

                try:
                    last_started_at = time.monotonic()
                    should_restart = await self._run_once()

                    if not should_restart:
                        self._logger.info(&#34;shard has disconnected and shut down normally&#34;)
                        return

                except errors.GatewayConnectionError as ex:
                    self._logger.error(
                        &#34;failed to communicate with server, reason was: %s. Will retry shortly&#34;,
                        ex.__cause__,
                    )

                except errors.GatewayServerClosedConnectionError as ex:
                    if not ex.can_reconnect:
                        raise

                    self._logger.info(
                        &#34;server has closed connection, will reconnect if possible [code:%s, reason:%s]&#34;,
                        ex.code,
                        ex.reason,
                    )

                    # We don&#39;t want to back off from this. If Discord keep closing the connection, it is their issue.
                    # If we back off here, we&#39;ll find a mass outage will prevent shards from becoming healthy on
                    # reconnect in large sharded bots for a very long period of time.
                    backoff.reset()

                except errors.GatewayError as ex:
                    self._logger.error(&#34;encountered generic gateway error&#34;, exc_info=ex)
                    raise

                except Exception as ex:
                    self._logger.error(&#34;encountered some unhandled error&#34;, exc_info=ex)
                    raise
        finally:
            self._closing.set()
            self._closed.set()

    async def _run_once(self) -&gt; bool:
        self._handshake_completed.clear()
        dispatch_disconnect = False

        exit_stack = contextlib.AsyncExitStack()

        self._ws = await exit_stack.enter_async_context(
            _GatewayTransport.connect(
                http_settings=self._http_settings,
                log_filterer=_log_filterer(self._token),
                logger=self._logger,
                proxy_settings=self._proxy_settings,
                url=self._url,
            )
        )

        try:
            # Dispatch CONNECTED synthetic event.
            self._event_consumer(self, &#34;CONNECTED&#34;, {})
            dispatch_disconnect = True

            heartbeat_task = await self._wait_for_hello()

            try:
                if self._seq is not None:
                    self._logger.debug(&#34;resuming session %s&#34;, self._session_id)
                    await self._resume()
                else:
                    self._logger.debug(&#34;identifying with new session&#34;)
                    await self._identify()

                if self._closing.is_set():
                    self._logger.debug(
                        &#34;closing flag was set during handshake, disconnecting with GOING AWAY &#34;
                        &#34;(_run_once =&gt; do not reconnect)&#34;
                    )
                    await self._ws.send_close(  # type: ignore[union-attr]
                        code=errors.ShardCloseCode.GOING_AWAY, message=b&#34;shard disconnecting&#34;
                    )
                    return False

                # Event polling.
                while not self._closing.is_set() and not heartbeat_task.done() and not heartbeat_task.cancelled():
                    try:
                        result = await self._poll_events()

                        if result is not None:
                            return result
                    except asyncio.TimeoutError:
                        # We should check if the shard is still alive and then poll again after.
                        pass

                # If the heartbeat died due to an error, it should be raised here.
                # This will currently allow us to try to resume if that happens
                # We return True if zombied.
                if await heartbeat_task:
                    now = time.monotonic()
                    self._logger.error(
                        &#34;connection is a zombie, last heartbeat sent %.2fs ago&#34;,
                        now - self._last_heartbeat_sent,
                    )
                    self._logger.debug(&#34;will attempt to reconnect (_run_once =&gt; reconnect)&#34;)
                    return True

                self._logger.debug(
                    &#34;shard has requested graceful termination, so will not attempt to reconnect &#34;
                    &#34;(_run_once =&gt; do not reconnect)&#34;
                )
                await self._ws.send_close(  # type: ignore[union-attr]
                    code=errors.ShardCloseCode.GOING_AWAY,
                    message=b&#34;shard disconnecting&#34;,
                )
                return False

            finally:
                heartbeat_task.cancel()

        finally:
            ws = self._ws
            self._ws = None
            await exit_stack.aclose()
            if dispatch_disconnect:
                # If we managed to connect, we must always send the DISCONNECT event
                # afterwards.
                self._event_consumer(self, &#34;DISCONNECTED&#34;, {})

            # Check if we made the socket close or handled it. If we didn&#39;t, we should always try to
            # reconnect, as aiohttp is probably closing it internally without telling us properly.
            if not ws.sent_close:  # type: ignore[union-attr]
                return True

    async def _send_heartbeat(self) -&gt; None:
        await self._ws.send_json({_OP: _HEARTBEAT, _D: self._seq})  # type: ignore[union-attr]
        self._last_heartbeat_sent = time.monotonic()

    async def _send_heartbeat_ack(self) -&gt; None:
        await self._ws.send_json({_OP: _HEARTBEAT_ACK, _D: None})  # type: ignore[union-attr]

    @staticmethod
    def _serialize_activity(activity: typing.Optional[presences.Activity]) -&gt; data_binding.JSONish:
        if activity is None:
            return None

        return {&#34;name&#34;: activity.name, &#34;type&#34;: int(activity.type), &#34;url&#34;: activity.url}

    def _serialize_and_store_presence_payload(
        self,
        idle_since: undefined.UndefinedNoneOr[datetime.datetime] = undefined.UNDEFINED,
        afk: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        status: undefined.UndefinedOr[presences.Status] = undefined.UNDEFINED,
        activity: undefined.UndefinedNoneOr[presences.Activity] = undefined.UNDEFINED,
    ) -&gt; data_binding.JSONObject:
        payload = data_binding.JSONObjectBuilder()

        if activity is undefined.UNDEFINED:
            activity = self._activity
        else:
            self._activity = activity

        if status is undefined.UNDEFINED:
            status = self._status
        else:
            self._status = status

        if idle_since is undefined.UNDEFINED:
            idle_since = self._idle_since
        else:
            self._idle_since = idle_since

        if afk is undefined.UNDEFINED:
            afk = self._is_afk
        else:
            self._is_afk = afk

        payload.put(&#34;since&#34;, idle_since, conversion=self._serialize_datetime)
        payload.put(&#34;afk&#34;, afk)
        payload.put(&#34;game&#34;, activity, conversion=self._serialize_activity)
        # Sending &#34;offline&#34; to the gateway wont do anything, we will have to
        # send &#34;invisible&#34; instead for this to work.
        if status is presences.Status.OFFLINE:
            payload.put(&#34;status&#34;, &#34;invisible&#34;)
        else:
            payload.put(&#34;status&#34;, status)
        return payload

    @staticmethod
    def _serialize_datetime(dt: typing.Optional[datetime.datetime]) -&gt; typing.Optional[int]:
        if dt is None:
            return None

        return int(dt.timestamp() * 1_000)

    async def _wait_for_hello(self) -&gt; asyncio.Task[bool]:
        # Expect HELLO.
        payload = await self._ws.receive_json()  # type: ignore[union-attr]
        if payload[_OP] != _HELLO:
            self._logger.debug(
                &#34;expected HELLO opcode, received %s which makes no sense, closing with PROTOCOL ERROR &#34;,
                &#34;(_run_once =&gt; raise and do not reconnect)&#34;,
                payload[_OP],
            )
            await self._ws.send_close(  # type: ignore[union-attr]
                code=errors.ShardCloseCode.PROTOCOL_ERROR,
                message=b&#34;Expected HELLO op&#34;,
            )
            raise errors.GatewayError(f&#34;Expected opcode {_HELLO}, but received {payload[_OP]}&#34;)

        if self._closing.is_set():
            self._logger.debug(
                &#34;closing flag was set before we could handshake, disconnecting with GOING AWAY &#34;
                &#34;(_run_once =&gt; do not reconnect)&#34;
            )
            await self._ws.send_close(  # type: ignore[union-attr]
                code=errors.ShardCloseCode.GOING_AWAY,
                message=b&#34;shard disconnecting&#34;,
            )
            raise asyncio.CancelledError(&#34;closing flag was set before we could handshake&#34;)

        heartbeat_interval = float(payload[_D][&#34;heartbeat_interval&#34;]) / 1_000.0
        heartbeat_task = asyncio.create_task(self._heartbeat(heartbeat_interval))
        return heartbeat_task</code></pre>
</details>
</div>
</div>
<h2 id="class-heading">Classes</h2>
<section class="definition">
<dl class="no-nest root">
<dt>
<h4><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="GatewayShardImpl -- Implementation of a V6 and V7 compatible gateway …" href="#hikari.impl.shard.GatewayShardImpl"
>GatewayShardImpl</a></h4>
</dt>
<dd>
<pre><code id="hikari.impl.shard.GatewayShardImpl" class="hljs python"><abbr title='A standard Python type.'>class</abbr> GatewayShardImpl (
    *,
    compression: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = &lt;GatewayCompression.PAYLOAD_ZLIB_STREAM: &#x27;payload_zlib_stream&#x27;&gt;,
    initial_activity: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.Activity'>presences.Activity</a>] = None,
    initial_idle_since: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>] = None,
    initial_is_afk: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    initial_status: <a href='../presences.html#hikari.presences.Status'>presences.Status</a> = &lt;Status.ONLINE: &#x27;online&#x27;&gt;,
    intents: <a href='../intents.html#hikari.intents.Intents'>intents_.Intents</a>,
    large_threshold: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 250,
    shard_id: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 0,
    shard_count: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 1,
    event_consumer: <a href='https://docs.python.org/3/library/typing.html#typing.Callable'>Callable</a>[[<a href='../api/shard.html#hikari.api.shard.GatewayShard'>shard.GatewayShard</a>, <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>, <a href='../internal/data_binding.html#hikari.internal.data_binding.JSONObject'>data_binding.JSONObject</a>], <a href='https://docs.python.org/3/library/constants.html#None'>None</a>],
    http_settings: <a href='../config.html#hikari.config.HTTPSettings'>config.HTTPSettings</a>,
    proxy_settings: <a href='../config.html#hikari.config.ProxySettings'>config.ProxySettings</a>,
    data_format: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a> = &lt;GatewayDataFormat.JSON: &#x27;json&#x27;&gt;,
    token: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
    url: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>,
): ...</code></pre>
<p>Implementation of a V6 and V7 compatible gateway.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>compression</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[buitlins.str]</code></dt>
<dd>Compression format to use for the shard. Only supported values are
<code>"payload_zlib_stream"</code> or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> to disable it.</dd>
<dt><strong><code>initial_activity</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../presences.html#hikari.presences.Activity'>Activity</a>]</code></dt>
<dd>The initial activity to appear to have for this shard, or
<code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if no activity should be set initially. This is the
default.</dd>
<dt><strong><code>initial_idle_since</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>]</code></dt>
<dd>The datetime to appear to be idle since, or <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code> if the
shard should not provide this. The default is <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>.</dd>
<dt><strong><code>initial_is_afk</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>Whether to appear to be AFK or not on login. Defaults to
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>.</dd>
<dt><strong><code>initial_status</code></strong> :&ensp;<code><a href='../presences.html#hikari.presences.Status'>Status</a></code></dt>
<dd>The initial status to set on login for the shard. Defaults to
<code><a href='../presences.html#hikari.presences.Status.ONLINE'>ONLINE</a></code>.</dd>
<dt><strong><code>intents</code></strong> :&ensp;<code><a href='../intents.html#hikari.intents.Intents'>Intents</a></code></dt>
<dd>Collection of intents to use. Unlike on the V6 gateway, this is
MANDATORY.</dd>
<dt><strong><code>large_threshold</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The number of members to have in a guild for it to be considered large.</dd>
<dt><strong><code>shard_id</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The shard ID.</dd>
<dt><strong><code>shard_count</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The shard count.</dd>
<dt><strong><code>event_consumer</code></strong></dt>
<dd>A non-coroutine function consuming a <code><a href='#hikari.impl.shard.GatewayShardImpl'>GatewayShardImpl</a></code>,
a <code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code> event name, and a
<code><a href='../internal/data_binding.html#hikari.internal.data_binding.JSONObject'>JSONObject</a></code> event object as parameters.
This should return <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>, and will be called with each event
that fires.</dd>
<dt><strong><code>http_settings</code></strong> :&ensp;<code><a href='../config.html#hikari.config.HTTPSettings'>HTTPSettings</a></code></dt>
<dd>The HTTP-related settings to use while negotiating a websocket.</dd>
<dt><strong><code>proxy_settings</code></strong> :&ensp;<code><a href='../config.html#hikari.config.ProxySettings'>ProxySettings</a></code></dt>
<dd>The proxy settings to use while negotiating a websocket.</dd>
<dt><strong><code>data_format</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>Data format to use for inbound data. Only supported format is
<code>"<a href='https://docs.python.org/3/library/json.html#module-json'>json</a>"</code>.</dd>
<dt><strong><code>token</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The bot token to use.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>The gateway URL to use. This should not contain a query-string or
fragments.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>If all four of <code>initial_activity</code>, <code>initial_idle_since</code>,
<code>initial_is_afk</code>, and <code>initial_status</code> are not defined and left to their
default values, then the presence will not be <em>updated</em> on startup
at all.
If any of these <em>are</em> specified, then any that are not specified will
be set to sane defaults, which may change the previous status. This will
only occur during startup, and is an artifact of how Discord manages
these updates internally. All other calls to update the status of
the shard will support partial updates.</p>
</div>
<div class="sep"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/shard.py#L316-L989" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">class GatewayShardImpl(shard.GatewayShard):
    &#34;&#34;&#34;Implementation of a V6 and V7 compatible gateway.

    Parameters
    ----------
    compression : typing.Optional[buitlins.str]
        Compression format to use for the shard. Only supported values are
        `&#34;payload_zlib_stream&#34;` or `builtins.None` to disable it.
    initial_activity : typing.Optional[hikari.presences.Activity]
        The initial activity to appear to have for this shard, or
        `builtins.None` if no activity should be set initially. This is the
        default.
    initial_idle_since : typing.Optional[datetime.datetime]
        The datetime to appear to be idle since, or `builtins.None` if the
        shard should not provide this. The default is `builtins.None`.
    initial_is_afk : bool
        Whether to appear to be AFK or not on login. Defaults to
        `builtins.False`.
    initial_status : hikari.presences.Status
        The initial status to set on login for the shard. Defaults to
        `hikari.presences.Status.ONLINE`.
    intents : hikari.intents.Intents
        Collection of intents to use. Unlike on the V6 gateway, this is
        MANDATORY.
    large_threshold : builtins.int
        The number of members to have in a guild for it to be considered large.
    shard_id : builtins.int
        The shard ID.
    shard_count : builtins.int
        The shard count.
    event_consumer
        A non-coroutine function consuming a `GatewayShardImpl`,
        a `builtins.str` event name, and a
        `hikari.internal.data_binding.JSONObject` event object as parameters.
        This should return `builtins.None`, and will be called with each event
        that fires.
    http_settings : hikari.config.HTTPSettings
        The HTTP-related settings to use while negotiating a websocket.
    proxy_settings : hikari.config.ProxySettings
        The proxy settings to use while negotiating a websocket.
    data_format : builtins.str
        Data format to use for inbound data. Only supported format is
        `&#34;json&#34;`.
    token : builtins.str
        The bot token to use.
    url : builtins.str
        The gateway URL to use. This should not contain a query-string or
        fragments.

    !!! note
        If all four of `initial_activity`, `initial_idle_since`,
        `initial_is_afk`, and `initial_status` are not defined and left to their
        default values, then the presence will not be _updated_ on startup
        at all.
        If any of these _are_ specified, then any that are not specified will
        be set to sane defaults, which may change the previous status. This will
        only occur during startup, and is an artifact of how Discord manages
        these updates internally. All other calls to update the status of
        the shard will support partial updates.
    &#34;&#34;&#34;

    __slots__: typing.Sequence[str] = (
        &#34;_activity&#34;,
        &#34;_closed&#34;,
        &#34;_closing&#34;,
        &#34;_chunking_rate_limit&#34;,
        &#34;_event_consumer&#34;,
        &#34;_handshake_completed&#34;,
        &#34;_heartbeat_latency&#34;,
        &#34;_http_settings&#34;,
        &#34;_idle_since&#34;,
        &#34;_intents&#34;,
        &#34;_is_afk&#34;,
        &#34;_large_threshold&#34;,
        &#34;_last_heartbeat_ack_received&#34;,
        &#34;_last_heartbeat_sent&#34;,
        &#34;_logger&#34;,
        &#34;_proxy_settings&#34;,
        &#34;_run_task&#34;,
        &#34;_seq&#34;,
        &#34;_session_id&#34;,
        &#34;_shard_count&#34;,
        &#34;_shard_id&#34;,
        &#34;_status&#34;,
        &#34;_token&#34;,
        &#34;_total_rate_limit&#34;,
        &#34;_url&#34;,
        &#34;_user_id&#34;,
        &#34;_ws&#34;,
    )

    def __init__(
        self,
        *,
        compression: typing.Optional[str] = shard.GatewayCompression.PAYLOAD_ZLIB_STREAM,
        initial_activity: typing.Optional[presences.Activity] = None,
        initial_idle_since: typing.Optional[datetime.datetime] = None,
        initial_is_afk: bool = False,
        initial_status: presences.Status = presences.Status.ONLINE,
        intents: intents_.Intents,
        large_threshold: int = 250,
        shard_id: int = 0,
        shard_count: int = 1,
        event_consumer: typing.Callable[[shard.GatewayShard, str, data_binding.JSONObject], None],
        http_settings: config.HTTPSettings,
        proxy_settings: config.ProxySettings,
        data_format: str = shard.GatewayDataFormat.JSON,
        token: str,
        url: str,
    ) -&gt; None:

        if data_format != shard.GatewayDataFormat.JSON:
            raise NotImplementedError(f&#34;Unsupported gateway data format: {data_format}&#34;)

        query = {&#34;v&#34;: _VERSION, &#34;encoding&#34;: str(data_format)}

        if compression is not None:
            if compression == shard.GatewayCompression.PAYLOAD_ZLIB_STREAM:
                query[&#34;compress&#34;] = &#34;zlib-stream&#34;
            else:
                raise NotImplementedError(f&#34;Unsupported compression format {compression}&#34;)

        scheme, netloc, path, params, _, _ = urllib.parse.urlparse(url, allow_fragments=True)
        new_query = urllib.parse.urlencode(query)

        self._activity = initial_activity
        self._closing = asyncio.Event()
        self._closed = asyncio.Event()
        self._chunking_rate_limit = rate_limits.WindowedBurstRateLimiter(
            f&#34;shard {shard_id} chunking rate limit&#34;,
            *_CHUNKING_RATELIMIT,
        )
        self._event_consumer = event_consumer
        self._handshake_completed = asyncio.Event()
        self._heartbeat_latency = float(&#34;nan&#34;)
        self._http_settings = http_settings
        self._idle_since = initial_idle_since
        self._intents = intents
        self._is_afk = initial_is_afk
        self._large_threshold = large_threshold
        self._last_heartbeat_ack_received = float(&#34;nan&#34;)
        self._last_heartbeat_sent = float(&#34;nan&#34;)
        self._logger = logging.getLogger(f&#34;hikari.gateway.{shard_id}&#34;)
        self._proxy_settings = proxy_settings
        self._run_task: typing.Optional[asyncio.Task[None]] = None
        self._seq: typing.Optional[int] = None
        self._session_id: typing.Optional[str] = None
        self._shard_count = shard_count
        self._shard_id = shard_id
        self._status = initial_status
        self._token = token
        self._total_rate_limit = rate_limits.WindowedBurstRateLimiter(
            f&#34;shard {shard_id} total rate limit&#34;,
            *_TOTAL_RATELIMIT,
        )
        self._url = urllib.parse.urlunparse((scheme, netloc, path, params, new_query, &#34;&#34;))
        self._user_id: typing.Optional[snowflakes.Snowflake] = None
        self._ws: typing.Optional[_GatewayTransport] = None

    @property
    def heartbeat_latency(self) -&gt; float:
        return self._heartbeat_latency

    @property
    def id(self) -&gt; int:
        return self._shard_id

    @property
    def intents(self) -&gt; intents_.Intents:
        return self._intents

    @property
    def is_alive(self) -&gt; bool:
        return self._run_task is not None and not self._run_task.done()

    @property
    def shard_count(self) -&gt; int:
        return self._shard_count

    async def close(self) -&gt; None:
        if not self._closing.is_set():
            try:
                if self._ws is not None:
                    self._logger.debug(
                        &#34;shard.close() was called and the websocket was still alive -- &#34;
                        &#34;disconnecting immediately with GOING AWAY&#34;
                    )
                    await self._ws.close(code=errors.ShardCloseCode.GOING_AWAY, message=b&#34;shard disconnecting&#34;)
                self._closing.set()
            finally:
                self._chunking_rate_limit.close()
                self._total_rate_limit.close()

    async def get_user_id(self) -&gt; snowflakes.Snowflake:
        await self._handshake_completed.wait()
        if self._user_id is None:
            raise RuntimeError(&#34;user_id was not known, this is probably a bug&#34;)
        return self._user_id

    async def join(self) -&gt; None:
        &#34;&#34;&#34;Wait for this shard to close, if running.&#34;&#34;&#34;
        await self._closed.wait()

    async def request_guild_members(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        *,
        include_presences: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        query: str = &#34;&#34;,
        limit: int = 0,
        users: undefined.UndefinedOr[typing.Sequence[snowflakes.SnowflakeishOr[users_.User]]] = undefined.UNDEFINED,
        nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
    ) -&gt; None:
        if not query and not limit and not self._intents &amp; intents_.Intents.GUILD_MEMBERS:
            raise errors.MissingIntentError(intents_.Intents.GUILD_MEMBERS)

        if include_presences is not undefined.UNDEFINED and not self._intents &amp; intents_.Intents.GUILD_PRESENCES:
            raise errors.MissingIntentError(intents_.Intents.GUILD_PRESENCES)

        if users is not undefined.UNDEFINED and (query or limit):
            raise ValueError(&#34;Cannot specify limit/query with users&#34;)

        if not 0 &lt;= limit &lt;= 100:
            raise ValueError(&#34;&#39;limit&#39; must be between 0 and 100, both inclusive&#34;)

        if users is not undefined.UNDEFINED and len(users) &gt; 100:
            raise ValueError(&#34;&#39;users&#39; is limited to 100 users&#34;)

        if nonce is not undefined.UNDEFINED and len(bytes(nonce, &#34;utf-8&#34;)) &gt; 32:
            raise ValueError(&#34;&#39;nonce&#39; can be no longer than 32 byte characters long.&#34;)

        await self._chunking_rate_limit.acquire()

        payload = data_binding.JSONObjectBuilder()
        payload.put_snowflake(&#34;guild_id&#34;, guild)
        payload.put(&#34;presences&#34;, include_presences)
        payload.put(&#34;query&#34;, query)
        payload.put(&#34;limit&#34;, limit)
        payload.put_snowflake_array(&#34;user_ids&#34;, users)
        payload.put(&#34;nonce&#34;, nonce)

        await self._ws.send_json({_OP: _REQUEST_GUILD_MEMBERS, _D: payload})  # type: ignore[union-attr]

    async def start(self) -&gt; None:
        if self._run_task is not None:
            raise RuntimeError(&#34;Cannot run more than one instance of one shard concurrently&#34;)

        run_task = asyncio.create_task(self._run(), name=f&#34;run shard {self._shard_id}&#34;)
        self._run_task = run_task
        waiter = asyncio.create_task(self._handshake_completed.wait(), name=f&#34;wait for shard {self._shard_id} to start&#34;)
        done, _ = await asyncio.wait((waiter, run_task), return_when=asyncio.FIRST_COMPLETED)
        waiter.cancel()

        if done and waiter not in done:
            # This might throw an error, or it might not, depending on what we do with it.
            # This occurs if the run task finished before the handshake completion event,
            # which implies the shard died before it could become ready/resume...
            self._run_task = None
            run_task.result()
            raise asyncio.CancelledError(f&#34;Shard {self._shard_id} was closed before it could start successfully&#34;)

    async def update_presence(
        self,
        *,
        idle_since: undefined.UndefinedNoneOr[datetime.datetime] = undefined.UNDEFINED,
        afk: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        activity: undefined.UndefinedNoneOr[presences.Activity] = undefined.UNDEFINED,
        status: undefined.UndefinedOr[presences.Status] = undefined.UNDEFINED,
    ) -&gt; None:
        presence_payload = self._serialize_and_store_presence_payload(
            idle_since=idle_since,
            afk=afk,
            activity=activity,
            status=status,
        )
        payload: data_binding.JSONObject = {_OP: _PRESENCE_UPDATE, _D: presence_payload}
        await self._ws.send_json(payload)  # type: ignore[union-attr]

    async def update_voice_state(
        self,
        guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
        channel: typing.Optional[snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]],
        *,
        self_mute: bool = False,
        self_deaf: bool = False,
    ) -&gt; None:
        await self._ws.send_json(  # type: ignore[union-attr]
            {
                _OP: _VOICE_STATE_UPDATE,
                _D: {
                    &#34;guild_id&#34;: str(int(guild)),
                    &#34;channel_id&#34;: str(int(channel)) if channel is not None else None,
                    &#34;mute&#34;: self_mute,
                    &#34;deaf&#34;: self_deaf,
                },
            }
        )

    def _dispatch(self, name: str, seq: int, data: data_binding.JSONObject) -&gt; None:
        # This is invoked a lot, and we don&#39;t need to explicitly await anything, so it should
        # not be a coroutine. Makes event dispatches much much faster under significant load.

        self._seq = seq

        if name == &#34;READY&#34;:
            self._session_id = data[&#34;session_id&#34;]
            user_pl = data[&#34;user&#34;]
            user_id = user_pl[&#34;id&#34;]
            self._user_id = snowflakes.Snowflake(user_id)
            tag = user_pl[&#34;username&#34;] + &#34;#&#34; + user_pl[&#34;discriminator&#34;]
            unavailable_guild_count = len(data[&#34;guilds&#34;])
            version = data[&#34;v&#34;]
            self._logger.info(
                &#34;shard is ready: %s guilds, %s (%s), session %r on v%s gateway&#34;,
                unavailable_guild_count,
                tag,
                user_id,
                self._session_id,
                version,
            )
            self._handshake_completed.set()

        elif name == &#34;RESUME&#34;:
            self._logger.info(&#34;shard has resumed [session:%s, seq:%s]&#34;, self._session_id, self._seq)
            self._handshake_completed.set()

        self._event_consumer(self, name, data)

    async def _identify(self) -&gt; None:
        payload: data_binding.JSONObject = {
            _OP: _IDENTIFY,
            _D: {
                &#34;token&#34;: self._token,
                &#34;compress&#34;: False,
                &#34;large_threshold&#34;: self._large_threshold,
                &#34;properties&#34;: {
                    &#34;$os&#34;: f&#34;{platform.system()} {platform.architecture()[0]}&#34;,
                    &#34;$browser&#34;: f&#34;aiohttp {aiohttp.__version__}&#34;,
                    &#34;$device&#34;: f&#34;hikari {about.__version__}&#34;,
                },
                &#34;shard&#34;: [self._shard_id, self._shard_count],
            },
        }

        payload[_D][&#34;intents&#34;] = self._intents

        payload[_D][&#34;presence&#34;] = self._serialize_and_store_presence_payload()

        await self._ws.send_json(payload)  # type: ignore[union-attr]

    async def _heartbeat(self, heartbeat_interval: float) -&gt; bool:
        # Return True if zombied or should reconnect, false if time to die forever.
        # Prevent immediately zombie-ing.
        self._last_heartbeat_ack_received = time.monotonic()
        self._logger.debug(&#34;starting heartbeat with interval %ss&#34;, heartbeat_interval)

        while not self._closing.is_set() and not self._closed.is_set():
            if self._last_heartbeat_ack_received &lt;= self._last_heartbeat_sent:
                # Gateway is zombie, close and request reconnect.
                self._logger.warning(
                    &#34;connection has not received a HEARTBEAT_ACK for approx %.1fs and is being disconnected, &#34;
                    &#34;expect a reconnect shortly&#34;,
                    time.monotonic() - self._last_heartbeat_ack_received,
                )
                return True

            self._logger.log(
                ux.TRACE, &#34;preparing to send HEARTBEAT [s:%s, interval:%ss]&#34;, self._seq, heartbeat_interval
            )

            await self._send_heartbeat()

            try:
                await asyncio.wait_for(self._closing.wait(), timeout=heartbeat_interval)
                # We are closing
                break
            except asyncio.TimeoutError:
                # We should continue
                continue

        self._logger.debug(&#34;heartbeat task is finishing now&#34;)
        return False

    async def _poll_events(self) -&gt; typing.Optional[bool]:
        payload = await self._ws.receive_json(timeout=5)  # type: ignore[union-attr]

        op = payload[_OP]  # opcode int
        d = payload[_D]  # data/payload. Usually a dict or a bool for INVALID_SESSION

        if op == _DISPATCH:
            t = payload[_T]  # event name str
            s = payload[_S]  # seq int
            self._logger.log(ux.TRACE, &#34;dispatching %s with seq %s&#34;, t, s)
            self._dispatch(t, s, d)
        elif op == _HEARTBEAT:
            await self._send_heartbeat_ack()
            self._logger.log(ux.TRACE, &#34;sent HEARTBEAT&#34;)
        elif op == _HEARTBEAT_ACK:
            now = time.monotonic()
            self._last_heartbeat_ack_received = now
            self._heartbeat_latency = now - self._last_heartbeat_sent
            self._logger.log(ux.TRACE, &#34;received HEARTBEAT ACK in %.1fms&#34;, self._heartbeat_latency * 1_000)
        elif op == _RECONNECT:
            # We should be able to resume...
            self._logger.info(&#34;received instruction to reconnect, will resume existing session&#34;)
            return True
        elif op == _INVALID_SESSION:
            # We can resume if the payload was `true`.
            if not d:
                self._logger.info(&#34;received invalid session, will need to start a new session&#34;)
                self._seq = None
                self._session_id = None
            else:
                self._logger.info(&#34;received invalid session, will resume existing session&#34;)
            return True
        else:
            self._logger.log(ux.TRACE, &#34;unknown opcode %s received, it will be ignored...&#34;, op)

        return None

    async def _resume(self) -&gt; None:
        await self._ws.send_json(  # type: ignore[union-attr]
            {
                _OP: _RESUME,
                _D: {&#34;token&#34;: self._token, &#34;seq&#34;: self._seq, &#34;session_id&#34;: self._session_id},
            }
        )

    async def _run(self) -&gt; None:
        self._closed.clear()
        self._closing.clear()
        last_started_at = -float(&#34;inf&#34;)

        backoff = rate_limits.ExponentialBackOff(
            base=_BACKOFF_BASE,
            maximum=_BACKOFF_CAP,
            initial_increment=_BACKOFF_INCREMENT_START,
        )

        try:
            while not self._closing.is_set() and not self._closed.is_set():
                if time.monotonic() - last_started_at &lt; _BACKOFF_WINDOW:
                    backoff_time = next(backoff)
                    self._logger.info(&#34;backing off reconnecting for %.2fs&#34;, backoff_time)

                    try:
                        await asyncio.wait_for(self._closing.wait(), timeout=backoff_time)
                        # We were told to close.
                        return
                    except asyncio.TimeoutError:
                        # We are going to run once.
                        pass

                try:
                    last_started_at = time.monotonic()
                    should_restart = await self._run_once()

                    if not should_restart:
                        self._logger.info(&#34;shard has disconnected and shut down normally&#34;)
                        return

                except errors.GatewayConnectionError as ex:
                    self._logger.error(
                        &#34;failed to communicate with server, reason was: %s. Will retry shortly&#34;,
                        ex.__cause__,
                    )

                except errors.GatewayServerClosedConnectionError as ex:
                    if not ex.can_reconnect:
                        raise

                    self._logger.info(
                        &#34;server has closed connection, will reconnect if possible [code:%s, reason:%s]&#34;,
                        ex.code,
                        ex.reason,
                    )

                    # We don&#39;t want to back off from this. If Discord keep closing the connection, it is their issue.
                    # If we back off here, we&#39;ll find a mass outage will prevent shards from becoming healthy on
                    # reconnect in large sharded bots for a very long period of time.
                    backoff.reset()

                except errors.GatewayError as ex:
                    self._logger.error(&#34;encountered generic gateway error&#34;, exc_info=ex)
                    raise

                except Exception as ex:
                    self._logger.error(&#34;encountered some unhandled error&#34;, exc_info=ex)
                    raise
        finally:
            self._closing.set()
            self._closed.set()

    async def _run_once(self) -&gt; bool:
        self._handshake_completed.clear()
        dispatch_disconnect = False

        exit_stack = contextlib.AsyncExitStack()

        self._ws = await exit_stack.enter_async_context(
            _GatewayTransport.connect(
                http_settings=self._http_settings,
                log_filterer=_log_filterer(self._token),
                logger=self._logger,
                proxy_settings=self._proxy_settings,
                url=self._url,
            )
        )

        try:
            # Dispatch CONNECTED synthetic event.
            self._event_consumer(self, &#34;CONNECTED&#34;, {})
            dispatch_disconnect = True

            heartbeat_task = await self._wait_for_hello()

            try:
                if self._seq is not None:
                    self._logger.debug(&#34;resuming session %s&#34;, self._session_id)
                    await self._resume()
                else:
                    self._logger.debug(&#34;identifying with new session&#34;)
                    await self._identify()

                if self._closing.is_set():
                    self._logger.debug(
                        &#34;closing flag was set during handshake, disconnecting with GOING AWAY &#34;
                        &#34;(_run_once =&gt; do not reconnect)&#34;
                    )
                    await self._ws.send_close(  # type: ignore[union-attr]
                        code=errors.ShardCloseCode.GOING_AWAY, message=b&#34;shard disconnecting&#34;
                    )
                    return False

                # Event polling.
                while not self._closing.is_set() and not heartbeat_task.done() and not heartbeat_task.cancelled():
                    try:
                        result = await self._poll_events()

                        if result is not None:
                            return result
                    except asyncio.TimeoutError:
                        # We should check if the shard is still alive and then poll again after.
                        pass

                # If the heartbeat died due to an error, it should be raised here.
                # This will currently allow us to try to resume if that happens
                # We return True if zombied.
                if await heartbeat_task:
                    now = time.monotonic()
                    self._logger.error(
                        &#34;connection is a zombie, last heartbeat sent %.2fs ago&#34;,
                        now - self._last_heartbeat_sent,
                    )
                    self._logger.debug(&#34;will attempt to reconnect (_run_once =&gt; reconnect)&#34;)
                    return True

                self._logger.debug(
                    &#34;shard has requested graceful termination, so will not attempt to reconnect &#34;
                    &#34;(_run_once =&gt; do not reconnect)&#34;
                )
                await self._ws.send_close(  # type: ignore[union-attr]
                    code=errors.ShardCloseCode.GOING_AWAY,
                    message=b&#34;shard disconnecting&#34;,
                )
                return False

            finally:
                heartbeat_task.cancel()

        finally:
            ws = self._ws
            self._ws = None
            await exit_stack.aclose()
            if dispatch_disconnect:
                # If we managed to connect, we must always send the DISCONNECT event
                # afterwards.
                self._event_consumer(self, &#34;DISCONNECTED&#34;, {})

            # Check if we made the socket close or handled it. If we didn&#39;t, we should always try to
            # reconnect, as aiohttp is probably closing it internally without telling us properly.
            if not ws.sent_close:  # type: ignore[union-attr]
                return True

    async def _send_heartbeat(self) -&gt; None:
        await self._ws.send_json({_OP: _HEARTBEAT, _D: self._seq})  # type: ignore[union-attr]
        self._last_heartbeat_sent = time.monotonic()

    async def _send_heartbeat_ack(self) -&gt; None:
        await self._ws.send_json({_OP: _HEARTBEAT_ACK, _D: None})  # type: ignore[union-attr]

    @staticmethod
    def _serialize_activity(activity: typing.Optional[presences.Activity]) -&gt; data_binding.JSONish:
        if activity is None:
            return None

        return {&#34;name&#34;: activity.name, &#34;type&#34;: int(activity.type), &#34;url&#34;: activity.url}

    def _serialize_and_store_presence_payload(
        self,
        idle_since: undefined.UndefinedNoneOr[datetime.datetime] = undefined.UNDEFINED,
        afk: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
        status: undefined.UndefinedOr[presences.Status] = undefined.UNDEFINED,
        activity: undefined.UndefinedNoneOr[presences.Activity] = undefined.UNDEFINED,
    ) -&gt; data_binding.JSONObject:
        payload = data_binding.JSONObjectBuilder()

        if activity is undefined.UNDEFINED:
            activity = self._activity
        else:
            self._activity = activity

        if status is undefined.UNDEFINED:
            status = self._status
        else:
            self._status = status

        if idle_since is undefined.UNDEFINED:
            idle_since = self._idle_since
        else:
            self._idle_since = idle_since

        if afk is undefined.UNDEFINED:
            afk = self._is_afk
        else:
            self._is_afk = afk

        payload.put(&#34;since&#34;, idle_since, conversion=self._serialize_datetime)
        payload.put(&#34;afk&#34;, afk)
        payload.put(&#34;game&#34;, activity, conversion=self._serialize_activity)
        # Sending &#34;offline&#34; to the gateway wont do anything, we will have to
        # send &#34;invisible&#34; instead for this to work.
        if status is presences.Status.OFFLINE:
            payload.put(&#34;status&#34;, &#34;invisible&#34;)
        else:
            payload.put(&#34;status&#34;, status)
        return payload

    @staticmethod
    def _serialize_datetime(dt: typing.Optional[datetime.datetime]) -&gt; typing.Optional[int]:
        if dt is None:
            return None

        return int(dt.timestamp() * 1_000)

    async def _wait_for_hello(self) -&gt; asyncio.Task[bool]:
        # Expect HELLO.
        payload = await self._ws.receive_json()  # type: ignore[union-attr]
        if payload[_OP] != _HELLO:
            self._logger.debug(
                &#34;expected HELLO opcode, received %s which makes no sense, closing with PROTOCOL ERROR &#34;,
                &#34;(_run_once =&gt; raise and do not reconnect)&#34;,
                payload[_OP],
            )
            await self._ws.send_close(  # type: ignore[union-attr]
                code=errors.ShardCloseCode.PROTOCOL_ERROR,
                message=b&#34;Expected HELLO op&#34;,
            )
            raise errors.GatewayError(f&#34;Expected opcode {_HELLO}, but received {payload[_OP]}&#34;)

        if self._closing.is_set():
            self._logger.debug(
                &#34;closing flag was set before we could handshake, disconnecting with GOING AWAY &#34;
                &#34;(_run_once =&gt; do not reconnect)&#34;
            )
            await self._ws.send_close(  # type: ignore[union-attr]
                code=errors.ShardCloseCode.GOING_AWAY,
                message=b&#34;shard disconnecting&#34;,
            )
            raise asyncio.CancelledError(&#34;closing flag was set before we could handshake&#34;)

        heartbeat_interval = float(payload[_D][&#34;heartbeat_interval&#34;]) / 1_000.0
        heartbeat_task = asyncio.create_task(self._heartbeat(heartbeat_interval))
        return heartbeat_task</code></pre>
</details>
<div class="sep"></div>
<h5>Method resolution order</h5>
<dl>
<dt class="nested"><small class='text-muted'><em><abbr title='A standard Python type.'>class</abbr></em></small> <a title="GatewayShardImpl -- Implementation of a V6 and V7 compatible gateway …" href="#hikari.impl.shard.GatewayShardImpl"
>GatewayShardImpl</a></dt>
<dd class="nested"><em class="text-muted">That's this class!</em></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='An abstract base class which may have abstract methods and abstract properties.'>abstract</abbr> <abbr title='A standard Python type.'>class</abbr></em></small> <a title="GatewayShard -- Interface for a definition of a V6/V7 compatible websocket gateway …" href="../api/shard.html#hikari.api.shard.GatewayShard"
>GatewayShard</a></dt>
<dd class="nested"><p>Interface for a definition of a V6/V7 compatible websocket gateway …</p></dd>
<dt class="nested"><small class='text-muted'><em><abbr title='Anything that is external to this library.'>extern</abbr> class</em></small> <a title="abc.ABC -- Helper class that provides a standard way to create an ABC using
inheritance." href="https://docs.python.org/3/library/abc.html#abc.ABC"
>abc.ABC</a></dt>
<dd class="nested"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></dd>
</dl>
<div class="sep"></div>
<h5>Variables and properties</h5>
<dl>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="heartbeat_latency -- Return the shard's most recent heartbeat latency …" href="#hikari.impl.shard.GatewayShardImpl.heartbeat_latency" id="hikari.impl.shard.GatewayShardImpl.heartbeat_latency" >heartbeat_latency</a> : <a href='https://docs.python.org/3/library/functions.html#float'>float</a></code></pre>
</dt>
<dd><p>Return the shard's most recent heartbeat latency.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#float'>float</a></code></dt>
<dd>Heartbeat latency measured in seconds. If the information is
not yet available, then this will be <code><a href='https://docs.python.org/3/library/functions.html#float'>float</a>('<a href='https://docs.python.org/3/library/functions.html#grammar-token-nan'>nan</a>')</code> instead.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="id -- Return the shard ID for this shard …" href="#hikari.impl.shard.GatewayShardImpl.id" id="hikari.impl.shard.GatewayShardImpl.id" >id</a> : <a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></pre>
</dt>
<dd><p>Return the shard ID for this shard.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>The integer 0-based shard ID.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="intents -- Return the intents set on this shard …" href="#hikari.impl.shard.GatewayShardImpl.intents" id="hikari.impl.shard.GatewayShardImpl.intents" >intents</a> : <a href='../intents.html#hikari.intents.Intents'>Intents</a></code></pre>
</dt>
<dd><p>Return the intents set on this shard.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../intents.html#hikari.intents.Intents'>Intents</a></code></dt>
<dd>The intents being used on this shard.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="is_alive -- Return `builtins.True` if the shard is alive and connected …" href="#hikari.impl.shard.GatewayShardImpl.is_alive" id="hikari.impl.shard.GatewayShardImpl.is_alive" >is_alive</a> : <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></pre>
</dt>
<dd><p>Return <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if the shard is alive and connected.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd><code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code> if connected, or <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code> if not.</dd>
</dl></dd>
<dt>
<pre><code class="python"><small class='text-muted'><em><abbr title='A descriptor on an object that behaves like a synthetic attribute/variable.'>property</abbr></em></small> <a title="shard_count -- Return the total number of shards expected in the entire application …" href="#hikari.impl.shard.GatewayShardImpl.shard_count" id="hikari.impl.shard.GatewayShardImpl.shard_count" >shard_count</a> : <a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></pre>
</dt>
<dd><p>Return the total number of shards expected in the entire application.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>A number of shards greater than or equal to 1.</dd>
</dl></dd>
</dl>
<div class="sep"></div>
<h5>Methods</h5>
<dl>
<dt>
<pre><code id="hikari.impl.shard.GatewayShardImpl.close" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="close" href="#hikari.impl.shard.GatewayShardImpl.close" id="hikari.impl.shard.GatewayShardImpl.close">close</a>() -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="GatewayShard -- Interface for a definition of a V6/V7 compatible websocket gateway …" href="../api/shard.html#hikari.api.shard.GatewayShard"
>GatewayShard</a></code>.<code><a title="close -- Close the websocket if it is connected, otherwise do nothing." href="../api/shard.html#hikari.api.shard.GatewayShard.close"
>close</a></code>
</p>
<p>Close the websocket if it is connected, otherwise do nothing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/shard.py#L495-L507" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def close(self) -&gt; None:
    if not self._closing.is_set():
        try:
            if self._ws is not None:
                self._logger.debug(
                    &#34;shard.close() was called and the websocket was still alive -- &#34;
                    &#34;disconnecting immediately with GOING AWAY&#34;
                )
                await self._ws.close(code=errors.ShardCloseCode.GOING_AWAY, message=b&#34;shard disconnecting&#34;)
            self._closing.set()
        finally:
            self._chunking_rate_limit.close()
            self._total_rate_limit.close()</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.shard.GatewayShardImpl.get_user_id" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="get_user_id" href="#hikari.impl.shard.GatewayShardImpl.get_user_id" id="hikari.impl.shard.GatewayShardImpl.get_user_id">get_user_id</a>() -> <a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="GatewayShard -- Interface for a definition of a V6/V7 compatible websocket gateway …" href="../api/shard.html#hikari.api.shard.GatewayShard"
>GatewayShard</a></code>.<code><a title="get_user_id -- Return the user ID …" href="../api/shard.html#hikari.api.shard.GatewayShard.get_user_id"
>get_user_id</a></code>
</p>
<p>Return the user ID.</p>
<p>If the shard has not connected fully yet, this should wait until the ID
is set before returning.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a href='../snowflakes.html#hikari.snowflakes.Snowflake'>Snowflake</a></code></dt>
<dd>The user ID for the application user.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/shard.py#L509-L513" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def get_user_id(self) -&gt; snowflakes.Snowflake:
    await self._handshake_completed.wait()
    if self._user_id is None:
        raise RuntimeError(&#34;user_id was not known, this is probably a bug&#34;)
    return self._user_id</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.shard.GatewayShardImpl.join" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="join" href="#hikari.impl.shard.GatewayShardImpl.join" id="hikari.impl.shard.GatewayShardImpl.join">join</a>() -> None: ...</code></pre>
</dt>
<dd>
<p>Wait for this shard to close, if running.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/shard.py#L515-L517" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def join(self) -&gt; None:
    &#34;&#34;&#34;Wait for this shard to close, if running.&#34;&#34;&#34;
    await self._closed.wait()</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.shard.GatewayShardImpl.request_guild_members" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="request_guild_members" href="#hikari.impl.shard.GatewayShardImpl.request_guild_members" id="hikari.impl.shard.GatewayShardImpl.request_guild_members">request_guild_members</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    *,
    include_presences: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    query: <a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a> = '',
    limit: <a href='https://docs.python.org/3/library/functions.html#int'>int</a> = 0,
    users: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../users.html#hikari.users.User'>users_.User</a>]]] = UNDEFINED,
    nonce: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="GatewayShard -- Interface for a definition of a V6/V7 compatible websocket gateway …" href="../api/shard.html#hikari.api.shard.GatewayShard"
>GatewayShard</a></code>.<code><a title="request_guild_members -- Request for a guild chunk …" href="../api/shard.html#hikari.api.shard.GatewayShard.request_guild_members"
>request_guild_members</a></code>
</p>
<p>Request for a guild chunk.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../guilds.html#hikari.guilds.Guild'>Guild</a></code></dt>
<dd>The guild to request chunk for.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>include_presences</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If provided, whether to request presences.</dd>
<dt><strong><code>query</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a></code></dt>
<dd>If not <code>""</code>, request the members which username starts with the string.</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#int'>int</a></code></dt>
<dd>Maximum number of members to send matching the query.</dd>
<dt><strong><code>users</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/typing.html#typing.Sequence'>Sequence</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../users.html#hikari.users.User'>User</a>]]]</code></dt>
<dd>If provided, the users to request for.</dd>
<dt><strong><code>nonce</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/stdtypes.html#str'>str</a>]</code></dt>
<dd>If provided, the nonce to be sent with guild chunks.</dd>
</dl>
<div class="alert alert-success">
<p class="admonition-title">Note</p>
<p>To request the full list of members, set <code>query</code> to <code>""</code> (empty
string) and <code>limit</code> to <code>0</code>.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a href='https://docs.python.org/3/library/exceptions.html#ValueError'>ValueError</a></code></dt>
<dd>When trying to specify <code>users</code> with <code>query</code>/<code>limit</code>, if <code>limit</code> is not between
0 and 100, both inclusive or if <code>users</code> length is over 100.</dd>
<dt><code><a href='../errors.html#hikari.errors.MissingIntentError'>MissingIntentError</a></code></dt>
<dd>When trying to request presences without the <code>GUILD_MEMBERS</code> or when trying to
request the full list of members without <code>GUILD_PRESENCES</code>.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/shard.py#L519-L557" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def request_guild_members(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    *,
    include_presences: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    query: str = &#34;&#34;,
    limit: int = 0,
    users: undefined.UndefinedOr[typing.Sequence[snowflakes.SnowflakeishOr[users_.User]]] = undefined.UNDEFINED,
    nonce: undefined.UndefinedOr[str] = undefined.UNDEFINED,
) -&gt; None:
    if not query and not limit and not self._intents &amp; intents_.Intents.GUILD_MEMBERS:
        raise errors.MissingIntentError(intents_.Intents.GUILD_MEMBERS)

    if include_presences is not undefined.UNDEFINED and not self._intents &amp; intents_.Intents.GUILD_PRESENCES:
        raise errors.MissingIntentError(intents_.Intents.GUILD_PRESENCES)

    if users is not undefined.UNDEFINED and (query or limit):
        raise ValueError(&#34;Cannot specify limit/query with users&#34;)

    if not 0 &lt;= limit &lt;= 100:
        raise ValueError(&#34;&#39;limit&#39; must be between 0 and 100, both inclusive&#34;)

    if users is not undefined.UNDEFINED and len(users) &gt; 100:
        raise ValueError(&#34;&#39;users&#39; is limited to 100 users&#34;)

    if nonce is not undefined.UNDEFINED and len(bytes(nonce, &#34;utf-8&#34;)) &gt; 32:
        raise ValueError(&#34;&#39;nonce&#39; can be no longer than 32 byte characters long.&#34;)

    await self._chunking_rate_limit.acquire()

    payload = data_binding.JSONObjectBuilder()
    payload.put_snowflake(&#34;guild_id&#34;, guild)
    payload.put(&#34;presences&#34;, include_presences)
    payload.put(&#34;query&#34;, query)
    payload.put(&#34;limit&#34;, limit)
    payload.put_snowflake_array(&#34;user_ids&#34;, users)
    payload.put(&#34;nonce&#34;, nonce)

    await self._ws.send_json({_OP: _REQUEST_GUILD_MEMBERS, _D: payload})  # type: ignore[union-attr]</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.shard.GatewayShardImpl.start" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="start" href="#hikari.impl.shard.GatewayShardImpl.start" id="hikari.impl.shard.GatewayShardImpl.start">start</a>() -> None: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="GatewayShard -- Interface for a definition of a V6/V7 compatible websocket gateway …" href="../api/shard.html#hikari.api.shard.GatewayShard"
>GatewayShard</a></code>.<code><a title="start -- Start the shard, wait for it to become ready." href="../api/shard.html#hikari.api.shard.GatewayShard.start"
>start</a></code>
</p>
<p>Start the shard, wait for it to become ready.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/shard.py#L559-L575" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def start(self) -&gt; None:
    if self._run_task is not None:
        raise RuntimeError(&#34;Cannot run more than one instance of one shard concurrently&#34;)

    run_task = asyncio.create_task(self._run(), name=f&#34;run shard {self._shard_id}&#34;)
    self._run_task = run_task
    waiter = asyncio.create_task(self._handshake_completed.wait(), name=f&#34;wait for shard {self._shard_id} to start&#34;)
    done, _ = await asyncio.wait((waiter, run_task), return_when=asyncio.FIRST_COMPLETED)
    waiter.cancel()

    if done and waiter not in done:
        # This might throw an error, or it might not, depending on what we do with it.
        # This occurs if the run task finished before the handshake completion event,
        # which implies the shard died before it could become ready/resume...
        self._run_task = None
        run_task.result()
        raise asyncio.CancelledError(f&#34;Shard {self._shard_id} was closed before it could start successfully&#34;)</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.shard.GatewayShardImpl.update_presence" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="update_presence" href="#hikari.impl.shard.GatewayShardImpl.update_presence" id="hikari.impl.shard.GatewayShardImpl.update_presence">update_presence</a>(
    *,
    idle_since: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>] = UNDEFINED,
    afk: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>] = UNDEFINED,
    activity: <a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>undefined.UndefinedNoneOr</a>[<a href='../presences.html#hikari.presences.Activity'>presences.Activity</a>] = UNDEFINED,
    status: <a href='../undefined.html#hikari.undefined.UndefinedOr'>undefined.UndefinedOr</a>[<a href='../presences.html#hikari.presences.Status'>presences.Status</a>] = UNDEFINED,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="GatewayShard -- Interface for a definition of a V6/V7 compatible websocket gateway …" href="../api/shard.html#hikari.api.shard.GatewayShard"
>GatewayShard</a></code>.<code><a title="update_presence -- Update the presence of the shard user …" href="../api/shard.html#hikari.api.shard.GatewayShard.update_presence"
>update_presence</a></code>
</p>
<p>Update the presence of the shard user.</p>
<p>If the shard is not alive, no physical data will be sent, however,
the new presence settings will be remembered for when the shard
does connect.</p>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>idle_since</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='https://docs.python.org/3/library/datetime.html#datetime.datetime'>datetime.datetime</a>]</code></dt>
<dd>The datetime that the user started being idle. If undefined, this
will not be changed.</dd>
<dt><strong><code>afk</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='https://docs.python.org/3/library/functions.html#bool'>bool</a>]</code></dt>
<dd>If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, the user is marked as AFK. If <code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>,
the user is marked as being active. If undefined, this will not be
changed.</dd>
<dt><strong><code>activity</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedNoneOr'>UndefinedNoneOr</a>[<a href='../presences.html#hikari.presences.Activity'>Activity</a>]</code></dt>
<dd>The activity to appear to be playing. If undefined, this will not be
changed.</dd>
<dt><strong><code>status</code></strong> :&ensp;<code><a href='../undefined.html#hikari.undefined.UndefinedOr'>UndefinedOr</a>[<a href='../presences.html#hikari.presences.Status'>Status</a>]</code></dt>
<dd>The web status to show. If undefined, this will not be changed.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/shard.py#L577-L592" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def update_presence(
    self,
    *,
    idle_since: undefined.UndefinedNoneOr[datetime.datetime] = undefined.UNDEFINED,
    afk: undefined.UndefinedOr[bool] = undefined.UNDEFINED,
    activity: undefined.UndefinedNoneOr[presences.Activity] = undefined.UNDEFINED,
    status: undefined.UndefinedOr[presences.Status] = undefined.UNDEFINED,
) -&gt; None:
    presence_payload = self._serialize_and_store_presence_payload(
        idle_since=idle_since,
        afk=afk,
        activity=activity,
        status=status,
    )
    payload: data_binding.JSONObject = {_OP: _PRESENCE_UPDATE, _D: presence_payload}
    await self._ws.send_json(payload)  # type: ignore[union-attr]</code></pre>
</details>
</dd>
<div class="sep"></div>
<dt>
<pre><code id="hikari.impl.shard.GatewayShardImpl.update_voice_state" class="hljs python"><abbr title='A function that returns a coroutine and must be awaited.'>async def</abbr> <a title="update_voice_state" href="#hikari.impl.shard.GatewayShardImpl.update_voice_state" id="hikari.impl.shard.GatewayShardImpl.update_voice_state">update_voice_state</a>(
    guild: <a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>guilds.PartialGuild</a>],
    channel: <a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>snowflakes.SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>channels.GuildVoiceChannel</a>]],
    *,
    self_mute: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
    self_deaf: <a href='https://docs.python.org/3/library/functions.html#bool'>bool</a> = False,
) -> <a href='https://docs.python.org/3/library/constants.html#None'>None</a>: ...</code></pre>
</dt>
<dd>
<p class="inheritance">
<em><small>Inherited from:</small></em>
<code><a title="GatewayShard -- Interface for a definition of a V6/V7 compatible websocket gateway …" href="../api/shard.html#hikari.api.shard.GatewayShard"
>GatewayShard</a></code>.<code><a title="update_voice_state -- Update the voice state for this shard in a given guild …" href="../api/shard.html#hikari.api.shard.GatewayShard.update_voice_state"
>update_voice_state</a></code>
</p>
<p>Update the voice state for this shard in a given guild.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>guild</code></strong> :&ensp;<code><a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../guilds.html#hikari.guilds.PartialGuild'>PartialGuild</a>]</code></dt>
<dd>The guild or guild ID to update the voice state for.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/typing.html#typing.Optional'>Optional</a>[<a href='../snowflakes.html#hikari.snowflakes.SnowflakeishOr'>SnowflakeishOr</a>[<a href='../channels.html#hikari.channels.GuildVoiceChannel'>GuildVoiceChannel</a>]]</code></dt>
<dd>The channel or channel ID to update the voice state for. If <code><a href='https://docs.python.org/3/library/constants.html#None'>None</a></code>
then the bot will leave the voice channel that it is in for the
given guild.</dd>
<dt><strong><code>self_mute</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, the bot will mute itself in that voice channel. If
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, then it will unmute itself.</dd>
<dt><strong><code>self_deaf</code></strong> :&ensp;<code><a href='https://docs.python.org/3/library/functions.html#bool'>bool</a></code></dt>
<dd>If <code><a href='https://docs.python.org/3/library/constants.html#True'>True</a></code>, the bot will deafen itself in that voice channel. If
<code><a href='https://docs.python.org/3/library/constants.html#False'>False</a></code>, then it will undeafen itself.</dd>
</dl>
<details class="source">
<summary>
<span>Expand source code</span>
<br />
<a href="https://github.com/hikari-py/hikari/blob/c8d88c83b926f0874158593f8bc7ba0f580a97d8/hikari/impl/shard.py#L594-L612" class="git-link dotted">Browse git</a>
</summary>
<pre><code class="python">async def update_voice_state(
    self,
    guild: snowflakes.SnowflakeishOr[guilds.PartialGuild],
    channel: typing.Optional[snowflakes.SnowflakeishOr[channels.GuildVoiceChannel]],
    *,
    self_mute: bool = False,
    self_deaf: bool = False,
) -&gt; None:
    await self._ws.send_json(  # type: ignore[union-attr]
        {
            _OP: _VOICE_STATE_UPDATE,
            _D: {
                &#34;guild_id&#34;: str(int(guild)),
                &#34;channel_id&#34;: str(int(channel)) if channel is not None else None,
                &#34;mute&#34;: self_mute,
                &#34;deaf&#34;: self_deaf,
            },
        }
    )</code></pre>
</details>
</dd>
<div class="sep"></div>
</dl>
<div class="sep"></div>
</dd>
</dl>
</section>
</div>
</div>
</div>
<!-- Search script and dependencies -->
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../search.html#' + encodeURIComponent(query);
window.location.href = url;
};
</script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>